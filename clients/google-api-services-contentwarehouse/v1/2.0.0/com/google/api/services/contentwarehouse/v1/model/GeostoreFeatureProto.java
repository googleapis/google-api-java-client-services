/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.contentwarehouse.v1.model;

/**
 * Every entry in the GeoStore database is called a "feature". A feature is represented as a
 * discriminated union of all the different feature types, where the actual feature type is
 * specified by the "type" field. There are also various fields that are meaningful for most or all
 * feature types, such as bounding regions and names. Every feature has a globally unique id that
 * can be used to refer to it from other features.
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the Document AI Warehouse API. For a detailed explanation
 * see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class GeostoreFeatureProto extends com.google.api.client.json.GenericJson {

  /**
   * Optional access point information. Access points hold detailed information about routing
   * endpoints. For example, the main Google office is at "1600 Amphitheatre Parkway". The feature
   * representing that office has a polygon, a center, and an address with components for the street
   * number, route, locality, etc. The access point information, on the other hand, identifies the
   * specific segment, the latitude/longitude of the driveway, and so forth.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreAccessPointProto> accessPoint;

  static {
    // hack to force ProGuard to consider GeostoreAccessPointProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreAccessPointProto.class);
  }

  /**
   * Address for this feature. A Geo Schema address is designed to model a mailing address, so only
   * features that have mailing addresses in the real world may have addresses. Each feature should
   * have only one address. If you want to describe the geographic location of a feature which does
   * not have a mailing address with respect to other well-known features, some other schema
   * constructs should be used. Note that the field is defined as repeated though features that use
   * this field with its intended semantics are constrained to have a single address even if they
   * may have multiple mailing addresses in the real world. The “single address” rule is enforced by
   * lint. Current exceptions to the single address rule and mailing address rule are described in
   * the g3doc. Bear note that the schema team is actively working on eliminating these exceptions.
   * http://go/geo-addresses Note the following conventions: - Addresses follow the postal
   * hierarchy, not the political hierarchy. Addresses may have components that refer to political
   * entities when those entities also appear in the postal hierarchy. - As stated previously, but
   * it bears repeating, addresses on features are mailing addresses. In many cases the physical
   * address and the mailing address are the same but the address stored on a feature represents the
   * mailing address of the feature. An example of a non-physical mailing address would be a PO Box.
   * - These addresses are commonly defined and verifiable by a governmental authority (e.g. the
   * United States Postal Service in the United States, Royal Mail in the United Kingdom, Correios
   * in Brazil, etc.) and should follow conventions and rules defined by those authorities.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreAddressProto> address;

  static {
    // hack to force ProGuard to consider GeostoreAddressProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreAddressProto.class);
  }

  /**
   * Represents information about the feature’s anchored geometry.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreAnchoredGeometryProto anchoredGeometry;

  /**
   * The collection of attachments for this feature. Documentation: http://go/geo-attachments
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreAttachmentsAttachmentProto> attachment;

  static {
    // hack to force ProGuard to consider GeostoreAttachmentsAttachmentProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreAttachmentsAttachmentProto.class);
  }

  /**
   * ** DEPRECATED ** A list of attributes that describe defined aspects of this feature. An
   * attribute must be a concrete, high quality, and editable piece of information about a feature,
   * and must be used on some general consumer facing Google property. The data types used for
   * attributes must be primitive types or reusable in a generic manner.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreAttributeProto> attribute;

  static {
    // hack to force ProGuard to consider GeostoreAttributeProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreAttributeProto.class);
  }

  /**
   * Describes the best-match locale for this feature.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreBestLocaleProto bestLocale;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreBorderProto border;

  /**
   * A latitude-longitude rectangle used by bucketing MapReduces. See the documentation on bucketing
   * MapReduce for details. This field can be a source of confusion. Because it is called "bound",
   * it is often assumed that it is a tight bound on the geometry but it can be (and often is) much
   * larger. If a tight bound is needed then use the standard GetFeatureGeometryBound() function
   * instead. To be more explicit, if you are using this field for *anything* else than a bucketing
   * MapReduce, you are doing the wrong thing. Not all features are required to have bounding boxes.
   * See geostore::IsBoundRequiredForFeatureType() for the list of feature types required to have a
   * bounding box. This bound field will be updated when a feature changes in MapFacts to include
   * its geometry. Also, a GeoSchema pipeline, go/geo-schema-pipelines-docs#expand-bounds runs
   * periodically to update the field for strong references from other features. Therefore, most
   * editors don't need to edit this field explicitly. See go/geo-changes:no-edit-for-feature-bound
   * for the details.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreRectProto bound;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreBuildingProto building;

  /**
   * Data specific to business chain features, e.g., Canonical GConcepts.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreBusinessChainProto businessChain;

  /**
   * The conceptual center of the feature, used for routing. For cities, this would be the center of
   * the downtown, or maybe the location of city hall. For states and countries it might be the
   * capital city. Most feature types will not have a conceptual center - by default, routing will
   * use the centroid of the feature's geometry. If you need a feature center point consider using
   * GetFeatureGeometryCenter() function from geostore/base/public/feature.h rather than reading
   * from this field directly.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostorePointProto center;

  /**
   * Features can define themselves as a collection of other features. For example, a route is a
   * collection of road segments, and a feature for the "Great Lakes" could be defined as lakes
   * Superior, Michigan, Huron, Erie, and Ontario. It is not recommended to design a multi level
   * tree using the child field to build up a feature because it requires fetching many features to
   * see the details of the feature. In practice this is used to model archipelago, route, transit
   * (agencies, lines, trips, departures), and river features. The geometry of a feature is
   * implicitly defined by its children, so if a feature has children then it should not have any
   * points, polylines, or polygons. In general, this field should not be used to represent
   * political or postal hierarchies. For example, a county would not list its cities as children,
   * because the county is not defined in terms of its cities (it also contains unincorporated
   * areas, etc.).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreFeatureIdProto> child;

  static {
    // hack to force ProGuard to consider GeostoreFeatureIdProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreFeatureIdProto.class);
  }

  /**
   * S2 cell coverings for this feature. See util/geometry/s2cell_union.h for more information about
   * S2 cells. Coverings are useful for quick containment or intersection tests. S2 covering that
   * consists of cells that intersect with the feature.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreCellCoveringProto covering;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreDataSourceProto dataSource;

  /**
   * Data used to render this feature on a map.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreDisplayDataProto displayData;

  /**
   * ** DEPRECATED **
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreDoodleProto doodle;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreElevationProto elevation;

  /**
   * Captures elevation data used on TYPE_DIGITAL_ELEVATION_MODEL features.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreElevationModelProto elevationModel;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreEntranceProto entrance;

  /**
   * Also allowed on TYPE_BUSINESS_CHAIN and TYPE_TRANSIT_AGENCY features, to model the feature's
   * phone number(s). Other fields within EstablishmentProto are not permitted on non-
   * TYPE_ESTABLISHMENT features.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreEstablishmentProto establishment;

  /**
   * A list of feature ids of polygon based restrictions that do not apply to this feature. This may
   * only include features of TYPE_REGULATED_AREA that also have a
   * feature.regulated_area.restriction field defined. Setting this field opts the feature out of
   * all restrictions set on that regulated area.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreFeatureIdProto> exemptRegulatedArea;

  static {
    // hack to force ProGuard to consider GeostoreFeatureIdProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreFeatureIdProto.class);
  }

  /**
   * Specifies the TYPE_FUTURE_GEOMETRY whose geometry will replace this feature's geometry. If this
   * field is populated, the referenced future geometry must have a future_geometry_for referencing
   * this feature.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFeatureIdProto futureGeometry;

  /**
   * Specifies the feature that this feature's geometry will replace. If this field is populated,
   * the referenced feature must have a future_geometry reference back to this feature. This field
   * is only allowed (and required) for TYPE_FUTURE_GEOMETRY features.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFeatureIdProto futureGeometryFor;

  /**
   * If set, the feature's actual location can be assumed to be somewhere within a circle of this
   * radius, centered on the feature's location. More information on this field at go/gpm-
   * definition-update. NOTE: Only applicable to features with 'point' geometry. Please contact geo-
   * schema-team@ if you have non-point use cases for which this field would be useful.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Double geometryPrecisionMeters;

  /**
   * Geopolitical (unsimplified) polygons for a feature for different geopolitical use cases.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreGeopoliticalGeometryProto geopoliticalGeometry;

  /**
   * ** DEPRECATED ** Features can have zero or more HTML texts associated with them. These might be
   * HTML balloons used by Google Earth, for example.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreHtmlTextProto> htmlText;

  /**
   * The globally unique id for this feature.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFeatureIdProto id;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreInferredGeometryProto inferredGeometry;

  /**
   * S2 interior covering that consists of cells completely enclosed within the feature's geometry
   * (for features with polygonal geometry).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreCellCoveringProto interiorCovering;

  /**
   * Additional internal feature-level attributes that may be set by data providers to be used
   * inside the Geo Data infrastructure. This field should never be present in the output of the Geo
   * Data infrastructure that read-only clients consume.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreInternalFeatureProto internal;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreIntersectionProto intersection;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreIntersectionGroupProto intersectionGroup;

  /**
   * Properties that apply to this feature whose schema is defined in the Knowledge Graph schema
   * (see https://hume.google.com/graph/schema). Not all properties that exist in the KG schema can
   * be asserted via this mechanism. The set of properties that are allowed to be set on a feature
   * depends on the feature's GConcepts (and feature type). For instance, only gcid:country features
   * may have the /geo/type/country/president property (made up example, since that property doesn't
   * actually exist in the KG schema). GConcept hierarchy is taken into account for deciding the set
   * of allowed properties. Additionally, the specific properties allowed are further constrained by
   * the list specified at go/kg-property-allowlist. NOTE: not all types of properties are allowed
   * to appear in the Geo Schema. For now, we limit ourselves to properties whose value type is
   * TYPE_BOOL, TYPE_COMPOUND, TYPE_DATETIME, TYPE_FLOAT, TYPE_ID, TYPE_INT, TYPE_NESTED_STRUCT,
   * TYPE_TEXT, or TYPE_URI. NOTE(b/35039936): We are in the process of changing how a KG property
   * with multiple values is stored in this field. Currently, such a KG property is stored in a
   * single instance of the kg_property field. However, we will be changing this so that each value
   * will be stored in its own instance of kg_property. Any client that wants to read from this
   * field should be prepared to read data represented in either format. See b/35039936 or the
   * announcement at http://g/geo-schema-announce/7IXR3Fex8to/7yFyT5UoAwAJ for an example and more
   * details. The mechanism to assert that a KG property has no value is via the
   * property_value_status field below. freebase.PropertyValue.value_status is not allowed be set
   * here for consistency reason.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<FreebasePropertyValue> kgProperty;

  static {
    // hack to force ProGuard to consider FreebasePropertyValue used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(FreebasePropertyValue.class);
  }

  /**
   * RESERVED
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreKnowledgeGraphReferenceProto knowledgeGraphReference;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreLaneMarkerProto laneMarker;

  /**
   * Represents information about TYPE_LEVEL features.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreLevelProto level;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreLocaleProto locale;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreLogicalBorderProto logicalBorder;

  /**
   * Metadata about this particular feature. Metadata is managed internally by the Geo Data
   * Infrastructure and in general should not be set by clients. Features that don't ultimately come
   * from the Geo repository (MapFacts) won't have any metadata set.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFeatureMetadataProto metadata;

  /**
   * The name(s) of this feature. A feature may have different names in different languages,
   * colloquial or "vanity" names, etc.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreNameProto> name;

  /**
   * Information about this feature's operations, e.g. when this feature is temporarily closed.
   * NOTE: for legacy reasons, some closure-specifc information (e.g. permanent closure reason)
   * lives in ExistenceProto instead. In the future, such information should move here in
   * OperationsProto.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreOperationsProto operations;

  /**
   * This field is used internally by the pipeline for id stability. It should not be set by
   * individual importers, nor should it be read by consumer clients. In particular, this field will
   * not be present in features read or snapshotted from the Mapfacts Repository.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFeatureIdProto originalId;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreFeatureIdProto> parent;

  static {
    // hack to force ProGuard to consider GeostoreFeatureIdProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreFeatureIdProto.class);
  }

  /**
   * Describes parking details for the feature.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreParkingProto parking;

  /**
   * Defines the geometry of the feature. The geometry may be specified as an arbitrary union of
   * points, poses, polylines, tracks, and polygons. Points, poses, polylines, and tracks are
   * assumed to represent regions of unspecified size or width rather than regions of zero area.
   * Most features should have some sort of geometry. Geometry may be synthesized if none is
   * available (e.g., polygons for postal codes). The synthetic_geometry flag should be set in that
   * case. Point is currently enforced as a non-repeating field for all feature types, though it is
   * defined as repeating in case future modeling requires multiple points. The number of allowed
   * polylines, tracks, or polygons vary based on feature type. A feature can have at most one pose
   * (it is an optional field).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostorePointProto> point;

  /**
   * ** DEPRECATED ** Detail discussion could be found at b/18611003.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostorePoliticalProto political;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostorePolygonProto> polygon;

  /**
   * Provide version of the geometry suitable for display. This has been subject to water removal
   * and (possibly) moderate simplification.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostorePolygonProto polygonForDisplay;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostorePolyLineProto> polyline;

  /**
   * Defines the geometry of a feature as a 6D pose, including lat, lng, altitude, roll, pitch, and
   * yaw along the WGS-84 ellipsoid. Only the lat and lng are strictly required.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostorePoseProto pose;

  /**
   * The preferred viewport for this feature. If present, this latitude-longitude rectangle holds
   * the preferred viewport for the feature. For example, it might hold the bounds of the "central"
   * portion of a large city. There are no aspect ratio requirements. This is an optional field: if
   * no viewport is supplied, interested clients can use heuristics to determine a viewport. Calling
   * the standard GetFeatureGeometryBound() function would be a good way to start but note that it
   * can return an empty bounding box (e.g., if the feature has no geometry). The preferred viewport
   * is not necessarily fully contained by the above bounding box.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreRectProto preferredViewport;

  /**
   * The value status of properties on this feature. For example, this specifies whether the feature
   * is known to have no name (this is the value status of the 'FEATURE_NAME' property). Only
   * property IDs which have no specific value are allowed to have a value status. Note: not all
   * field types will be supported, please contact geo schema team if you want to enable this field
   * for a field type that is not currently supported.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostorePropertyValueStatusProto> propertyValueStatus;

  /**
   * WARNING: Please do NOT introduce new uses of this field; treat it as if it were deprecated. For
   * appropriate ranking contacts, see g3doc/company/teams/gdeng/geo-schema-reference/home/feature-
   * properties/rank.md. A floating-point number between 0.0 and 1.0 indicating how "important" we
   * think this feature is. This can be used to decide which features to render on maps, and how to
   * rank results when the user does a search. The rank can depend on any number of factors such as
   * the number of references to this feature in web pages, geographic size, population, number of
   * referring geographic entities, "priority" information encoded in the source data, etc.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Float rank;

  /**
   * The rank field is computed as a weighted sum of several signals. This field contains a protocol
   * buffer whose fields give those signals and their weights. Clients should try very hard not to
   * depend on these individual signals and use the single rank field instead. At some point in the
   * future, this field will not be exposed anymore.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreRankDetailsProto rankDetails;

  /**
   * Geo Ontology GConcept Instances - Design doc linked off http://go/geo-ontology - In order to
   * shield clients from changes in GConcept representation we provide an accessor library:
   * geostore/base/public/gconcept_instance.h
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreOntologyRawGConceptInstanceContainerProto rawGconceptInstanceContainer;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreRegulatedAreaProto regulatedArea;

  /**
   * For TYPE_COUNTRY or TYPE_ADMINISTRATIVE_AREA1 features, this field defines the associated
   * TYPE_BORDERs which reference this feature. The linked TYPE_BORDERs must have the feature.border
   * set, pointing to this feature. TYPE_COUNTRY or TYPE_ADMINISTRATIVE_AREA1 features must have
   * this field set for each TYPE_BORDER referencing them.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreFeatureIdProto> relatedBorder;

  static {
    // hack to force ProGuard to consider GeostoreFeatureIdProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreFeatureIdProto.class);
  }

  /**
   * Logical relationship to other features that are entrances or exits to this feature.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreEntranceReferenceProto> relatedEntrance;

  static {
    // hack to force ProGuard to consider GeostoreEntranceReferenceProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreEntranceReferenceProto.class);
  }

  /**
   * Geographic or logical relationships to other features. Importers don't need to fill a
   * geographic relationship in - it is handled by related feature processing by a standalone
   * pipeline. Adding "contained by" country relations is however encouraged (and required for
   * TYPE_ROUTE features). WARNING: Updates to this field handled by standalone pipelines are NOT
   * atomic with regard to updates to the features being referenced; we do not guarantee that a
   * given MapFacts snapshot will be consistent between this field and the related features.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreRelationProto> relatedFeature;

  /**
   * Terminal points associated with this feature. For instance, an airport terminal may have
   * specifically designated pickup and drop-off points.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreFeatureIdProto> relatedTerminalPoint;

  static {
    // hack to force ProGuard to consider GeostoreFeatureIdProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreFeatureIdProto.class);
  }

  /**
   * Contains time zones known to be associated with a feature. Most features are associated with
   * the single time zone that contains them. However, some larger features (countries, continents,
   * etc.) are associated with all of the time zones they contain. Most features can have any number
   * of related time zones, but TYPE_SEGMENT and TYPE_ESTABLISHMENT_POI features can have at most 1.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreTimezoneProto> relatedTimezone;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreRestrictionGroupProto restrictionGroup;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreRoadMonitorProto roadMonitor;

  /**
   * Additional details on the feature types below can be found in the individual protocol buffer
   * definitions. These extensions capture data that is specific to a set of feature types and which
   * makes no sense for other feature types.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreRouteProto route;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreSchoolDistrictProto schoolDistrict;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreSegmentProto segment;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreSegmentPathProto segmentPath;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreRoadSignProto sign;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreSkiBoundaryProto skiBoundary;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreSkiLiftProto skiLift;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreSkiTrailProto skiTrail;

  /**
   * All establishments must have a social reference. WARNING: Aside from creating new
   * establishments, please do NOT introduce new uses; treat social references as if they were
   * deprecated. For alternatives and more, see g3doc/company/teams/gdeng/geo-schema-reference/home
   * /feature-types/establishments/social-reference.md.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreSocialReferenceProto socialReference;

  /**
   * A list of the data sources that were used to construct this feature, together with optional
   * "raw data" in the provider's format. Raw data should not be used by production clients but may
   * be useful for exploring data that is not currently converted to a canonical form.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreSourceInfoProto> sourceInfo;

  /**
   * All features can have "existence" information associated with them.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreExistenceProto status;

  /**
   * Represents information about the store front geoemtry. Only TYPE_ESTABLISHMENT_POI should have
   * this field set.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreAnchoredGeometryProto> storefrontGeometry;

  static {
    // hack to force ProGuard to consider GeostoreAnchoredGeometryProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreAnchoredGeometryProto.class);
  }

  /**
   * We prefer features that have geometry over those that do not. In some cases we synthesize
   * geometry (e.g., polygons for postal codes). This flag is set to indicate features that have
   * such synthetic geometry.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean syntheticGeometry;

  /**
   * A place for clients to attach arbitrary data to a feature. Never set in MapFacts.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private Proto2BridgeMessageSet temporaryData;

  /**
   * Captures full model representing the feature's 3D geometry. Should only be found on
   * TYPE_COMPOUND_BUILDING features for now, but not part of the BuildingProto extension for
   * possible future extensions.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreThreeDimensionalModelProto threeDimModel;

  /**
   * Represents information about TYPE_TOLL_CLUSTER features.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreTollClusterProto tollCluster;

  /**
   * Defines the geometry of a feature as a sequence of 6D poses, including lat, lng, altitude,
   * roll, pitch, and yaw. Only lat and lng are typically required. Each track has an index so that
   * they can be viewed in a stable order.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreTrackProto> track;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreTransitLineProto transitLine;

  /**
   * RESERVED
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreTransitLineVariantProto transitLineVariant;

  /**
   * RESERVED
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreTransitStationProto transitStation;

  /**
   * The type of this feature -- see comments above.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String type;

  /**
   * Represents vertical ordering for this feature relative to other geometrically-overlaping
   * features. See go/aboutgrades for more information about distinction among different levels.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreVerticalOrderingProto verticalOrdering;

  /**
   * A version of the geometry which has water removed but is not simplified (thus having equal or
   * more vertices than polygon_for_display).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostorePolygonProto waterRemovedPolygon;

  /**
   * The official website of this feature. Stored as a repeated field to allow for multilingual
   * official websites (see comments in url.proto).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreUrlProto> website;

  /**
   * Optional access point information. Access points hold detailed information about routing
   * endpoints. For example, the main Google office is at "1600 Amphitheatre Parkway". The feature
   * representing that office has a polygon, a center, and an address with components for the street
   * number, route, locality, etc. The access point information, on the other hand, identifies the
   * specific segment, the latitude/longitude of the driveway, and so forth.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreAccessPointProto> getAccessPoint() {
    return accessPoint;
  }

  /**
   * Optional access point information. Access points hold detailed information about routing
   * endpoints. For example, the main Google office is at "1600 Amphitheatre Parkway". The feature
   * representing that office has a polygon, a center, and an address with components for the street
   * number, route, locality, etc. The access point information, on the other hand, identifies the
   * specific segment, the latitude/longitude of the driveway, and so forth.
   * @param accessPoint accessPoint or {@code null} for none
   */
  public GeostoreFeatureProto setAccessPoint(java.util.List<GeostoreAccessPointProto> accessPoint) {
    this.accessPoint = accessPoint;
    return this;
  }

  /**
   * Address for this feature. A Geo Schema address is designed to model a mailing address, so only
   * features that have mailing addresses in the real world may have addresses. Each feature should
   * have only one address. If you want to describe the geographic location of a feature which does
   * not have a mailing address with respect to other well-known features, some other schema
   * constructs should be used. Note that the field is defined as repeated though features that use
   * this field with its intended semantics are constrained to have a single address even if they
   * may have multiple mailing addresses in the real world. The “single address” rule is enforced by
   * lint. Current exceptions to the single address rule and mailing address rule are described in
   * the g3doc. Bear note that the schema team is actively working on eliminating these exceptions.
   * http://go/geo-addresses Note the following conventions: - Addresses follow the postal
   * hierarchy, not the political hierarchy. Addresses may have components that refer to political
   * entities when those entities also appear in the postal hierarchy. - As stated previously, but
   * it bears repeating, addresses on features are mailing addresses. In many cases the physical
   * address and the mailing address are the same but the address stored on a feature represents the
   * mailing address of the feature. An example of a non-physical mailing address would be a PO Box.
   * - These addresses are commonly defined and verifiable by a governmental authority (e.g. the
   * United States Postal Service in the United States, Royal Mail in the United Kingdom, Correios
   * in Brazil, etc.) and should follow conventions and rules defined by those authorities.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreAddressProto> getAddress() {
    return address;
  }

  /**
   * Address for this feature. A Geo Schema address is designed to model a mailing address, so only
   * features that have mailing addresses in the real world may have addresses. Each feature should
   * have only one address. If you want to describe the geographic location of a feature which does
   * not have a mailing address with respect to other well-known features, some other schema
   * constructs should be used. Note that the field is defined as repeated though features that use
   * this field with its intended semantics are constrained to have a single address even if they
   * may have multiple mailing addresses in the real world. The “single address” rule is enforced by
   * lint. Current exceptions to the single address rule and mailing address rule are described in
   * the g3doc. Bear note that the schema team is actively working on eliminating these exceptions.
   * http://go/geo-addresses Note the following conventions: - Addresses follow the postal
   * hierarchy, not the political hierarchy. Addresses may have components that refer to political
   * entities when those entities also appear in the postal hierarchy. - As stated previously, but
   * it bears repeating, addresses on features are mailing addresses. In many cases the physical
   * address and the mailing address are the same but the address stored on a feature represents the
   * mailing address of the feature. An example of a non-physical mailing address would be a PO Box.
   * - These addresses are commonly defined and verifiable by a governmental authority (e.g. the
   * United States Postal Service in the United States, Royal Mail in the United Kingdom, Correios
   * in Brazil, etc.) and should follow conventions and rules defined by those authorities.
   * @param address address or {@code null} for none
   */
  public GeostoreFeatureProto setAddress(java.util.List<GeostoreAddressProto> address) {
    this.address = address;
    return this;
  }

  /**
   * Represents information about the feature’s anchored geometry.
   * @return value or {@code null} for none
   */
  public GeostoreAnchoredGeometryProto getAnchoredGeometry() {
    return anchoredGeometry;
  }

  /**
   * Represents information about the feature’s anchored geometry.
   * @param anchoredGeometry anchoredGeometry or {@code null} for none
   */
  public GeostoreFeatureProto setAnchoredGeometry(GeostoreAnchoredGeometryProto anchoredGeometry) {
    this.anchoredGeometry = anchoredGeometry;
    return this;
  }

  /**
   * The collection of attachments for this feature. Documentation: http://go/geo-attachments
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreAttachmentsAttachmentProto> getAttachment() {
    return attachment;
  }

  /**
   * The collection of attachments for this feature. Documentation: http://go/geo-attachments
   * @param attachment attachment or {@code null} for none
   */
  public GeostoreFeatureProto setAttachment(java.util.List<GeostoreAttachmentsAttachmentProto> attachment) {
    this.attachment = attachment;
    return this;
  }

  /**
   * ** DEPRECATED ** A list of attributes that describe defined aspects of this feature. An
   * attribute must be a concrete, high quality, and editable piece of information about a feature,
   * and must be used on some general consumer facing Google property. The data types used for
   * attributes must be primitive types or reusable in a generic manner.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreAttributeProto> getAttribute() {
    return attribute;
  }

  /**
   * ** DEPRECATED ** A list of attributes that describe defined aspects of this feature. An
   * attribute must be a concrete, high quality, and editable piece of information about a feature,
   * and must be used on some general consumer facing Google property. The data types used for
   * attributes must be primitive types or reusable in a generic manner.
   * @param attribute attribute or {@code null} for none
   */
  public GeostoreFeatureProto setAttribute(java.util.List<GeostoreAttributeProto> attribute) {
    this.attribute = attribute;
    return this;
  }

  /**
   * Describes the best-match locale for this feature.
   * @return value or {@code null} for none
   */
  public GeostoreBestLocaleProto getBestLocale() {
    return bestLocale;
  }

  /**
   * Describes the best-match locale for this feature.
   * @param bestLocale bestLocale or {@code null} for none
   */
  public GeostoreFeatureProto setBestLocale(GeostoreBestLocaleProto bestLocale) {
    this.bestLocale = bestLocale;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreBorderProto getBorder() {
    return border;
  }

  /**
   * @param border border or {@code null} for none
   */
  public GeostoreFeatureProto setBorder(GeostoreBorderProto border) {
    this.border = border;
    return this;
  }

  /**
   * A latitude-longitude rectangle used by bucketing MapReduces. See the documentation on bucketing
   * MapReduce for details. This field can be a source of confusion. Because it is called "bound",
   * it is often assumed that it is a tight bound on the geometry but it can be (and often is) much
   * larger. If a tight bound is needed then use the standard GetFeatureGeometryBound() function
   * instead. To be more explicit, if you are using this field for *anything* else than a bucketing
   * MapReduce, you are doing the wrong thing. Not all features are required to have bounding boxes.
   * See geostore::IsBoundRequiredForFeatureType() for the list of feature types required to have a
   * bounding box. This bound field will be updated when a feature changes in MapFacts to include
   * its geometry. Also, a GeoSchema pipeline, go/geo-schema-pipelines-docs#expand-bounds runs
   * periodically to update the field for strong references from other features. Therefore, most
   * editors don't need to edit this field explicitly. See go/geo-changes:no-edit-for-feature-bound
   * for the details.
   * @return value or {@code null} for none
   */
  public GeostoreRectProto getBound() {
    return bound;
  }

  /**
   * A latitude-longitude rectangle used by bucketing MapReduces. See the documentation on bucketing
   * MapReduce for details. This field can be a source of confusion. Because it is called "bound",
   * it is often assumed that it is a tight bound on the geometry but it can be (and often is) much
   * larger. If a tight bound is needed then use the standard GetFeatureGeometryBound() function
   * instead. To be more explicit, if you are using this field for *anything* else than a bucketing
   * MapReduce, you are doing the wrong thing. Not all features are required to have bounding boxes.
   * See geostore::IsBoundRequiredForFeatureType() for the list of feature types required to have a
   * bounding box. This bound field will be updated when a feature changes in MapFacts to include
   * its geometry. Also, a GeoSchema pipeline, go/geo-schema-pipelines-docs#expand-bounds runs
   * periodically to update the field for strong references from other features. Therefore, most
   * editors don't need to edit this field explicitly. See go/geo-changes:no-edit-for-feature-bound
   * for the details.
   * @param bound bound or {@code null} for none
   */
  public GeostoreFeatureProto setBound(GeostoreRectProto bound) {
    this.bound = bound;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreBuildingProto getBuilding() {
    return building;
  }

  /**
   * @param building building or {@code null} for none
   */
  public GeostoreFeatureProto setBuilding(GeostoreBuildingProto building) {
    this.building = building;
    return this;
  }

  /**
   * Data specific to business chain features, e.g., Canonical GConcepts.
   * @return value or {@code null} for none
   */
  public GeostoreBusinessChainProto getBusinessChain() {
    return businessChain;
  }

  /**
   * Data specific to business chain features, e.g., Canonical GConcepts.
   * @param businessChain businessChain or {@code null} for none
   */
  public GeostoreFeatureProto setBusinessChain(GeostoreBusinessChainProto businessChain) {
    this.businessChain = businessChain;
    return this;
  }

  /**
   * The conceptual center of the feature, used for routing. For cities, this would be the center of
   * the downtown, or maybe the location of city hall. For states and countries it might be the
   * capital city. Most feature types will not have a conceptual center - by default, routing will
   * use the centroid of the feature's geometry. If you need a feature center point consider using
   * GetFeatureGeometryCenter() function from geostore/base/public/feature.h rather than reading
   * from this field directly.
   * @return value or {@code null} for none
   */
  public GeostorePointProto getCenter() {
    return center;
  }

  /**
   * The conceptual center of the feature, used for routing. For cities, this would be the center of
   * the downtown, or maybe the location of city hall. For states and countries it might be the
   * capital city. Most feature types will not have a conceptual center - by default, routing will
   * use the centroid of the feature's geometry. If you need a feature center point consider using
   * GetFeatureGeometryCenter() function from geostore/base/public/feature.h rather than reading
   * from this field directly.
   * @param center center or {@code null} for none
   */
  public GeostoreFeatureProto setCenter(GeostorePointProto center) {
    this.center = center;
    return this;
  }

  /**
   * Features can define themselves as a collection of other features. For example, a route is a
   * collection of road segments, and a feature for the "Great Lakes" could be defined as lakes
   * Superior, Michigan, Huron, Erie, and Ontario. It is not recommended to design a multi level
   * tree using the child field to build up a feature because it requires fetching many features to
   * see the details of the feature. In practice this is used to model archipelago, route, transit
   * (agencies, lines, trips, departures), and river features. The geometry of a feature is
   * implicitly defined by its children, so if a feature has children then it should not have any
   * points, polylines, or polygons. In general, this field should not be used to represent
   * political or postal hierarchies. For example, a county would not list its cities as children,
   * because the county is not defined in terms of its cities (it also contains unincorporated
   * areas, etc.).
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreFeatureIdProto> getChild() {
    return child;
  }

  /**
   * Features can define themselves as a collection of other features. For example, a route is a
   * collection of road segments, and a feature for the "Great Lakes" could be defined as lakes
   * Superior, Michigan, Huron, Erie, and Ontario. It is not recommended to design a multi level
   * tree using the child field to build up a feature because it requires fetching many features to
   * see the details of the feature. In practice this is used to model archipelago, route, transit
   * (agencies, lines, trips, departures), and river features. The geometry of a feature is
   * implicitly defined by its children, so if a feature has children then it should not have any
   * points, polylines, or polygons. In general, this field should not be used to represent
   * political or postal hierarchies. For example, a county would not list its cities as children,
   * because the county is not defined in terms of its cities (it also contains unincorporated
   * areas, etc.).
   * @param child child or {@code null} for none
   */
  public GeostoreFeatureProto setChild(java.util.List<GeostoreFeatureIdProto> child) {
    this.child = child;
    return this;
  }

  /**
   * S2 cell coverings for this feature. See util/geometry/s2cell_union.h for more information about
   * S2 cells. Coverings are useful for quick containment or intersection tests. S2 covering that
   * consists of cells that intersect with the feature.
   * @return value or {@code null} for none
   */
  public GeostoreCellCoveringProto getCovering() {
    return covering;
  }

  /**
   * S2 cell coverings for this feature. See util/geometry/s2cell_union.h for more information about
   * S2 cells. Coverings are useful for quick containment or intersection tests. S2 covering that
   * consists of cells that intersect with the feature.
   * @param covering covering or {@code null} for none
   */
  public GeostoreFeatureProto setCovering(GeostoreCellCoveringProto covering) {
    this.covering = covering;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreDataSourceProto getDataSource() {
    return dataSource;
  }

  /**
   * @param dataSource dataSource or {@code null} for none
   */
  public GeostoreFeatureProto setDataSource(GeostoreDataSourceProto dataSource) {
    this.dataSource = dataSource;
    return this;
  }

  /**
   * Data used to render this feature on a map.
   * @return value or {@code null} for none
   */
  public GeostoreDisplayDataProto getDisplayData() {
    return displayData;
  }

  /**
   * Data used to render this feature on a map.
   * @param displayData displayData or {@code null} for none
   */
  public GeostoreFeatureProto setDisplayData(GeostoreDisplayDataProto displayData) {
    this.displayData = displayData;
    return this;
  }

  /**
   * ** DEPRECATED **
   * @return value or {@code null} for none
   */
  public GeostoreDoodleProto getDoodle() {
    return doodle;
  }

  /**
   * ** DEPRECATED **
   * @param doodle doodle or {@code null} for none
   */
  public GeostoreFeatureProto setDoodle(GeostoreDoodleProto doodle) {
    this.doodle = doodle;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreElevationProto getElevation() {
    return elevation;
  }

  /**
   * @param elevation elevation or {@code null} for none
   */
  public GeostoreFeatureProto setElevation(GeostoreElevationProto elevation) {
    this.elevation = elevation;
    return this;
  }

  /**
   * Captures elevation data used on TYPE_DIGITAL_ELEVATION_MODEL features.
   * @return value or {@code null} for none
   */
  public GeostoreElevationModelProto getElevationModel() {
    return elevationModel;
  }

  /**
   * Captures elevation data used on TYPE_DIGITAL_ELEVATION_MODEL features.
   * @param elevationModel elevationModel or {@code null} for none
   */
  public GeostoreFeatureProto setElevationModel(GeostoreElevationModelProto elevationModel) {
    this.elevationModel = elevationModel;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreEntranceProto getEntrance() {
    return entrance;
  }

  /**
   * @param entrance entrance or {@code null} for none
   */
  public GeostoreFeatureProto setEntrance(GeostoreEntranceProto entrance) {
    this.entrance = entrance;
    return this;
  }

  /**
   * Also allowed on TYPE_BUSINESS_CHAIN and TYPE_TRANSIT_AGENCY features, to model the feature's
   * phone number(s). Other fields within EstablishmentProto are not permitted on non-
   * TYPE_ESTABLISHMENT features.
   * @return value or {@code null} for none
   */
  public GeostoreEstablishmentProto getEstablishment() {
    return establishment;
  }

  /**
   * Also allowed on TYPE_BUSINESS_CHAIN and TYPE_TRANSIT_AGENCY features, to model the feature's
   * phone number(s). Other fields within EstablishmentProto are not permitted on non-
   * TYPE_ESTABLISHMENT features.
   * @param establishment establishment or {@code null} for none
   */
  public GeostoreFeatureProto setEstablishment(GeostoreEstablishmentProto establishment) {
    this.establishment = establishment;
    return this;
  }

  /**
   * A list of feature ids of polygon based restrictions that do not apply to this feature. This may
   * only include features of TYPE_REGULATED_AREA that also have a
   * feature.regulated_area.restriction field defined. Setting this field opts the feature out of
   * all restrictions set on that regulated area.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreFeatureIdProto> getExemptRegulatedArea() {
    return exemptRegulatedArea;
  }

  /**
   * A list of feature ids of polygon based restrictions that do not apply to this feature. This may
   * only include features of TYPE_REGULATED_AREA that also have a
   * feature.regulated_area.restriction field defined. Setting this field opts the feature out of
   * all restrictions set on that regulated area.
   * @param exemptRegulatedArea exemptRegulatedArea or {@code null} for none
   */
  public GeostoreFeatureProto setExemptRegulatedArea(java.util.List<GeostoreFeatureIdProto> exemptRegulatedArea) {
    this.exemptRegulatedArea = exemptRegulatedArea;
    return this;
  }

  /**
   * Specifies the TYPE_FUTURE_GEOMETRY whose geometry will replace this feature's geometry. If this
   * field is populated, the referenced future geometry must have a future_geometry_for referencing
   * this feature.
   * @return value or {@code null} for none
   */
  public GeostoreFeatureIdProto getFutureGeometry() {
    return futureGeometry;
  }

  /**
   * Specifies the TYPE_FUTURE_GEOMETRY whose geometry will replace this feature's geometry. If this
   * field is populated, the referenced future geometry must have a future_geometry_for referencing
   * this feature.
   * @param futureGeometry futureGeometry or {@code null} for none
   */
  public GeostoreFeatureProto setFutureGeometry(GeostoreFeatureIdProto futureGeometry) {
    this.futureGeometry = futureGeometry;
    return this;
  }

  /**
   * Specifies the feature that this feature's geometry will replace. If this field is populated,
   * the referenced feature must have a future_geometry reference back to this feature. This field
   * is only allowed (and required) for TYPE_FUTURE_GEOMETRY features.
   * @return value or {@code null} for none
   */
  public GeostoreFeatureIdProto getFutureGeometryFor() {
    return futureGeometryFor;
  }

  /**
   * Specifies the feature that this feature's geometry will replace. If this field is populated,
   * the referenced feature must have a future_geometry reference back to this feature. This field
   * is only allowed (and required) for TYPE_FUTURE_GEOMETRY features.
   * @param futureGeometryFor futureGeometryFor or {@code null} for none
   */
  public GeostoreFeatureProto setFutureGeometryFor(GeostoreFeatureIdProto futureGeometryFor) {
    this.futureGeometryFor = futureGeometryFor;
    return this;
  }

  /**
   * If set, the feature's actual location can be assumed to be somewhere within a circle of this
   * radius, centered on the feature's location. More information on this field at go/gpm-
   * definition-update. NOTE: Only applicable to features with 'point' geometry. Please contact geo-
   * schema-team@ if you have non-point use cases for which this field would be useful.
   * @return value or {@code null} for none
   */
  public java.lang.Double getGeometryPrecisionMeters() {
    return geometryPrecisionMeters;
  }

  /**
   * If set, the feature's actual location can be assumed to be somewhere within a circle of this
   * radius, centered on the feature's location. More information on this field at go/gpm-
   * definition-update. NOTE: Only applicable to features with 'point' geometry. Please contact geo-
   * schema-team@ if you have non-point use cases for which this field would be useful.
   * @param geometryPrecisionMeters geometryPrecisionMeters or {@code null} for none
   */
  public GeostoreFeatureProto setGeometryPrecisionMeters(java.lang.Double geometryPrecisionMeters) {
    this.geometryPrecisionMeters = geometryPrecisionMeters;
    return this;
  }

  /**
   * Geopolitical (unsimplified) polygons for a feature for different geopolitical use cases.
   * @return value or {@code null} for none
   */
  public GeostoreGeopoliticalGeometryProto getGeopoliticalGeometry() {
    return geopoliticalGeometry;
  }

  /**
   * Geopolitical (unsimplified) polygons for a feature for different geopolitical use cases.
   * @param geopoliticalGeometry geopoliticalGeometry or {@code null} for none
   */
  public GeostoreFeatureProto setGeopoliticalGeometry(GeostoreGeopoliticalGeometryProto geopoliticalGeometry) {
    this.geopoliticalGeometry = geopoliticalGeometry;
    return this;
  }

  /**
   * ** DEPRECATED ** Features can have zero or more HTML texts associated with them. These might be
   * HTML balloons used by Google Earth, for example.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreHtmlTextProto> getHtmlText() {
    return htmlText;
  }

  /**
   * ** DEPRECATED ** Features can have zero or more HTML texts associated with them. These might be
   * HTML balloons used by Google Earth, for example.
   * @param htmlText htmlText or {@code null} for none
   */
  public GeostoreFeatureProto setHtmlText(java.util.List<GeostoreHtmlTextProto> htmlText) {
    this.htmlText = htmlText;
    return this;
  }

  /**
   * The globally unique id for this feature.
   * @return value or {@code null} for none
   */
  public GeostoreFeatureIdProto getId() {
    return id;
  }

  /**
   * The globally unique id for this feature.
   * @param id id or {@code null} for none
   */
  public GeostoreFeatureProto setId(GeostoreFeatureIdProto id) {
    this.id = id;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreInferredGeometryProto getInferredGeometry() {
    return inferredGeometry;
  }

  /**
   * @param inferredGeometry inferredGeometry or {@code null} for none
   */
  public GeostoreFeatureProto setInferredGeometry(GeostoreInferredGeometryProto inferredGeometry) {
    this.inferredGeometry = inferredGeometry;
    return this;
  }

  /**
   * S2 interior covering that consists of cells completely enclosed within the feature's geometry
   * (for features with polygonal geometry).
   * @return value or {@code null} for none
   */
  public GeostoreCellCoveringProto getInteriorCovering() {
    return interiorCovering;
  }

  /**
   * S2 interior covering that consists of cells completely enclosed within the feature's geometry
   * (for features with polygonal geometry).
   * @param interiorCovering interiorCovering or {@code null} for none
   */
  public GeostoreFeatureProto setInteriorCovering(GeostoreCellCoveringProto interiorCovering) {
    this.interiorCovering = interiorCovering;
    return this;
  }

  /**
   * Additional internal feature-level attributes that may be set by data providers to be used
   * inside the Geo Data infrastructure. This field should never be present in the output of the Geo
   * Data infrastructure that read-only clients consume.
   * @return value or {@code null} for none
   */
  public GeostoreInternalFeatureProto getInternal() {
    return internal;
  }

  /**
   * Additional internal feature-level attributes that may be set by data providers to be used
   * inside the Geo Data infrastructure. This field should never be present in the output of the Geo
   * Data infrastructure that read-only clients consume.
   * @param internal internal or {@code null} for none
   */
  public GeostoreFeatureProto setInternal(GeostoreInternalFeatureProto internal) {
    this.internal = internal;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreIntersectionProto getIntersection() {
    return intersection;
  }

  /**
   * @param intersection intersection or {@code null} for none
   */
  public GeostoreFeatureProto setIntersection(GeostoreIntersectionProto intersection) {
    this.intersection = intersection;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreIntersectionGroupProto getIntersectionGroup() {
    return intersectionGroup;
  }

  /**
   * @param intersectionGroup intersectionGroup or {@code null} for none
   */
  public GeostoreFeatureProto setIntersectionGroup(GeostoreIntersectionGroupProto intersectionGroup) {
    this.intersectionGroup = intersectionGroup;
    return this;
  }

  /**
   * Properties that apply to this feature whose schema is defined in the Knowledge Graph schema
   * (see https://hume.google.com/graph/schema). Not all properties that exist in the KG schema can
   * be asserted via this mechanism. The set of properties that are allowed to be set on a feature
   * depends on the feature's GConcepts (and feature type). For instance, only gcid:country features
   * may have the /geo/type/country/president property (made up example, since that property doesn't
   * actually exist in the KG schema). GConcept hierarchy is taken into account for deciding the set
   * of allowed properties. Additionally, the specific properties allowed are further constrained by
   * the list specified at go/kg-property-allowlist. NOTE: not all types of properties are allowed
   * to appear in the Geo Schema. For now, we limit ourselves to properties whose value type is
   * TYPE_BOOL, TYPE_COMPOUND, TYPE_DATETIME, TYPE_FLOAT, TYPE_ID, TYPE_INT, TYPE_NESTED_STRUCT,
   * TYPE_TEXT, or TYPE_URI. NOTE(b/35039936): We are in the process of changing how a KG property
   * with multiple values is stored in this field. Currently, such a KG property is stored in a
   * single instance of the kg_property field. However, we will be changing this so that each value
   * will be stored in its own instance of kg_property. Any client that wants to read from this
   * field should be prepared to read data represented in either format. See b/35039936 or the
   * announcement at http://g/geo-schema-announce/7IXR3Fex8to/7yFyT5UoAwAJ for an example and more
   * details. The mechanism to assert that a KG property has no value is via the
   * property_value_status field below. freebase.PropertyValue.value_status is not allowed be set
   * here for consistency reason.
   * @return value or {@code null} for none
   */
  public java.util.List<FreebasePropertyValue> getKgProperty() {
    return kgProperty;
  }

  /**
   * Properties that apply to this feature whose schema is defined in the Knowledge Graph schema
   * (see https://hume.google.com/graph/schema). Not all properties that exist in the KG schema can
   * be asserted via this mechanism. The set of properties that are allowed to be set on a feature
   * depends on the feature's GConcepts (and feature type). For instance, only gcid:country features
   * may have the /geo/type/country/president property (made up example, since that property doesn't
   * actually exist in the KG schema). GConcept hierarchy is taken into account for deciding the set
   * of allowed properties. Additionally, the specific properties allowed are further constrained by
   * the list specified at go/kg-property-allowlist. NOTE: not all types of properties are allowed
   * to appear in the Geo Schema. For now, we limit ourselves to properties whose value type is
   * TYPE_BOOL, TYPE_COMPOUND, TYPE_DATETIME, TYPE_FLOAT, TYPE_ID, TYPE_INT, TYPE_NESTED_STRUCT,
   * TYPE_TEXT, or TYPE_URI. NOTE(b/35039936): We are in the process of changing how a KG property
   * with multiple values is stored in this field. Currently, such a KG property is stored in a
   * single instance of the kg_property field. However, we will be changing this so that each value
   * will be stored in its own instance of kg_property. Any client that wants to read from this
   * field should be prepared to read data represented in either format. See b/35039936 or the
   * announcement at http://g/geo-schema-announce/7IXR3Fex8to/7yFyT5UoAwAJ for an example and more
   * details. The mechanism to assert that a KG property has no value is via the
   * property_value_status field below. freebase.PropertyValue.value_status is not allowed be set
   * here for consistency reason.
   * @param kgProperty kgProperty or {@code null} for none
   */
  public GeostoreFeatureProto setKgProperty(java.util.List<FreebasePropertyValue> kgProperty) {
    this.kgProperty = kgProperty;
    return this;
  }

  /**
   * RESERVED
   * @return value or {@code null} for none
   */
  public GeostoreKnowledgeGraphReferenceProto getKnowledgeGraphReference() {
    return knowledgeGraphReference;
  }

  /**
   * RESERVED
   * @param knowledgeGraphReference knowledgeGraphReference or {@code null} for none
   */
  public GeostoreFeatureProto setKnowledgeGraphReference(GeostoreKnowledgeGraphReferenceProto knowledgeGraphReference) {
    this.knowledgeGraphReference = knowledgeGraphReference;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreLaneMarkerProto getLaneMarker() {
    return laneMarker;
  }

  /**
   * @param laneMarker laneMarker or {@code null} for none
   */
  public GeostoreFeatureProto setLaneMarker(GeostoreLaneMarkerProto laneMarker) {
    this.laneMarker = laneMarker;
    return this;
  }

  /**
   * Represents information about TYPE_LEVEL features.
   * @return value or {@code null} for none
   */
  public GeostoreLevelProto getLevel() {
    return level;
  }

  /**
   * Represents information about TYPE_LEVEL features.
   * @param level level or {@code null} for none
   */
  public GeostoreFeatureProto setLevel(GeostoreLevelProto level) {
    this.level = level;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreLocaleProto getLocale() {
    return locale;
  }

  /**
   * @param locale locale or {@code null} for none
   */
  public GeostoreFeatureProto setLocale(GeostoreLocaleProto locale) {
    this.locale = locale;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreLogicalBorderProto getLogicalBorder() {
    return logicalBorder;
  }

  /**
   * @param logicalBorder logicalBorder or {@code null} for none
   */
  public GeostoreFeatureProto setLogicalBorder(GeostoreLogicalBorderProto logicalBorder) {
    this.logicalBorder = logicalBorder;
    return this;
  }

  /**
   * Metadata about this particular feature. Metadata is managed internally by the Geo Data
   * Infrastructure and in general should not be set by clients. Features that don't ultimately come
   * from the Geo repository (MapFacts) won't have any metadata set.
   * @return value or {@code null} for none
   */
  public GeostoreFeatureMetadataProto getMetadata() {
    return metadata;
  }

  /**
   * Metadata about this particular feature. Metadata is managed internally by the Geo Data
   * Infrastructure and in general should not be set by clients. Features that don't ultimately come
   * from the Geo repository (MapFacts) won't have any metadata set.
   * @param metadata metadata or {@code null} for none
   */
  public GeostoreFeatureProto setMetadata(GeostoreFeatureMetadataProto metadata) {
    this.metadata = metadata;
    return this;
  }

  /**
   * The name(s) of this feature. A feature may have different names in different languages,
   * colloquial or "vanity" names, etc.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreNameProto> getName() {
    return name;
  }

  /**
   * The name(s) of this feature. A feature may have different names in different languages,
   * colloquial or "vanity" names, etc.
   * @param name name or {@code null} for none
   */
  public GeostoreFeatureProto setName(java.util.List<GeostoreNameProto> name) {
    this.name = name;
    return this;
  }

  /**
   * Information about this feature's operations, e.g. when this feature is temporarily closed.
   * NOTE: for legacy reasons, some closure-specifc information (e.g. permanent closure reason)
   * lives in ExistenceProto instead. In the future, such information should move here in
   * OperationsProto.
   * @return value or {@code null} for none
   */
  public GeostoreOperationsProto getOperations() {
    return operations;
  }

  /**
   * Information about this feature's operations, e.g. when this feature is temporarily closed.
   * NOTE: for legacy reasons, some closure-specifc information (e.g. permanent closure reason)
   * lives in ExistenceProto instead. In the future, such information should move here in
   * OperationsProto.
   * @param operations operations or {@code null} for none
   */
  public GeostoreFeatureProto setOperations(GeostoreOperationsProto operations) {
    this.operations = operations;
    return this;
  }

  /**
   * This field is used internally by the pipeline for id stability. It should not be set by
   * individual importers, nor should it be read by consumer clients. In particular, this field will
   * not be present in features read or snapshotted from the Mapfacts Repository.
   * @return value or {@code null} for none
   */
  public GeostoreFeatureIdProto getOriginalId() {
    return originalId;
  }

  /**
   * This field is used internally by the pipeline for id stability. It should not be set by
   * individual importers, nor should it be read by consumer clients. In particular, this field will
   * not be present in features read or snapshotted from the Mapfacts Repository.
   * @param originalId originalId or {@code null} for none
   */
  public GeostoreFeatureProto setOriginalId(GeostoreFeatureIdProto originalId) {
    this.originalId = originalId;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreFeatureIdProto> getParent() {
    return parent;
  }

  /**
   * @param parent parent or {@code null} for none
   */
  public GeostoreFeatureProto setParent(java.util.List<GeostoreFeatureIdProto> parent) {
    this.parent = parent;
    return this;
  }

  /**
   * Describes parking details for the feature.
   * @return value or {@code null} for none
   */
  public GeostoreParkingProto getParking() {
    return parking;
  }

  /**
   * Describes parking details for the feature.
   * @param parking parking or {@code null} for none
   */
  public GeostoreFeatureProto setParking(GeostoreParkingProto parking) {
    this.parking = parking;
    return this;
  }

  /**
   * Defines the geometry of the feature. The geometry may be specified as an arbitrary union of
   * points, poses, polylines, tracks, and polygons. Points, poses, polylines, and tracks are
   * assumed to represent regions of unspecified size or width rather than regions of zero area.
   * Most features should have some sort of geometry. Geometry may be synthesized if none is
   * available (e.g., polygons for postal codes). The synthetic_geometry flag should be set in that
   * case. Point is currently enforced as a non-repeating field for all feature types, though it is
   * defined as repeating in case future modeling requires multiple points. The number of allowed
   * polylines, tracks, or polygons vary based on feature type. A feature can have at most one pose
   * (it is an optional field).
   * @return value or {@code null} for none
   */
  public java.util.List<GeostorePointProto> getPoint() {
    return point;
  }

  /**
   * Defines the geometry of the feature. The geometry may be specified as an arbitrary union of
   * points, poses, polylines, tracks, and polygons. Points, poses, polylines, and tracks are
   * assumed to represent regions of unspecified size or width rather than regions of zero area.
   * Most features should have some sort of geometry. Geometry may be synthesized if none is
   * available (e.g., polygons for postal codes). The synthetic_geometry flag should be set in that
   * case. Point is currently enforced as a non-repeating field for all feature types, though it is
   * defined as repeating in case future modeling requires multiple points. The number of allowed
   * polylines, tracks, or polygons vary based on feature type. A feature can have at most one pose
   * (it is an optional field).
   * @param point point or {@code null} for none
   */
  public GeostoreFeatureProto setPoint(java.util.List<GeostorePointProto> point) {
    this.point = point;
    return this;
  }

  /**
   * ** DEPRECATED ** Detail discussion could be found at b/18611003.
   * @return value or {@code null} for none
   */
  public GeostorePoliticalProto getPolitical() {
    return political;
  }

  /**
   * ** DEPRECATED ** Detail discussion could be found at b/18611003.
   * @param political political or {@code null} for none
   */
  public GeostoreFeatureProto setPolitical(GeostorePoliticalProto political) {
    this.political = political;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.util.List<GeostorePolygonProto> getPolygon() {
    return polygon;
  }

  /**
   * @param polygon polygon or {@code null} for none
   */
  public GeostoreFeatureProto setPolygon(java.util.List<GeostorePolygonProto> polygon) {
    this.polygon = polygon;
    return this;
  }

  /**
   * Provide version of the geometry suitable for display. This has been subject to water removal
   * and (possibly) moderate simplification.
   * @return value or {@code null} for none
   */
  public GeostorePolygonProto getPolygonForDisplay() {
    return polygonForDisplay;
  }

  /**
   * Provide version of the geometry suitable for display. This has been subject to water removal
   * and (possibly) moderate simplification.
   * @param polygonForDisplay polygonForDisplay or {@code null} for none
   */
  public GeostoreFeatureProto setPolygonForDisplay(GeostorePolygonProto polygonForDisplay) {
    this.polygonForDisplay = polygonForDisplay;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.util.List<GeostorePolyLineProto> getPolyline() {
    return polyline;
  }

  /**
   * @param polyline polyline or {@code null} for none
   */
  public GeostoreFeatureProto setPolyline(java.util.List<GeostorePolyLineProto> polyline) {
    this.polyline = polyline;
    return this;
  }

  /**
   * Defines the geometry of a feature as a 6D pose, including lat, lng, altitude, roll, pitch, and
   * yaw along the WGS-84 ellipsoid. Only the lat and lng are strictly required.
   * @return value or {@code null} for none
   */
  public GeostorePoseProto getPose() {
    return pose;
  }

  /**
   * Defines the geometry of a feature as a 6D pose, including lat, lng, altitude, roll, pitch, and
   * yaw along the WGS-84 ellipsoid. Only the lat and lng are strictly required.
   * @param pose pose or {@code null} for none
   */
  public GeostoreFeatureProto setPose(GeostorePoseProto pose) {
    this.pose = pose;
    return this;
  }

  /**
   * The preferred viewport for this feature. If present, this latitude-longitude rectangle holds
   * the preferred viewport for the feature. For example, it might hold the bounds of the "central"
   * portion of a large city. There are no aspect ratio requirements. This is an optional field: if
   * no viewport is supplied, interested clients can use heuristics to determine a viewport. Calling
   * the standard GetFeatureGeometryBound() function would be a good way to start but note that it
   * can return an empty bounding box (e.g., if the feature has no geometry). The preferred viewport
   * is not necessarily fully contained by the above bounding box.
   * @return value or {@code null} for none
   */
  public GeostoreRectProto getPreferredViewport() {
    return preferredViewport;
  }

  /**
   * The preferred viewport for this feature. If present, this latitude-longitude rectangle holds
   * the preferred viewport for the feature. For example, it might hold the bounds of the "central"
   * portion of a large city. There are no aspect ratio requirements. This is an optional field: if
   * no viewport is supplied, interested clients can use heuristics to determine a viewport. Calling
   * the standard GetFeatureGeometryBound() function would be a good way to start but note that it
   * can return an empty bounding box (e.g., if the feature has no geometry). The preferred viewport
   * is not necessarily fully contained by the above bounding box.
   * @param preferredViewport preferredViewport or {@code null} for none
   */
  public GeostoreFeatureProto setPreferredViewport(GeostoreRectProto preferredViewport) {
    this.preferredViewport = preferredViewport;
    return this;
  }

  /**
   * The value status of properties on this feature. For example, this specifies whether the feature
   * is known to have no name (this is the value status of the 'FEATURE_NAME' property). Only
   * property IDs which have no specific value are allowed to have a value status. Note: not all
   * field types will be supported, please contact geo schema team if you want to enable this field
   * for a field type that is not currently supported.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostorePropertyValueStatusProto> getPropertyValueStatus() {
    return propertyValueStatus;
  }

  /**
   * The value status of properties on this feature. For example, this specifies whether the feature
   * is known to have no name (this is the value status of the 'FEATURE_NAME' property). Only
   * property IDs which have no specific value are allowed to have a value status. Note: not all
   * field types will be supported, please contact geo schema team if you want to enable this field
   * for a field type that is not currently supported.
   * @param propertyValueStatus propertyValueStatus or {@code null} for none
   */
  public GeostoreFeatureProto setPropertyValueStatus(java.util.List<GeostorePropertyValueStatusProto> propertyValueStatus) {
    this.propertyValueStatus = propertyValueStatus;
    return this;
  }

  /**
   * WARNING: Please do NOT introduce new uses of this field; treat it as if it were deprecated. For
   * appropriate ranking contacts, see g3doc/company/teams/gdeng/geo-schema-reference/home/feature-
   * properties/rank.md. A floating-point number between 0.0 and 1.0 indicating how "important" we
   * think this feature is. This can be used to decide which features to render on maps, and how to
   * rank results when the user does a search. The rank can depend on any number of factors such as
   * the number of references to this feature in web pages, geographic size, population, number of
   * referring geographic entities, "priority" information encoded in the source data, etc.
   * @return value or {@code null} for none
   */
  public java.lang.Float getRank() {
    return rank;
  }

  /**
   * WARNING: Please do NOT introduce new uses of this field; treat it as if it were deprecated. For
   * appropriate ranking contacts, see g3doc/company/teams/gdeng/geo-schema-reference/home/feature-
   * properties/rank.md. A floating-point number between 0.0 and 1.0 indicating how "important" we
   * think this feature is. This can be used to decide which features to render on maps, and how to
   * rank results when the user does a search. The rank can depend on any number of factors such as
   * the number of references to this feature in web pages, geographic size, population, number of
   * referring geographic entities, "priority" information encoded in the source data, etc.
   * @param rank rank or {@code null} for none
   */
  public GeostoreFeatureProto setRank(java.lang.Float rank) {
    this.rank = rank;
    return this;
  }

  /**
   * The rank field is computed as a weighted sum of several signals. This field contains a protocol
   * buffer whose fields give those signals and their weights. Clients should try very hard not to
   * depend on these individual signals and use the single rank field instead. At some point in the
   * future, this field will not be exposed anymore.
   * @return value or {@code null} for none
   */
  public GeostoreRankDetailsProto getRankDetails() {
    return rankDetails;
  }

  /**
   * The rank field is computed as a weighted sum of several signals. This field contains a protocol
   * buffer whose fields give those signals and their weights. Clients should try very hard not to
   * depend on these individual signals and use the single rank field instead. At some point in the
   * future, this field will not be exposed anymore.
   * @param rankDetails rankDetails or {@code null} for none
   */
  public GeostoreFeatureProto setRankDetails(GeostoreRankDetailsProto rankDetails) {
    this.rankDetails = rankDetails;
    return this;
  }

  /**
   * Geo Ontology GConcept Instances - Design doc linked off http://go/geo-ontology - In order to
   * shield clients from changes in GConcept representation we provide an accessor library:
   * geostore/base/public/gconcept_instance.h
   * @return value or {@code null} for none
   */
  public GeostoreOntologyRawGConceptInstanceContainerProto getRawGconceptInstanceContainer() {
    return rawGconceptInstanceContainer;
  }

  /**
   * Geo Ontology GConcept Instances - Design doc linked off http://go/geo-ontology - In order to
   * shield clients from changes in GConcept representation we provide an accessor library:
   * geostore/base/public/gconcept_instance.h
   * @param rawGconceptInstanceContainer rawGconceptInstanceContainer or {@code null} for none
   */
  public GeostoreFeatureProto setRawGconceptInstanceContainer(GeostoreOntologyRawGConceptInstanceContainerProto rawGconceptInstanceContainer) {
    this.rawGconceptInstanceContainer = rawGconceptInstanceContainer;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreRegulatedAreaProto getRegulatedArea() {
    return regulatedArea;
  }

  /**
   * @param regulatedArea regulatedArea or {@code null} for none
   */
  public GeostoreFeatureProto setRegulatedArea(GeostoreRegulatedAreaProto regulatedArea) {
    this.regulatedArea = regulatedArea;
    return this;
  }

  /**
   * For TYPE_COUNTRY or TYPE_ADMINISTRATIVE_AREA1 features, this field defines the associated
   * TYPE_BORDERs which reference this feature. The linked TYPE_BORDERs must have the feature.border
   * set, pointing to this feature. TYPE_COUNTRY or TYPE_ADMINISTRATIVE_AREA1 features must have
   * this field set for each TYPE_BORDER referencing them.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreFeatureIdProto> getRelatedBorder() {
    return relatedBorder;
  }

  /**
   * For TYPE_COUNTRY or TYPE_ADMINISTRATIVE_AREA1 features, this field defines the associated
   * TYPE_BORDERs which reference this feature. The linked TYPE_BORDERs must have the feature.border
   * set, pointing to this feature. TYPE_COUNTRY or TYPE_ADMINISTRATIVE_AREA1 features must have
   * this field set for each TYPE_BORDER referencing them.
   * @param relatedBorder relatedBorder or {@code null} for none
   */
  public GeostoreFeatureProto setRelatedBorder(java.util.List<GeostoreFeatureIdProto> relatedBorder) {
    this.relatedBorder = relatedBorder;
    return this;
  }

  /**
   * Logical relationship to other features that are entrances or exits to this feature.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreEntranceReferenceProto> getRelatedEntrance() {
    return relatedEntrance;
  }

  /**
   * Logical relationship to other features that are entrances or exits to this feature.
   * @param relatedEntrance relatedEntrance or {@code null} for none
   */
  public GeostoreFeatureProto setRelatedEntrance(java.util.List<GeostoreEntranceReferenceProto> relatedEntrance) {
    this.relatedEntrance = relatedEntrance;
    return this;
  }

  /**
   * Geographic or logical relationships to other features. Importers don't need to fill a
   * geographic relationship in - it is handled by related feature processing by a standalone
   * pipeline. Adding "contained by" country relations is however encouraged (and required for
   * TYPE_ROUTE features). WARNING: Updates to this field handled by standalone pipelines are NOT
   * atomic with regard to updates to the features being referenced; we do not guarantee that a
   * given MapFacts snapshot will be consistent between this field and the related features.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreRelationProto> getRelatedFeature() {
    return relatedFeature;
  }

  /**
   * Geographic or logical relationships to other features. Importers don't need to fill a
   * geographic relationship in - it is handled by related feature processing by a standalone
   * pipeline. Adding "contained by" country relations is however encouraged (and required for
   * TYPE_ROUTE features). WARNING: Updates to this field handled by standalone pipelines are NOT
   * atomic with regard to updates to the features being referenced; we do not guarantee that a
   * given MapFacts snapshot will be consistent between this field and the related features.
   * @param relatedFeature relatedFeature or {@code null} for none
   */
  public GeostoreFeatureProto setRelatedFeature(java.util.List<GeostoreRelationProto> relatedFeature) {
    this.relatedFeature = relatedFeature;
    return this;
  }

  /**
   * Terminal points associated with this feature. For instance, an airport terminal may have
   * specifically designated pickup and drop-off points.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreFeatureIdProto> getRelatedTerminalPoint() {
    return relatedTerminalPoint;
  }

  /**
   * Terminal points associated with this feature. For instance, an airport terminal may have
   * specifically designated pickup and drop-off points.
   * @param relatedTerminalPoint relatedTerminalPoint or {@code null} for none
   */
  public GeostoreFeatureProto setRelatedTerminalPoint(java.util.List<GeostoreFeatureIdProto> relatedTerminalPoint) {
    this.relatedTerminalPoint = relatedTerminalPoint;
    return this;
  }

  /**
   * Contains time zones known to be associated with a feature. Most features are associated with
   * the single time zone that contains them. However, some larger features (countries, continents,
   * etc.) are associated with all of the time zones they contain. Most features can have any number
   * of related time zones, but TYPE_SEGMENT and TYPE_ESTABLISHMENT_POI features can have at most 1.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreTimezoneProto> getRelatedTimezone() {
    return relatedTimezone;
  }

  /**
   * Contains time zones known to be associated with a feature. Most features are associated with
   * the single time zone that contains them. However, some larger features (countries, continents,
   * etc.) are associated with all of the time zones they contain. Most features can have any number
   * of related time zones, but TYPE_SEGMENT and TYPE_ESTABLISHMENT_POI features can have at most 1.
   * @param relatedTimezone relatedTimezone or {@code null} for none
   */
  public GeostoreFeatureProto setRelatedTimezone(java.util.List<GeostoreTimezoneProto> relatedTimezone) {
    this.relatedTimezone = relatedTimezone;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreRestrictionGroupProto getRestrictionGroup() {
    return restrictionGroup;
  }

  /**
   * @param restrictionGroup restrictionGroup or {@code null} for none
   */
  public GeostoreFeatureProto setRestrictionGroup(GeostoreRestrictionGroupProto restrictionGroup) {
    this.restrictionGroup = restrictionGroup;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreRoadMonitorProto getRoadMonitor() {
    return roadMonitor;
  }

  /**
   * @param roadMonitor roadMonitor or {@code null} for none
   */
  public GeostoreFeatureProto setRoadMonitor(GeostoreRoadMonitorProto roadMonitor) {
    this.roadMonitor = roadMonitor;
    return this;
  }

  /**
   * Additional details on the feature types below can be found in the individual protocol buffer
   * definitions. These extensions capture data that is specific to a set of feature types and which
   * makes no sense for other feature types.
   * @return value or {@code null} for none
   */
  public GeostoreRouteProto getRoute() {
    return route;
  }

  /**
   * Additional details on the feature types below can be found in the individual protocol buffer
   * definitions. These extensions capture data that is specific to a set of feature types and which
   * makes no sense for other feature types.
   * @param route route or {@code null} for none
   */
  public GeostoreFeatureProto setRoute(GeostoreRouteProto route) {
    this.route = route;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreSchoolDistrictProto getSchoolDistrict() {
    return schoolDistrict;
  }

  /**
   * @param schoolDistrict schoolDistrict or {@code null} for none
   */
  public GeostoreFeatureProto setSchoolDistrict(GeostoreSchoolDistrictProto schoolDistrict) {
    this.schoolDistrict = schoolDistrict;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreSegmentProto getSegment() {
    return segment;
  }

  /**
   * @param segment segment or {@code null} for none
   */
  public GeostoreFeatureProto setSegment(GeostoreSegmentProto segment) {
    this.segment = segment;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreSegmentPathProto getSegmentPath() {
    return segmentPath;
  }

  /**
   * @param segmentPath segmentPath or {@code null} for none
   */
  public GeostoreFeatureProto setSegmentPath(GeostoreSegmentPathProto segmentPath) {
    this.segmentPath = segmentPath;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreRoadSignProto getSign() {
    return sign;
  }

  /**
   * @param sign sign or {@code null} for none
   */
  public GeostoreFeatureProto setSign(GeostoreRoadSignProto sign) {
    this.sign = sign;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreSkiBoundaryProto getSkiBoundary() {
    return skiBoundary;
  }

  /**
   * @param skiBoundary skiBoundary or {@code null} for none
   */
  public GeostoreFeatureProto setSkiBoundary(GeostoreSkiBoundaryProto skiBoundary) {
    this.skiBoundary = skiBoundary;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreSkiLiftProto getSkiLift() {
    return skiLift;
  }

  /**
   * @param skiLift skiLift or {@code null} for none
   */
  public GeostoreFeatureProto setSkiLift(GeostoreSkiLiftProto skiLift) {
    this.skiLift = skiLift;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreSkiTrailProto getSkiTrail() {
    return skiTrail;
  }

  /**
   * @param skiTrail skiTrail or {@code null} for none
   */
  public GeostoreFeatureProto setSkiTrail(GeostoreSkiTrailProto skiTrail) {
    this.skiTrail = skiTrail;
    return this;
  }

  /**
   * All establishments must have a social reference. WARNING: Aside from creating new
   * establishments, please do NOT introduce new uses; treat social references as if they were
   * deprecated. For alternatives and more, see g3doc/company/teams/gdeng/geo-schema-reference/home
   * /feature-types/establishments/social-reference.md.
   * @return value or {@code null} for none
   */
  public GeostoreSocialReferenceProto getSocialReference() {
    return socialReference;
  }

  /**
   * All establishments must have a social reference. WARNING: Aside from creating new
   * establishments, please do NOT introduce new uses; treat social references as if they were
   * deprecated. For alternatives and more, see g3doc/company/teams/gdeng/geo-schema-reference/home
   * /feature-types/establishments/social-reference.md.
   * @param socialReference socialReference or {@code null} for none
   */
  public GeostoreFeatureProto setSocialReference(GeostoreSocialReferenceProto socialReference) {
    this.socialReference = socialReference;
    return this;
  }

  /**
   * A list of the data sources that were used to construct this feature, together with optional
   * "raw data" in the provider's format. Raw data should not be used by production clients but may
   * be useful for exploring data that is not currently converted to a canonical form.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreSourceInfoProto> getSourceInfo() {
    return sourceInfo;
  }

  /**
   * A list of the data sources that were used to construct this feature, together with optional
   * "raw data" in the provider's format. Raw data should not be used by production clients but may
   * be useful for exploring data that is not currently converted to a canonical form.
   * @param sourceInfo sourceInfo or {@code null} for none
   */
  public GeostoreFeatureProto setSourceInfo(java.util.List<GeostoreSourceInfoProto> sourceInfo) {
    this.sourceInfo = sourceInfo;
    return this;
  }

  /**
   * All features can have "existence" information associated with them.
   * @return value or {@code null} for none
   */
  public GeostoreExistenceProto getStatus() {
    return status;
  }

  /**
   * All features can have "existence" information associated with them.
   * @param status status or {@code null} for none
   */
  public GeostoreFeatureProto setStatus(GeostoreExistenceProto status) {
    this.status = status;
    return this;
  }

  /**
   * Represents information about the store front geoemtry. Only TYPE_ESTABLISHMENT_POI should have
   * this field set.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreAnchoredGeometryProto> getStorefrontGeometry() {
    return storefrontGeometry;
  }

  /**
   * Represents information about the store front geoemtry. Only TYPE_ESTABLISHMENT_POI should have
   * this field set.
   * @param storefrontGeometry storefrontGeometry or {@code null} for none
   */
  public GeostoreFeatureProto setStorefrontGeometry(java.util.List<GeostoreAnchoredGeometryProto> storefrontGeometry) {
    this.storefrontGeometry = storefrontGeometry;
    return this;
  }

  /**
   * We prefer features that have geometry over those that do not. In some cases we synthesize
   * geometry (e.g., polygons for postal codes). This flag is set to indicate features that have
   * such synthetic geometry.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getSyntheticGeometry() {
    return syntheticGeometry;
  }

  /**
   * We prefer features that have geometry over those that do not. In some cases we synthesize
   * geometry (e.g., polygons for postal codes). This flag is set to indicate features that have
   * such synthetic geometry.
   * @param syntheticGeometry syntheticGeometry or {@code null} for none
   */
  public GeostoreFeatureProto setSyntheticGeometry(java.lang.Boolean syntheticGeometry) {
    this.syntheticGeometry = syntheticGeometry;
    return this;
  }

  /**
   * A place for clients to attach arbitrary data to a feature. Never set in MapFacts.
   * @return value or {@code null} for none
   */
  public Proto2BridgeMessageSet getTemporaryData() {
    return temporaryData;
  }

  /**
   * A place for clients to attach arbitrary data to a feature. Never set in MapFacts.
   * @param temporaryData temporaryData or {@code null} for none
   */
  public GeostoreFeatureProto setTemporaryData(Proto2BridgeMessageSet temporaryData) {
    this.temporaryData = temporaryData;
    return this;
  }

  /**
   * Captures full model representing the feature's 3D geometry. Should only be found on
   * TYPE_COMPOUND_BUILDING features for now, but not part of the BuildingProto extension for
   * possible future extensions.
   * @return value or {@code null} for none
   */
  public GeostoreThreeDimensionalModelProto getThreeDimModel() {
    return threeDimModel;
  }

  /**
   * Captures full model representing the feature's 3D geometry. Should only be found on
   * TYPE_COMPOUND_BUILDING features for now, but not part of the BuildingProto extension for
   * possible future extensions.
   * @param threeDimModel threeDimModel or {@code null} for none
   */
  public GeostoreFeatureProto setThreeDimModel(GeostoreThreeDimensionalModelProto threeDimModel) {
    this.threeDimModel = threeDimModel;
    return this;
  }

  /**
   * Represents information about TYPE_TOLL_CLUSTER features.
   * @return value or {@code null} for none
   */
  public GeostoreTollClusterProto getTollCluster() {
    return tollCluster;
  }

  /**
   * Represents information about TYPE_TOLL_CLUSTER features.
   * @param tollCluster tollCluster or {@code null} for none
   */
  public GeostoreFeatureProto setTollCluster(GeostoreTollClusterProto tollCluster) {
    this.tollCluster = tollCluster;
    return this;
  }

  /**
   * Defines the geometry of a feature as a sequence of 6D poses, including lat, lng, altitude,
   * roll, pitch, and yaw. Only lat and lng are typically required. Each track has an index so that
   * they can be viewed in a stable order.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreTrackProto> getTrack() {
    return track;
  }

  /**
   * Defines the geometry of a feature as a sequence of 6D poses, including lat, lng, altitude,
   * roll, pitch, and yaw. Only lat and lng are typically required. Each track has an index so that
   * they can be viewed in a stable order.
   * @param track track or {@code null} for none
   */
  public GeostoreFeatureProto setTrack(java.util.List<GeostoreTrackProto> track) {
    this.track = track;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreTransitLineProto getTransitLine() {
    return transitLine;
  }

  /**
   * @param transitLine transitLine or {@code null} for none
   */
  public GeostoreFeatureProto setTransitLine(GeostoreTransitLineProto transitLine) {
    this.transitLine = transitLine;
    return this;
  }

  /**
   * RESERVED
   * @return value or {@code null} for none
   */
  public GeostoreTransitLineVariantProto getTransitLineVariant() {
    return transitLineVariant;
  }

  /**
   * RESERVED
   * @param transitLineVariant transitLineVariant or {@code null} for none
   */
  public GeostoreFeatureProto setTransitLineVariant(GeostoreTransitLineVariantProto transitLineVariant) {
    this.transitLineVariant = transitLineVariant;
    return this;
  }

  /**
   * RESERVED
   * @return value or {@code null} for none
   */
  public GeostoreTransitStationProto getTransitStation() {
    return transitStation;
  }

  /**
   * RESERVED
   * @param transitStation transitStation or {@code null} for none
   */
  public GeostoreFeatureProto setTransitStation(GeostoreTransitStationProto transitStation) {
    this.transitStation = transitStation;
    return this;
  }

  /**
   * The type of this feature -- see comments above.
   * @return value or {@code null} for none
   */
  public java.lang.String getType() {
    return type;
  }

  /**
   * The type of this feature -- see comments above.
   * @param type type or {@code null} for none
   */
  public GeostoreFeatureProto setType(java.lang.String type) {
    this.type = type;
    return this;
  }

  /**
   * Represents vertical ordering for this feature relative to other geometrically-overlaping
   * features. See go/aboutgrades for more information about distinction among different levels.
   * @return value or {@code null} for none
   */
  public GeostoreVerticalOrderingProto getVerticalOrdering() {
    return verticalOrdering;
  }

  /**
   * Represents vertical ordering for this feature relative to other geometrically-overlaping
   * features. See go/aboutgrades for more information about distinction among different levels.
   * @param verticalOrdering verticalOrdering or {@code null} for none
   */
  public GeostoreFeatureProto setVerticalOrdering(GeostoreVerticalOrderingProto verticalOrdering) {
    this.verticalOrdering = verticalOrdering;
    return this;
  }

  /**
   * A version of the geometry which has water removed but is not simplified (thus having equal or
   * more vertices than polygon_for_display).
   * @return value or {@code null} for none
   */
  public GeostorePolygonProto getWaterRemovedPolygon() {
    return waterRemovedPolygon;
  }

  /**
   * A version of the geometry which has water removed but is not simplified (thus having equal or
   * more vertices than polygon_for_display).
   * @param waterRemovedPolygon waterRemovedPolygon or {@code null} for none
   */
  public GeostoreFeatureProto setWaterRemovedPolygon(GeostorePolygonProto waterRemovedPolygon) {
    this.waterRemovedPolygon = waterRemovedPolygon;
    return this;
  }

  /**
   * The official website of this feature. Stored as a repeated field to allow for multilingual
   * official websites (see comments in url.proto).
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreUrlProto> getWebsite() {
    return website;
  }

  /**
   * The official website of this feature. Stored as a repeated field to allow for multilingual
   * official websites (see comments in url.proto).
   * @param website website or {@code null} for none
   */
  public GeostoreFeatureProto setWebsite(java.util.List<GeostoreUrlProto> website) {
    this.website = website;
    return this;
  }

  @Override
  public GeostoreFeatureProto set(String fieldName, Object value) {
    return (GeostoreFeatureProto) super.set(fieldName, value);
  }

  @Override
  public GeostoreFeatureProto clone() {
    return (GeostoreFeatureProto) super.clone();
  }

}
