/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.addressvalidation.v1.model;

/**
 * Details of the post-processed address. Post-processing includes correcting misspelled parts of
 * the address, replacing incorrect parts, and inferring missing parts.
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the Address Validation API. For a detailed explanation
 * see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class GoogleMapsAddressvalidationV1Address extends com.google.api.client.json.GenericJson {

  /**
   * Unordered list. The individual address components of the formatted and corrected address, along
   * with validation information. This provides information on the validation status of the
   * individual components. Address components are not ordered in a particular way. Do not make any
   * assumptions on the ordering of the address components in the list.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GoogleMapsAddressvalidationV1AddressComponent> addressComponents;

  /**
   * The post-processed address, formatted as a single-line address following the address formatting
   * rules of the region where the address is located. Note: the format of this address may not
   * match the format of the address in the `postal_address` field. For example, the
   * `postal_address` always represents the country as a 2 letter `region_code`, such as "US" or
   * "NZ". By contrast, this field uses a longer form of the country name, such as "USA" or "New
   * Zealand".
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String formattedAddress;

  /**
   * The types of components that were expected to be present in a correctly formatted mailing
   * address but were not found in the input AND could not be inferred. An example might be
   * `['street_number', 'route']` for an input like "Boulder, Colorado, 80301, USA". The list of
   * possible types can be found
   * [here](https://developers.google.com/maps/documentation/geocoding/requests-geocoding#Types).
   * **Note: you might see a missing component type when you think you've already supplied the
   * missing component.** For example, this can happen when the input address contains the building
   * name, but not the premise number. In the address "渋谷区渋谷３丁目　Shibuya Stream", the building name
   * "Shibuya Stream" has the component type `premise`, but the premise number is missing, so
   * `missing_component_types` will contain `premise`.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.String> missingComponentTypes;

  /**
   * The post-processed address represented as a postal address.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GoogleTypePostalAddress postalAddress;

  /**
   * The types of the components that are present in the `address_components` but could not be
   * confirmed to be correct. This field is provided for the sake of convenience: its contents are
   * equivalent to iterating through the `address_components` to find the types of all the
   * components where the confirmation_level is not CONFIRMED or the inferred flag is not set to
   * `true`. The list of possible types can be found
   * [here](https://developers.google.com/maps/documentation/geocoding/requests-geocoding#Types).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.String> unconfirmedComponentTypes;

  /**
   * Any tokens in the input that could not be resolved. This might be an input that was not
   * recognized as a valid part of an address. For example, for an input such as "Parcel 0000123123
   * & 0000456456 Str # Guthrie Center IA 50115 US", the unresolved tokens might look like
   * `["Parcel", "0000123123", "&", "0000456456"]`.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.String> unresolvedTokens;

  /**
   * Unordered list. The individual address components of the formatted and corrected address, along
   * with validation information. This provides information on the validation status of the
   * individual components. Address components are not ordered in a particular way. Do not make any
   * assumptions on the ordering of the address components in the list.
   * @return value or {@code null} for none
   */
  public java.util.List<GoogleMapsAddressvalidationV1AddressComponent> getAddressComponents() {
    return addressComponents;
  }

  /**
   * Unordered list. The individual address components of the formatted and corrected address, along
   * with validation information. This provides information on the validation status of the
   * individual components. Address components are not ordered in a particular way. Do not make any
   * assumptions on the ordering of the address components in the list.
   * @param addressComponents addressComponents or {@code null} for none
   */
  public GoogleMapsAddressvalidationV1Address setAddressComponents(java.util.List<GoogleMapsAddressvalidationV1AddressComponent> addressComponents) {
    this.addressComponents = addressComponents;
    return this;
  }

  /**
   * The post-processed address, formatted as a single-line address following the address formatting
   * rules of the region where the address is located. Note: the format of this address may not
   * match the format of the address in the `postal_address` field. For example, the
   * `postal_address` always represents the country as a 2 letter `region_code`, such as "US" or
   * "NZ". By contrast, this field uses a longer form of the country name, such as "USA" or "New
   * Zealand".
   * @return value or {@code null} for none
   */
  public java.lang.String getFormattedAddress() {
    return formattedAddress;
  }

  /**
   * The post-processed address, formatted as a single-line address following the address formatting
   * rules of the region where the address is located. Note: the format of this address may not
   * match the format of the address in the `postal_address` field. For example, the
   * `postal_address` always represents the country as a 2 letter `region_code`, such as "US" or
   * "NZ". By contrast, this field uses a longer form of the country name, such as "USA" or "New
   * Zealand".
   * @param formattedAddress formattedAddress or {@code null} for none
   */
  public GoogleMapsAddressvalidationV1Address setFormattedAddress(java.lang.String formattedAddress) {
    this.formattedAddress = formattedAddress;
    return this;
  }

  /**
   * The types of components that were expected to be present in a correctly formatted mailing
   * address but were not found in the input AND could not be inferred. An example might be
   * `['street_number', 'route']` for an input like "Boulder, Colorado, 80301, USA". The list of
   * possible types can be found
   * [here](https://developers.google.com/maps/documentation/geocoding/requests-geocoding#Types).
   * **Note: you might see a missing component type when you think you've already supplied the
   * missing component.** For example, this can happen when the input address contains the building
   * name, but not the premise number. In the address "渋谷区渋谷３丁目　Shibuya Stream", the building name
   * "Shibuya Stream" has the component type `premise`, but the premise number is missing, so
   * `missing_component_types` will contain `premise`.
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.String> getMissingComponentTypes() {
    return missingComponentTypes;
  }

  /**
   * The types of components that were expected to be present in a correctly formatted mailing
   * address but were not found in the input AND could not be inferred. An example might be
   * `['street_number', 'route']` for an input like "Boulder, Colorado, 80301, USA". The list of
   * possible types can be found
   * [here](https://developers.google.com/maps/documentation/geocoding/requests-geocoding#Types).
   * **Note: you might see a missing component type when you think you've already supplied the
   * missing component.** For example, this can happen when the input address contains the building
   * name, but not the premise number. In the address "渋谷区渋谷３丁目　Shibuya Stream", the building name
   * "Shibuya Stream" has the component type `premise`, but the premise number is missing, so
   * `missing_component_types` will contain `premise`.
   * @param missingComponentTypes missingComponentTypes or {@code null} for none
   */
  public GoogleMapsAddressvalidationV1Address setMissingComponentTypes(java.util.List<java.lang.String> missingComponentTypes) {
    this.missingComponentTypes = missingComponentTypes;
    return this;
  }

  /**
   * The post-processed address represented as a postal address.
   * @return value or {@code null} for none
   */
  public GoogleTypePostalAddress getPostalAddress() {
    return postalAddress;
  }

  /**
   * The post-processed address represented as a postal address.
   * @param postalAddress postalAddress or {@code null} for none
   */
  public GoogleMapsAddressvalidationV1Address setPostalAddress(GoogleTypePostalAddress postalAddress) {
    this.postalAddress = postalAddress;
    return this;
  }

  /**
   * The types of the components that are present in the `address_components` but could not be
   * confirmed to be correct. This field is provided for the sake of convenience: its contents are
   * equivalent to iterating through the `address_components` to find the types of all the
   * components where the confirmation_level is not CONFIRMED or the inferred flag is not set to
   * `true`. The list of possible types can be found
   * [here](https://developers.google.com/maps/documentation/geocoding/requests-geocoding#Types).
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.String> getUnconfirmedComponentTypes() {
    return unconfirmedComponentTypes;
  }

  /**
   * The types of the components that are present in the `address_components` but could not be
   * confirmed to be correct. This field is provided for the sake of convenience: its contents are
   * equivalent to iterating through the `address_components` to find the types of all the
   * components where the confirmation_level is not CONFIRMED or the inferred flag is not set to
   * `true`. The list of possible types can be found
   * [here](https://developers.google.com/maps/documentation/geocoding/requests-geocoding#Types).
   * @param unconfirmedComponentTypes unconfirmedComponentTypes or {@code null} for none
   */
  public GoogleMapsAddressvalidationV1Address setUnconfirmedComponentTypes(java.util.List<java.lang.String> unconfirmedComponentTypes) {
    this.unconfirmedComponentTypes = unconfirmedComponentTypes;
    return this;
  }

  /**
   * Any tokens in the input that could not be resolved. This might be an input that was not
   * recognized as a valid part of an address. For example, for an input such as "Parcel 0000123123
   * & 0000456456 Str # Guthrie Center IA 50115 US", the unresolved tokens might look like
   * `["Parcel", "0000123123", "&", "0000456456"]`.
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.String> getUnresolvedTokens() {
    return unresolvedTokens;
  }

  /**
   * Any tokens in the input that could not be resolved. This might be an input that was not
   * recognized as a valid part of an address. For example, for an input such as "Parcel 0000123123
   * & 0000456456 Str # Guthrie Center IA 50115 US", the unresolved tokens might look like
   * `["Parcel", "0000123123", "&", "0000456456"]`.
   * @param unresolvedTokens unresolvedTokens or {@code null} for none
   */
  public GoogleMapsAddressvalidationV1Address setUnresolvedTokens(java.util.List<java.lang.String> unresolvedTokens) {
    this.unresolvedTokens = unresolvedTokens;
    return this;
  }

  @Override
  public GoogleMapsAddressvalidationV1Address set(String fieldName, Object value) {
    return (GoogleMapsAddressvalidationV1Address) super.set(fieldName, value);
  }

  @Override
  public GoogleMapsAddressvalidationV1Address clone() {
    return (GoogleMapsAddressvalidationV1Address) super.clone();
  }

}
