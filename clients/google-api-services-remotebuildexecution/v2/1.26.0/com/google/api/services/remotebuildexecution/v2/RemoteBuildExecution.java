/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.remotebuildexecution.v2;

/**
 * Service definition for RemoteBuildExecution (v2).
 *
 * <p>
 * Supplies a Remote Execution API service for tools such as bazel.
 * </p>
 *
 * <p>
 * For more information about this service, see the
 * <a href="https://cloud.google.com/remote-build-execution/docs/" target="_blank">API Documentation</a>
 * </p>
 *
 * <p>
 * This service uses {@link RemoteBuildExecutionRequestInitializer} to initialize global parameters via its
 * {@link Builder}.
 * </p>
 *
 * @since 1.3
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public class RemoteBuildExecution extends com.google.api.client.googleapis.services.json.AbstractGoogleJsonClient {

  // Note: Leave this static initializer at the top of the file.
  static {
    com.google.api.client.util.Preconditions.checkState(
        com.google.api.client.googleapis.GoogleUtils.MAJOR_VERSION == 1 &&
        com.google.api.client.googleapis.GoogleUtils.MINOR_VERSION >= 15,
        "You are currently running with version %s of google-api-client. " +
        "You need at least version 1.15 of google-api-client to run version " +
        "1.26.0 of the Remote Build Execution API library.", com.google.api.client.googleapis.GoogleUtils.VERSION);
  }

  /**
   * The default encoded root URL of the service. This is determined when the library is generated
   * and normally should not be changed.
   *
   * @since 1.7
   */
  public static final String DEFAULT_ROOT_URL = "https://remotebuildexecution.googleapis.com/";

  /**
   * The default encoded service path of the service. This is determined when the library is
   * generated and normally should not be changed.
   *
   * @since 1.7
   */
  public static final String DEFAULT_SERVICE_PATH = "";

  /**
   * The default encoded batch path of the service. This is determined when the library is
   * generated and normally should not be changed.
   *
   * @since 1.23
   */
  public static final String DEFAULT_BATCH_PATH = "batch";

  /**
   * The default encoded base URL of the service. This is determined when the library is generated
   * and normally should not be changed.
   */
  public static final String DEFAULT_BASE_URL = DEFAULT_ROOT_URL + DEFAULT_SERVICE_PATH;

  /**
   * Constructor.
   *
   * <p>
   * Use {@link Builder} if you need to specify any of the optional parameters.
   * </p>
   *
   * @param transport HTTP transport, which should normally be:
   *        <ul>
   *        <li>Google App Engine:
   *        {@code com.google.api.client.extensions.appengine.http.UrlFetchTransport}</li>
   *        <li>Android: {@code newCompatibleTransport} from
   *        {@code com.google.api.client.extensions.android.http.AndroidHttp}</li>
   *        <li>Java: {@link com.google.api.client.googleapis.javanet.GoogleNetHttpTransport#newTrustedTransport()}
   *        </li>
   *        </ul>
   * @param jsonFactory JSON factory, which may be:
   *        <ul>
   *        <li>Jackson: {@code com.google.api.client.json.jackson2.JacksonFactory}</li>
   *        <li>Google GSON: {@code com.google.api.client.json.gson.GsonFactory}</li>
   *        <li>Android Honeycomb or higher:
   *        {@code com.google.api.client.extensions.android.json.AndroidJsonFactory}</li>
   *        </ul>
   * @param httpRequestInitializer HTTP request initializer or {@code null} for none
   * @since 1.7
   */
  public RemoteBuildExecution(com.google.api.client.http.HttpTransport transport, com.google.api.client.json.JsonFactory jsonFactory,
      com.google.api.client.http.HttpRequestInitializer httpRequestInitializer) {
    this(new Builder(transport, jsonFactory, httpRequestInitializer));
  }

  /**
   * @param builder builder
   */
  RemoteBuildExecution(Builder builder) {
    super(builder);
  }

  @Override
  protected void initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest<?> httpClientRequest) throws java.io.IOException {
    super.initialize(httpClientRequest);
  }

  /**
   * An accessor for creating requests from the ActionResults collection.
   *
   * <p>The typical use is:</p>
   * <pre>
   *   {@code RemoteBuildExecution remotebuildexecution = new RemoteBuildExecution(...);}
   *   {@code RemoteBuildExecution.ActionResults.List request = remotebuildexecution.actionResults().list(parameters ...)}
   * </pre>
   *
   * @return the resource collection
   */
  public ActionResults actionResults() {
    return new ActionResults();
  }

  /**
   * The "actionResults" collection of methods.
   */
  public class ActionResults {

    /**
     * Retrieve a cached execution result.
     *
     * Implementations SHOULD ensure that any blobs referenced from the ContentAddressableStorage are
     * available at the time of returning the ActionResult and will be for some period of time
     * afterwards. The TTLs of the referenced blobs SHOULD be increased if necessary and applicable.
     *
     * Errors:
     *
     * * `NOT_FOUND`: The requested `ActionResult` is not in the cache.
     *
     * Create a request for the method "actionResults.get".
     *
     * This request holds the parameters needed by the remotebuildexecution server.  After setting any
     * optional parameters, call the {@link Get#execute()} method to invoke the remote operation.
     *
     * @param instanceName The instance of the execution system to operate against. A server may
    support multiple instances of
     *        the execution system (with their own workers,
    storage, caches, etc.). The server MAY
     *        require use of this field to select
    between them in an implementation-defined fashion,
     *        otherwise it can be
    omitted.
     * @param hash The hash. In the case of SHA-256, it will always be a lowercase hex string
    exactly 64 characters
     *        long.
     * @param sizeBytes The size of the blob, in bytes.
     * @return the request
     */
    public Get get(java.lang.String instanceName, java.lang.String hash, java.lang.Long sizeBytes) throws java.io.IOException {
      Get result = new Get(instanceName, hash, sizeBytes);
      initialize(result);
      return result;
    }

    public class Get extends RemoteBuildExecutionRequest<com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2ActionResult> {

      private static final String REST_PATH = "v2/{+instanceName}/actionResults/{hash}/{sizeBytes}";

      private final java.util.regex.Pattern INSTANCE_NAME_PATTERN =
          java.util.regex.Pattern.compile("^.+$");

      /**
       * Retrieve a cached execution result.
       *
       * Implementations SHOULD ensure that any blobs referenced from the ContentAddressableStorage are
       * available at the time of returning the ActionResult and will be for some period of time
       * afterwards. The TTLs of the referenced blobs SHOULD be increased if necessary and applicable.
       *
       * Errors:
       *
       * * `NOT_FOUND`: The requested `ActionResult` is not in the cache.
       *
       * Create a request for the method "actionResults.get".
       *
       * This request holds the parameters needed by the the remotebuildexecution server.  After setting
       * any optional parameters, call the {@link Get#execute()} method to invoke the remote operation.
       * <p> {@link
       * Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must be
       * called to initialize this instance immediately after invoking the constructor. </p>
       *
       * @param instanceName The instance of the execution system to operate against. A server may
    support multiple instances of
     *        the execution system (with their own workers,
    storage, caches, etc.). The server MAY
     *        require use of this field to select
    between them in an implementation-defined fashion,
     *        otherwise it can be
    omitted.
       * @param hash The hash. In the case of SHA-256, it will always be a lowercase hex string
    exactly 64 characters
     *        long.
       * @param sizeBytes The size of the blob, in bytes.
       * @since 1.13
       */
      protected Get(java.lang.String instanceName, java.lang.String hash, java.lang.Long sizeBytes) {
        super(RemoteBuildExecution.this, "GET", REST_PATH, null, com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2ActionResult.class);
        this.instanceName = com.google.api.client.util.Preconditions.checkNotNull(instanceName, "Required parameter instanceName must be specified.");
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(INSTANCE_NAME_PATTERN.matcher(instanceName).matches(),
              "Parameter instanceName must conform to the pattern " +
              "^.+$");
        }
        this.hash = com.google.api.client.util.Preconditions.checkNotNull(hash, "Required parameter hash must be specified.");
        this.sizeBytes = com.google.api.client.util.Preconditions.checkNotNull(sizeBytes, "Required parameter sizeBytes must be specified.");
      }

      @Override
      public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
        return super.executeUsingHead();
      }

      @Override
      public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
        return super.buildHttpRequestUsingHead();
      }

      @Override
      public Get set$Xgafv(java.lang.String $Xgafv) {
        return (Get) super.set$Xgafv($Xgafv);
      }

      @Override
      public Get setAccessToken(java.lang.String accessToken) {
        return (Get) super.setAccessToken(accessToken);
      }

      @Override
      public Get setAlt(java.lang.String alt) {
        return (Get) super.setAlt(alt);
      }

      @Override
      public Get setCallback(java.lang.String callback) {
        return (Get) super.setCallback(callback);
      }

      @Override
      public Get setFields(java.lang.String fields) {
        return (Get) super.setFields(fields);
      }

      @Override
      public Get setKey(java.lang.String key) {
        return (Get) super.setKey(key);
      }

      @Override
      public Get setOauthToken(java.lang.String oauthToken) {
        return (Get) super.setOauthToken(oauthToken);
      }

      @Override
      public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
        return (Get) super.setPrettyPrint(prettyPrint);
      }

      @Override
      public Get setQuotaUser(java.lang.String quotaUser) {
        return (Get) super.setQuotaUser(quotaUser);
      }

      @Override
      public Get setUploadType(java.lang.String uploadType) {
        return (Get) super.setUploadType(uploadType);
      }

      @Override
      public Get setUploadProtocol(java.lang.String uploadProtocol) {
        return (Get) super.setUploadProtocol(uploadProtocol);
      }

      /**
       * The instance of the execution system to operate against. A server may support multiple
       * instances of the execution system (with their own workers, storage, caches, etc.). The
       * server MAY require use of this field to select between them in an implementation-defined
       * fashion, otherwise it can be omitted.
       */
      @com.google.api.client.util.Key
      private java.lang.String instanceName;

      /** The instance of the execution system to operate against. A server may support multiple instances of
     the execution system (with their own workers, storage, caches, etc.). The server MAY require use of
     this field to select between them in an implementation-defined fashion, otherwise it can be
     omitted.
       */
      public java.lang.String getInstanceName() {
        return instanceName;
      }

      /**
       * The instance of the execution system to operate against. A server may support multiple
       * instances of the execution system (with their own workers, storage, caches, etc.). The
       * server MAY require use of this field to select between them in an implementation-defined
       * fashion, otherwise it can be omitted.
       */
      public Get setInstanceName(java.lang.String instanceName) {
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(INSTANCE_NAME_PATTERN.matcher(instanceName).matches(),
              "Parameter instanceName must conform to the pattern " +
              "^.+$");
        }
        this.instanceName = instanceName;
        return this;
      }

      /**
       * The hash. In the case of SHA-256, it will always be a lowercase hex string exactly 64
       * characters long.
       */
      @com.google.api.client.util.Key
      private java.lang.String hash;

      /** The hash. In the case of SHA-256, it will always be a lowercase hex string exactly 64 characters
     long.
       */
      public java.lang.String getHash() {
        return hash;
      }

      /**
       * The hash. In the case of SHA-256, it will always be a lowercase hex string exactly 64
       * characters long.
       */
      public Get setHash(java.lang.String hash) {
        this.hash = hash;
        return this;
      }

      /** The size of the blob, in bytes. */
      @com.google.api.client.util.Key
      private java.lang.Long sizeBytes;

      /** The size of the blob, in bytes.
       */
      public java.lang.Long getSizeBytes() {
        return sizeBytes;
      }

      /** The size of the blob, in bytes. */
      public Get setSizeBytes(java.lang.Long sizeBytes) {
        this.sizeBytes = sizeBytes;
        return this;
      }

      /**
       * A hint to the server to inline the contents of the listed output files. Each path needs to
       * exactly match one path in `output_files` in the Command message.
       */
      @com.google.api.client.util.Key
      private java.util.List<java.lang.String> inlineOutputFiles;

      /** A hint to the server to inline the contents of the listed output files. Each path needs to exactly
     match one path in `output_files` in the Command message.
       */
      public java.util.List<java.lang.String> getInlineOutputFiles() {
        return inlineOutputFiles;
      }

      /**
       * A hint to the server to inline the contents of the listed output files. Each path needs to
       * exactly match one path in `output_files` in the Command message.
       */
      public Get setInlineOutputFiles(java.util.List<java.lang.String> inlineOutputFiles) {
        this.inlineOutputFiles = inlineOutputFiles;
        return this;
      }

      /**
       * A hint to the server to request inlining stderr in the ActionResult message.
       */
      @com.google.api.client.util.Key
      private java.lang.Boolean inlineStderr;

      /** A hint to the server to request inlining stderr in the ActionResult message.
       */
      public java.lang.Boolean getInlineStderr() {
        return inlineStderr;
      }

      /**
       * A hint to the server to request inlining stderr in the ActionResult message.
       */
      public Get setInlineStderr(java.lang.Boolean inlineStderr) {
        this.inlineStderr = inlineStderr;
        return this;
      }

      /**
       * A hint to the server to request inlining stdout in the ActionResult message.
       */
      @com.google.api.client.util.Key
      private java.lang.Boolean inlineStdout;

      /** A hint to the server to request inlining stdout in the ActionResult message.
       */
      public java.lang.Boolean getInlineStdout() {
        return inlineStdout;
      }

      /**
       * A hint to the server to request inlining stdout in the ActionResult message.
       */
      public Get setInlineStdout(java.lang.Boolean inlineStdout) {
        this.inlineStdout = inlineStdout;
        return this;
      }

      @Override
      public Get set(String parameterName, Object value) {
        return (Get) super.set(parameterName, value);
      }
    }
    /**
     * Upload a new execution result.
     *
     * In order to allow the server to perform access control based on the type of action, and to assist
     * with client debugging, the client MUST first upload the Action that produced the result, along
     * with its Command, into the `ContentAddressableStorage`.
     *
     * Errors:
     *
     * * `INVALID_ARGUMENT`: One or more arguments are invalid. * `FAILED_PRECONDITION`: One or more
     * errors occurred in updating the   action result, such as a missing command or action. *
     * `RESOURCE_EXHAUSTED`: There is insufficient storage space to add the   entry to the cache.
     *
     * Create a request for the method "actionResults.update".
     *
     * This request holds the parameters needed by the remotebuildexecution server.  After setting any
     * optional parameters, call the {@link Update#execute()} method to invoke the remote operation.
     *
     * @param instanceName The instance of the execution system to operate against. A server may
    support multiple instances of
     *        the execution system (with their own workers,
    storage, caches, etc.). The server MAY
     *        require use of this field to select
    between them in an implementation-defined fashion,
     *        otherwise it can be
    omitted.
     * @param hash The hash. In the case of SHA-256, it will always be a lowercase hex string
    exactly 64 characters
     *        long.
     * @param sizeBytes The size of the blob, in bytes.
     * @param content the {@link com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2ActionResult}
     * @return the request
     */
    public Update update(java.lang.String instanceName, java.lang.String hash, java.lang.Long sizeBytes, com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2ActionResult content) throws java.io.IOException {
      Update result = new Update(instanceName, hash, sizeBytes, content);
      initialize(result);
      return result;
    }

    public class Update extends RemoteBuildExecutionRequest<com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2ActionResult> {

      private static final String REST_PATH = "v2/{+instanceName}/actionResults/{hash}/{sizeBytes}";

      private final java.util.regex.Pattern INSTANCE_NAME_PATTERN =
          java.util.regex.Pattern.compile("^.+$");

      /**
       * Upload a new execution result.
       *
       * In order to allow the server to perform access control based on the type of action, and to
       * assist with client debugging, the client MUST first upload the Action that produced the result,
       * along with its Command, into the `ContentAddressableStorage`.
       *
       * Errors:
       *
       * * `INVALID_ARGUMENT`: One or more arguments are invalid. * `FAILED_PRECONDITION`: One or more
       * errors occurred in updating the   action result, such as a missing command or action. *
       * `RESOURCE_EXHAUSTED`: There is insufficient storage space to add the   entry to the cache.
       *
       * Create a request for the method "actionResults.update".
       *
       * This request holds the parameters needed by the the remotebuildexecution server.  After setting
       * any optional parameters, call the {@link Update#execute()} method to invoke the remote
       * operation. <p> {@link
       * Update#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
       * be called to initialize this instance immediately after invoking the constructor. </p>
       *
       * @param instanceName The instance of the execution system to operate against. A server may
    support multiple instances of
     *        the execution system (with their own workers,
    storage, caches, etc.). The server MAY
     *        require use of this field to select
    between them in an implementation-defined fashion,
     *        otherwise it can be
    omitted.
       * @param hash The hash. In the case of SHA-256, it will always be a lowercase hex string
    exactly 64 characters
     *        long.
       * @param sizeBytes The size of the blob, in bytes.
       * @param content the {@link com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2ActionResult}
       * @since 1.13
       */
      protected Update(java.lang.String instanceName, java.lang.String hash, java.lang.Long sizeBytes, com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2ActionResult content) {
        super(RemoteBuildExecution.this, "PUT", REST_PATH, content, com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2ActionResult.class);
        this.instanceName = com.google.api.client.util.Preconditions.checkNotNull(instanceName, "Required parameter instanceName must be specified.");
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(INSTANCE_NAME_PATTERN.matcher(instanceName).matches(),
              "Parameter instanceName must conform to the pattern " +
              "^.+$");
        }
        this.hash = com.google.api.client.util.Preconditions.checkNotNull(hash, "Required parameter hash must be specified.");
        this.sizeBytes = com.google.api.client.util.Preconditions.checkNotNull(sizeBytes, "Required parameter sizeBytes must be specified.");
      }

      @Override
      public Update set$Xgafv(java.lang.String $Xgafv) {
        return (Update) super.set$Xgafv($Xgafv);
      }

      @Override
      public Update setAccessToken(java.lang.String accessToken) {
        return (Update) super.setAccessToken(accessToken);
      }

      @Override
      public Update setAlt(java.lang.String alt) {
        return (Update) super.setAlt(alt);
      }

      @Override
      public Update setCallback(java.lang.String callback) {
        return (Update) super.setCallback(callback);
      }

      @Override
      public Update setFields(java.lang.String fields) {
        return (Update) super.setFields(fields);
      }

      @Override
      public Update setKey(java.lang.String key) {
        return (Update) super.setKey(key);
      }

      @Override
      public Update setOauthToken(java.lang.String oauthToken) {
        return (Update) super.setOauthToken(oauthToken);
      }

      @Override
      public Update setPrettyPrint(java.lang.Boolean prettyPrint) {
        return (Update) super.setPrettyPrint(prettyPrint);
      }

      @Override
      public Update setQuotaUser(java.lang.String quotaUser) {
        return (Update) super.setQuotaUser(quotaUser);
      }

      @Override
      public Update setUploadType(java.lang.String uploadType) {
        return (Update) super.setUploadType(uploadType);
      }

      @Override
      public Update setUploadProtocol(java.lang.String uploadProtocol) {
        return (Update) super.setUploadProtocol(uploadProtocol);
      }

      /**
       * The instance of the execution system to operate against. A server may support multiple
       * instances of the execution system (with their own workers, storage, caches, etc.). The
       * server MAY require use of this field to select between them in an implementation-defined
       * fashion, otherwise it can be omitted.
       */
      @com.google.api.client.util.Key
      private java.lang.String instanceName;

      /** The instance of the execution system to operate against. A server may support multiple instances of
     the execution system (with their own workers, storage, caches, etc.). The server MAY require use of
     this field to select between them in an implementation-defined fashion, otherwise it can be
     omitted.
       */
      public java.lang.String getInstanceName() {
        return instanceName;
      }

      /**
       * The instance of the execution system to operate against. A server may support multiple
       * instances of the execution system (with their own workers, storage, caches, etc.). The
       * server MAY require use of this field to select between them in an implementation-defined
       * fashion, otherwise it can be omitted.
       */
      public Update setInstanceName(java.lang.String instanceName) {
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(INSTANCE_NAME_PATTERN.matcher(instanceName).matches(),
              "Parameter instanceName must conform to the pattern " +
              "^.+$");
        }
        this.instanceName = instanceName;
        return this;
      }

      /**
       * The hash. In the case of SHA-256, it will always be a lowercase hex string exactly 64
       * characters long.
       */
      @com.google.api.client.util.Key
      private java.lang.String hash;

      /** The hash. In the case of SHA-256, it will always be a lowercase hex string exactly 64 characters
     long.
       */
      public java.lang.String getHash() {
        return hash;
      }

      /**
       * The hash. In the case of SHA-256, it will always be a lowercase hex string exactly 64
       * characters long.
       */
      public Update setHash(java.lang.String hash) {
        this.hash = hash;
        return this;
      }

      /** The size of the blob, in bytes. */
      @com.google.api.client.util.Key
      private java.lang.Long sizeBytes;

      /** The size of the blob, in bytes.
       */
      public java.lang.Long getSizeBytes() {
        return sizeBytes;
      }

      /** The size of the blob, in bytes. */
      public Update setSizeBytes(java.lang.Long sizeBytes) {
        this.sizeBytes = sizeBytes;
        return this;
      }

      /**
       * The priority (relative importance) of this content in the overall cache. Generally, a lower
       * value means a longer retention time or other advantage, but the interpretation of a given
       * value is server-dependent. A priority of 0 means a *default* value, decided by the server.
       *
       * The particular semantics of this field is up to the server. In particular, every server
       * will have their own supported range of priorities, and will decide how these map into
       * retention/eviction policy.
       */
      @com.google.api.client.util.Key("resultsCachePolicy.priority")
      private java.lang.Integer resultsCachePolicyPriority;

      /** The priority (relative importance) of this content in the overall cache. Generally, a lower value
     means a longer retention time or other advantage, but the interpretation of a given value is
     server-dependent. A priority of 0 means a *default* value, decided by the server.

     The particular semantics of this field is up to the server. In particular, every server will have
     their own supported range of priorities, and will decide how these map into retention/eviction
     policy.
       */
      public java.lang.Integer getResultsCachePolicyPriority() {
        return resultsCachePolicyPriority;
      }

      /**
       * The priority (relative importance) of this content in the overall cache. Generally, a lower
       * value means a longer retention time or other advantage, but the interpretation of a given
       * value is server-dependent. A priority of 0 means a *default* value, decided by the server.
       *
       * The particular semantics of this field is up to the server. In particular, every server
       * will have their own supported range of priorities, and will decide how these map into
       * retention/eviction policy.
       */
      public Update setResultsCachePolicyPriority(java.lang.Integer resultsCachePolicyPriority) {
        this.resultsCachePolicyPriority = resultsCachePolicyPriority;
        return this;
      }

      @Override
      public Update set(String parameterName, Object value) {
        return (Update) super.set(parameterName, value);
      }
    }

  }

  /**
   * An accessor for creating requests from the Actions collection.
   *
   * <p>The typical use is:</p>
   * <pre>
   *   {@code RemoteBuildExecution remotebuildexecution = new RemoteBuildExecution(...);}
   *   {@code RemoteBuildExecution.Actions.List request = remotebuildexecution.actions().list(parameters ...)}
   * </pre>
   *
   * @return the resource collection
   */
  public Actions actions() {
    return new Actions();
  }

  /**
   * The "actions" collection of methods.
   */
  public class Actions {

    /**
     * Execute an action remotely.
     *
     * In order to execute an action, the client must first upload all of the inputs, the Command to
     * run, and the Action into the ContentAddressableStorage. It then calls `Execute` with an
     * `action_digest` referring to them. The server will run the action and eventually return the
     * result.
     *
     * The input `Action`'s fields MUST meet the various canonicalization requirements specified in the
     * documentation for their types so that it has the same digest as other logically equivalent
     * `Action`s. The server MAY enforce the requirements and return errors if a non-canonical input is
     * received. It MAY also proceed without verifying some or all of the requirements, such as for
     * performance reasons. If the server does not verify the requirement, then it will treat the
     * `Action` as distinct from another logically equivalent action if they hash differently.
     *
     * Returns a stream of google.longrunning.Operation messages describing the resulting execution,
     * with eventual `response` ExecuteResponse. The `metadata` on the operation is of type
     * ExecuteOperationMetadata.
     *
     * If the client remains connected after the first response is returned after the server, then
     * updates are streamed as if the client had called WaitExecution until the execution completes or
     * the request reaches an error. The operation can also be queried using Operations API.
     *
     * The server NEED NOT implement other methods or functionality of the Operations API.
     *
     * Errors discovered during creation of the `Operation` will be reported as gRPC Status errors,
     * while errors that occurred while running the action will be reported in the `status` field of the
     * `ExecuteResponse`. The server MUST NOT set the `error` field of the `Operation` proto. The
     * possible errors include:
     *
     * * `INVALID_ARGUMENT`: One or more arguments are invalid. * `FAILED_PRECONDITION`: One or more
     * errors occurred in setting up the   action requested, such as a missing input or command or no
     * worker being   available. The client may be able to fix the errors and retry. *
     * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to run   the action. *
     * `UNAVAILABLE`: Due to a transient condition, such as all workers being   occupied (and the server
     * does not support a queue), the action could not   be started. The client should retry. *
     * `INTERNAL`: An internal error occurred in the execution engine or the   worker. *
     * `DEADLINE_EXCEEDED`: The execution timed out. * `CANCELLED`: The operation was cancelled by the
     * client. This status is   only possible if the server implements the Operations API
     * CancelOperation   method, and it was called for the current execution.
     *
     * In the case of a missing input or command, the server SHOULD additionally send a
     * PreconditionFailure error detail where, for each requested blob not present in the CAS, there is
     * a `Violation` with a `type` of `MISSING` and a `subject` of `"blobs/{hash}/{size}"` indicating
     * the digest of the missing blob.
     *
     * Create a request for the method "actions.execute".
     *
     * This request holds the parameters needed by the remotebuildexecution server.  After setting any
     * optional parameters, call the {@link Execute#execute()} method to invoke the remote operation.
     *
     * @param instanceName The instance of the execution system to operate against. A server may
    support multiple instances of
     *        the execution system (with their own workers,
    storage, caches, etc.). The server MAY
     *        require use of this field to select
    between them in an implementation-defined fashion,
     *        otherwise it can be
    omitted.
     * @param content the {@link com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2ExecuteRequest}
     * @return the request
     */
    public Execute execute(java.lang.String instanceName, com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2ExecuteRequest content) throws java.io.IOException {
      Execute result = new Execute(instanceName, content);
      initialize(result);
      return result;
    }

    public class Execute extends RemoteBuildExecutionRequest<com.google.api.services.remotebuildexecution.v2.model.GoogleLongrunningOperation> {

      private static final String REST_PATH = "v2/{+instanceName}/actions:execute";

      private final java.util.regex.Pattern INSTANCE_NAME_PATTERN =
          java.util.regex.Pattern.compile("^.+$");

      /**
       * Execute an action remotely.
       *
       * In order to execute an action, the client must first upload all of the inputs, the Command to
       * run, and the Action into the ContentAddressableStorage. It then calls `Execute` with an
       * `action_digest` referring to them. The server will run the action and eventually return the
       * result.
       *
       * The input `Action`'s fields MUST meet the various canonicalization requirements specified in
       * the documentation for their types so that it has the same digest as other logically equivalent
       * `Action`s. The server MAY enforce the requirements and return errors if a non-canonical input
       * is received. It MAY also proceed without verifying some or all of the requirements, such as for
       * performance reasons. If the server does not verify the requirement, then it will treat the
       * `Action` as distinct from another logically equivalent action if they hash differently.
       *
       * Returns a stream of google.longrunning.Operation messages describing the resulting execution,
       * with eventual `response` ExecuteResponse. The `metadata` on the operation is of type
       * ExecuteOperationMetadata.
       *
       * If the client remains connected after the first response is returned after the server, then
       * updates are streamed as if the client had called WaitExecution until the execution completes or
       * the request reaches an error. The operation can also be queried using Operations API.
       *
       * The server NEED NOT implement other methods or functionality of the Operations API.
       *
       * Errors discovered during creation of the `Operation` will be reported as gRPC Status errors,
       * while errors that occurred while running the action will be reported in the `status` field of
       * the `ExecuteResponse`. The server MUST NOT set the `error` field of the `Operation` proto. The
       * possible errors include:
       *
       * * `INVALID_ARGUMENT`: One or more arguments are invalid. * `FAILED_PRECONDITION`: One or more
       * errors occurred in setting up the   action requested, such as a missing input or command or no
       * worker being   available. The client may be able to fix the errors and retry. *
       * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to run   the action. *
       * `UNAVAILABLE`: Due to a transient condition, such as all workers being   occupied (and the
       * server does not support a queue), the action could not   be started. The client should retry. *
       * `INTERNAL`: An internal error occurred in the execution engine or the   worker. *
       * `DEADLINE_EXCEEDED`: The execution timed out. * `CANCELLED`: The operation was cancelled by the
       * client. This status is   only possible if the server implements the Operations API
       * CancelOperation   method, and it was called for the current execution.
       *
       * In the case of a missing input or command, the server SHOULD additionally send a
       * PreconditionFailure error detail where, for each requested blob not present in the CAS, there
       * is a `Violation` with a `type` of `MISSING` and a `subject` of `"blobs/{hash}/{size}"`
       * indicating the digest of the missing blob.
       *
       * Create a request for the method "actions.execute".
       *
       * This request holds the parameters needed by the the remotebuildexecution server.  After setting
       * any optional parameters, call the {@link Execute#execute()} method to invoke the remote
       * operation. <p> {@link
       * Execute#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
       * be called to initialize this instance immediately after invoking the constructor. </p>
       *
       * @param instanceName The instance of the execution system to operate against. A server may
    support multiple instances of
     *        the execution system (with their own workers,
    storage, caches, etc.). The server MAY
     *        require use of this field to select
    between them in an implementation-defined fashion,
     *        otherwise it can be
    omitted.
       * @param content the {@link com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2ExecuteRequest}
       * @since 1.13
       */
      protected Execute(java.lang.String instanceName, com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2ExecuteRequest content) {
        super(RemoteBuildExecution.this, "POST", REST_PATH, content, com.google.api.services.remotebuildexecution.v2.model.GoogleLongrunningOperation.class);
        this.instanceName = com.google.api.client.util.Preconditions.checkNotNull(instanceName, "Required parameter instanceName must be specified.");
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(INSTANCE_NAME_PATTERN.matcher(instanceName).matches(),
              "Parameter instanceName must conform to the pattern " +
              "^.+$");
        }
      }

      @Override
      public Execute set$Xgafv(java.lang.String $Xgafv) {
        return (Execute) super.set$Xgafv($Xgafv);
      }

      @Override
      public Execute setAccessToken(java.lang.String accessToken) {
        return (Execute) super.setAccessToken(accessToken);
      }

      @Override
      public Execute setAlt(java.lang.String alt) {
        return (Execute) super.setAlt(alt);
      }

      @Override
      public Execute setCallback(java.lang.String callback) {
        return (Execute) super.setCallback(callback);
      }

      @Override
      public Execute setFields(java.lang.String fields) {
        return (Execute) super.setFields(fields);
      }

      @Override
      public Execute setKey(java.lang.String key) {
        return (Execute) super.setKey(key);
      }

      @Override
      public Execute setOauthToken(java.lang.String oauthToken) {
        return (Execute) super.setOauthToken(oauthToken);
      }

      @Override
      public Execute setPrettyPrint(java.lang.Boolean prettyPrint) {
        return (Execute) super.setPrettyPrint(prettyPrint);
      }

      @Override
      public Execute setQuotaUser(java.lang.String quotaUser) {
        return (Execute) super.setQuotaUser(quotaUser);
      }

      @Override
      public Execute setUploadType(java.lang.String uploadType) {
        return (Execute) super.setUploadType(uploadType);
      }

      @Override
      public Execute setUploadProtocol(java.lang.String uploadProtocol) {
        return (Execute) super.setUploadProtocol(uploadProtocol);
      }

      /**
       * The instance of the execution system to operate against. A server may support multiple
       * instances of the execution system (with their own workers, storage, caches, etc.). The
       * server MAY require use of this field to select between them in an implementation-defined
       * fashion, otherwise it can be omitted.
       */
      @com.google.api.client.util.Key
      private java.lang.String instanceName;

      /** The instance of the execution system to operate against. A server may support multiple instances of
     the execution system (with their own workers, storage, caches, etc.). The server MAY require use of
     this field to select between them in an implementation-defined fashion, otherwise it can be
     omitted.
       */
      public java.lang.String getInstanceName() {
        return instanceName;
      }

      /**
       * The instance of the execution system to operate against. A server may support multiple
       * instances of the execution system (with their own workers, storage, caches, etc.). The
       * server MAY require use of this field to select between them in an implementation-defined
       * fashion, otherwise it can be omitted.
       */
      public Execute setInstanceName(java.lang.String instanceName) {
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(INSTANCE_NAME_PATTERN.matcher(instanceName).matches(),
              "Parameter instanceName must conform to the pattern " +
              "^.+$");
        }
        this.instanceName = instanceName;
        return this;
      }

      @Override
      public Execute set(String parameterName, Object value) {
        return (Execute) super.set(parameterName, value);
      }
    }

  }

  /**
   * An accessor for creating requests from the Blobs collection.
   *
   * <p>The typical use is:</p>
   * <pre>
   *   {@code RemoteBuildExecution remotebuildexecution = new RemoteBuildExecution(...);}
   *   {@code RemoteBuildExecution.Blobs.List request = remotebuildexecution.blobs().list(parameters ...)}
   * </pre>
   *
   * @return the resource collection
   */
  public Blobs blobs() {
    return new Blobs();
  }

  /**
   * The "blobs" collection of methods.
   */
  public class Blobs {

    /**
     * Download many blobs at once.
     *
     * The server may enforce a limit of the combined total size of blobs to be downloaded using this
     * API. This limit may be obtained using the Capabilities API. Requests exceeding the limit should
     * either be split into smaller chunks or downloaded using the ByteStream API, as appropriate.
     *
     * This request is equivalent to calling a Bytestream `Read` request on each individual blob, in
     * parallel. The requests may succeed or fail independently.
     *
     * Errors:
     *
     * * `INVALID_ARGUMENT`: The client attempted to read more than the   server supported limit.
     *
     * Every error on individual read will be returned in the corresponding digest status.
     *
     * Create a request for the method "blobs.batchRead".
     *
     * This request holds the parameters needed by the remotebuildexecution server.  After setting any
     * optional parameters, call the {@link BatchRead#execute()} method to invoke the remote operation.
     *
     * @param instanceName The instance of the execution system to operate against. A server may
    support multiple instances of
     *        the execution system (with their own workers,
    storage, caches, etc.). The server MAY
     *        require use of this field to select
    between them in an implementation-defined fashion,
     *        otherwise it can be
    omitted.
     * @param content the {@link com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2BatchReadBlobsRequest}
     * @return the request
     */
    public BatchRead batchRead(java.lang.String instanceName, com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2BatchReadBlobsRequest content) throws java.io.IOException {
      BatchRead result = new BatchRead(instanceName, content);
      initialize(result);
      return result;
    }

    public class BatchRead extends RemoteBuildExecutionRequest<com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2BatchReadBlobsResponse> {

      private static final String REST_PATH = "v2/{+instanceName}/blobs:batchRead";

      private final java.util.regex.Pattern INSTANCE_NAME_PATTERN =
          java.util.regex.Pattern.compile("^.+$");

      /**
       * Download many blobs at once.
       *
       * The server may enforce a limit of the combined total size of blobs to be downloaded using this
       * API. This limit may be obtained using the Capabilities API. Requests exceeding the limit should
       * either be split into smaller chunks or downloaded using the ByteStream API, as appropriate.
       *
       * This request is equivalent to calling a Bytestream `Read` request on each individual blob, in
       * parallel. The requests may succeed or fail independently.
       *
       * Errors:
       *
       * * `INVALID_ARGUMENT`: The client attempted to read more than the   server supported limit.
       *
       * Every error on individual read will be returned in the corresponding digest status.
       *
       * Create a request for the method "blobs.batchRead".
       *
       * This request holds the parameters needed by the the remotebuildexecution server.  After setting
       * any optional parameters, call the {@link BatchRead#execute()} method to invoke the remote
       * operation. <p> {@link
       * BatchRead#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
       * must be called to initialize this instance immediately after invoking the constructor. </p>
       *
       * @param instanceName The instance of the execution system to operate against. A server may
    support multiple instances of
     *        the execution system (with their own workers,
    storage, caches, etc.). The server MAY
     *        require use of this field to select
    between them in an implementation-defined fashion,
     *        otherwise it can be
    omitted.
       * @param content the {@link com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2BatchReadBlobsRequest}
       * @since 1.13
       */
      protected BatchRead(java.lang.String instanceName, com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2BatchReadBlobsRequest content) {
        super(RemoteBuildExecution.this, "POST", REST_PATH, content, com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2BatchReadBlobsResponse.class);
        this.instanceName = com.google.api.client.util.Preconditions.checkNotNull(instanceName, "Required parameter instanceName must be specified.");
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(INSTANCE_NAME_PATTERN.matcher(instanceName).matches(),
              "Parameter instanceName must conform to the pattern " +
              "^.+$");
        }
      }

      @Override
      public BatchRead set$Xgafv(java.lang.String $Xgafv) {
        return (BatchRead) super.set$Xgafv($Xgafv);
      }

      @Override
      public BatchRead setAccessToken(java.lang.String accessToken) {
        return (BatchRead) super.setAccessToken(accessToken);
      }

      @Override
      public BatchRead setAlt(java.lang.String alt) {
        return (BatchRead) super.setAlt(alt);
      }

      @Override
      public BatchRead setCallback(java.lang.String callback) {
        return (BatchRead) super.setCallback(callback);
      }

      @Override
      public BatchRead setFields(java.lang.String fields) {
        return (BatchRead) super.setFields(fields);
      }

      @Override
      public BatchRead setKey(java.lang.String key) {
        return (BatchRead) super.setKey(key);
      }

      @Override
      public BatchRead setOauthToken(java.lang.String oauthToken) {
        return (BatchRead) super.setOauthToken(oauthToken);
      }

      @Override
      public BatchRead setPrettyPrint(java.lang.Boolean prettyPrint) {
        return (BatchRead) super.setPrettyPrint(prettyPrint);
      }

      @Override
      public BatchRead setQuotaUser(java.lang.String quotaUser) {
        return (BatchRead) super.setQuotaUser(quotaUser);
      }

      @Override
      public BatchRead setUploadType(java.lang.String uploadType) {
        return (BatchRead) super.setUploadType(uploadType);
      }

      @Override
      public BatchRead setUploadProtocol(java.lang.String uploadProtocol) {
        return (BatchRead) super.setUploadProtocol(uploadProtocol);
      }

      /**
       * The instance of the execution system to operate against. A server may support multiple
       * instances of the execution system (with their own workers, storage, caches, etc.). The
       * server MAY require use of this field to select between them in an implementation-defined
       * fashion, otherwise it can be omitted.
       */
      @com.google.api.client.util.Key
      private java.lang.String instanceName;

      /** The instance of the execution system to operate against. A server may support multiple instances of
     the execution system (with their own workers, storage, caches, etc.). The server MAY require use of
     this field to select between them in an implementation-defined fashion, otherwise it can be
     omitted.
       */
      public java.lang.String getInstanceName() {
        return instanceName;
      }

      /**
       * The instance of the execution system to operate against. A server may support multiple
       * instances of the execution system (with their own workers, storage, caches, etc.). The
       * server MAY require use of this field to select between them in an implementation-defined
       * fashion, otherwise it can be omitted.
       */
      public BatchRead setInstanceName(java.lang.String instanceName) {
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(INSTANCE_NAME_PATTERN.matcher(instanceName).matches(),
              "Parameter instanceName must conform to the pattern " +
              "^.+$");
        }
        this.instanceName = instanceName;
        return this;
      }

      @Override
      public BatchRead set(String parameterName, Object value) {
        return (BatchRead) super.set(parameterName, value);
      }
    }
    /**
     * Upload many blobs at once.
     *
     * The server may enforce a limit of the combined total size of blobs to be uploaded using this API.
     * This limit may be obtained using the Capabilities API. Requests exceeding the limit should either
     * be split into smaller chunks or uploaded using the ByteStream API, as appropriate.
     *
     * This request is equivalent to calling a Bytestream `Write` request on each individual blob, in
     * parallel. The requests may succeed or fail independently.
     *
     * Errors:
     *
     * * `INVALID_ARGUMENT`: The client attempted to upload more than the   server supported limit.
     *
     * Individual requests may return the following errors, additionally:
     *
     * * `RESOURCE_EXHAUSTED`: There is insufficient disk quota to store the blob. * `INVALID_ARGUMENT`:
     * The Digest does not match the provided data.
     *
     * Create a request for the method "blobs.batchUpdate".
     *
     * This request holds the parameters needed by the remotebuildexecution server.  After setting any
     * optional parameters, call the {@link BatchUpdate#execute()} method to invoke the remote
     * operation.
     *
     * @param instanceName The instance of the execution system to operate against. A server may
    support multiple instances of
     *        the execution system (with their own workers,
    storage, caches, etc.). The server MAY
     *        require use of this field to select
    between them in an implementation-defined fashion,
     *        otherwise it can be
    omitted.
     * @param content the {@link com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2BatchUpdateBlobsRequest}
     * @return the request
     */
    public BatchUpdate batchUpdate(java.lang.String instanceName, com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2BatchUpdateBlobsRequest content) throws java.io.IOException {
      BatchUpdate result = new BatchUpdate(instanceName, content);
      initialize(result);
      return result;
    }

    public class BatchUpdate extends RemoteBuildExecutionRequest<com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2BatchUpdateBlobsResponse> {

      private static final String REST_PATH = "v2/{+instanceName}/blobs:batchUpdate";

      private final java.util.regex.Pattern INSTANCE_NAME_PATTERN =
          java.util.regex.Pattern.compile("^.+$");

      /**
       * Upload many blobs at once.
       *
       * The server may enforce a limit of the combined total size of blobs to be uploaded using this
       * API. This limit may be obtained using the Capabilities API. Requests exceeding the limit should
       * either be split into smaller chunks or uploaded using the ByteStream API, as appropriate.
       *
       * This request is equivalent to calling a Bytestream `Write` request on each individual blob, in
       * parallel. The requests may succeed or fail independently.
       *
       * Errors:
       *
       * * `INVALID_ARGUMENT`: The client attempted to upload more than the   server supported limit.
       *
       * Individual requests may return the following errors, additionally:
       *
       * * `RESOURCE_EXHAUSTED`: There is insufficient disk quota to store the blob. *
       * `INVALID_ARGUMENT`: The Digest does not match the provided data.
       *
       * Create a request for the method "blobs.batchUpdate".
       *
       * This request holds the parameters needed by the the remotebuildexecution server.  After setting
       * any optional parameters, call the {@link BatchUpdate#execute()} method to invoke the remote
       * operation. <p> {@link
       * BatchUpdate#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
       * must be called to initialize this instance immediately after invoking the constructor. </p>
       *
       * @param instanceName The instance of the execution system to operate against. A server may
    support multiple instances of
     *        the execution system (with their own workers,
    storage, caches, etc.). The server MAY
     *        require use of this field to select
    between them in an implementation-defined fashion,
     *        otherwise it can be
    omitted.
       * @param content the {@link com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2BatchUpdateBlobsRequest}
       * @since 1.13
       */
      protected BatchUpdate(java.lang.String instanceName, com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2BatchUpdateBlobsRequest content) {
        super(RemoteBuildExecution.this, "POST", REST_PATH, content, com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2BatchUpdateBlobsResponse.class);
        this.instanceName = com.google.api.client.util.Preconditions.checkNotNull(instanceName, "Required parameter instanceName must be specified.");
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(INSTANCE_NAME_PATTERN.matcher(instanceName).matches(),
              "Parameter instanceName must conform to the pattern " +
              "^.+$");
        }
      }

      @Override
      public BatchUpdate set$Xgafv(java.lang.String $Xgafv) {
        return (BatchUpdate) super.set$Xgafv($Xgafv);
      }

      @Override
      public BatchUpdate setAccessToken(java.lang.String accessToken) {
        return (BatchUpdate) super.setAccessToken(accessToken);
      }

      @Override
      public BatchUpdate setAlt(java.lang.String alt) {
        return (BatchUpdate) super.setAlt(alt);
      }

      @Override
      public BatchUpdate setCallback(java.lang.String callback) {
        return (BatchUpdate) super.setCallback(callback);
      }

      @Override
      public BatchUpdate setFields(java.lang.String fields) {
        return (BatchUpdate) super.setFields(fields);
      }

      @Override
      public BatchUpdate setKey(java.lang.String key) {
        return (BatchUpdate) super.setKey(key);
      }

      @Override
      public BatchUpdate setOauthToken(java.lang.String oauthToken) {
        return (BatchUpdate) super.setOauthToken(oauthToken);
      }

      @Override
      public BatchUpdate setPrettyPrint(java.lang.Boolean prettyPrint) {
        return (BatchUpdate) super.setPrettyPrint(prettyPrint);
      }

      @Override
      public BatchUpdate setQuotaUser(java.lang.String quotaUser) {
        return (BatchUpdate) super.setQuotaUser(quotaUser);
      }

      @Override
      public BatchUpdate setUploadType(java.lang.String uploadType) {
        return (BatchUpdate) super.setUploadType(uploadType);
      }

      @Override
      public BatchUpdate setUploadProtocol(java.lang.String uploadProtocol) {
        return (BatchUpdate) super.setUploadProtocol(uploadProtocol);
      }

      /**
       * The instance of the execution system to operate against. A server may support multiple
       * instances of the execution system (with their own workers, storage, caches, etc.). The
       * server MAY require use of this field to select between them in an implementation-defined
       * fashion, otherwise it can be omitted.
       */
      @com.google.api.client.util.Key
      private java.lang.String instanceName;

      /** The instance of the execution system to operate against. A server may support multiple instances of
     the execution system (with their own workers, storage, caches, etc.). The server MAY require use of
     this field to select between them in an implementation-defined fashion, otherwise it can be
     omitted.
       */
      public java.lang.String getInstanceName() {
        return instanceName;
      }

      /**
       * The instance of the execution system to operate against. A server may support multiple
       * instances of the execution system (with their own workers, storage, caches, etc.). The
       * server MAY require use of this field to select between them in an implementation-defined
       * fashion, otherwise it can be omitted.
       */
      public BatchUpdate setInstanceName(java.lang.String instanceName) {
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(INSTANCE_NAME_PATTERN.matcher(instanceName).matches(),
              "Parameter instanceName must conform to the pattern " +
              "^.+$");
        }
        this.instanceName = instanceName;
        return this;
      }

      @Override
      public BatchUpdate set(String parameterName, Object value) {
        return (BatchUpdate) super.set(parameterName, value);
      }
    }
    /**
     * Determine if blobs are present in the CAS.
     *
     * Clients can use this API before uploading blobs to determine which ones are already present in
     * the CAS and do not need to be uploaded again.
     *
     * There are no method-specific errors.
     *
     * Create a request for the method "blobs.findMissing".
     *
     * This request holds the parameters needed by the remotebuildexecution server.  After setting any
     * optional parameters, call the {@link FindMissing#execute()} method to invoke the remote
     * operation.
     *
     * @param instanceName The instance of the execution system to operate against. A server may
    support multiple instances of
     *        the execution system (with their own workers,
    storage, caches, etc.). The server MAY
     *        require use of this field to select
    between them in an implementation-defined fashion,
     *        otherwise it can be
    omitted.
     * @param content the {@link com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2FindMissingBlobsRequest}
     * @return the request
     */
    public FindMissing findMissing(java.lang.String instanceName, com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2FindMissingBlobsRequest content) throws java.io.IOException {
      FindMissing result = new FindMissing(instanceName, content);
      initialize(result);
      return result;
    }

    public class FindMissing extends RemoteBuildExecutionRequest<com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2FindMissingBlobsResponse> {

      private static final String REST_PATH = "v2/{+instanceName}/blobs:findMissing";

      private final java.util.regex.Pattern INSTANCE_NAME_PATTERN =
          java.util.regex.Pattern.compile("^.+$");

      /**
       * Determine if blobs are present in the CAS.
       *
       * Clients can use this API before uploading blobs to determine which ones are already present in
       * the CAS and do not need to be uploaded again.
       *
       * There are no method-specific errors.
       *
       * Create a request for the method "blobs.findMissing".
       *
       * This request holds the parameters needed by the the remotebuildexecution server.  After setting
       * any optional parameters, call the {@link FindMissing#execute()} method to invoke the remote
       * operation. <p> {@link
       * FindMissing#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
       * must be called to initialize this instance immediately after invoking the constructor. </p>
       *
       * @param instanceName The instance of the execution system to operate against. A server may
    support multiple instances of
     *        the execution system (with their own workers,
    storage, caches, etc.). The server MAY
     *        require use of this field to select
    between them in an implementation-defined fashion,
     *        otherwise it can be
    omitted.
       * @param content the {@link com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2FindMissingBlobsRequest}
       * @since 1.13
       */
      protected FindMissing(java.lang.String instanceName, com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2FindMissingBlobsRequest content) {
        super(RemoteBuildExecution.this, "POST", REST_PATH, content, com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2FindMissingBlobsResponse.class);
        this.instanceName = com.google.api.client.util.Preconditions.checkNotNull(instanceName, "Required parameter instanceName must be specified.");
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(INSTANCE_NAME_PATTERN.matcher(instanceName).matches(),
              "Parameter instanceName must conform to the pattern " +
              "^.+$");
        }
      }

      @Override
      public FindMissing set$Xgafv(java.lang.String $Xgafv) {
        return (FindMissing) super.set$Xgafv($Xgafv);
      }

      @Override
      public FindMissing setAccessToken(java.lang.String accessToken) {
        return (FindMissing) super.setAccessToken(accessToken);
      }

      @Override
      public FindMissing setAlt(java.lang.String alt) {
        return (FindMissing) super.setAlt(alt);
      }

      @Override
      public FindMissing setCallback(java.lang.String callback) {
        return (FindMissing) super.setCallback(callback);
      }

      @Override
      public FindMissing setFields(java.lang.String fields) {
        return (FindMissing) super.setFields(fields);
      }

      @Override
      public FindMissing setKey(java.lang.String key) {
        return (FindMissing) super.setKey(key);
      }

      @Override
      public FindMissing setOauthToken(java.lang.String oauthToken) {
        return (FindMissing) super.setOauthToken(oauthToken);
      }

      @Override
      public FindMissing setPrettyPrint(java.lang.Boolean prettyPrint) {
        return (FindMissing) super.setPrettyPrint(prettyPrint);
      }

      @Override
      public FindMissing setQuotaUser(java.lang.String quotaUser) {
        return (FindMissing) super.setQuotaUser(quotaUser);
      }

      @Override
      public FindMissing setUploadType(java.lang.String uploadType) {
        return (FindMissing) super.setUploadType(uploadType);
      }

      @Override
      public FindMissing setUploadProtocol(java.lang.String uploadProtocol) {
        return (FindMissing) super.setUploadProtocol(uploadProtocol);
      }

      /**
       * The instance of the execution system to operate against. A server may support multiple
       * instances of the execution system (with their own workers, storage, caches, etc.). The
       * server MAY require use of this field to select between them in an implementation-defined
       * fashion, otherwise it can be omitted.
       */
      @com.google.api.client.util.Key
      private java.lang.String instanceName;

      /** The instance of the execution system to operate against. A server may support multiple instances of
     the execution system (with their own workers, storage, caches, etc.). The server MAY require use of
     this field to select between them in an implementation-defined fashion, otherwise it can be
     omitted.
       */
      public java.lang.String getInstanceName() {
        return instanceName;
      }

      /**
       * The instance of the execution system to operate against. A server may support multiple
       * instances of the execution system (with their own workers, storage, caches, etc.). The
       * server MAY require use of this field to select between them in an implementation-defined
       * fashion, otherwise it can be omitted.
       */
      public FindMissing setInstanceName(java.lang.String instanceName) {
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(INSTANCE_NAME_PATTERN.matcher(instanceName).matches(),
              "Parameter instanceName must conform to the pattern " +
              "^.+$");
        }
        this.instanceName = instanceName;
        return this;
      }

      @Override
      public FindMissing set(String parameterName, Object value) {
        return (FindMissing) super.set(parameterName, value);
      }
    }
    /**
     * Fetch the entire directory tree rooted at a node.
     *
     * This request must be targeted at a Directory stored in the ContentAddressableStorage (CAS). The
     * server will enumerate the `Directory` tree recursively and return every node descended from the
     * root.
     *
     * The GetTreeRequest.page_token parameter can be used to skip ahead in the stream (e.g. when
     * retrying a partially completed and aborted request), by setting it to a value taken from
     * GetTreeResponse.next_page_token of the last successfully processed GetTreeResponse).
     *
     * The exact traversal order is unspecified and, unless retrieving subsequent pages from an earlier
     * request, is not guaranteed to be stable across multiple invocations of `GetTree`.
     *
     * If part of the tree is missing from the CAS, the server will return the portion present and omit
     * the rest.
     *
     * * `NOT_FOUND`: The requested tree root is not present in the CAS.
     *
     * Create a request for the method "blobs.getTree".
     *
     * This request holds the parameters needed by the remotebuildexecution server.  After setting any
     * optional parameters, call the {@link GetTree#execute()} method to invoke the remote operation.
     *
     * @param instanceName The instance of the execution system to operate against. A server may
    support multiple instances of
     *        the execution system (with their own workers,
    storage, caches, etc.). The server MAY
     *        require use of this field to select
    between them in an implementation-defined fashion,
     *        otherwise it can be
    omitted.
     * @param hash The hash. In the case of SHA-256, it will always be a lowercase hex string
    exactly 64 characters
     *        long.
     * @param sizeBytes The size of the blob, in bytes.
     * @return the request
     */
    public GetTree getTree(java.lang.String instanceName, java.lang.String hash, java.lang.Long sizeBytes) throws java.io.IOException {
      GetTree result = new GetTree(instanceName, hash, sizeBytes);
      initialize(result);
      return result;
    }

    public class GetTree extends RemoteBuildExecutionRequest<com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2GetTreeResponse> {

      private static final String REST_PATH = "v2/{+instanceName}/blobs/{hash}/{sizeBytes}:getTree";

      private final java.util.regex.Pattern INSTANCE_NAME_PATTERN =
          java.util.regex.Pattern.compile("^.+$");

      /**
       * Fetch the entire directory tree rooted at a node.
       *
       * This request must be targeted at a Directory stored in the ContentAddressableStorage (CAS). The
       * server will enumerate the `Directory` tree recursively and return every node descended from the
       * root.
       *
       * The GetTreeRequest.page_token parameter can be used to skip ahead in the stream (e.g. when
       * retrying a partially completed and aborted request), by setting it to a value taken from
       * GetTreeResponse.next_page_token of the last successfully processed GetTreeResponse).
       *
       * The exact traversal order is unspecified and, unless retrieving subsequent pages from an
       * earlier request, is not guaranteed to be stable across multiple invocations of `GetTree`.
       *
       * If part of the tree is missing from the CAS, the server will return the portion present and
       * omit the rest.
       *
       * * `NOT_FOUND`: The requested tree root is not present in the CAS.
       *
       * Create a request for the method "blobs.getTree".
       *
       * This request holds the parameters needed by the the remotebuildexecution server.  After setting
       * any optional parameters, call the {@link GetTree#execute()} method to invoke the remote
       * operation. <p> {@link
       * GetTree#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
       * be called to initialize this instance immediately after invoking the constructor. </p>
       *
       * @param instanceName The instance of the execution system to operate against. A server may
    support multiple instances of
     *        the execution system (with their own workers,
    storage, caches, etc.). The server MAY
     *        require use of this field to select
    between them in an implementation-defined fashion,
     *        otherwise it can be
    omitted.
       * @param hash The hash. In the case of SHA-256, it will always be a lowercase hex string
    exactly 64 characters
     *        long.
       * @param sizeBytes The size of the blob, in bytes.
       * @since 1.13
       */
      protected GetTree(java.lang.String instanceName, java.lang.String hash, java.lang.Long sizeBytes) {
        super(RemoteBuildExecution.this, "GET", REST_PATH, null, com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2GetTreeResponse.class);
        this.instanceName = com.google.api.client.util.Preconditions.checkNotNull(instanceName, "Required parameter instanceName must be specified.");
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(INSTANCE_NAME_PATTERN.matcher(instanceName).matches(),
              "Parameter instanceName must conform to the pattern " +
              "^.+$");
        }
        this.hash = com.google.api.client.util.Preconditions.checkNotNull(hash, "Required parameter hash must be specified.");
        this.sizeBytes = com.google.api.client.util.Preconditions.checkNotNull(sizeBytes, "Required parameter sizeBytes must be specified.");
      }

      @Override
      public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
        return super.executeUsingHead();
      }

      @Override
      public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
        return super.buildHttpRequestUsingHead();
      }

      @Override
      public GetTree set$Xgafv(java.lang.String $Xgafv) {
        return (GetTree) super.set$Xgafv($Xgafv);
      }

      @Override
      public GetTree setAccessToken(java.lang.String accessToken) {
        return (GetTree) super.setAccessToken(accessToken);
      }

      @Override
      public GetTree setAlt(java.lang.String alt) {
        return (GetTree) super.setAlt(alt);
      }

      @Override
      public GetTree setCallback(java.lang.String callback) {
        return (GetTree) super.setCallback(callback);
      }

      @Override
      public GetTree setFields(java.lang.String fields) {
        return (GetTree) super.setFields(fields);
      }

      @Override
      public GetTree setKey(java.lang.String key) {
        return (GetTree) super.setKey(key);
      }

      @Override
      public GetTree setOauthToken(java.lang.String oauthToken) {
        return (GetTree) super.setOauthToken(oauthToken);
      }

      @Override
      public GetTree setPrettyPrint(java.lang.Boolean prettyPrint) {
        return (GetTree) super.setPrettyPrint(prettyPrint);
      }

      @Override
      public GetTree setQuotaUser(java.lang.String quotaUser) {
        return (GetTree) super.setQuotaUser(quotaUser);
      }

      @Override
      public GetTree setUploadType(java.lang.String uploadType) {
        return (GetTree) super.setUploadType(uploadType);
      }

      @Override
      public GetTree setUploadProtocol(java.lang.String uploadProtocol) {
        return (GetTree) super.setUploadProtocol(uploadProtocol);
      }

      /**
       * The instance of the execution system to operate against. A server may support multiple
       * instances of the execution system (with their own workers, storage, caches, etc.). The
       * server MAY require use of this field to select between them in an implementation-defined
       * fashion, otherwise it can be omitted.
       */
      @com.google.api.client.util.Key
      private java.lang.String instanceName;

      /** The instance of the execution system to operate against. A server may support multiple instances of
     the execution system (with their own workers, storage, caches, etc.). The server MAY require use of
     this field to select between them in an implementation-defined fashion, otherwise it can be
     omitted.
       */
      public java.lang.String getInstanceName() {
        return instanceName;
      }

      /**
       * The instance of the execution system to operate against. A server may support multiple
       * instances of the execution system (with their own workers, storage, caches, etc.). The
       * server MAY require use of this field to select between them in an implementation-defined
       * fashion, otherwise it can be omitted.
       */
      public GetTree setInstanceName(java.lang.String instanceName) {
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(INSTANCE_NAME_PATTERN.matcher(instanceName).matches(),
              "Parameter instanceName must conform to the pattern " +
              "^.+$");
        }
        this.instanceName = instanceName;
        return this;
      }

      /**
       * The hash. In the case of SHA-256, it will always be a lowercase hex string exactly 64
       * characters long.
       */
      @com.google.api.client.util.Key
      private java.lang.String hash;

      /** The hash. In the case of SHA-256, it will always be a lowercase hex string exactly 64 characters
     long.
       */
      public java.lang.String getHash() {
        return hash;
      }

      /**
       * The hash. In the case of SHA-256, it will always be a lowercase hex string exactly 64
       * characters long.
       */
      public GetTree setHash(java.lang.String hash) {
        this.hash = hash;
        return this;
      }

      /** The size of the blob, in bytes. */
      @com.google.api.client.util.Key
      private java.lang.Long sizeBytes;

      /** The size of the blob, in bytes.
       */
      public java.lang.Long getSizeBytes() {
        return sizeBytes;
      }

      /** The size of the blob, in bytes. */
      public GetTree setSizeBytes(java.lang.Long sizeBytes) {
        this.sizeBytes = sizeBytes;
        return this;
      }

      /**
       * A maximum page size to request. If present, the server will request no more than this many
       * items. Regardless of whether a page size is specified, the server may place its own limit
       * on the number of items to be returned and require the client to retrieve more items using a
       * subsequent request.
       */
      @com.google.api.client.util.Key
      private java.lang.Integer pageSize;

      /** A maximum page size to request. If present, the server will request no more than this many items.
     Regardless of whether a page size is specified, the server may place its own limit on the number of
     items to be returned and require the client to retrieve more items using a subsequent request.
       */
      public java.lang.Integer getPageSize() {
        return pageSize;
      }

      /**
       * A maximum page size to request. If present, the server will request no more than this many
       * items. Regardless of whether a page size is specified, the server may place its own limit
       * on the number of items to be returned and require the client to retrieve more items using a
       * subsequent request.
       */
      public GetTree setPageSize(java.lang.Integer pageSize) {
        this.pageSize = pageSize;
        return this;
      }

      /**
       * A page token, which must be a value received in a previous GetTreeResponse. If present, the
       * server will use it to return the following page of results.
       */
      @com.google.api.client.util.Key
      private java.lang.String pageToken;

      /** A page token, which must be a value received in a previous GetTreeResponse. If present, the server
     will use it to return the following page of results.
       */
      public java.lang.String getPageToken() {
        return pageToken;
      }

      /**
       * A page token, which must be a value received in a previous GetTreeResponse. If present, the
       * server will use it to return the following page of results.
       */
      public GetTree setPageToken(java.lang.String pageToken) {
        this.pageToken = pageToken;
        return this;
      }

      @Override
      public GetTree set(String parameterName, Object value) {
        return (GetTree) super.set(parameterName, value);
      }
    }

  }

  /**
   * An accessor for creating requests from the Operations collection.
   *
   * <p>The typical use is:</p>
   * <pre>
   *   {@code RemoteBuildExecution remotebuildexecution = new RemoteBuildExecution(...);}
   *   {@code RemoteBuildExecution.Operations.List request = remotebuildexecution.operations().list(parameters ...)}
   * </pre>
   *
   * @return the resource collection
   */
  public Operations operations() {
    return new Operations();
  }

  /**
   * The "operations" collection of methods.
   */
  public class Operations {

    /**
     * Wait for an execution operation to complete. When the client initially makes the request, the
     * server immediately responds with the current status of the execution. The server will leave the
     * request stream open until the operation completes, and then respond with the completed operation.
     * The server MAY choose to stream additional updates as execution progresses, such as to provide an
     * update as to the state of the execution.
     *
     * Create a request for the method "operations.waitExecution".
     *
     * This request holds the parameters needed by the remotebuildexecution server.  After setting any
     * optional parameters, call the {@link WaitExecution#execute()} method to invoke the remote
     * operation.
     *
     * @param name The name of the Operation
    returned by Execute.
     * @param content the {@link com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2WaitExecutionRequest}
     * @return the request
     */
    public WaitExecution waitExecution(java.lang.String name, com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2WaitExecutionRequest content) throws java.io.IOException {
      WaitExecution result = new WaitExecution(name, content);
      initialize(result);
      return result;
    }

    public class WaitExecution extends RemoteBuildExecutionRequest<com.google.api.services.remotebuildexecution.v2.model.GoogleLongrunningOperation> {

      private static final String REST_PATH = "v2/{+name}:waitExecution";

      private final java.util.regex.Pattern NAME_PATTERN =
          java.util.regex.Pattern.compile("^operations/.+$");

      /**
       * Wait for an execution operation to complete. When the client initially makes the request, the
       * server immediately responds with the current status of the execution. The server will leave the
       * request stream open until the operation completes, and then respond with the completed
       * operation. The server MAY choose to stream additional updates as execution progresses, such as
       * to provide an update as to the state of the execution.
       *
       * Create a request for the method "operations.waitExecution".
       *
       * This request holds the parameters needed by the the remotebuildexecution server.  After setting
       * any optional parameters, call the {@link WaitExecution#execute()} method to invoke the remote
       * operation. <p> {@link WaitExecution#initialize(com.google.api.client.googleapis.services.Abstra
       * ctGoogleClientRequest)} must be called to initialize this instance immediately after invoking
       * the constructor. </p>
       *
       * @param name The name of the Operation
    returned by Execute.
       * @param content the {@link com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2WaitExecutionRequest}
       * @since 1.13
       */
      protected WaitExecution(java.lang.String name, com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2WaitExecutionRequest content) {
        super(RemoteBuildExecution.this, "POST", REST_PATH, content, com.google.api.services.remotebuildexecution.v2.model.GoogleLongrunningOperation.class);
        this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
              "Parameter name must conform to the pattern " +
              "^operations/.+$");
        }
      }

      @Override
      public WaitExecution set$Xgafv(java.lang.String $Xgafv) {
        return (WaitExecution) super.set$Xgafv($Xgafv);
      }

      @Override
      public WaitExecution setAccessToken(java.lang.String accessToken) {
        return (WaitExecution) super.setAccessToken(accessToken);
      }

      @Override
      public WaitExecution setAlt(java.lang.String alt) {
        return (WaitExecution) super.setAlt(alt);
      }

      @Override
      public WaitExecution setCallback(java.lang.String callback) {
        return (WaitExecution) super.setCallback(callback);
      }

      @Override
      public WaitExecution setFields(java.lang.String fields) {
        return (WaitExecution) super.setFields(fields);
      }

      @Override
      public WaitExecution setKey(java.lang.String key) {
        return (WaitExecution) super.setKey(key);
      }

      @Override
      public WaitExecution setOauthToken(java.lang.String oauthToken) {
        return (WaitExecution) super.setOauthToken(oauthToken);
      }

      @Override
      public WaitExecution setPrettyPrint(java.lang.Boolean prettyPrint) {
        return (WaitExecution) super.setPrettyPrint(prettyPrint);
      }

      @Override
      public WaitExecution setQuotaUser(java.lang.String quotaUser) {
        return (WaitExecution) super.setQuotaUser(quotaUser);
      }

      @Override
      public WaitExecution setUploadType(java.lang.String uploadType) {
        return (WaitExecution) super.setUploadType(uploadType);
      }

      @Override
      public WaitExecution setUploadProtocol(java.lang.String uploadProtocol) {
        return (WaitExecution) super.setUploadProtocol(uploadProtocol);
      }

      /**
       * The name of the Operation returned by Execute.
       */
      @com.google.api.client.util.Key
      private java.lang.String name;

      /** The name of the Operation returned by Execute.
       */
      public java.lang.String getName() {
        return name;
      }

      /**
       * The name of the Operation returned by Execute.
       */
      public WaitExecution setName(java.lang.String name) {
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
              "Parameter name must conform to the pattern " +
              "^operations/.+$");
        }
        this.name = name;
        return this;
      }

      @Override
      public WaitExecution set(String parameterName, Object value) {
        return (WaitExecution) super.set(parameterName, value);
      }
    }

  }

  /**
   * An accessor for creating requests from the V2 collection.
   *
   * <p>The typical use is:</p>
   * <pre>
   *   {@code RemoteBuildExecution remotebuildexecution = new RemoteBuildExecution(...);}
   *   {@code RemoteBuildExecution.V2.List request = remotebuildexecution.v2().list(parameters ...)}
   * </pre>
   *
   * @return the resource collection
   */
  public V2 v2() {
    return new V2();
  }

  /**
   * The "v2" collection of methods.
   */
  public class V2 {

    /**
     * GetCapabilities returns the server capabilities configuration of the remote endpoint. Only the
     * capabilities of the services supported by the endpoint will be returned: * Execution + CAS +
     * Action Cache endpoints should return both   CacheCapabilities and ExecutionCapabilities. *
     * Execution only endpoints should return ExecutionCapabilities. * CAS + Action Cache only endpoints
     * should return CacheCapabilities.
     *
     * Create a request for the method "v2.getCapabilities".
     *
     * This request holds the parameters needed by the remotebuildexecution server.  After setting any
     * optional parameters, call the {@link GetCapabilities#execute()} method to invoke the remote
     * operation.
     *
     * @param instanceName The instance of the execution system to operate against. A server may
    support multiple instances of
     *        the execution system (with their own workers,
    storage, caches, etc.). The server MAY
     *        require use of this field to select
    between them in an implementation-defined fashion,
     *        otherwise it can be
    omitted.
     * @return the request
     */
    public GetCapabilities getCapabilities(java.lang.String instanceName) throws java.io.IOException {
      GetCapabilities result = new GetCapabilities(instanceName);
      initialize(result);
      return result;
    }

    public class GetCapabilities extends RemoteBuildExecutionRequest<com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2ServerCapabilities> {

      private static final String REST_PATH = "v2/{+instanceName}/capabilities";

      private final java.util.regex.Pattern INSTANCE_NAME_PATTERN =
          java.util.regex.Pattern.compile("^.+$");

      /**
       * GetCapabilities returns the server capabilities configuration of the remote endpoint. Only the
       * capabilities of the services supported by the endpoint will be returned: * Execution + CAS +
       * Action Cache endpoints should return both   CacheCapabilities and ExecutionCapabilities. *
       * Execution only endpoints should return ExecutionCapabilities. * CAS + Action Cache only
       * endpoints should return CacheCapabilities.
       *
       * Create a request for the method "v2.getCapabilities".
       *
       * This request holds the parameters needed by the the remotebuildexecution server.  After setting
       * any optional parameters, call the {@link GetCapabilities#execute()} method to invoke the remote
       * operation. <p> {@link GetCapabilities#initialize(com.google.api.client.googleapis.services.Abst
       * ractGoogleClientRequest)} must be called to initialize this instance immediately after invoking
       * the constructor. </p>
       *
       * @param instanceName The instance of the execution system to operate against. A server may
    support multiple instances of
     *        the execution system (with their own workers,
    storage, caches, etc.). The server MAY
     *        require use of this field to select
    between them in an implementation-defined fashion,
     *        otherwise it can be
    omitted.
       * @since 1.13
       */
      protected GetCapabilities(java.lang.String instanceName) {
        super(RemoteBuildExecution.this, "GET", REST_PATH, null, com.google.api.services.remotebuildexecution.v2.model.BuildBazelRemoteExecutionV2ServerCapabilities.class);
        this.instanceName = com.google.api.client.util.Preconditions.checkNotNull(instanceName, "Required parameter instanceName must be specified.");
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(INSTANCE_NAME_PATTERN.matcher(instanceName).matches(),
              "Parameter instanceName must conform to the pattern " +
              "^.+$");
        }
      }

      @Override
      public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
        return super.executeUsingHead();
      }

      @Override
      public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
        return super.buildHttpRequestUsingHead();
      }

      @Override
      public GetCapabilities set$Xgafv(java.lang.String $Xgafv) {
        return (GetCapabilities) super.set$Xgafv($Xgafv);
      }

      @Override
      public GetCapabilities setAccessToken(java.lang.String accessToken) {
        return (GetCapabilities) super.setAccessToken(accessToken);
      }

      @Override
      public GetCapabilities setAlt(java.lang.String alt) {
        return (GetCapabilities) super.setAlt(alt);
      }

      @Override
      public GetCapabilities setCallback(java.lang.String callback) {
        return (GetCapabilities) super.setCallback(callback);
      }

      @Override
      public GetCapabilities setFields(java.lang.String fields) {
        return (GetCapabilities) super.setFields(fields);
      }

      @Override
      public GetCapabilities setKey(java.lang.String key) {
        return (GetCapabilities) super.setKey(key);
      }

      @Override
      public GetCapabilities setOauthToken(java.lang.String oauthToken) {
        return (GetCapabilities) super.setOauthToken(oauthToken);
      }

      @Override
      public GetCapabilities setPrettyPrint(java.lang.Boolean prettyPrint) {
        return (GetCapabilities) super.setPrettyPrint(prettyPrint);
      }

      @Override
      public GetCapabilities setQuotaUser(java.lang.String quotaUser) {
        return (GetCapabilities) super.setQuotaUser(quotaUser);
      }

      @Override
      public GetCapabilities setUploadType(java.lang.String uploadType) {
        return (GetCapabilities) super.setUploadType(uploadType);
      }

      @Override
      public GetCapabilities setUploadProtocol(java.lang.String uploadProtocol) {
        return (GetCapabilities) super.setUploadProtocol(uploadProtocol);
      }

      /**
       * The instance of the execution system to operate against. A server may support multiple
       * instances of the execution system (with their own workers, storage, caches, etc.). The
       * server MAY require use of this field to select between them in an implementation-defined
       * fashion, otherwise it can be omitted.
       */
      @com.google.api.client.util.Key
      private java.lang.String instanceName;

      /** The instance of the execution system to operate against. A server may support multiple instances of
     the execution system (with their own workers, storage, caches, etc.). The server MAY require use of
     this field to select between them in an implementation-defined fashion, otherwise it can be
     omitted.
       */
      public java.lang.String getInstanceName() {
        return instanceName;
      }

      /**
       * The instance of the execution system to operate against. A server may support multiple
       * instances of the execution system (with their own workers, storage, caches, etc.). The
       * server MAY require use of this field to select between them in an implementation-defined
       * fashion, otherwise it can be omitted.
       */
      public GetCapabilities setInstanceName(java.lang.String instanceName) {
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(INSTANCE_NAME_PATTERN.matcher(instanceName).matches(),
              "Parameter instanceName must conform to the pattern " +
              "^.+$");
        }
        this.instanceName = instanceName;
        return this;
      }

      @Override
      public GetCapabilities set(String parameterName, Object value) {
        return (GetCapabilities) super.set(parameterName, value);
      }
    }

  }

  /**
   * Builder for {@link RemoteBuildExecution}.
   *
   * <p>
   * Implementation is not thread-safe.
   * </p>
   *
   * @since 1.3.0
   */
  public static final class Builder extends com.google.api.client.googleapis.services.json.AbstractGoogleJsonClient.Builder {

    /**
     * Returns an instance of a new builder.
     *
     * @param transport HTTP transport, which should normally be:
     *        <ul>
     *        <li>Google App Engine:
     *        {@code com.google.api.client.extensions.appengine.http.UrlFetchTransport}</li>
     *        <li>Android: {@code newCompatibleTransport} from
     *        {@code com.google.api.client.extensions.android.http.AndroidHttp}</li>
     *        <li>Java: {@link com.google.api.client.googleapis.javanet.GoogleNetHttpTransport#newTrustedTransport()}
     *        </li>
     *        </ul>
     * @param jsonFactory JSON factory, which may be:
     *        <ul>
     *        <li>Jackson: {@code com.google.api.client.json.jackson2.JacksonFactory}</li>
     *        <li>Google GSON: {@code com.google.api.client.json.gson.GsonFactory}</li>
     *        <li>Android Honeycomb or higher:
     *        {@code com.google.api.client.extensions.android.json.AndroidJsonFactory}</li>
     *        </ul>
     * @param httpRequestInitializer HTTP request initializer or {@code null} for none
     * @since 1.7
     */
    public Builder(com.google.api.client.http.HttpTransport transport, com.google.api.client.json.JsonFactory jsonFactory,
        com.google.api.client.http.HttpRequestInitializer httpRequestInitializer) {
      super(
          transport,
          jsonFactory,
          DEFAULT_ROOT_URL,
          DEFAULT_SERVICE_PATH,
          httpRequestInitializer,
          false);
      setBatchPath(DEFAULT_BATCH_PATH);
    }

    /** Builds a new instance of {@link RemoteBuildExecution}. */
    @Override
    public RemoteBuildExecution build() {
      return new RemoteBuildExecution(this);
    }

    @Override
    public Builder setRootUrl(String rootUrl) {
      return (Builder) super.setRootUrl(rootUrl);
    }

    @Override
    public Builder setServicePath(String servicePath) {
      return (Builder) super.setServicePath(servicePath);
    }

    @Override
    public Builder setBatchPath(String batchPath) {
      return (Builder) super.setBatchPath(batchPath);
    }

    @Override
    public Builder setHttpRequestInitializer(com.google.api.client.http.HttpRequestInitializer httpRequestInitializer) {
      return (Builder) super.setHttpRequestInitializer(httpRequestInitializer);
    }

    @Override
    public Builder setApplicationName(String applicationName) {
      return (Builder) super.setApplicationName(applicationName);
    }

    @Override
    public Builder setSuppressPatternChecks(boolean suppressPatternChecks) {
      return (Builder) super.setSuppressPatternChecks(suppressPatternChecks);
    }

    @Override
    public Builder setSuppressRequiredParameterChecks(boolean suppressRequiredParameterChecks) {
      return (Builder) super.setSuppressRequiredParameterChecks(suppressRequiredParameterChecks);
    }

    @Override
    public Builder setSuppressAllChecks(boolean suppressAllChecks) {
      return (Builder) super.setSuppressAllChecks(suppressAllChecks);
    }

    /**
     * Set the {@link RemoteBuildExecutionRequestInitializer}.
     *
     * @since 1.12
     */
    public Builder setRemoteBuildExecutionRequestInitializer(
        RemoteBuildExecutionRequestInitializer remotebuildexecutionRequestInitializer) {
      return (Builder) super.setGoogleClientRequestInitializer(remotebuildexecutionRequestInitializer);
    }

    @Override
    public Builder setGoogleClientRequestInitializer(
        com.google.api.client.googleapis.services.GoogleClientRequestInitializer googleClientRequestInitializer) {
      return (Builder) super.setGoogleClientRequestInitializer(googleClientRequestInitializer);
    }
  }
}
