/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.androidmanagement.v1.model;

/**
 * Policy for an individual app.
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the Android Management API. For a detailed explanation
 * see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class ApplicationPolicy extends com.google.api.client.json.GenericJson {

  /**
   * List of the app’s track IDs that a device belonging to the enterprise can access. If the list
   * contains multiple track IDs, devices receive the latest version among all accessible tracks. If
   * the list contains no track IDs, devices only have access to the app’s production track. More
   * details about each track are available in AppTrackInfo.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.String> accessibleTrackIds;

  /**
   * Specifies whether the app is allowed networking when the VPN is not connected and
   * alwaysOnVpnPackage.lockdownEnabled is enabled. If set to VPN_LOCKDOWN_ENFORCED, the app is not
   * allowed networking, and if set to VPN_LOCKDOWN_EXEMPTION, the app is allowed networking. Only
   * supported on devices running Android 10 and above. If this is not supported by the device, the
   * device will contain a NonComplianceDetail with non_compliance_reason set to API_LEVEL and a
   * fieldPath. If this is not applicable to the app, the device will contain a NonComplianceDetail
   * with non_compliance_reason set to UNSUPPORTED and a fieldPath. The fieldPath is set to
   * applications[i].alwaysOnVpnLockdownExemption, where i is the index of the package in the
   * applications policy.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String alwaysOnVpnLockdownExemption;

  /**
   * Controls the auto-update mode for the app.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String autoUpdateMode;

  /**
   * Controls whether the app can communicate with itself across a device’s work and personal
   * profiles, subject to user consent.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String connectedWorkAndPersonalApp;

  /**
   * The default policy for all permissions requested by the app. If specified, this overrides the
   * policy-level default_permission_policy which applies to all apps. It does not override the
   * permission_grants which applies to all apps.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String defaultPermissionPolicy;

  /**
   * The scopes delegated to the app from Android Device Policy.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.String> delegatedScopes;

  /**
   * Whether the app is disabled. When disabled, the app data is still preserved.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean disabled;

  /**
   * Configuration to enable this app as an extension app, with the capability of interacting with
   * Android Device Policy offline.This field can be set for at most one app.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private ExtensionConfig extensionConfig;

  /**
   * The type of installation to perform.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String installType;

  /**
   * Whether the app is allowed to lock itself in full-screen mode. DEPRECATED. Use InstallType
   * KIOSK or kioskCustomLauncherEnabled to to configure a dedicated device.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean lockTaskAllowed;

  /**
   * Managed configuration applied to the app. The format for the configuration is dictated by the
   * ManagedProperty values supported by the app. Each field name in the managed configuration must
   * match the key field of the ManagedProperty. The field value must be compatible with the type of
   * the ManagedProperty: *type* *JSON value* BOOL true or false STRING string INTEGER number CHOICE
   * string MULTISELECT array of strings HIDDEN string BUNDLE_ARRAY array of objects
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.Map<String, java.lang.Object> managedConfiguration;

  /**
   * The managed configurations template for the app, saved from the managed configurations iframe.
   * This field is ignored if managed_configuration is set.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private ManagedConfigurationTemplate managedConfigurationTemplate;

  /**
   * The minimum version of the app that runs on the device. If set, the device attempts to update
   * the app to at least this version code. If the app is not up-to-date, the device will contain a
   * NonComplianceDetail with non_compliance_reason set to APP_NOT_UPDATED. The app must already be
   * published to Google Play with a version code greater than or equal to this value. At most 20
   * apps may specify a minimum version code per policy.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer minimumVersionCode;

  /**
   * The package name of the app. For example, com.google.android.youtube for the YouTube app.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String packageName;

  /**
   * Explicit permission grants or denials for the app. These values override the
   * default_permission_policy and permission_grants which apply to all apps.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<PermissionGrant> permissionGrants;

  /**
   * List of the app’s track IDs that a device belonging to the enterprise can access. If the list
   * contains multiple track IDs, devices receive the latest version among all accessible tracks. If
   * the list contains no track IDs, devices only have access to the app’s production track. More
   * details about each track are available in AppTrackInfo.
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.String> getAccessibleTrackIds() {
    return accessibleTrackIds;
  }

  /**
   * List of the app’s track IDs that a device belonging to the enterprise can access. If the list
   * contains multiple track IDs, devices receive the latest version among all accessible tracks. If
   * the list contains no track IDs, devices only have access to the app’s production track. More
   * details about each track are available in AppTrackInfo.
   * @param accessibleTrackIds accessibleTrackIds or {@code null} for none
   */
  public ApplicationPolicy setAccessibleTrackIds(java.util.List<java.lang.String> accessibleTrackIds) {
    this.accessibleTrackIds = accessibleTrackIds;
    return this;
  }

  /**
   * Specifies whether the app is allowed networking when the VPN is not connected and
   * alwaysOnVpnPackage.lockdownEnabled is enabled. If set to VPN_LOCKDOWN_ENFORCED, the app is not
   * allowed networking, and if set to VPN_LOCKDOWN_EXEMPTION, the app is allowed networking. Only
   * supported on devices running Android 10 and above. If this is not supported by the device, the
   * device will contain a NonComplianceDetail with non_compliance_reason set to API_LEVEL and a
   * fieldPath. If this is not applicable to the app, the device will contain a NonComplianceDetail
   * with non_compliance_reason set to UNSUPPORTED and a fieldPath. The fieldPath is set to
   * applications[i].alwaysOnVpnLockdownExemption, where i is the index of the package in the
   * applications policy.
   * @return value or {@code null} for none
   */
  public java.lang.String getAlwaysOnVpnLockdownExemption() {
    return alwaysOnVpnLockdownExemption;
  }

  /**
   * Specifies whether the app is allowed networking when the VPN is not connected and
   * alwaysOnVpnPackage.lockdownEnabled is enabled. If set to VPN_LOCKDOWN_ENFORCED, the app is not
   * allowed networking, and if set to VPN_LOCKDOWN_EXEMPTION, the app is allowed networking. Only
   * supported on devices running Android 10 and above. If this is not supported by the device, the
   * device will contain a NonComplianceDetail with non_compliance_reason set to API_LEVEL and a
   * fieldPath. If this is not applicable to the app, the device will contain a NonComplianceDetail
   * with non_compliance_reason set to UNSUPPORTED and a fieldPath. The fieldPath is set to
   * applications[i].alwaysOnVpnLockdownExemption, where i is the index of the package in the
   * applications policy.
   * @param alwaysOnVpnLockdownExemption alwaysOnVpnLockdownExemption or {@code null} for none
   */
  public ApplicationPolicy setAlwaysOnVpnLockdownExemption(java.lang.String alwaysOnVpnLockdownExemption) {
    this.alwaysOnVpnLockdownExemption = alwaysOnVpnLockdownExemption;
    return this;
  }

  /**
   * Controls the auto-update mode for the app.
   * @return value or {@code null} for none
   */
  public java.lang.String getAutoUpdateMode() {
    return autoUpdateMode;
  }

  /**
   * Controls the auto-update mode for the app.
   * @param autoUpdateMode autoUpdateMode or {@code null} for none
   */
  public ApplicationPolicy setAutoUpdateMode(java.lang.String autoUpdateMode) {
    this.autoUpdateMode = autoUpdateMode;
    return this;
  }

  /**
   * Controls whether the app can communicate with itself across a device’s work and personal
   * profiles, subject to user consent.
   * @return value or {@code null} for none
   */
  public java.lang.String getConnectedWorkAndPersonalApp() {
    return connectedWorkAndPersonalApp;
  }

  /**
   * Controls whether the app can communicate with itself across a device’s work and personal
   * profiles, subject to user consent.
   * @param connectedWorkAndPersonalApp connectedWorkAndPersonalApp or {@code null} for none
   */
  public ApplicationPolicy setConnectedWorkAndPersonalApp(java.lang.String connectedWorkAndPersonalApp) {
    this.connectedWorkAndPersonalApp = connectedWorkAndPersonalApp;
    return this;
  }

  /**
   * The default policy for all permissions requested by the app. If specified, this overrides the
   * policy-level default_permission_policy which applies to all apps. It does not override the
   * permission_grants which applies to all apps.
   * @return value or {@code null} for none
   */
  public java.lang.String getDefaultPermissionPolicy() {
    return defaultPermissionPolicy;
  }

  /**
   * The default policy for all permissions requested by the app. If specified, this overrides the
   * policy-level default_permission_policy which applies to all apps. It does not override the
   * permission_grants which applies to all apps.
   * @param defaultPermissionPolicy defaultPermissionPolicy or {@code null} for none
   */
  public ApplicationPolicy setDefaultPermissionPolicy(java.lang.String defaultPermissionPolicy) {
    this.defaultPermissionPolicy = defaultPermissionPolicy;
    return this;
  }

  /**
   * The scopes delegated to the app from Android Device Policy.
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.String> getDelegatedScopes() {
    return delegatedScopes;
  }

  /**
   * The scopes delegated to the app from Android Device Policy.
   * @param delegatedScopes delegatedScopes or {@code null} for none
   */
  public ApplicationPolicy setDelegatedScopes(java.util.List<java.lang.String> delegatedScopes) {
    this.delegatedScopes = delegatedScopes;
    return this;
  }

  /**
   * Whether the app is disabled. When disabled, the app data is still preserved.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getDisabled() {
    return disabled;
  }

  /**
   * Whether the app is disabled. When disabled, the app data is still preserved.
   * @param disabled disabled or {@code null} for none
   */
  public ApplicationPolicy setDisabled(java.lang.Boolean disabled) {
    this.disabled = disabled;
    return this;
  }

  /**
   * Configuration to enable this app as an extension app, with the capability of interacting with
   * Android Device Policy offline.This field can be set for at most one app.
   * @return value or {@code null} for none
   */
  public ExtensionConfig getExtensionConfig() {
    return extensionConfig;
  }

  /**
   * Configuration to enable this app as an extension app, with the capability of interacting with
   * Android Device Policy offline.This field can be set for at most one app.
   * @param extensionConfig extensionConfig or {@code null} for none
   */
  public ApplicationPolicy setExtensionConfig(ExtensionConfig extensionConfig) {
    this.extensionConfig = extensionConfig;
    return this;
  }

  /**
   * The type of installation to perform.
   * @return value or {@code null} for none
   */
  public java.lang.String getInstallType() {
    return installType;
  }

  /**
   * The type of installation to perform.
   * @param installType installType or {@code null} for none
   */
  public ApplicationPolicy setInstallType(java.lang.String installType) {
    this.installType = installType;
    return this;
  }

  /**
   * Whether the app is allowed to lock itself in full-screen mode. DEPRECATED. Use InstallType
   * KIOSK or kioskCustomLauncherEnabled to to configure a dedicated device.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getLockTaskAllowed() {
    return lockTaskAllowed;
  }

  /**
   * Whether the app is allowed to lock itself in full-screen mode. DEPRECATED. Use InstallType
   * KIOSK or kioskCustomLauncherEnabled to to configure a dedicated device.
   * @param lockTaskAllowed lockTaskAllowed or {@code null} for none
   */
  public ApplicationPolicy setLockTaskAllowed(java.lang.Boolean lockTaskAllowed) {
    this.lockTaskAllowed = lockTaskAllowed;
    return this;
  }

  /**
   * Managed configuration applied to the app. The format for the configuration is dictated by the
   * ManagedProperty values supported by the app. Each field name in the managed configuration must
   * match the key field of the ManagedProperty. The field value must be compatible with the type of
   * the ManagedProperty: *type* *JSON value* BOOL true or false STRING string INTEGER number CHOICE
   * string MULTISELECT array of strings HIDDEN string BUNDLE_ARRAY array of objects
   * @return value or {@code null} for none
   */
  public java.util.Map<String, java.lang.Object> getManagedConfiguration() {
    return managedConfiguration;
  }

  /**
   * Managed configuration applied to the app. The format for the configuration is dictated by the
   * ManagedProperty values supported by the app. Each field name in the managed configuration must
   * match the key field of the ManagedProperty. The field value must be compatible with the type of
   * the ManagedProperty: *type* *JSON value* BOOL true or false STRING string INTEGER number CHOICE
   * string MULTISELECT array of strings HIDDEN string BUNDLE_ARRAY array of objects
   * @param managedConfiguration managedConfiguration or {@code null} for none
   */
  public ApplicationPolicy setManagedConfiguration(java.util.Map<String, java.lang.Object> managedConfiguration) {
    this.managedConfiguration = managedConfiguration;
    return this;
  }

  /**
   * The managed configurations template for the app, saved from the managed configurations iframe.
   * This field is ignored if managed_configuration is set.
   * @return value or {@code null} for none
   */
  public ManagedConfigurationTemplate getManagedConfigurationTemplate() {
    return managedConfigurationTemplate;
  }

  /**
   * The managed configurations template for the app, saved from the managed configurations iframe.
   * This field is ignored if managed_configuration is set.
   * @param managedConfigurationTemplate managedConfigurationTemplate or {@code null} for none
   */
  public ApplicationPolicy setManagedConfigurationTemplate(ManagedConfigurationTemplate managedConfigurationTemplate) {
    this.managedConfigurationTemplate = managedConfigurationTemplate;
    return this;
  }

  /**
   * The minimum version of the app that runs on the device. If set, the device attempts to update
   * the app to at least this version code. If the app is not up-to-date, the device will contain a
   * NonComplianceDetail with non_compliance_reason set to APP_NOT_UPDATED. The app must already be
   * published to Google Play with a version code greater than or equal to this value. At most 20
   * apps may specify a minimum version code per policy.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getMinimumVersionCode() {
    return minimumVersionCode;
  }

  /**
   * The minimum version of the app that runs on the device. If set, the device attempts to update
   * the app to at least this version code. If the app is not up-to-date, the device will contain a
   * NonComplianceDetail with non_compliance_reason set to APP_NOT_UPDATED. The app must already be
   * published to Google Play with a version code greater than or equal to this value. At most 20
   * apps may specify a minimum version code per policy.
   * @param minimumVersionCode minimumVersionCode or {@code null} for none
   */
  public ApplicationPolicy setMinimumVersionCode(java.lang.Integer minimumVersionCode) {
    this.minimumVersionCode = minimumVersionCode;
    return this;
  }

  /**
   * The package name of the app. For example, com.google.android.youtube for the YouTube app.
   * @return value or {@code null} for none
   */
  public java.lang.String getPackageName() {
    return packageName;
  }

  /**
   * The package name of the app. For example, com.google.android.youtube for the YouTube app.
   * @param packageName packageName or {@code null} for none
   */
  public ApplicationPolicy setPackageName(java.lang.String packageName) {
    this.packageName = packageName;
    return this;
  }

  /**
   * Explicit permission grants or denials for the app. These values override the
   * default_permission_policy and permission_grants which apply to all apps.
   * @return value or {@code null} for none
   */
  public java.util.List<PermissionGrant> getPermissionGrants() {
    return permissionGrants;
  }

  /**
   * Explicit permission grants or denials for the app. These values override the
   * default_permission_policy and permission_grants which apply to all apps.
   * @param permissionGrants permissionGrants or {@code null} for none
   */
  public ApplicationPolicy setPermissionGrants(java.util.List<PermissionGrant> permissionGrants) {
    this.permissionGrants = permissionGrants;
    return this;
  }

  @Override
  public ApplicationPolicy set(String fieldName, Object value) {
    return (ApplicationPolicy) super.set(fieldName, value);
  }

  @Override
  public ApplicationPolicy clone() {
    return (ApplicationPolicy) super.clone();
  }

}
