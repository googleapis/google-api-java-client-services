/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.contentwarehouse.v1.model;

/**
 * Response to a query. The main result is the nearest neighbor list, but we also optionally include
 * debugging information if the appropriate field is set in the request. Last used: 8
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the contentwarehouse API. For a detailed explanation see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class ResearchScamQueryResponse extends com.google.api.client.json.GenericJson {

  /**
   * Debugging fields: The wall and CPU time used by each query on each machine. For successful
   * queries, there will be one entry here for each machine that the query used if
   * QueryRequest.enable_latency_stats was enabled. For unsuccessful queries, the contents of this
   * field will be undefined. NOTE: The following accounting rules apply in batched mode, assuming
   * there are
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<ResearchScamOnlineSearchLatencyStats> latency;

  static {
    // hack to force ProGuard to consider ResearchScamOnlineSearchLatencyStats used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(ResearchScamOnlineSearchLatencyStats.class);
  }

  /**
   * The number of non-root machines for which a DEADLINE_EXCEEDED error occurred when they were
   * contacted. This value does NOT include machines for which no reply was received because their
   * parent machine timed out. Therefore, num_total_machines may be larger than num_ok_machines +
   * num_unreachable_machines + num_deadline_exceeded_machines.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Long numDeadlineExceededMachines;

  /**
   * Number of machines that contributed to the results; this might be less than the total number of
   * machines if a machine has failed. The impact of a single machine failure could be larger than
   * just one machine, if it happens to be one of the machines involved in distributing the query
   * and collecting results.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Long numOkMachines;

  /**
   * The number of machines used in this service for the dataset that was queried. If everything
   * went right, this should be equal to num_ok_machines. If num_ok_machines < num_total_machines,
   * some neighbors may be missing from results.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Long numTotalMachines;

  /**
   * The number of non-root machines for which an UNREACHABLE error occurred when they were
   * contacted. This value does NOT include machines that were implicitly unreachable because their
   * parent machine was not reachable. Therefore, num_total_machines may be larger than
   * num_ok_machines + num_unreachable_machines + num_deadline_exceeded_machines.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Long numUnreachableMachines;

  /**
   * The number of "active" datapoints for each dataset, i.e. points that are whitelisted by
   * restricts and could be returned if they were close enough to the query. For successful queries,
   * there will be one entry here for each dataset queried, if QueryRequest.enable_restrict_stats
   * was true. For partially-successful successful queries, this field will contain results
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<ResearchScamRestrictStats> restrictStats;

  /**
   * The results for each dataset searched. If per_dataset_parameters was empty in QueryRequest then
   * this will have one entry, the results for dataset 0. If per_dataset_parameters was not empty in
   * QueryRequest, this will contain the results for each dataset queried, in order corresponding to
   * the order of QueryRequest.per_dataset_parameters.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<ResearchScamNearestNeighbors> results;

  static {
    // hack to force ProGuard to consider ResearchScamNearestNeighbors used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(ResearchScamNearestNeighbors.class);
  }

  /**
   * USEFUL ONLY IN CUSTOM BINARIES. In the stock ScaM server binary, all errors are relayed via the
   * RPC's status. Thus, if RPC's status is ok, this field is guaranteed to be ok and if RPC's
   * status is an error, no QueryResponse will be returned. The status of this query. This is useful
   * when using a batched postprocessing lambda, which may ignore erroneous subqueries, continue
   * postprocessing the valid ones and return OkStatus. In this case, this field will inform the
   * client of any invalid subqueries.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private UtilStatusProto status;

  /**
   * Debugging fields: The wall and CPU time used by each query on each machine. For successful
   * queries, there will be one entry here for each machine that the query used if
   * QueryRequest.enable_latency_stats was enabled. For unsuccessful queries, the contents of this
   * field will be undefined. NOTE: The following accounting rules apply in batched mode, assuming
   * there are
   * @return value or {@code null} for none
   */
  public java.util.List<ResearchScamOnlineSearchLatencyStats> getLatency() {
    return latency;
  }

  /**
   * Debugging fields: The wall and CPU time used by each query on each machine. For successful
   * queries, there will be one entry here for each machine that the query used if
   * QueryRequest.enable_latency_stats was enabled. For unsuccessful queries, the contents of this
   * field will be undefined. NOTE: The following accounting rules apply in batched mode, assuming
   * there are
   * @param latency latency or {@code null} for none
   */
  public ResearchScamQueryResponse setLatency(java.util.List<ResearchScamOnlineSearchLatencyStats> latency) {
    this.latency = latency;
    return this;
  }

  /**
   * The number of non-root machines for which a DEADLINE_EXCEEDED error occurred when they were
   * contacted. This value does NOT include machines for which no reply was received because their
   * parent machine timed out. Therefore, num_total_machines may be larger than num_ok_machines +
   * num_unreachable_machines + num_deadline_exceeded_machines.
   * @return value or {@code null} for none
   */
  public java.lang.Long getNumDeadlineExceededMachines() {
    return numDeadlineExceededMachines;
  }

  /**
   * The number of non-root machines for which a DEADLINE_EXCEEDED error occurred when they were
   * contacted. This value does NOT include machines for which no reply was received because their
   * parent machine timed out. Therefore, num_total_machines may be larger than num_ok_machines +
   * num_unreachable_machines + num_deadline_exceeded_machines.
   * @param numDeadlineExceededMachines numDeadlineExceededMachines or {@code null} for none
   */
  public ResearchScamQueryResponse setNumDeadlineExceededMachines(java.lang.Long numDeadlineExceededMachines) {
    this.numDeadlineExceededMachines = numDeadlineExceededMachines;
    return this;
  }

  /**
   * Number of machines that contributed to the results; this might be less than the total number of
   * machines if a machine has failed. The impact of a single machine failure could be larger than
   * just one machine, if it happens to be one of the machines involved in distributing the query
   * and collecting results.
   * @return value or {@code null} for none
   */
  public java.lang.Long getNumOkMachines() {
    return numOkMachines;
  }

  /**
   * Number of machines that contributed to the results; this might be less than the total number of
   * machines if a machine has failed. The impact of a single machine failure could be larger than
   * just one machine, if it happens to be one of the machines involved in distributing the query
   * and collecting results.
   * @param numOkMachines numOkMachines or {@code null} for none
   */
  public ResearchScamQueryResponse setNumOkMachines(java.lang.Long numOkMachines) {
    this.numOkMachines = numOkMachines;
    return this;
  }

  /**
   * The number of machines used in this service for the dataset that was queried. If everything
   * went right, this should be equal to num_ok_machines. If num_ok_machines < num_total_machines,
   * some neighbors may be missing from results.
   * @return value or {@code null} for none
   */
  public java.lang.Long getNumTotalMachines() {
    return numTotalMachines;
  }

  /**
   * The number of machines used in this service for the dataset that was queried. If everything
   * went right, this should be equal to num_ok_machines. If num_ok_machines < num_total_machines,
   * some neighbors may be missing from results.
   * @param numTotalMachines numTotalMachines or {@code null} for none
   */
  public ResearchScamQueryResponse setNumTotalMachines(java.lang.Long numTotalMachines) {
    this.numTotalMachines = numTotalMachines;
    return this;
  }

  /**
   * The number of non-root machines for which an UNREACHABLE error occurred when they were
   * contacted. This value does NOT include machines that were implicitly unreachable because their
   * parent machine was not reachable. Therefore, num_total_machines may be larger than
   * num_ok_machines + num_unreachable_machines + num_deadline_exceeded_machines.
   * @return value or {@code null} for none
   */
  public java.lang.Long getNumUnreachableMachines() {
    return numUnreachableMachines;
  }

  /**
   * The number of non-root machines for which an UNREACHABLE error occurred when they were
   * contacted. This value does NOT include machines that were implicitly unreachable because their
   * parent machine was not reachable. Therefore, num_total_machines may be larger than
   * num_ok_machines + num_unreachable_machines + num_deadline_exceeded_machines.
   * @param numUnreachableMachines numUnreachableMachines or {@code null} for none
   */
  public ResearchScamQueryResponse setNumUnreachableMachines(java.lang.Long numUnreachableMachines) {
    this.numUnreachableMachines = numUnreachableMachines;
    return this;
  }

  /**
   * The number of "active" datapoints for each dataset, i.e. points that are whitelisted by
   * restricts and could be returned if they were close enough to the query. For successful queries,
   * there will be one entry here for each dataset queried, if QueryRequest.enable_restrict_stats
   * was true. For partially-successful successful queries, this field will contain results
   * @return value or {@code null} for none
   */
  public java.util.List<ResearchScamRestrictStats> getRestrictStats() {
    return restrictStats;
  }

  /**
   * The number of "active" datapoints for each dataset, i.e. points that are whitelisted by
   * restricts and could be returned if they were close enough to the query. For successful queries,
   * there will be one entry here for each dataset queried, if QueryRequest.enable_restrict_stats
   * was true. For partially-successful successful queries, this field will contain results
   * @param restrictStats restrictStats or {@code null} for none
   */
  public ResearchScamQueryResponse setRestrictStats(java.util.List<ResearchScamRestrictStats> restrictStats) {
    this.restrictStats = restrictStats;
    return this;
  }

  /**
   * The results for each dataset searched. If per_dataset_parameters was empty in QueryRequest then
   * this will have one entry, the results for dataset 0. If per_dataset_parameters was not empty in
   * QueryRequest, this will contain the results for each dataset queried, in order corresponding to
   * the order of QueryRequest.per_dataset_parameters.
   * @return value or {@code null} for none
   */
  public java.util.List<ResearchScamNearestNeighbors> getResults() {
    return results;
  }

  /**
   * The results for each dataset searched. If per_dataset_parameters was empty in QueryRequest then
   * this will have one entry, the results for dataset 0. If per_dataset_parameters was not empty in
   * QueryRequest, this will contain the results for each dataset queried, in order corresponding to
   * the order of QueryRequest.per_dataset_parameters.
   * @param results results or {@code null} for none
   */
  public ResearchScamQueryResponse setResults(java.util.List<ResearchScamNearestNeighbors> results) {
    this.results = results;
    return this;
  }

  /**
   * USEFUL ONLY IN CUSTOM BINARIES. In the stock ScaM server binary, all errors are relayed via the
   * RPC's status. Thus, if RPC's status is ok, this field is guaranteed to be ok and if RPC's
   * status is an error, no QueryResponse will be returned. The status of this query. This is useful
   * when using a batched postprocessing lambda, which may ignore erroneous subqueries, continue
   * postprocessing the valid ones and return OkStatus. In this case, this field will inform the
   * client of any invalid subqueries.
   * @return value or {@code null} for none
   */
  public UtilStatusProto getStatus() {
    return status;
  }

  /**
   * USEFUL ONLY IN CUSTOM BINARIES. In the stock ScaM server binary, all errors are relayed via the
   * RPC's status. Thus, if RPC's status is ok, this field is guaranteed to be ok and if RPC's
   * status is an error, no QueryResponse will be returned. The status of this query. This is useful
   * when using a batched postprocessing lambda, which may ignore erroneous subqueries, continue
   * postprocessing the valid ones and return OkStatus. In this case, this field will inform the
   * client of any invalid subqueries.
   * @param status status or {@code null} for none
   */
  public ResearchScamQueryResponse setStatus(UtilStatusProto status) {
    this.status = status;
    return this;
  }

  @Override
  public ResearchScamQueryResponse set(String fieldName, Object value) {
    return (ResearchScamQueryResponse) super.set(fieldName, value);
  }

  @Override
  public ResearchScamQueryResponse clone() {
    return (ResearchScamQueryResponse) super.clone();
  }

}
