/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.spanner.v1.model;

/**
 * Partial results from a streaming read or SQL query. Streaming reads and SQL queries better
 * tolerate large result sets, large rows, and large values, but are a little trickier to consume.
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the Cloud Spanner API. For a detailed explanation see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class PartialResultSet extends com.google.api.client.json.GenericJson {

  /**
   * If true, then the final value in values is chunked, and must be combined with more values from
   * subsequent `PartialResultSet`s to obtain a complete field value.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean chunkedValue;

  /**
   * Optional. Indicates whether this is the last `PartialResultSet` in the stream. The server might
   * optionally set this field. Clients shouldn't rely on this field being set in all cases.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean last;

  /**
   * Metadata about the result set, such as row type information. Only present in the first
   * response.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private ResultSetMetadata metadata;

  /**
   * Optional. A precommit token is included if the read-write transaction has multiplexed sessions
   * enabled. Pass the precommit token with the highest sequence number from this transaction
   * attempt to the Commit request for this transaction.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private MultiplexedSessionPrecommitToken precommitToken;

  /**
   * Streaming calls might be interrupted for a variety of reasons, such as TCP connection loss. If
   * this occurs, the stream of results can be resumed by re-sending the original request and
   * including `resume_token`. Note that executing any other transaction in the same session
   * invalidates the token.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String resumeToken;

  /**
   * Query plan and execution statistics for the statement that produced this streaming result set.
   * These can be requested by setting ExecuteSqlRequest.query_mode and are sent only once with the
   * last response in the stream. This field is also present in the last response for DML
   * statements.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private ResultSetStats stats;

  /**
   * A streamed result set consists of a stream of values, which might be split into many
   * `PartialResultSet` messages to accommodate large rows and/or large values. Every N complete
   * values defines a row, where N is equal to the number of entries in metadata.row_type.fields.
   * Most values are encoded based on type as described here. It's possible that the last value in
   * values is "chunked", meaning that the rest of the value is sent in subsequent
   * `PartialResultSet`(s). This is denoted by the chunked_value field. Two or more chunked values
   * can be merged to form a complete value as follows: * `bool/number/null`: can't be chunked *
   * `string`: concatenate the strings * `list`: concatenate the lists. If the last element in a
   * list is a `string`, `list`, or `object`, merge it with the first element in the next list by
   * applying these rules recursively. * `object`: concatenate the (field name, field value) pairs.
   * If a field name is duplicated, then apply these rules recursively to merge the field values.
   * Some examples of merging: Strings are concatenated. "foo", "bar" => "foobar" Lists of non-
   * strings are concatenated. [2, 3], [4] => [2, 3, 4] Lists are concatenated, but the last and
   * first elements are merged because they are strings. ["a", "b"], ["c", "d"] => ["a", "bc", "d"]
   * Lists are concatenated, but the last and first elements are merged because they are lists.
   * Recursively, the last and first elements of the inner lists are merged because they are
   * strings. ["a", ["b", "c"]], [["d"], "e"] => ["a", ["b", "cd"], "e"] Non-overlapping object
   * fields are combined. {"a": "1"}, {"b": "2"} => {"a": "1", "b": 2"} Overlapping object fields
   * are merged. {"a": "1"}, {"a": "2"} => {"a": "12"} Examples of merging objects containing lists
   * of strings. {"a": ["1"]}, {"a": ["2"]} => {"a": ["12"]} For a more complete example, suppose a
   * streaming SQL query is yielding a result set whose rows contain a single string field. The
   * following `PartialResultSet`s might be yielded: { "metadata": { ... } "values": ["Hello", "W"]
   * "chunked_value": true "resume_token": "Af65..." } { "values": ["orl"] "chunked_value": true } {
   * "values": ["d"] "resume_token": "Zx1B..." } This sequence of `PartialResultSet`s encodes two
   * rows, one containing the field value `"Hello"`, and a second containing the field value
   * `"World" = "W" + "orl" + "d"`. Not all `PartialResultSet`s contain a `resume_token`. Execution
   * can only be resumed from a previously yielded `resume_token`. For the above sequence of
   * `PartialResultSet`s, resuming the query with `"resume_token": "Af65..."` yields results from
   * the `PartialResultSet` with value "orl".
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.Object> values;

  /**
   * If true, then the final value in values is chunked, and must be combined with more values from
   * subsequent `PartialResultSet`s to obtain a complete field value.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getChunkedValue() {
    return chunkedValue;
  }

  /**
   * If true, then the final value in values is chunked, and must be combined with more values from
   * subsequent `PartialResultSet`s to obtain a complete field value.
   * @param chunkedValue chunkedValue or {@code null} for none
   */
  public PartialResultSet setChunkedValue(java.lang.Boolean chunkedValue) {
    this.chunkedValue = chunkedValue;
    return this;
  }

  /**
   * Optional. Indicates whether this is the last `PartialResultSet` in the stream. The server might
   * optionally set this field. Clients shouldn't rely on this field being set in all cases.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getLast() {
    return last;
  }

  /**
   * Optional. Indicates whether this is the last `PartialResultSet` in the stream. The server might
   * optionally set this field. Clients shouldn't rely on this field being set in all cases.
   * @param last last or {@code null} for none
   */
  public PartialResultSet setLast(java.lang.Boolean last) {
    this.last = last;
    return this;
  }

  /**
   * Metadata about the result set, such as row type information. Only present in the first
   * response.
   * @return value or {@code null} for none
   */
  public ResultSetMetadata getMetadata() {
    return metadata;
  }

  /**
   * Metadata about the result set, such as row type information. Only present in the first
   * response.
   * @param metadata metadata or {@code null} for none
   */
  public PartialResultSet setMetadata(ResultSetMetadata metadata) {
    this.metadata = metadata;
    return this;
  }

  /**
   * Optional. A precommit token is included if the read-write transaction has multiplexed sessions
   * enabled. Pass the precommit token with the highest sequence number from this transaction
   * attempt to the Commit request for this transaction.
   * @return value or {@code null} for none
   */
  public MultiplexedSessionPrecommitToken getPrecommitToken() {
    return precommitToken;
  }

  /**
   * Optional. A precommit token is included if the read-write transaction has multiplexed sessions
   * enabled. Pass the precommit token with the highest sequence number from this transaction
   * attempt to the Commit request for this transaction.
   * @param precommitToken precommitToken or {@code null} for none
   */
  public PartialResultSet setPrecommitToken(MultiplexedSessionPrecommitToken precommitToken) {
    this.precommitToken = precommitToken;
    return this;
  }

  /**
   * Streaming calls might be interrupted for a variety of reasons, such as TCP connection loss. If
   * this occurs, the stream of results can be resumed by re-sending the original request and
   * including `resume_token`. Note that executing any other transaction in the same session
   * invalidates the token.
   * @see #decodeResumeToken()
   * @return value or {@code null} for none
   */
  public java.lang.String getResumeToken() {
    return resumeToken;
  }

  /**
   * Streaming calls might be interrupted for a variety of reasons, such as TCP connection loss. If
   * this occurs, the stream of results can be resumed by re-sending the original request and
   * including `resume_token`. Note that executing any other transaction in the same session
   * invalidates the token.
   * @see #getResumeToken()
   * @return Base64 decoded value or {@code null} for none
   *
   * @since 1.14
   */
  public byte[] decodeResumeToken() {
    return com.google.api.client.util.Base64.decodeBase64(resumeToken);
  }

  /**
   * Streaming calls might be interrupted for a variety of reasons, such as TCP connection loss. If
   * this occurs, the stream of results can be resumed by re-sending the original request and
   * including `resume_token`. Note that executing any other transaction in the same session
   * invalidates the token.
   * @see #encodeResumeToken()
   * @param resumeToken resumeToken or {@code null} for none
   */
  public PartialResultSet setResumeToken(java.lang.String resumeToken) {
    this.resumeToken = resumeToken;
    return this;
  }

  /**
   * Streaming calls might be interrupted for a variety of reasons, such as TCP connection loss. If
   * this occurs, the stream of results can be resumed by re-sending the original request and
   * including `resume_token`. Note that executing any other transaction in the same session
   * invalidates the token.
   * @see #setResumeToken()
   *
   * <p>
   * The value is encoded Base64 or {@code null} for none.
   * </p>
   *
   * @since 1.14
   */
  public PartialResultSet encodeResumeToken(byte[] resumeToken) {
    this.resumeToken = com.google.api.client.util.Base64.encodeBase64URLSafeString(resumeToken);
    return this;
  }

  /**
   * Query plan and execution statistics for the statement that produced this streaming result set.
   * These can be requested by setting ExecuteSqlRequest.query_mode and are sent only once with the
   * last response in the stream. This field is also present in the last response for DML
   * statements.
   * @return value or {@code null} for none
   */
  public ResultSetStats getStats() {
    return stats;
  }

  /**
   * Query plan and execution statistics for the statement that produced this streaming result set.
   * These can be requested by setting ExecuteSqlRequest.query_mode and are sent only once with the
   * last response in the stream. This field is also present in the last response for DML
   * statements.
   * @param stats stats or {@code null} for none
   */
  public PartialResultSet setStats(ResultSetStats stats) {
    this.stats = stats;
    return this;
  }

  /**
   * A streamed result set consists of a stream of values, which might be split into many
   * `PartialResultSet` messages to accommodate large rows and/or large values. Every N complete
   * values defines a row, where N is equal to the number of entries in metadata.row_type.fields.
   * Most values are encoded based on type as described here. It's possible that the last value in
   * values is "chunked", meaning that the rest of the value is sent in subsequent
   * `PartialResultSet`(s). This is denoted by the chunked_value field. Two or more chunked values
   * can be merged to form a complete value as follows: * `bool/number/null`: can't be chunked *
   * `string`: concatenate the strings * `list`: concatenate the lists. If the last element in a
   * list is a `string`, `list`, or `object`, merge it with the first element in the next list by
   * applying these rules recursively. * `object`: concatenate the (field name, field value) pairs.
   * If a field name is duplicated, then apply these rules recursively to merge the field values.
   * Some examples of merging: Strings are concatenated. "foo", "bar" => "foobar" Lists of non-
   * strings are concatenated. [2, 3], [4] => [2, 3, 4] Lists are concatenated, but the last and
   * first elements are merged because they are strings. ["a", "b"], ["c", "d"] => ["a", "bc", "d"]
   * Lists are concatenated, but the last and first elements are merged because they are lists.
   * Recursively, the last and first elements of the inner lists are merged because they are
   * strings. ["a", ["b", "c"]], [["d"], "e"] => ["a", ["b", "cd"], "e"] Non-overlapping object
   * fields are combined. {"a": "1"}, {"b": "2"} => {"a": "1", "b": 2"} Overlapping object fields
   * are merged. {"a": "1"}, {"a": "2"} => {"a": "12"} Examples of merging objects containing lists
   * of strings. {"a": ["1"]}, {"a": ["2"]} => {"a": ["12"]} For a more complete example, suppose a
   * streaming SQL query is yielding a result set whose rows contain a single string field. The
   * following `PartialResultSet`s might be yielded: { "metadata": { ... } "values": ["Hello", "W"]
   * "chunked_value": true "resume_token": "Af65..." } { "values": ["orl"] "chunked_value": true } {
   * "values": ["d"] "resume_token": "Zx1B..." } This sequence of `PartialResultSet`s encodes two
   * rows, one containing the field value `"Hello"`, and a second containing the field value
   * `"World" = "W" + "orl" + "d"`. Not all `PartialResultSet`s contain a `resume_token`. Execution
   * can only be resumed from a previously yielded `resume_token`. For the above sequence of
   * `PartialResultSet`s, resuming the query with `"resume_token": "Af65..."` yields results from
   * the `PartialResultSet` with value "orl".
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.Object> getValues() {
    return values;
  }

  /**
   * A streamed result set consists of a stream of values, which might be split into many
   * `PartialResultSet` messages to accommodate large rows and/or large values. Every N complete
   * values defines a row, where N is equal to the number of entries in metadata.row_type.fields.
   * Most values are encoded based on type as described here. It's possible that the last value in
   * values is "chunked", meaning that the rest of the value is sent in subsequent
   * `PartialResultSet`(s). This is denoted by the chunked_value field. Two or more chunked values
   * can be merged to form a complete value as follows: * `bool/number/null`: can't be chunked *
   * `string`: concatenate the strings * `list`: concatenate the lists. If the last element in a
   * list is a `string`, `list`, or `object`, merge it with the first element in the next list by
   * applying these rules recursively. * `object`: concatenate the (field name, field value) pairs.
   * If a field name is duplicated, then apply these rules recursively to merge the field values.
   * Some examples of merging: Strings are concatenated. "foo", "bar" => "foobar" Lists of non-
   * strings are concatenated. [2, 3], [4] => [2, 3, 4] Lists are concatenated, but the last and
   * first elements are merged because they are strings. ["a", "b"], ["c", "d"] => ["a", "bc", "d"]
   * Lists are concatenated, but the last and first elements are merged because they are lists.
   * Recursively, the last and first elements of the inner lists are merged because they are
   * strings. ["a", ["b", "c"]], [["d"], "e"] => ["a", ["b", "cd"], "e"] Non-overlapping object
   * fields are combined. {"a": "1"}, {"b": "2"} => {"a": "1", "b": 2"} Overlapping object fields
   * are merged. {"a": "1"}, {"a": "2"} => {"a": "12"} Examples of merging objects containing lists
   * of strings. {"a": ["1"]}, {"a": ["2"]} => {"a": ["12"]} For a more complete example, suppose a
   * streaming SQL query is yielding a result set whose rows contain a single string field. The
   * following `PartialResultSet`s might be yielded: { "metadata": { ... } "values": ["Hello", "W"]
   * "chunked_value": true "resume_token": "Af65..." } { "values": ["orl"] "chunked_value": true } {
   * "values": ["d"] "resume_token": "Zx1B..." } This sequence of `PartialResultSet`s encodes two
   * rows, one containing the field value `"Hello"`, and a second containing the field value
   * `"World" = "W" + "orl" + "d"`. Not all `PartialResultSet`s contain a `resume_token`. Execution
   * can only be resumed from a previously yielded `resume_token`. For the above sequence of
   * `PartialResultSet`s, resuming the query with `"resume_token": "Af65..."` yields results from
   * the `PartialResultSet` with value "orl".
   * @param values values or {@code null} for none
   */
  public PartialResultSet setValues(java.util.List<java.lang.Object> values) {
    this.values = values;
    return this;
  }

  @Override
  public PartialResultSet set(String fieldName, Object value) {
    return (PartialResultSet) super.set(fieldName, value);
  }

  @Override
  public PartialResultSet clone() {
    return (PartialResultSet) super.clone();
  }

}
