/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.contentwarehouse.v1.model;

/**
 * TODO(yanghu) add 25/50/75 percentiles of FPS to have a 5 number summary. Next id: 48
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the Document AI Warehouse API. For a detailed explanation
 * see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class VideoVideoStreamInfoVideoStream extends com.google.api.client.json.GenericJson {

  /**
   * This represents the canonical frame rate of the video. This is named average_fps for historical
   * reasons, and may not actually be the arithmetic mean. For variable frame rate videos, the
   * algorithm may change again in future. Currently, full vsi set it with arithmetic mean, and
   * partial vsi set it with median.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Double averageFps;

  /**
   * video bitrate in bits/s
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long bitrate;

  /**
   * Contains the color information obtained after inspection of the bitstream in cases where there
   * may be inconsistencies between container and coded bitstream that are resolved in favor of the
   * container.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private VideoFileColorInfo bitstreamColorInfo;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private VideoVideoStreamInfoVideoStreamCleanAperture cleanAperture;

  /**
   * some container allows for a clock discontinuity. In this case, the end_timestamp may not be the
   * correct DTS of the stream.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long clockDiscontinuityUs;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private VideoClosedCaptions closedCaptions;

  /**
   * closed_gop_size refers to chunkable boundaries for each specified codec and may actually
   * contain one or more GOPs, e.g. for H.264, closed_gop_size will denote the distance (frame
   * count) between two IDR frames.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private VideoVideoStreamInfoVideoStreamStatistics closedGopSize;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String codecFourcc;

  /**
   * Primary video codec information
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String codecId;

  /**
   * RFC6381 Codec string.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String codecString;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private VideoFileColorInfo colorInfo;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private VideoFileContentLightLevel contentLightLevel;

  /**
   * The bytes offset of the end of the first decodable packet.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long decodeOffset;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer displayHeight;

  /**
   * final display video width and height if explicitly set in the video otherwise this can be
   * calculated from source width/height and video_pixel_aspect_ratio
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer displayWidth;

  /**
   * Dolby Vision configuration if stream is compatible.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private VideoDoViDecoderConfiguration doviConfiguration;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long endTimestamp;

  /**
   * Should the video be mirrored horizontally / vertically? When rotation and flip both are present
   * for a video, it is assumed that the flip is applied first, and then the rotation.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String flip;

  /**
   * video frame per second, obtained by parsing video header information. It could be inaccurate
   * for some types of codecs, notably, WMV, ASF, and FLV. It will be inaccurate for videos that
   * does not have constant frame rate since it is the smallest framerate that can accurately
   * represent all timestamps (see ffmpeg doc for AVStream.r_frame_rate). Also frame rate can be
   * parsed from headers and can be wrong if it is not available there since ffmpeg uses a heuristic
   * for determining it.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Double fps;

  /**
   * video frame size
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long frameSize;

  /**
   * Statistics about gop sizes of the video.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private VideoVideoStreamInfoVideoStreamStatistics gopSize;

  /**
   * video has b frames
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean hasBFrames;

  /**
   * Stats on HDR10+ over video frames.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private VideoFileHDR10PlusStats hdr10PlusStats;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer height;

  /**
   * Information on interlaced video.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String interlace;

  /**
   * Check if a video size insane or not. It is set if the input file is an MOV file.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean isInsaneSize;

  /**
   * User data registered Itu-T T.35 SEI message
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<VideoUserDataRegisteredItuTT35> ituTT35;

  static {
    // hack to force ProGuard to consider VideoUserDataRegisteredItuTT35 used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(VideoUserDataRegisteredItuTT35.class);
  }

  /**
   * video length in seconds Note that when the VSI is from users videos, it is not guaranteed to be
   * the same as transcode lengths and it could be 0 when the full VSI cannot compute the length
   * from the source header and timestamps (for example when header and timestamps are too broken).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Double length;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer level;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private VideoFileMasteringDisplayMetadata masteringDisplayMetadata;

  /**
   * Maximum instantaneous frame rate seen from analyzing the entire stream.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Double maxFps;

  /**
   * Metadata for video elementary stream;
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<VideoClipInfo> metadata;

  static {
    // hack to force ProGuard to consider VideoClipInfo used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(VideoClipInfo.class);
  }

  /**
   * Minimum instantaneous frame rate seen from analyzing the entire stream.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Double minFps;

  /**
   * Number of video frames.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long numberOfFrames;

  /**
   * Invisible frame count Keep a count of frames that are not displayed should the full frame count
   * be needed for the video stream. The only codec currently reporting this value is VP8 with
   * alternate reference frames enabled
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer numberOfInvisibleFrames;

  /**
   * Pixel format for the video stream.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String pixFmt;

  /**
   * video pixel aspect ratio
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Double pixelAspectRatio;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String profile;

  /**
   * The nominal frame rate ('fps' field) represented as a fraction.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private VideoRational32 rationalFps;

  /**
   * Is the video rotated ?
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String rotation;

  /**
   * video SEI payload types and total payload size of a type this is only for H.264 and H.265
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<VideoSEIMessage> seiMessage;

  static {
    // hack to force ProGuard to consider VideoSEIMessage used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(VideoSEIMessage.class);
  }

  /**
   * Optional spherical video information.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private VideoFileSphericalMetadata spherical;

  /**
   * Start/end timestamps of audio/video in ms.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long startTimestamp;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long streamCodecTag;

  /**
   * Index of the stream in the file. it is 0 based.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long streamIndex;

  /**
   * User data unregistered SEI message
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<VideoUserDataUnregistered> userDataUnregistered;

  static {
    // hack to force ProGuard to consider VideoUserDataUnregistered used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(VideoUserDataUnregistered.class);
  }

  /**
   * source video width and height
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer width;

  /**
   * This represents the canonical frame rate of the video. This is named average_fps for historical
   * reasons, and may not actually be the arithmetic mean. For variable frame rate videos, the
   * algorithm may change again in future. Currently, full vsi set it with arithmetic mean, and
   * partial vsi set it with median.
   * @return value or {@code null} for none
   */
  public java.lang.Double getAverageFps() {
    return averageFps;
  }

  /**
   * This represents the canonical frame rate of the video. This is named average_fps for historical
   * reasons, and may not actually be the arithmetic mean. For variable frame rate videos, the
   * algorithm may change again in future. Currently, full vsi set it with arithmetic mean, and
   * partial vsi set it with median.
   * @param averageFps averageFps or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setAverageFps(java.lang.Double averageFps) {
    this.averageFps = averageFps;
    return this;
  }

  /**
   * video bitrate in bits/s
   * @return value or {@code null} for none
   */
  public java.lang.Long getBitrate() {
    return bitrate;
  }

  /**
   * video bitrate in bits/s
   * @param bitrate bitrate or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setBitrate(java.lang.Long bitrate) {
    this.bitrate = bitrate;
    return this;
  }

  /**
   * Contains the color information obtained after inspection of the bitstream in cases where there
   * may be inconsistencies between container and coded bitstream that are resolved in favor of the
   * container.
   * @return value or {@code null} for none
   */
  public VideoFileColorInfo getBitstreamColorInfo() {
    return bitstreamColorInfo;
  }

  /**
   * Contains the color information obtained after inspection of the bitstream in cases where there
   * may be inconsistencies between container and coded bitstream that are resolved in favor of the
   * container.
   * @param bitstreamColorInfo bitstreamColorInfo or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setBitstreamColorInfo(VideoFileColorInfo bitstreamColorInfo) {
    this.bitstreamColorInfo = bitstreamColorInfo;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStreamCleanAperture getCleanAperture() {
    return cleanAperture;
  }

  /**
   * @param cleanAperture cleanAperture or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setCleanAperture(VideoVideoStreamInfoVideoStreamCleanAperture cleanAperture) {
    this.cleanAperture = cleanAperture;
    return this;
  }

  /**
   * some container allows for a clock discontinuity. In this case, the end_timestamp may not be the
   * correct DTS of the stream.
   * @return value or {@code null} for none
   */
  public java.lang.Long getClockDiscontinuityUs() {
    return clockDiscontinuityUs;
  }

  /**
   * some container allows for a clock discontinuity. In this case, the end_timestamp may not be the
   * correct DTS of the stream.
   * @param clockDiscontinuityUs clockDiscontinuityUs or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setClockDiscontinuityUs(java.lang.Long clockDiscontinuityUs) {
    this.clockDiscontinuityUs = clockDiscontinuityUs;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public VideoClosedCaptions getClosedCaptions() {
    return closedCaptions;
  }

  /**
   * @param closedCaptions closedCaptions or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setClosedCaptions(VideoClosedCaptions closedCaptions) {
    this.closedCaptions = closedCaptions;
    return this;
  }

  /**
   * closed_gop_size refers to chunkable boundaries for each specified codec and may actually
   * contain one or more GOPs, e.g. for H.264, closed_gop_size will denote the distance (frame
   * count) between two IDR frames.
   * @return value or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStreamStatistics getClosedGopSize() {
    return closedGopSize;
  }

  /**
   * closed_gop_size refers to chunkable boundaries for each specified codec and may actually
   * contain one or more GOPs, e.g. for H.264, closed_gop_size will denote the distance (frame
   * count) between two IDR frames.
   * @param closedGopSize closedGopSize or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setClosedGopSize(VideoVideoStreamInfoVideoStreamStatistics closedGopSize) {
    this.closedGopSize = closedGopSize;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.String getCodecFourcc() {
    return codecFourcc;
  }

  /**
   * @param codecFourcc codecFourcc or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setCodecFourcc(java.lang.String codecFourcc) {
    this.codecFourcc = codecFourcc;
    return this;
  }

  /**
   * Primary video codec information
   * @return value or {@code null} for none
   */
  public java.lang.String getCodecId() {
    return codecId;
  }

  /**
   * Primary video codec information
   * @param codecId codecId or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setCodecId(java.lang.String codecId) {
    this.codecId = codecId;
    return this;
  }

  /**
   * RFC6381 Codec string.
   * @return value or {@code null} for none
   */
  public java.lang.String getCodecString() {
    return codecString;
  }

  /**
   * RFC6381 Codec string.
   * @param codecString codecString or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setCodecString(java.lang.String codecString) {
    this.codecString = codecString;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public VideoFileColorInfo getColorInfo() {
    return colorInfo;
  }

  /**
   * @param colorInfo colorInfo or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setColorInfo(VideoFileColorInfo colorInfo) {
    this.colorInfo = colorInfo;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public VideoFileContentLightLevel getContentLightLevel() {
    return contentLightLevel;
  }

  /**
   * @param contentLightLevel contentLightLevel or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setContentLightLevel(VideoFileContentLightLevel contentLightLevel) {
    this.contentLightLevel = contentLightLevel;
    return this;
  }

  /**
   * The bytes offset of the end of the first decodable packet.
   * @return value or {@code null} for none
   */
  public java.lang.Long getDecodeOffset() {
    return decodeOffset;
  }

  /**
   * The bytes offset of the end of the first decodable packet.
   * @param decodeOffset decodeOffset or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setDecodeOffset(java.lang.Long decodeOffset) {
    this.decodeOffset = decodeOffset;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getDisplayHeight() {
    return displayHeight;
  }

  /**
   * @param displayHeight displayHeight or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setDisplayHeight(java.lang.Integer displayHeight) {
    this.displayHeight = displayHeight;
    return this;
  }

  /**
   * final display video width and height if explicitly set in the video otherwise this can be
   * calculated from source width/height and video_pixel_aspect_ratio
   * @return value or {@code null} for none
   */
  public java.lang.Integer getDisplayWidth() {
    return displayWidth;
  }

  /**
   * final display video width and height if explicitly set in the video otherwise this can be
   * calculated from source width/height and video_pixel_aspect_ratio
   * @param displayWidth displayWidth or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setDisplayWidth(java.lang.Integer displayWidth) {
    this.displayWidth = displayWidth;
    return this;
  }

  /**
   * Dolby Vision configuration if stream is compatible.
   * @return value or {@code null} for none
   */
  public VideoDoViDecoderConfiguration getDoviConfiguration() {
    return doviConfiguration;
  }

  /**
   * Dolby Vision configuration if stream is compatible.
   * @param doviConfiguration doviConfiguration or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setDoviConfiguration(VideoDoViDecoderConfiguration doviConfiguration) {
    this.doviConfiguration = doviConfiguration;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Long getEndTimestamp() {
    return endTimestamp;
  }

  /**
   * @param endTimestamp endTimestamp or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setEndTimestamp(java.lang.Long endTimestamp) {
    this.endTimestamp = endTimestamp;
    return this;
  }

  /**
   * Should the video be mirrored horizontally / vertically? When rotation and flip both are present
   * for a video, it is assumed that the flip is applied first, and then the rotation.
   * @return value or {@code null} for none
   */
  public java.lang.String getFlip() {
    return flip;
  }

  /**
   * Should the video be mirrored horizontally / vertically? When rotation and flip both are present
   * for a video, it is assumed that the flip is applied first, and then the rotation.
   * @param flip flip or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setFlip(java.lang.String flip) {
    this.flip = flip;
    return this;
  }

  /**
   * video frame per second, obtained by parsing video header information. It could be inaccurate
   * for some types of codecs, notably, WMV, ASF, and FLV. It will be inaccurate for videos that
   * does not have constant frame rate since it is the smallest framerate that can accurately
   * represent all timestamps (see ffmpeg doc for AVStream.r_frame_rate). Also frame rate can be
   * parsed from headers and can be wrong if it is not available there since ffmpeg uses a heuristic
   * for determining it.
   * @return value or {@code null} for none
   */
  public java.lang.Double getFps() {
    return fps;
  }

  /**
   * video frame per second, obtained by parsing video header information. It could be inaccurate
   * for some types of codecs, notably, WMV, ASF, and FLV. It will be inaccurate for videos that
   * does not have constant frame rate since it is the smallest framerate that can accurately
   * represent all timestamps (see ffmpeg doc for AVStream.r_frame_rate). Also frame rate can be
   * parsed from headers and can be wrong if it is not available there since ffmpeg uses a heuristic
   * for determining it.
   * @param fps fps or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setFps(java.lang.Double fps) {
    this.fps = fps;
    return this;
  }

  /**
   * video frame size
   * @return value or {@code null} for none
   */
  public java.lang.Long getFrameSize() {
    return frameSize;
  }

  /**
   * video frame size
   * @param frameSize frameSize or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setFrameSize(java.lang.Long frameSize) {
    this.frameSize = frameSize;
    return this;
  }

  /**
   * Statistics about gop sizes of the video.
   * @return value or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStreamStatistics getGopSize() {
    return gopSize;
  }

  /**
   * Statistics about gop sizes of the video.
   * @param gopSize gopSize or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setGopSize(VideoVideoStreamInfoVideoStreamStatistics gopSize) {
    this.gopSize = gopSize;
    return this;
  }

  /**
   * video has b frames
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getHasBFrames() {
    return hasBFrames;
  }

  /**
   * video has b frames
   * @param hasBFrames hasBFrames or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setHasBFrames(java.lang.Boolean hasBFrames) {
    this.hasBFrames = hasBFrames;
    return this;
  }

  /**
   * Stats on HDR10+ over video frames.
   * @return value or {@code null} for none
   */
  public VideoFileHDR10PlusStats getHdr10PlusStats() {
    return hdr10PlusStats;
  }

  /**
   * Stats on HDR10+ over video frames.
   * @param hdr10PlusStats hdr10PlusStats or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setHdr10PlusStats(VideoFileHDR10PlusStats hdr10PlusStats) {
    this.hdr10PlusStats = hdr10PlusStats;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getHeight() {
    return height;
  }

  /**
   * @param height height or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setHeight(java.lang.Integer height) {
    this.height = height;
    return this;
  }

  /**
   * Information on interlaced video.
   * @return value or {@code null} for none
   */
  public java.lang.String getInterlace() {
    return interlace;
  }

  /**
   * Information on interlaced video.
   * @param interlace interlace or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setInterlace(java.lang.String interlace) {
    this.interlace = interlace;
    return this;
  }

  /**
   * Check if a video size insane or not. It is set if the input file is an MOV file.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getIsInsaneSize() {
    return isInsaneSize;
  }

  /**
   * Check if a video size insane or not. It is set if the input file is an MOV file.
   * @param isInsaneSize isInsaneSize or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setIsInsaneSize(java.lang.Boolean isInsaneSize) {
    this.isInsaneSize = isInsaneSize;
    return this;
  }

  /**
   * User data registered Itu-T T.35 SEI message
   * @return value or {@code null} for none
   */
  public java.util.List<VideoUserDataRegisteredItuTT35> getItuTT35() {
    return ituTT35;
  }

  /**
   * User data registered Itu-T T.35 SEI message
   * @param ituTT35 ituTT35 or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setItuTT35(java.util.List<VideoUserDataRegisteredItuTT35> ituTT35) {
    this.ituTT35 = ituTT35;
    return this;
  }

  /**
   * video length in seconds Note that when the VSI is from users videos, it is not guaranteed to be
   * the same as transcode lengths and it could be 0 when the full VSI cannot compute the length
   * from the source header and timestamps (for example when header and timestamps are too broken).
   * @return value or {@code null} for none
   */
  public java.lang.Double getLength() {
    return length;
  }

  /**
   * video length in seconds Note that when the VSI is from users videos, it is not guaranteed to be
   * the same as transcode lengths and it could be 0 when the full VSI cannot compute the length
   * from the source header and timestamps (for example when header and timestamps are too broken).
   * @param length length or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setLength(java.lang.Double length) {
    this.length = length;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getLevel() {
    return level;
  }

  /**
   * @param level level or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setLevel(java.lang.Integer level) {
    this.level = level;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public VideoFileMasteringDisplayMetadata getMasteringDisplayMetadata() {
    return masteringDisplayMetadata;
  }

  /**
   * @param masteringDisplayMetadata masteringDisplayMetadata or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setMasteringDisplayMetadata(VideoFileMasteringDisplayMetadata masteringDisplayMetadata) {
    this.masteringDisplayMetadata = masteringDisplayMetadata;
    return this;
  }

  /**
   * Maximum instantaneous frame rate seen from analyzing the entire stream.
   * @return value or {@code null} for none
   */
  public java.lang.Double getMaxFps() {
    return maxFps;
  }

  /**
   * Maximum instantaneous frame rate seen from analyzing the entire stream.
   * @param maxFps maxFps or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setMaxFps(java.lang.Double maxFps) {
    this.maxFps = maxFps;
    return this;
  }

  /**
   * Metadata for video elementary stream;
   * @return value or {@code null} for none
   */
  public java.util.List<VideoClipInfo> getMetadata() {
    return metadata;
  }

  /**
   * Metadata for video elementary stream;
   * @param metadata metadata or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setMetadata(java.util.List<VideoClipInfo> metadata) {
    this.metadata = metadata;
    return this;
  }

  /**
   * Minimum instantaneous frame rate seen from analyzing the entire stream.
   * @return value or {@code null} for none
   */
  public java.lang.Double getMinFps() {
    return minFps;
  }

  /**
   * Minimum instantaneous frame rate seen from analyzing the entire stream.
   * @param minFps minFps or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setMinFps(java.lang.Double minFps) {
    this.minFps = minFps;
    return this;
  }

  /**
   * Number of video frames.
   * @return value or {@code null} for none
   */
  public java.lang.Long getNumberOfFrames() {
    return numberOfFrames;
  }

  /**
   * Number of video frames.
   * @param numberOfFrames numberOfFrames or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setNumberOfFrames(java.lang.Long numberOfFrames) {
    this.numberOfFrames = numberOfFrames;
    return this;
  }

  /**
   * Invisible frame count Keep a count of frames that are not displayed should the full frame count
   * be needed for the video stream. The only codec currently reporting this value is VP8 with
   * alternate reference frames enabled
   * @return value or {@code null} for none
   */
  public java.lang.Integer getNumberOfInvisibleFrames() {
    return numberOfInvisibleFrames;
  }

  /**
   * Invisible frame count Keep a count of frames that are not displayed should the full frame count
   * be needed for the video stream. The only codec currently reporting this value is VP8 with
   * alternate reference frames enabled
   * @param numberOfInvisibleFrames numberOfInvisibleFrames or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setNumberOfInvisibleFrames(java.lang.Integer numberOfInvisibleFrames) {
    this.numberOfInvisibleFrames = numberOfInvisibleFrames;
    return this;
  }

  /**
   * Pixel format for the video stream.
   * @return value or {@code null} for none
   */
  public java.lang.String getPixFmt() {
    return pixFmt;
  }

  /**
   * Pixel format for the video stream.
   * @param pixFmt pixFmt or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setPixFmt(java.lang.String pixFmt) {
    this.pixFmt = pixFmt;
    return this;
  }

  /**
   * video pixel aspect ratio
   * @return value or {@code null} for none
   */
  public java.lang.Double getPixelAspectRatio() {
    return pixelAspectRatio;
  }

  /**
   * video pixel aspect ratio
   * @param pixelAspectRatio pixelAspectRatio or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setPixelAspectRatio(java.lang.Double pixelAspectRatio) {
    this.pixelAspectRatio = pixelAspectRatio;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.String getProfile() {
    return profile;
  }

  /**
   * @param profile profile or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setProfile(java.lang.String profile) {
    this.profile = profile;
    return this;
  }

  /**
   * The nominal frame rate ('fps' field) represented as a fraction.
   * @return value or {@code null} for none
   */
  public VideoRational32 getRationalFps() {
    return rationalFps;
  }

  /**
   * The nominal frame rate ('fps' field) represented as a fraction.
   * @param rationalFps rationalFps or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setRationalFps(VideoRational32 rationalFps) {
    this.rationalFps = rationalFps;
    return this;
  }

  /**
   * Is the video rotated ?
   * @return value or {@code null} for none
   */
  public java.lang.String getRotation() {
    return rotation;
  }

  /**
   * Is the video rotated ?
   * @param rotation rotation or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setRotation(java.lang.String rotation) {
    this.rotation = rotation;
    return this;
  }

  /**
   * video SEI payload types and total payload size of a type this is only for H.264 and H.265
   * @return value or {@code null} for none
   */
  public java.util.List<VideoSEIMessage> getSeiMessage() {
    return seiMessage;
  }

  /**
   * video SEI payload types and total payload size of a type this is only for H.264 and H.265
   * @param seiMessage seiMessage or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setSeiMessage(java.util.List<VideoSEIMessage> seiMessage) {
    this.seiMessage = seiMessage;
    return this;
  }

  /**
   * Optional spherical video information.
   * @return value or {@code null} for none
   */
  public VideoFileSphericalMetadata getSpherical() {
    return spherical;
  }

  /**
   * Optional spherical video information.
   * @param spherical spherical or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setSpherical(VideoFileSphericalMetadata spherical) {
    this.spherical = spherical;
    return this;
  }

  /**
   * Start/end timestamps of audio/video in ms.
   * @return value or {@code null} for none
   */
  public java.lang.Long getStartTimestamp() {
    return startTimestamp;
  }

  /**
   * Start/end timestamps of audio/video in ms.
   * @param startTimestamp startTimestamp or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setStartTimestamp(java.lang.Long startTimestamp) {
    this.startTimestamp = startTimestamp;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Long getStreamCodecTag() {
    return streamCodecTag;
  }

  /**
   * @param streamCodecTag streamCodecTag or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setStreamCodecTag(java.lang.Long streamCodecTag) {
    this.streamCodecTag = streamCodecTag;
    return this;
  }

  /**
   * Index of the stream in the file. it is 0 based.
   * @return value or {@code null} for none
   */
  public java.lang.Long getStreamIndex() {
    return streamIndex;
  }

  /**
   * Index of the stream in the file. it is 0 based.
   * @param streamIndex streamIndex or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setStreamIndex(java.lang.Long streamIndex) {
    this.streamIndex = streamIndex;
    return this;
  }

  /**
   * User data unregistered SEI message
   * @return value or {@code null} for none
   */
  public java.util.List<VideoUserDataUnregistered> getUserDataUnregistered() {
    return userDataUnregistered;
  }

  /**
   * User data unregistered SEI message
   * @param userDataUnregistered userDataUnregistered or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setUserDataUnregistered(java.util.List<VideoUserDataUnregistered> userDataUnregistered) {
    this.userDataUnregistered = userDataUnregistered;
    return this;
  }

  /**
   * source video width and height
   * @return value or {@code null} for none
   */
  public java.lang.Integer getWidth() {
    return width;
  }

  /**
   * source video width and height
   * @param width width or {@code null} for none
   */
  public VideoVideoStreamInfoVideoStream setWidth(java.lang.Integer width) {
    this.width = width;
    return this;
  }

  @Override
  public VideoVideoStreamInfoVideoStream set(String fieldName, Object value) {
    return (VideoVideoStreamInfoVideoStream) super.set(fieldName, value);
  }

  @Override
  public VideoVideoStreamInfoVideoStream clone() {
    return (VideoVideoStreamInfoVideoStream) super.clone();
  }

}
