/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.contentwarehouse.v1.model;

/**
 * Our TYPE_INTERSECTION features model the point where one or more segments terminate. This is
 * topological definition: it may not match what a typical user would think of as an "intersection".
 * Consider the intersections where Hayes, Market, Larkin, and 9th Street meet near (37.77765,
 * -122.41638) in San Francisco. Most people would probably consider this a single feature, even
 * though we model it as four separate TYPE_INTERSECTION features. The TYPE_INTERSECTION_GROUP is
 * used to model the user's concept of a real-world intersection, which also includes turn lanes or
 * a whole roundabout (a logical intersection). For the purposes of modeling turn restrictions and
 * lane connections, a smaller grouping is needed to model the "core" part of the intersection where
 * there are no lane markings. This is called a core or artifact group. An intersection group must
 * contain at least two intersections or add some information (e.g. a name or a polygon) compared to
 * the intersection itself, or else must not exist. The standard feature properties are interpreted
 * as follows: name - Can be used to specify any "special" names associated with this intersection
 * (e.g. Reads Corner intersection, PEI, Canada). Intersections that are named according to their
 * cross streets do not need to specify this field, since this can be determined by looking at the
 * routes associated with each segment. address - This should always be empty. point - Specifies the
 * center of the intersection. This is basically the point where the intersection name should be
 * rendered. Can be omitted in favor of a polygon. polyline - This should always be empty. polygon -
 * Specifies the two-dimensional extent of the intersection. This may substitute to the point field,
 * though having a center set is desirable in this case. child - This should always be empty.
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the Document AI Warehouse API. For a detailed explanation
 * see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class GeostoreIntersectionGroupProto extends com.google.api.client.json.GenericJson {

  /**
   * All artifact intersection groups that are in this logical group.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreFeatureIdProto> childGroup;

  static {
    // hack to force ProGuard to consider GeostoreFeatureIdProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreFeatureIdProto.class);
  }

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String groupType;

  /**
   * The list of TYPE_INTERSECTION features that form this intersection group, but are NOT in any of
   * this group's child groups. This could be an empty list, though that is sub-optimal. Even an
   * empty list would allow the paint team to draw a label for a named intersection, but a non-empty
   * list would, for example, enable PathFinder to generate better directions. Each of the
   * TYPE_INTERSECTION feature referred here must refer back to this feature in its
   * IntersectionProto.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreFeatureIdProto> intersection;

  static {
    // hack to force ProGuard to consider GeostoreFeatureIdProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreFeatureIdProto.class);
  }

  /**
   * Parent logical intersection group. An artifact group that does not have an associated parent
   * logical group is assumed to be both an artifact and logical group.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFeatureIdProto parentGroup;

  /**
   * All artifact intersection groups that are in this logical group.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreFeatureIdProto> getChildGroup() {
    return childGroup;
  }

  /**
   * All artifact intersection groups that are in this logical group.
   * @param childGroup childGroup or {@code null} for none
   */
  public GeostoreIntersectionGroupProto setChildGroup(java.util.List<GeostoreFeatureIdProto> childGroup) {
    this.childGroup = childGroup;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.String getGroupType() {
    return groupType;
  }

  /**
   * @param groupType groupType or {@code null} for none
   */
  public GeostoreIntersectionGroupProto setGroupType(java.lang.String groupType) {
    this.groupType = groupType;
    return this;
  }

  /**
   * The list of TYPE_INTERSECTION features that form this intersection group, but are NOT in any of
   * this group's child groups. This could be an empty list, though that is sub-optimal. Even an
   * empty list would allow the paint team to draw a label for a named intersection, but a non-empty
   * list would, for example, enable PathFinder to generate better directions. Each of the
   * TYPE_INTERSECTION feature referred here must refer back to this feature in its
   * IntersectionProto.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreFeatureIdProto> getIntersection() {
    return intersection;
  }

  /**
   * The list of TYPE_INTERSECTION features that form this intersection group, but are NOT in any of
   * this group's child groups. This could be an empty list, though that is sub-optimal. Even an
   * empty list would allow the paint team to draw a label for a named intersection, but a non-empty
   * list would, for example, enable PathFinder to generate better directions. Each of the
   * TYPE_INTERSECTION feature referred here must refer back to this feature in its
   * IntersectionProto.
   * @param intersection intersection or {@code null} for none
   */
  public GeostoreIntersectionGroupProto setIntersection(java.util.List<GeostoreFeatureIdProto> intersection) {
    this.intersection = intersection;
    return this;
  }

  /**
   * Parent logical intersection group. An artifact group that does not have an associated parent
   * logical group is assumed to be both an artifact and logical group.
   * @return value or {@code null} for none
   */
  public GeostoreFeatureIdProto getParentGroup() {
    return parentGroup;
  }

  /**
   * Parent logical intersection group. An artifact group that does not have an associated parent
   * logical group is assumed to be both an artifact and logical group.
   * @param parentGroup parentGroup or {@code null} for none
   */
  public GeostoreIntersectionGroupProto setParentGroup(GeostoreFeatureIdProto parentGroup) {
    this.parentGroup = parentGroup;
    return this;
  }

  @Override
  public GeostoreIntersectionGroupProto set(String fieldName, Object value) {
    return (GeostoreIntersectionGroupProto) super.set(fieldName, value);
  }

  @Override
  public GeostoreIntersectionGroupProto clone() {
    return (GeostoreIntersectionGroupProto) super.clone();
  }

}
