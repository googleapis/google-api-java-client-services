/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.contentwarehouse.v1.model;

/**
 * Model definition for AnchorsAnchor.
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the Document AI Warehouse API. For a detailed explanation
 * see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class AnchorsAnchor extends com.google.api.client.json.GenericJson {

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer bucket;

  /**
   * CATfish tags attached to a link. These are similar to link tags, except the values are created
   * on the fly within Cookbook. See: http://sites/cookbook/exporting/indexing
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.Integer> catfishTags;

  /**
   * If the anchor contained images, these image urls are stored here in compressed form.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.String> compressedImageUrls;

  /**
   * The anchor's original target url, compressed. Available only in Alexandria docjoins when the
   * anchor is forwarded.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String compressedOriginalTargetUrl;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer context;

  /**
   * This is a hash of terms near the anchor. (This is a second-generation hash replacing the value
   * stored in the 'context' field.)
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer context2;

  /**
   * used for history - the first and last time we have seen this anchor. creation_date also used
   * for Freshdocs Twitter indexing, a retweet is an anchor of the original tweet. This field
   * records the time when a retweet is created.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer creationDate;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean deleted;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer deletionDate;

  /**
   * DEPRECATED
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer demotionreason;

  /**
   * Encoded data containing information about newsiness of anchor. Populated only if anchor is
   * classified as coming from a newsy, high quality site. Encoded data for anchor sources are being
   * stored in googledata/quality/freshness/news_anchors/encoded_news_anchors_data.txt Scores are
   * being computed with quality/freshness/news_anchors/ routines.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Long encodedNewsAnchorData;

  /**
   * If true, the anchor is for experimental purposes and should not be used in serving.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean experimental;

  /**
   * true iff exp domain
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean expired;

  /**
   * # days past Dec 31, 1994, 23:00:00 UTC (Unix time @788914800) that this link was first seen.
   * Should never occupy more than 15 bits. NOTE: this is NOT the same as creation_date;
   * firstseen_date is filled during link extraction
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer firstseenDate;

  /**
   * true if we think 'firstseen_date' is an accurate estimate of when the link was actually added
   * to the source page. false if it may have existed for some time before we saw it.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean firstseenNearCreation;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer fontsize;

  /**
   * How the anchor is forwarded to the canonical, available only for forwarded anchors (i.e., the
   * field is set). The forwarding types are defined in URLForwardingUtil (segindexer/segment-
   * indexer-util.h). Always use URLForwardingUtil to access this field and use
   * URLForwardingUtil::GetAnchorForwardingReason to get the explanation how the anchor is forwarded
   * to the canonical. NOTE: Use with caution as it is only set for docjoins generated using the
   * urlmap from repository/updater.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Long forwardingTypes;

  /**
   * The URL fragment for this anchor (the foo in http://www.google.com#foo)
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String fragment;

  /**
   * The full context. These are not written out in the linklogs.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.util.List<java.math.BigInteger> fullLeftContext;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.util.List<java.math.BigInteger> fullRightContext;

  /**
   * The bit ~roughly~ indicates whether an anchor's source and target pages are on the same domain.
   * Note: this plays no role in determining whether an anchor is onsite, ondomain, or offdomain in
   * mustang (i.e., the bit above).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean isLocal;

  /**
   * Used for history and freshness tracking - the timestamp this anchor is updated in indexing.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer lastUpdateTimestamp;

  /**
   * Additional information related to the anchor, such as additional anchor text or scores.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private Proto2BridgeMessageSet linkAdditionalInfo;

  /**
   * Contains info on link type, source page, etc.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.Integer> linkTags;

  /**
   * For ranking purposes, the quality of an anchor is measured by its "locality" and "bucket". See
   * quality/anchors/definitions.h for more information.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer locality;

  /**
   * This is the offset for the first term in the anchor - it can be used as a unique ID for the
   * anchor within the document and compared against all per-tag data. This is measured in bytes
   * from the start of the document. We write this out to the linklogs to recover the original order
   * of links after source/target forwarding. This is necessary for computing the global related
   * data.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer offset;

  /**
   * Original text, including capitalization and punctuation. Runs of whitespace are collapsed into
   * a single space.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String origText;

  /**
   * The docid of the anchor's original target. This field is available if and only if the anchor is
   * forwarded.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.math.BigInteger originalTargetDocid;

  /**
   * Weight to be stored in linkmaps for pageranker
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Float pagerankWeight;

  /**
   * The number of additional links from the same source page to the same target domain. Not
   * populated if is_local is true.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer parallelLinks;

  /**
   * DEPRECATED. It used to be set if firstseen_date is not set. It's to indicate that the anchor is
   * possibly old, but we don't have enough information to tell until the linkage map is updated.
   * TODO(hxu) rename it to possibly_old_firstseen_date_DEPRECATED after clean up other
   * dependencies.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean possiblyOldFirstseenDate;

  /**
   * TEMPORARY
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Float setiPagerankWeight;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private AnchorsAnchorSource source;

  /**
   * is to record the quality of the anchor's source page and is correlated with but not identical
   * to the index tier of the source page. In the docjoins built by the indexing pipeline
   * (Alexandria), - Anchors marked TYPE_HIGH_QUALITY are from base documents. - Anchors marked
   * TYPE_MEDIUM_QUALITY are from documents of medium quality (roughly but not exactly supplemental
   * tier documents). - Anchors marked TYPE_LOW_QUALITY are from documents of low quality (roughly
   * but not exactly blackhole documents). Note that the source_type can also be used as an
   * importance indicator of an anchor (a lower source_type value indicates a more important
   * anchor), so it is important to enforce that TYPE_HIGH_QUALITY < TYPE_MEDIUM_QUALITY <
   * TYPE_LOW_QUALITY To add a new source type in future, please maintain the proper relationship
   * among the types as well. TYPE_FRESHDOCS, only available in freshdocs indexing, is a special
   * case and is considered the same type as TYPE_HIGH_QUALITY for the purpose of anchor importance
   * in duplicate anchor removal.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer sourceType;

  /**
   * A given target URL may be found in different encodings in different documents. We store the URL
   * encoding with each source anchor so that we can count them later to find the encoding most
   * likely to be expected by the Web site. Around 0.7% of target URLs are expected to require a
   * non-default value here. The default value 0 is referenced in C++ as
   * webutil::kDefaultUrlEncoding. See also webutil/urlencoding.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer targetUrlEncoding;

  /**
   * Space-delimited anchor words. Text that needs segmentation (like CJK or Thai) is unsegmented,
   * since we set FLAGS_segment_during_lexing to false in mr-linkextractor.cc .
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String text;

  /**
   * This field is DEPRECATED and no longer filled. For source page crawl timestamp, use
   * Source.crawl_timestamp. Next tag id should be 62.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long timestamp;

  /**
   * DEPRECATED: Now in link_tags
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer type;

  /**
   * weights are 0-127
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer weight;

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getBucket() {
    return bucket;
  }

  /**
   * @param bucket bucket or {@code null} for none
   */
  public AnchorsAnchor setBucket(java.lang.Integer bucket) {
    this.bucket = bucket;
    return this;
  }

  /**
   * CATfish tags attached to a link. These are similar to link tags, except the values are created
   * on the fly within Cookbook. See: http://sites/cookbook/exporting/indexing
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.Integer> getCatfishTags() {
    return catfishTags;
  }

  /**
   * CATfish tags attached to a link. These are similar to link tags, except the values are created
   * on the fly within Cookbook. See: http://sites/cookbook/exporting/indexing
   * @param catfishTags catfishTags or {@code null} for none
   */
  public AnchorsAnchor setCatfishTags(java.util.List<java.lang.Integer> catfishTags) {
    this.catfishTags = catfishTags;
    return this;
  }

  /**
   * If the anchor contained images, these image urls are stored here in compressed form.
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.String> getCompressedImageUrls() {
    return compressedImageUrls;
  }

  /**
   * If the anchor contained images, these image urls are stored here in compressed form.
   * @param compressedImageUrls compressedImageUrls or {@code null} for none
   */
  public AnchorsAnchor setCompressedImageUrls(java.util.List<java.lang.String> compressedImageUrls) {
    this.compressedImageUrls = compressedImageUrls;
    return this;
  }

  /**
   * The anchor's original target url, compressed. Available only in Alexandria docjoins when the
   * anchor is forwarded.
   * @see #decodeCompressedOriginalTargetUrl()
   * @return value or {@code null} for none
   */
  public java.lang.String getCompressedOriginalTargetUrl() {
    return compressedOriginalTargetUrl;
  }

  /**
   * The anchor's original target url, compressed. Available only in Alexandria docjoins when the
   * anchor is forwarded.
   * @see #getCompressedOriginalTargetUrl()
   * @return Base64 decoded value or {@code null} for none
   *
   * @since 1.14
   */
  public byte[] decodeCompressedOriginalTargetUrl() {
    return com.google.api.client.util.Base64.decodeBase64(compressedOriginalTargetUrl);
  }

  /**
   * The anchor's original target url, compressed. Available only in Alexandria docjoins when the
   * anchor is forwarded.
   * @see #encodeCompressedOriginalTargetUrl()
   * @param compressedOriginalTargetUrl compressedOriginalTargetUrl or {@code null} for none
   */
  public AnchorsAnchor setCompressedOriginalTargetUrl(java.lang.String compressedOriginalTargetUrl) {
    this.compressedOriginalTargetUrl = compressedOriginalTargetUrl;
    return this;
  }

  /**
   * The anchor's original target url, compressed. Available only in Alexandria docjoins when the
   * anchor is forwarded.
   * @see #setCompressedOriginalTargetUrl()
   *
   * <p>
   * The value is encoded Base64 or {@code null} for none.
   * </p>
   *
   * @since 1.14
   */
  public AnchorsAnchor encodeCompressedOriginalTargetUrl(byte[] compressedOriginalTargetUrl) {
    this.compressedOriginalTargetUrl = com.google.api.client.util.Base64.encodeBase64URLSafeString(compressedOriginalTargetUrl);
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getContext() {
    return context;
  }

  /**
   * @param context context or {@code null} for none
   */
  public AnchorsAnchor setContext(java.lang.Integer context) {
    this.context = context;
    return this;
  }

  /**
   * This is a hash of terms near the anchor. (This is a second-generation hash replacing the value
   * stored in the 'context' field.)
   * @return value or {@code null} for none
   */
  public java.lang.Integer getContext2() {
    return context2;
  }

  /**
   * This is a hash of terms near the anchor. (This is a second-generation hash replacing the value
   * stored in the 'context' field.)
   * @param context2 context2 or {@code null} for none
   */
  public AnchorsAnchor setContext2(java.lang.Integer context2) {
    this.context2 = context2;
    return this;
  }

  /**
   * used for history - the first and last time we have seen this anchor. creation_date also used
   * for Freshdocs Twitter indexing, a retweet is an anchor of the original tweet. This field
   * records the time when a retweet is created.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getCreationDate() {
    return creationDate;
  }

  /**
   * used for history - the first and last time we have seen this anchor. creation_date also used
   * for Freshdocs Twitter indexing, a retweet is an anchor of the original tweet. This field
   * records the time when a retweet is created.
   * @param creationDate creationDate or {@code null} for none
   */
  public AnchorsAnchor setCreationDate(java.lang.Integer creationDate) {
    this.creationDate = creationDate;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getDeleted() {
    return deleted;
  }

  /**
   * @param deleted deleted or {@code null} for none
   */
  public AnchorsAnchor setDeleted(java.lang.Boolean deleted) {
    this.deleted = deleted;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getDeletionDate() {
    return deletionDate;
  }

  /**
   * @param deletionDate deletionDate or {@code null} for none
   */
  public AnchorsAnchor setDeletionDate(java.lang.Integer deletionDate) {
    this.deletionDate = deletionDate;
    return this;
  }

  /**
   * DEPRECATED
   * @return value or {@code null} for none
   */
  public java.lang.Integer getDemotionreason() {
    return demotionreason;
  }

  /**
   * DEPRECATED
   * @param demotionreason demotionreason or {@code null} for none
   */
  public AnchorsAnchor setDemotionreason(java.lang.Integer demotionreason) {
    this.demotionreason = demotionreason;
    return this;
  }

  /**
   * Encoded data containing information about newsiness of anchor. Populated only if anchor is
   * classified as coming from a newsy, high quality site. Encoded data for anchor sources are being
   * stored in googledata/quality/freshness/news_anchors/encoded_news_anchors_data.txt Scores are
   * being computed with quality/freshness/news_anchors/ routines.
   * @return value or {@code null} for none
   */
  public java.lang.Long getEncodedNewsAnchorData() {
    return encodedNewsAnchorData;
  }

  /**
   * Encoded data containing information about newsiness of anchor. Populated only if anchor is
   * classified as coming from a newsy, high quality site. Encoded data for anchor sources are being
   * stored in googledata/quality/freshness/news_anchors/encoded_news_anchors_data.txt Scores are
   * being computed with quality/freshness/news_anchors/ routines.
   * @param encodedNewsAnchorData encodedNewsAnchorData or {@code null} for none
   */
  public AnchorsAnchor setEncodedNewsAnchorData(java.lang.Long encodedNewsAnchorData) {
    this.encodedNewsAnchorData = encodedNewsAnchorData;
    return this;
  }

  /**
   * If true, the anchor is for experimental purposes and should not be used in serving.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getExperimental() {
    return experimental;
  }

  /**
   * If true, the anchor is for experimental purposes and should not be used in serving.
   * @param experimental experimental or {@code null} for none
   */
  public AnchorsAnchor setExperimental(java.lang.Boolean experimental) {
    this.experimental = experimental;
    return this;
  }

  /**
   * true iff exp domain
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getExpired() {
    return expired;
  }

  /**
   * true iff exp domain
   * @param expired expired or {@code null} for none
   */
  public AnchorsAnchor setExpired(java.lang.Boolean expired) {
    this.expired = expired;
    return this;
  }

  /**
   * # days past Dec 31, 1994, 23:00:00 UTC (Unix time @788914800) that this link was first seen.
   * Should never occupy more than 15 bits. NOTE: this is NOT the same as creation_date;
   * firstseen_date is filled during link extraction
   * @return value or {@code null} for none
   */
  public java.lang.Integer getFirstseenDate() {
    return firstseenDate;
  }

  /**
   * # days past Dec 31, 1994, 23:00:00 UTC (Unix time @788914800) that this link was first seen.
   * Should never occupy more than 15 bits. NOTE: this is NOT the same as creation_date;
   * firstseen_date is filled during link extraction
   * @param firstseenDate firstseenDate or {@code null} for none
   */
  public AnchorsAnchor setFirstseenDate(java.lang.Integer firstseenDate) {
    this.firstseenDate = firstseenDate;
    return this;
  }

  /**
   * true if we think 'firstseen_date' is an accurate estimate of when the link was actually added
   * to the source page. false if it may have existed for some time before we saw it.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getFirstseenNearCreation() {
    return firstseenNearCreation;
  }

  /**
   * true if we think 'firstseen_date' is an accurate estimate of when the link was actually added
   * to the source page. false if it may have existed for some time before we saw it.
   * @param firstseenNearCreation firstseenNearCreation or {@code null} for none
   */
  public AnchorsAnchor setFirstseenNearCreation(java.lang.Boolean firstseenNearCreation) {
    this.firstseenNearCreation = firstseenNearCreation;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getFontsize() {
    return fontsize;
  }

  /**
   * @param fontsize fontsize or {@code null} for none
   */
  public AnchorsAnchor setFontsize(java.lang.Integer fontsize) {
    this.fontsize = fontsize;
    return this;
  }

  /**
   * How the anchor is forwarded to the canonical, available only for forwarded anchors (i.e., the
   * field is set). The forwarding types are defined in URLForwardingUtil (segindexer/segment-
   * indexer-util.h). Always use URLForwardingUtil to access this field and use
   * URLForwardingUtil::GetAnchorForwardingReason to get the explanation how the anchor is forwarded
   * to the canonical. NOTE: Use with caution as it is only set for docjoins generated using the
   * urlmap from repository/updater.
   * @return value or {@code null} for none
   */
  public java.lang.Long getForwardingTypes() {
    return forwardingTypes;
  }

  /**
   * How the anchor is forwarded to the canonical, available only for forwarded anchors (i.e., the
   * field is set). The forwarding types are defined in URLForwardingUtil (segindexer/segment-
   * indexer-util.h). Always use URLForwardingUtil to access this field and use
   * URLForwardingUtil::GetAnchorForwardingReason to get the explanation how the anchor is forwarded
   * to the canonical. NOTE: Use with caution as it is only set for docjoins generated using the
   * urlmap from repository/updater.
   * @param forwardingTypes forwardingTypes or {@code null} for none
   */
  public AnchorsAnchor setForwardingTypes(java.lang.Long forwardingTypes) {
    this.forwardingTypes = forwardingTypes;
    return this;
  }

  /**
   * The URL fragment for this anchor (the foo in http://www.google.com#foo)
   * @return value or {@code null} for none
   */
  public java.lang.String getFragment() {
    return fragment;
  }

  /**
   * The URL fragment for this anchor (the foo in http://www.google.com#foo)
   * @param fragment fragment or {@code null} for none
   */
  public AnchorsAnchor setFragment(java.lang.String fragment) {
    this.fragment = fragment;
    return this;
  }

  /**
   * The full context. These are not written out in the linklogs.
   * @return value or {@code null} for none
   */
  public java.util.List<java.math.BigInteger> getFullLeftContext() {
    return fullLeftContext;
  }

  /**
   * The full context. These are not written out in the linklogs.
   * @param fullLeftContext fullLeftContext or {@code null} for none
   */
  public AnchorsAnchor setFullLeftContext(java.util.List<java.math.BigInteger> fullLeftContext) {
    this.fullLeftContext = fullLeftContext;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.util.List<java.math.BigInteger> getFullRightContext() {
    return fullRightContext;
  }

  /**
   * @param fullRightContext fullRightContext or {@code null} for none
   */
  public AnchorsAnchor setFullRightContext(java.util.List<java.math.BigInteger> fullRightContext) {
    this.fullRightContext = fullRightContext;
    return this;
  }

  /**
   * The bit ~roughly~ indicates whether an anchor's source and target pages are on the same domain.
   * Note: this plays no role in determining whether an anchor is onsite, ondomain, or offdomain in
   * mustang (i.e., the bit above).
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getIsLocal() {
    return isLocal;
  }

  /**
   * The bit ~roughly~ indicates whether an anchor's source and target pages are on the same domain.
   * Note: this plays no role in determining whether an anchor is onsite, ondomain, or offdomain in
   * mustang (i.e., the bit above).
   * @param isLocal isLocal or {@code null} for none
   */
  public AnchorsAnchor setIsLocal(java.lang.Boolean isLocal) {
    this.isLocal = isLocal;
    return this;
  }

  /**
   * Used for history and freshness tracking - the timestamp this anchor is updated in indexing.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getLastUpdateTimestamp() {
    return lastUpdateTimestamp;
  }

  /**
   * Used for history and freshness tracking - the timestamp this anchor is updated in indexing.
   * @param lastUpdateTimestamp lastUpdateTimestamp or {@code null} for none
   */
  public AnchorsAnchor setLastUpdateTimestamp(java.lang.Integer lastUpdateTimestamp) {
    this.lastUpdateTimestamp = lastUpdateTimestamp;
    return this;
  }

  /**
   * Additional information related to the anchor, such as additional anchor text or scores.
   * @return value or {@code null} for none
   */
  public Proto2BridgeMessageSet getLinkAdditionalInfo() {
    return linkAdditionalInfo;
  }

  /**
   * Additional information related to the anchor, such as additional anchor text or scores.
   * @param linkAdditionalInfo linkAdditionalInfo or {@code null} for none
   */
  public AnchorsAnchor setLinkAdditionalInfo(Proto2BridgeMessageSet linkAdditionalInfo) {
    this.linkAdditionalInfo = linkAdditionalInfo;
    return this;
  }

  /**
   * Contains info on link type, source page, etc.
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.Integer> getLinkTags() {
    return linkTags;
  }

  /**
   * Contains info on link type, source page, etc.
   * @param linkTags linkTags or {@code null} for none
   */
  public AnchorsAnchor setLinkTags(java.util.List<java.lang.Integer> linkTags) {
    this.linkTags = linkTags;
    return this;
  }

  /**
   * For ranking purposes, the quality of an anchor is measured by its "locality" and "bucket". See
   * quality/anchors/definitions.h for more information.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getLocality() {
    return locality;
  }

  /**
   * For ranking purposes, the quality of an anchor is measured by its "locality" and "bucket". See
   * quality/anchors/definitions.h for more information.
   * @param locality locality or {@code null} for none
   */
  public AnchorsAnchor setLocality(java.lang.Integer locality) {
    this.locality = locality;
    return this;
  }

  /**
   * This is the offset for the first term in the anchor - it can be used as a unique ID for the
   * anchor within the document and compared against all per-tag data. This is measured in bytes
   * from the start of the document. We write this out to the linklogs to recover the original order
   * of links after source/target forwarding. This is necessary for computing the global related
   * data.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getOffset() {
    return offset;
  }

  /**
   * This is the offset for the first term in the anchor - it can be used as a unique ID for the
   * anchor within the document and compared against all per-tag data. This is measured in bytes
   * from the start of the document. We write this out to the linklogs to recover the original order
   * of links after source/target forwarding. This is necessary for computing the global related
   * data.
   * @param offset offset or {@code null} for none
   */
  public AnchorsAnchor setOffset(java.lang.Integer offset) {
    this.offset = offset;
    return this;
  }

  /**
   * Original text, including capitalization and punctuation. Runs of whitespace are collapsed into
   * a single space.
   * @return value or {@code null} for none
   */
  public java.lang.String getOrigText() {
    return origText;
  }

  /**
   * Original text, including capitalization and punctuation. Runs of whitespace are collapsed into
   * a single space.
   * @param origText origText or {@code null} for none
   */
  public AnchorsAnchor setOrigText(java.lang.String origText) {
    this.origText = origText;
    return this;
  }

  /**
   * The docid of the anchor's original target. This field is available if and only if the anchor is
   * forwarded.
   * @return value or {@code null} for none
   */
  public java.math.BigInteger getOriginalTargetDocid() {
    return originalTargetDocid;
  }

  /**
   * The docid of the anchor's original target. This field is available if and only if the anchor is
   * forwarded.
   * @param originalTargetDocid originalTargetDocid or {@code null} for none
   */
  public AnchorsAnchor setOriginalTargetDocid(java.math.BigInteger originalTargetDocid) {
    this.originalTargetDocid = originalTargetDocid;
    return this;
  }

  /**
   * Weight to be stored in linkmaps for pageranker
   * @return value or {@code null} for none
   */
  public java.lang.Float getPagerankWeight() {
    return pagerankWeight;
  }

  /**
   * Weight to be stored in linkmaps for pageranker
   * @param pagerankWeight pagerankWeight or {@code null} for none
   */
  public AnchorsAnchor setPagerankWeight(java.lang.Float pagerankWeight) {
    this.pagerankWeight = pagerankWeight;
    return this;
  }

  /**
   * The number of additional links from the same source page to the same target domain. Not
   * populated if is_local is true.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getParallelLinks() {
    return parallelLinks;
  }

  /**
   * The number of additional links from the same source page to the same target domain. Not
   * populated if is_local is true.
   * @param parallelLinks parallelLinks or {@code null} for none
   */
  public AnchorsAnchor setParallelLinks(java.lang.Integer parallelLinks) {
    this.parallelLinks = parallelLinks;
    return this;
  }

  /**
   * DEPRECATED. It used to be set if firstseen_date is not set. It's to indicate that the anchor is
   * possibly old, but we don't have enough information to tell until the linkage map is updated.
   * TODO(hxu) rename it to possibly_old_firstseen_date_DEPRECATED after clean up other
   * dependencies.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getPossiblyOldFirstseenDate() {
    return possiblyOldFirstseenDate;
  }

  /**
   * DEPRECATED. It used to be set if firstseen_date is not set. It's to indicate that the anchor is
   * possibly old, but we don't have enough information to tell until the linkage map is updated.
   * TODO(hxu) rename it to possibly_old_firstseen_date_DEPRECATED after clean up other
   * dependencies.
   * @param possiblyOldFirstseenDate possiblyOldFirstseenDate or {@code null} for none
   */
  public AnchorsAnchor setPossiblyOldFirstseenDate(java.lang.Boolean possiblyOldFirstseenDate) {
    this.possiblyOldFirstseenDate = possiblyOldFirstseenDate;
    return this;
  }

  /**
   * TEMPORARY
   * @return value or {@code null} for none
   */
  public java.lang.Float getSetiPagerankWeight() {
    return setiPagerankWeight;
  }

  /**
   * TEMPORARY
   * @param setiPagerankWeight setiPagerankWeight or {@code null} for none
   */
  public AnchorsAnchor setSetiPagerankWeight(java.lang.Float setiPagerankWeight) {
    this.setiPagerankWeight = setiPagerankWeight;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public AnchorsAnchorSource getSource() {
    return source;
  }

  /**
   * @param source source or {@code null} for none
   */
  public AnchorsAnchor setSource(AnchorsAnchorSource source) {
    this.source = source;
    return this;
  }

  /**
   * is to record the quality of the anchor's source page and is correlated with but not identical
   * to the index tier of the source page. In the docjoins built by the indexing pipeline
   * (Alexandria), - Anchors marked TYPE_HIGH_QUALITY are from base documents. - Anchors marked
   * TYPE_MEDIUM_QUALITY are from documents of medium quality (roughly but not exactly supplemental
   * tier documents). - Anchors marked TYPE_LOW_QUALITY are from documents of low quality (roughly
   * but not exactly blackhole documents). Note that the source_type can also be used as an
   * importance indicator of an anchor (a lower source_type value indicates a more important
   * anchor), so it is important to enforce that TYPE_HIGH_QUALITY < TYPE_MEDIUM_QUALITY <
   * TYPE_LOW_QUALITY To add a new source type in future, please maintain the proper relationship
   * among the types as well. TYPE_FRESHDOCS, only available in freshdocs indexing, is a special
   * case and is considered the same type as TYPE_HIGH_QUALITY for the purpose of anchor importance
   * in duplicate anchor removal.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getSourceType() {
    return sourceType;
  }

  /**
   * is to record the quality of the anchor's source page and is correlated with but not identical
   * to the index tier of the source page. In the docjoins built by the indexing pipeline
   * (Alexandria), - Anchors marked TYPE_HIGH_QUALITY are from base documents. - Anchors marked
   * TYPE_MEDIUM_QUALITY are from documents of medium quality (roughly but not exactly supplemental
   * tier documents). - Anchors marked TYPE_LOW_QUALITY are from documents of low quality (roughly
   * but not exactly blackhole documents). Note that the source_type can also be used as an
   * importance indicator of an anchor (a lower source_type value indicates a more important
   * anchor), so it is important to enforce that TYPE_HIGH_QUALITY < TYPE_MEDIUM_QUALITY <
   * TYPE_LOW_QUALITY To add a new source type in future, please maintain the proper relationship
   * among the types as well. TYPE_FRESHDOCS, only available in freshdocs indexing, is a special
   * case and is considered the same type as TYPE_HIGH_QUALITY for the purpose of anchor importance
   * in duplicate anchor removal.
   * @param sourceType sourceType or {@code null} for none
   */
  public AnchorsAnchor setSourceType(java.lang.Integer sourceType) {
    this.sourceType = sourceType;
    return this;
  }

  /**
   * A given target URL may be found in different encodings in different documents. We store the URL
   * encoding with each source anchor so that we can count them later to find the encoding most
   * likely to be expected by the Web site. Around 0.7% of target URLs are expected to require a
   * non-default value here. The default value 0 is referenced in C++ as
   * webutil::kDefaultUrlEncoding. See also webutil/urlencoding.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getTargetUrlEncoding() {
    return targetUrlEncoding;
  }

  /**
   * A given target URL may be found in different encodings in different documents. We store the URL
   * encoding with each source anchor so that we can count them later to find the encoding most
   * likely to be expected by the Web site. Around 0.7% of target URLs are expected to require a
   * non-default value here. The default value 0 is referenced in C++ as
   * webutil::kDefaultUrlEncoding. See also webutil/urlencoding.
   * @param targetUrlEncoding targetUrlEncoding or {@code null} for none
   */
  public AnchorsAnchor setTargetUrlEncoding(java.lang.Integer targetUrlEncoding) {
    this.targetUrlEncoding = targetUrlEncoding;
    return this;
  }

  /**
   * Space-delimited anchor words. Text that needs segmentation (like CJK or Thai) is unsegmented,
   * since we set FLAGS_segment_during_lexing to false in mr-linkextractor.cc .
   * @return value or {@code null} for none
   */
  public java.lang.String getText() {
    return text;
  }

  /**
   * Space-delimited anchor words. Text that needs segmentation (like CJK or Thai) is unsegmented,
   * since we set FLAGS_segment_during_lexing to false in mr-linkextractor.cc .
   * @param text text or {@code null} for none
   */
  public AnchorsAnchor setText(java.lang.String text) {
    this.text = text;
    return this;
  }

  /**
   * This field is DEPRECATED and no longer filled. For source page crawl timestamp, use
   * Source.crawl_timestamp. Next tag id should be 62.
   * @return value or {@code null} for none
   */
  public java.lang.Long getTimestamp() {
    return timestamp;
  }

  /**
   * This field is DEPRECATED and no longer filled. For source page crawl timestamp, use
   * Source.crawl_timestamp. Next tag id should be 62.
   * @param timestamp timestamp or {@code null} for none
   */
  public AnchorsAnchor setTimestamp(java.lang.Long timestamp) {
    this.timestamp = timestamp;
    return this;
  }

  /**
   * DEPRECATED: Now in link_tags
   * @return value or {@code null} for none
   */
  public java.lang.Integer getType() {
    return type;
  }

  /**
   * DEPRECATED: Now in link_tags
   * @param type type or {@code null} for none
   */
  public AnchorsAnchor setType(java.lang.Integer type) {
    this.type = type;
    return this;
  }

  /**
   * weights are 0-127
   * @return value or {@code null} for none
   */
  public java.lang.Integer getWeight() {
    return weight;
  }

  /**
   * weights are 0-127
   * @param weight weight or {@code null} for none
   */
  public AnchorsAnchor setWeight(java.lang.Integer weight) {
    this.weight = weight;
    return this;
  }

  @Override
  public AnchorsAnchor set(String fieldName, Object value) {
    return (AnchorsAnchor) super.set(fieldName, value);
  }

  @Override
  public AnchorsAnchor clone() {
    return (AnchorsAnchor) super.clone();
  }

}
