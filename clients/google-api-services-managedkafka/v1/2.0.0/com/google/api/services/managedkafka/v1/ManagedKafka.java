/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.managedkafka.v1;

/**
 * Service definition for ManagedKafka (v1).
 *
 * <p>
 * Manage Apache Kafka clusters and resources. 
 * </p>
 *
 * <p>
 * For more information about this service, see the
 * <a href="https://cloud.google.com/managed-service-for-apache-kafka/docs" target="_blank">API Documentation</a>
 * </p>
 *
 * <p>
 * This service uses {@link ManagedKafkaRequestInitializer} to initialize global parameters via its
 * {@link Builder}.
 * </p>
 *
 * @since 1.3
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public class ManagedKafka extends com.google.api.client.googleapis.services.json.AbstractGoogleJsonClient {

  // Note: Leave this static initializer at the top of the file.
  static {
    com.google.api.client.util.Preconditions.checkState(
        (com.google.api.client.googleapis.GoogleUtils.MAJOR_VERSION == 1 &&
        (com.google.api.client.googleapis.GoogleUtils.MINOR_VERSION >= 32 ||
        (com.google.api.client.googleapis.GoogleUtils.MINOR_VERSION == 31 &&
        com.google.api.client.googleapis.GoogleUtils.BUGFIX_VERSION >= 1))) ||
        com.google.api.client.googleapis.GoogleUtils.MAJOR_VERSION >= 2,
        "You are currently running with version %s of google-api-client. " +
        "You need at least version 1.31.1 of google-api-client to run version " +
        "2.0.0 of the Managed Service for Apache Kafka API library.", com.google.api.client.googleapis.GoogleUtils.VERSION);
  }

  /**
   * The default encoded root URL of the service. This is determined when the library is generated
   * and normally should not be changed.
   *
   * @since 1.7
   */
  public static final String DEFAULT_ROOT_URL = "https://managedkafka.googleapis.com/";

  /**
   * The default encoded mTLS root URL of the service. This is determined when the library is generated
   * and normally should not be changed.
   *
   * @since 1.31
   */
  public static final String DEFAULT_MTLS_ROOT_URL = "https://managedkafka.mtls.googleapis.com/";

  /**
   * The default encoded service path of the service. This is determined when the library is
   * generated and normally should not be changed.
   *
   * @since 1.7
   */
  public static final String DEFAULT_SERVICE_PATH = "";

  /**
   * The default encoded batch path of the service. This is determined when the library is
   * generated and normally should not be changed.
   *
   * @since 1.23
   */
  public static final String DEFAULT_BATCH_PATH = "batch";

  /**
   * The default encoded base URL of the service. This is determined when the library is generated
   * and normally should not be changed.
   */
  public static final String DEFAULT_BASE_URL = DEFAULT_ROOT_URL + DEFAULT_SERVICE_PATH;

  /**
   * Constructor.
   *
   * <p>
   * Use {@link Builder} if you need to specify any of the optional parameters.
   * </p>
   *
   * @param transport HTTP transport, which should normally be:
   *        <ul>
   *        <li>Google App Engine:
   *        {@code com.google.api.client.extensions.appengine.http.UrlFetchTransport}</li>
   *        <li>Android: {@code newCompatibleTransport} from
   *        {@code com.google.api.client.extensions.android.http.AndroidHttp}</li>
   *        <li>Java: {@link com.google.api.client.googleapis.javanet.GoogleNetHttpTransport#newTrustedTransport()}
   *        </li>
   *        </ul>
   * @param jsonFactory JSON factory, which may be:
   *        <ul>
   *        <li>Jackson: {@code com.google.api.client.json.jackson2.JacksonFactory}</li>
   *        <li>Google GSON: {@code com.google.api.client.json.gson.GsonFactory}</li>
   *        <li>Android Honeycomb or higher:
   *        {@code com.google.api.client.extensions.android.json.AndroidJsonFactory}</li>
   *        </ul>
   * @param httpRequestInitializer HTTP request initializer or {@code null} for none
   * @since 1.7
   */
  public ManagedKafka(com.google.api.client.http.HttpTransport transport, com.google.api.client.json.JsonFactory jsonFactory,
      com.google.api.client.http.HttpRequestInitializer httpRequestInitializer) {
    this(new Builder(transport, jsonFactory, httpRequestInitializer));
  }

  /**
   * @param builder builder
   */
  ManagedKafka(Builder builder) {
    super(builder);
  }

  @Override
  protected void initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest<?> httpClientRequest) throws java.io.IOException {
    super.initialize(httpClientRequest);
  }

  /**
   * An accessor for creating requests from the Projects collection.
   *
   * <p>The typical use is:</p>
   * <pre>
   *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
   *   {@code ManagedKafka.Projects.List request = managedkafka.projects().list(parameters ...)}
   * </pre>
   *
   * @return the resource collection
   */
  public Projects projects() {
    return new Projects();
  }

  /**
   * The "projects" collection of methods.
   */
  public class Projects {

    /**
     * An accessor for creating requests from the Locations collection.
     *
     * <p>The typical use is:</p>
     * <pre>
     *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
     *   {@code ManagedKafka.Locations.List request = managedkafka.locations().list(parameters ...)}
     * </pre>
     *
     * @return the resource collection
     */
    public Locations locations() {
      return new Locations();
    }

    /**
     * The "locations" collection of methods.
     */
    public class Locations {

      /**
       * Gets information about a location.
       *
       * Create a request for the method "locations.get".
       *
       * This request holds the parameters needed by the managedkafka server.  After setting any optional
       * parameters, call the {@link Get#execute()} method to invoke the remote operation.
       *
       * @param name Resource name for the location.
       * @return the request
       */
      public Get get(java.lang.String name) throws java.io.IOException {
        Get result = new Get(name);
        initialize(result);
        return result;
      }

      public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Location> {

        private static final String REST_PATH = "v1/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+$");

        /**
         * Gets information about a location.
         *
         * Create a request for the method "locations.get".
         *
         * This request holds the parameters needed by the the managedkafka server.  After setting any
         * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
         * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Resource name for the location.
         * @since 1.13
         */
        protected Get(java.lang.String name) {
          super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Location.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/locations/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public Get set$Xgafv(java.lang.String $Xgafv) {
          return (Get) super.set$Xgafv($Xgafv);
        }

        @Override
        public Get setAccessToken(java.lang.String accessToken) {
          return (Get) super.setAccessToken(accessToken);
        }

        @Override
        public Get setAlt(java.lang.String alt) {
          return (Get) super.setAlt(alt);
        }

        @Override
        public Get setCallback(java.lang.String callback) {
          return (Get) super.setCallback(callback);
        }

        @Override
        public Get setFields(java.lang.String fields) {
          return (Get) super.setFields(fields);
        }

        @Override
        public Get setKey(java.lang.String key) {
          return (Get) super.setKey(key);
        }

        @Override
        public Get setOauthToken(java.lang.String oauthToken) {
          return (Get) super.setOauthToken(oauthToken);
        }

        @Override
        public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Get) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Get setQuotaUser(java.lang.String quotaUser) {
          return (Get) super.setQuotaUser(quotaUser);
        }

        @Override
        public Get setUploadType(java.lang.String uploadType) {
          return (Get) super.setUploadType(uploadType);
        }

        @Override
        public Get setUploadProtocol(java.lang.String uploadProtocol) {
          return (Get) super.setUploadProtocol(uploadProtocol);
        }

        /** Resource name for the location. */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Resource name for the location.
         */
        public java.lang.String getName() {
          return name;
        }

        /** Resource name for the location. */
        public Get setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/locations/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Get set(String parameterName, Object value) {
          return (Get) super.set(parameterName, value);
        }
      }
      /**
       * Lists information about the supported locations for this service.
       *
       * Create a request for the method "locations.list".
       *
       * This request holds the parameters needed by the managedkafka server.  After setting any optional
       * parameters, call the {@link List#execute()} method to invoke the remote operation.
       *
       * @param name The resource that owns the locations collection, if applicable.
       * @return the request
       */
      public List list(java.lang.String name) throws java.io.IOException {
        List result = new List(name);
        initialize(result);
        return result;
      }

      public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ListLocationsResponse> {

        private static final String REST_PATH = "v1/{+name}/locations";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Lists information about the supported locations for this service.
         *
         * Create a request for the method "locations.list".
         *
         * This request holds the parameters needed by the the managedkafka server.  After setting any
         * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
         * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name The resource that owns the locations collection, if applicable.
         * @since 1.13
         */
        protected List(java.lang.String name) {
          super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ListLocationsResponse.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public List set$Xgafv(java.lang.String $Xgafv) {
          return (List) super.set$Xgafv($Xgafv);
        }

        @Override
        public List setAccessToken(java.lang.String accessToken) {
          return (List) super.setAccessToken(accessToken);
        }

        @Override
        public List setAlt(java.lang.String alt) {
          return (List) super.setAlt(alt);
        }

        @Override
        public List setCallback(java.lang.String callback) {
          return (List) super.setCallback(callback);
        }

        @Override
        public List setFields(java.lang.String fields) {
          return (List) super.setFields(fields);
        }

        @Override
        public List setKey(java.lang.String key) {
          return (List) super.setKey(key);
        }

        @Override
        public List setOauthToken(java.lang.String oauthToken) {
          return (List) super.setOauthToken(oauthToken);
        }

        @Override
        public List setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (List) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public List setQuotaUser(java.lang.String quotaUser) {
          return (List) super.setQuotaUser(quotaUser);
        }

        @Override
        public List setUploadType(java.lang.String uploadType) {
          return (List) super.setUploadType(uploadType);
        }

        @Override
        public List setUploadProtocol(java.lang.String uploadProtocol) {
          return (List) super.setUploadProtocol(uploadProtocol);
        }

        /** The resource that owns the locations collection, if applicable. */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** The resource that owns the locations collection, if applicable.
         */
        public java.lang.String getName() {
          return name;
        }

        /** The resource that owns the locations collection, if applicable. */
        public List setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /**
         * Optional. A list of extra location types that should be used as conditions for
         * controlling the visibility of the locations.
         */
        @com.google.api.client.util.Key
        private java.util.List<java.lang.String> extraLocationTypes;

        /** Optional. A list of extra location types that should be used as conditions for controlling the
       visibility of the locations.
         */
        public java.util.List<java.lang.String> getExtraLocationTypes() {
          return extraLocationTypes;
        }

        /**
         * Optional. A list of extra location types that should be used as conditions for
         * controlling the visibility of the locations.
         */
        public List setExtraLocationTypes(java.util.List<java.lang.String> extraLocationTypes) {
          this.extraLocationTypes = extraLocationTypes;
          return this;
        }

        /**
         * A filter to narrow down results to a preferred subset. The filtering language accepts
         * strings like `"displayName=tokyo"`, and is documented in more detail in
         * [AIP-160](https://google.aip.dev/160).
         */
        @com.google.api.client.util.Key
        private java.lang.String filter;

        /** A filter to narrow down results to a preferred subset. The filtering language accepts strings like
       `"displayName=tokyo"`, and is documented in more detail in [AIP-160](https://google.aip.dev/160).
         */
        public java.lang.String getFilter() {
          return filter;
        }

        /**
         * A filter to narrow down results to a preferred subset. The filtering language accepts
         * strings like `"displayName=tokyo"`, and is documented in more detail in
         * [AIP-160](https://google.aip.dev/160).
         */
        public List setFilter(java.lang.String filter) {
          this.filter = filter;
          return this;
        }

        /** The maximum number of results to return. If not set, the service selects a default. */
        @com.google.api.client.util.Key
        private java.lang.Integer pageSize;

        /** The maximum number of results to return. If not set, the service selects a default.
         */
        public java.lang.Integer getPageSize() {
          return pageSize;
        }

        /** The maximum number of results to return. If not set, the service selects a default. */
        public List setPageSize(java.lang.Integer pageSize) {
          this.pageSize = pageSize;
          return this;
        }

        /**
         * A page token received from the `next_page_token` field in the response. Send that page
         * token to receive the subsequent page.
         */
        @com.google.api.client.util.Key
        private java.lang.String pageToken;

        /** A page token received from the `next_page_token` field in the response. Send that page token to
       receive the subsequent page.
         */
        public java.lang.String getPageToken() {
          return pageToken;
        }

        /**
         * A page token received from the `next_page_token` field in the response. Send that page
         * token to receive the subsequent page.
         */
        public List setPageToken(java.lang.String pageToken) {
          this.pageToken = pageToken;
          return this;
        }

        @Override
        public List set(String parameterName, Object value) {
          return (List) super.set(parameterName, value);
        }
      }

      /**
       * An accessor for creating requests from the Clusters collection.
       *
       * <p>The typical use is:</p>
       * <pre>
       *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
       *   {@code ManagedKafka.Clusters.List request = managedkafka.clusters().list(parameters ...)}
       * </pre>
       *
       * @return the resource collection
       */
      public Clusters clusters() {
        return new Clusters();
      }

      /**
       * The "clusters" collection of methods.
       */
      public class Clusters {

        /**
         * Creates a new cluster in a given project and location.
         *
         * Create a request for the method "clusters.create".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Create#execute()} method to invoke the remote operation.
         *
         * @param parent Required. The parent region in which to create the cluster. Structured like
         *        `projects/{project}/locations/{location}`.
         * @param content the {@link com.google.api.services.managedkafka.v1.model.Cluster}
         * @return the request
         */
        public Create create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.Cluster content) throws java.io.IOException {
          Create result = new Create(parent, content);
          initialize(result);
          return result;
        }

        public class Create extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Operation> {

          private static final String REST_PATH = "v1/{+parent}/clusters";

          private final java.util.regex.Pattern PARENT_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+$");

          /**
           * Creates a new cluster in a given project and location.
           *
           * Create a request for the method "clusters.create".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
           * <p> {@link
           * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
           * be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param parent Required. The parent region in which to create the cluster. Structured like
         *        `projects/{project}/locations/{location}`.
           * @param content the {@link com.google.api.services.managedkafka.v1.model.Cluster}
           * @since 1.13
           */
          protected Create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.Cluster content) {
            super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Operation.class);
            this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
          }

          @Override
          public Create set$Xgafv(java.lang.String $Xgafv) {
            return (Create) super.set$Xgafv($Xgafv);
          }

          @Override
          public Create setAccessToken(java.lang.String accessToken) {
            return (Create) super.setAccessToken(accessToken);
          }

          @Override
          public Create setAlt(java.lang.String alt) {
            return (Create) super.setAlt(alt);
          }

          @Override
          public Create setCallback(java.lang.String callback) {
            return (Create) super.setCallback(callback);
          }

          @Override
          public Create setFields(java.lang.String fields) {
            return (Create) super.setFields(fields);
          }

          @Override
          public Create setKey(java.lang.String key) {
            return (Create) super.setKey(key);
          }

          @Override
          public Create setOauthToken(java.lang.String oauthToken) {
            return (Create) super.setOauthToken(oauthToken);
          }

          @Override
          public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Create) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Create setQuotaUser(java.lang.String quotaUser) {
            return (Create) super.setQuotaUser(quotaUser);
          }

          @Override
          public Create setUploadType(java.lang.String uploadType) {
            return (Create) super.setUploadType(uploadType);
          }

          @Override
          public Create setUploadProtocol(java.lang.String uploadProtocol) {
            return (Create) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Required. The parent region in which to create the cluster. Structured like
           * `projects/{project}/locations/{location}`.
           */
          @com.google.api.client.util.Key
          private java.lang.String parent;

          /** Required. The parent region in which to create the cluster. Structured like
         `projects/{project}/locations/{location}`.
           */
          public java.lang.String getParent() {
            return parent;
          }

          /**
           * Required. The parent region in which to create the cluster. Structured like
           * `projects/{project}/locations/{location}`.
           */
          public Create setParent(java.lang.String parent) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
            this.parent = parent;
            return this;
          }

          /**
           * Required. The ID to use for the cluster, which will become the final component of the
           * cluster's name. The ID must be 1-63 characters long, and match the regular expression
           * `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value is structured like:
           * `my-cluster-id`.
           */
          @com.google.api.client.util.Key
          private java.lang.String clusterId;

          /** Required. The ID to use for the cluster, which will become the final component of the cluster's
         name. The ID must be 1-63 characters long, and match the regular expression
         `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value is structured like: `my-cluster-
         id`.
           */
          public java.lang.String getClusterId() {
            return clusterId;
          }

          /**
           * Required. The ID to use for the cluster, which will become the final component of the
           * cluster's name. The ID must be 1-63 characters long, and match the regular expression
           * `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value is structured like:
           * `my-cluster-id`.
           */
          public Create setClusterId(java.lang.String clusterId) {
            this.clusterId = clusterId;
            return this;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          @com.google.api.client.util.Key
          private java.lang.String requestId;

          /** Optional. An optional request ID to identify requests. Specify a unique request ID to avoid
         duplication of requests. If a request times out or fails, retrying with the same ID allows the
         server to recognize the previous attempt. For at least 60 minutes, the server ignores duplicate
         requests bearing the same ID. For example, consider a situation where you make an initial request
         and the request times out. If you make the request again with the same request ID within 60 minutes
         of the last request, the server checks if an original operation with the same request ID was
         received. If so, the server ignores the second request. The request ID must be a valid UUID. A zero
         UUID is not supported (00000000-0000-0000-0000-000000000000).
           */
          public java.lang.String getRequestId() {
            return requestId;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          public Create setRequestId(java.lang.String requestId) {
            this.requestId = requestId;
            return this;
          }

          @Override
          public Create set(String parameterName, Object value) {
            return (Create) super.set(parameterName, value);
          }
        }
        /**
         * Deletes a single cluster.
         *
         * Create a request for the method "clusters.delete".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
         *
         * @param name Required. The name of the cluster to delete.
         * @return the request
         */
        public Delete delete(java.lang.String name) throws java.io.IOException {
          Delete result = new Delete(name);
          initialize(result);
          return result;
        }

        public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Operation> {

          private static final String REST_PATH = "v1/{+name}";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");

          /**
           * Deletes a single cluster.
           *
           * Create a request for the method "clusters.delete".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
           * <p> {@link
           * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
           * be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name Required. The name of the cluster to delete.
           * @since 1.13
           */
          protected Delete(java.lang.String name) {
            super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Operation.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
            }
          }

          @Override
          public Delete set$Xgafv(java.lang.String $Xgafv) {
            return (Delete) super.set$Xgafv($Xgafv);
          }

          @Override
          public Delete setAccessToken(java.lang.String accessToken) {
            return (Delete) super.setAccessToken(accessToken);
          }

          @Override
          public Delete setAlt(java.lang.String alt) {
            return (Delete) super.setAlt(alt);
          }

          @Override
          public Delete setCallback(java.lang.String callback) {
            return (Delete) super.setCallback(callback);
          }

          @Override
          public Delete setFields(java.lang.String fields) {
            return (Delete) super.setFields(fields);
          }

          @Override
          public Delete setKey(java.lang.String key) {
            return (Delete) super.setKey(key);
          }

          @Override
          public Delete setOauthToken(java.lang.String oauthToken) {
            return (Delete) super.setOauthToken(oauthToken);
          }

          @Override
          public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Delete) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Delete setQuotaUser(java.lang.String quotaUser) {
            return (Delete) super.setQuotaUser(quotaUser);
          }

          @Override
          public Delete setUploadType(java.lang.String uploadType) {
            return (Delete) super.setUploadType(uploadType);
          }

          @Override
          public Delete setUploadProtocol(java.lang.String uploadProtocol) {
            return (Delete) super.setUploadProtocol(uploadProtocol);
          }

          /** Required. The name of the cluster to delete. */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** Required. The name of the cluster to delete.
           */
          public java.lang.String getName() {
            return name;
          }

          /** Required. The name of the cluster to delete. */
          public Delete setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
            }
            this.name = name;
            return this;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          @com.google.api.client.util.Key
          private java.lang.String requestId;

          /** Optional. An optional request ID to identify requests. Specify a unique request ID to avoid
         duplication of requests. If a request times out or fails, retrying with the same ID allows the
         server to recognize the previous attempt. For at least 60 minutes, the server ignores duplicate
         requests bearing the same ID. For example, consider a situation where you make an initial request
         and the request times out. If you make the request again with the same request ID within 60 minutes
         of the last request, the server checks if an original operation with the same request ID was
         received. If so, the server ignores the second request. The request ID must be a valid UUID. A zero
         UUID is not supported (00000000-0000-0000-0000-000000000000).
           */
          public java.lang.String getRequestId() {
            return requestId;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          public Delete setRequestId(java.lang.String requestId) {
            this.requestId = requestId;
            return this;
          }

          @Override
          public Delete set(String parameterName, Object value) {
            return (Delete) super.set(parameterName, value);
          }
        }
        /**
         * Returns the properties of a single cluster.
         *
         * Create a request for the method "clusters.get".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Get#execute()} method to invoke the remote operation.
         *
         * @param name Required. The name of the cluster whose configuration to return.
         * @return the request
         */
        public Get get(java.lang.String name) throws java.io.IOException {
          Get result = new Get(name);
          initialize(result);
          return result;
        }

        public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Cluster> {

          private static final String REST_PATH = "v1/{+name}";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");

          /**
           * Returns the properties of a single cluster.
           *
           * Create a request for the method "clusters.get".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
           * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
           * must be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name Required. The name of the cluster whose configuration to return.
           * @since 1.13
           */
          protected Get(java.lang.String name) {
            super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Cluster.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
            }
          }

          @Override
          public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
            return super.executeUsingHead();
          }

          @Override
          public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
            return super.buildHttpRequestUsingHead();
          }

          @Override
          public Get set$Xgafv(java.lang.String $Xgafv) {
            return (Get) super.set$Xgafv($Xgafv);
          }

          @Override
          public Get setAccessToken(java.lang.String accessToken) {
            return (Get) super.setAccessToken(accessToken);
          }

          @Override
          public Get setAlt(java.lang.String alt) {
            return (Get) super.setAlt(alt);
          }

          @Override
          public Get setCallback(java.lang.String callback) {
            return (Get) super.setCallback(callback);
          }

          @Override
          public Get setFields(java.lang.String fields) {
            return (Get) super.setFields(fields);
          }

          @Override
          public Get setKey(java.lang.String key) {
            return (Get) super.setKey(key);
          }

          @Override
          public Get setOauthToken(java.lang.String oauthToken) {
            return (Get) super.setOauthToken(oauthToken);
          }

          @Override
          public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Get) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Get setQuotaUser(java.lang.String quotaUser) {
            return (Get) super.setQuotaUser(quotaUser);
          }

          @Override
          public Get setUploadType(java.lang.String uploadType) {
            return (Get) super.setUploadType(uploadType);
          }

          @Override
          public Get setUploadProtocol(java.lang.String uploadProtocol) {
            return (Get) super.setUploadProtocol(uploadProtocol);
          }

          /** Required. The name of the cluster whose configuration to return. */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** Required. The name of the cluster whose configuration to return.
           */
          public java.lang.String getName() {
            return name;
          }

          /** Required. The name of the cluster whose configuration to return. */
          public Get setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
            }
            this.name = name;
            return this;
          }

          @Override
          public Get set(String parameterName, Object value) {
            return (Get) super.set(parameterName, value);
          }
        }
        /**
         * Lists the clusters in a given project and location.
         *
         * Create a request for the method "clusters.list".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link List#execute()} method to invoke the remote operation.
         *
         * @param parent Required. The parent location whose clusters are to be listed. Structured like
         *        `projects/{project}/locations/{location}`.
         * @return the request
         */
        public List list(java.lang.String parent) throws java.io.IOException {
          List result = new List(parent);
          initialize(result);
          return result;
        }

        public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ListClustersResponse> {

          private static final String REST_PATH = "v1/{+parent}/clusters";

          private final java.util.regex.Pattern PARENT_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+$");

          /**
           * Lists the clusters in a given project and location.
           *
           * Create a request for the method "clusters.list".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
           * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
           * must be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param parent Required. The parent location whose clusters are to be listed. Structured like
         *        `projects/{project}/locations/{location}`.
           * @since 1.13
           */
          protected List(java.lang.String parent) {
            super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ListClustersResponse.class);
            this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
          }

          @Override
          public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
            return super.executeUsingHead();
          }

          @Override
          public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
            return super.buildHttpRequestUsingHead();
          }

          @Override
          public List set$Xgafv(java.lang.String $Xgafv) {
            return (List) super.set$Xgafv($Xgafv);
          }

          @Override
          public List setAccessToken(java.lang.String accessToken) {
            return (List) super.setAccessToken(accessToken);
          }

          @Override
          public List setAlt(java.lang.String alt) {
            return (List) super.setAlt(alt);
          }

          @Override
          public List setCallback(java.lang.String callback) {
            return (List) super.setCallback(callback);
          }

          @Override
          public List setFields(java.lang.String fields) {
            return (List) super.setFields(fields);
          }

          @Override
          public List setKey(java.lang.String key) {
            return (List) super.setKey(key);
          }

          @Override
          public List setOauthToken(java.lang.String oauthToken) {
            return (List) super.setOauthToken(oauthToken);
          }

          @Override
          public List setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (List) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public List setQuotaUser(java.lang.String quotaUser) {
            return (List) super.setQuotaUser(quotaUser);
          }

          @Override
          public List setUploadType(java.lang.String uploadType) {
            return (List) super.setUploadType(uploadType);
          }

          @Override
          public List setUploadProtocol(java.lang.String uploadProtocol) {
            return (List) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Required. The parent location whose clusters are to be listed. Structured like
           * `projects/{project}/locations/{location}`.
           */
          @com.google.api.client.util.Key
          private java.lang.String parent;

          /** Required. The parent location whose clusters are to be listed. Structured like
         `projects/{project}/locations/{location}`.
           */
          public java.lang.String getParent() {
            return parent;
          }

          /**
           * Required. The parent location whose clusters are to be listed. Structured like
           * `projects/{project}/locations/{location}`.
           */
          public List setParent(java.lang.String parent) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
            this.parent = parent;
            return this;
          }

          /** Optional. Filter expression for the result. */
          @com.google.api.client.util.Key
          private java.lang.String filter;

          /** Optional. Filter expression for the result.
           */
          public java.lang.String getFilter() {
            return filter;
          }

          /** Optional. Filter expression for the result. */
          public List setFilter(java.lang.String filter) {
            this.filter = filter;
            return this;
          }

          /** Optional. Order by fields for the result. */
          @com.google.api.client.util.Key
          private java.lang.String orderBy;

          /** Optional. Order by fields for the result.
           */
          public java.lang.String getOrderBy() {
            return orderBy;
          }

          /** Optional. Order by fields for the result. */
          public List setOrderBy(java.lang.String orderBy) {
            this.orderBy = orderBy;
            return this;
          }

          /**
           * Optional. The maximum number of clusters to return. The service may return fewer than
           * this value. If unspecified, server will pick an appropriate default.
           */
          @com.google.api.client.util.Key
          private java.lang.Integer pageSize;

          /** Optional. The maximum number of clusters to return. The service may return fewer than this value.
         If unspecified, server will pick an appropriate default.
           */
          public java.lang.Integer getPageSize() {
            return pageSize;
          }

          /**
           * Optional. The maximum number of clusters to return. The service may return fewer than
           * this value. If unspecified, server will pick an appropriate default.
           */
          public List setPageSize(java.lang.Integer pageSize) {
            this.pageSize = pageSize;
            return this;
          }

          /**
           * Optional. A page token, received from a previous `ListClusters` call. Provide this to
           * retrieve the subsequent page. When paginating, all other parameters provided to
           * `ListClusters` must match the call that provided the page token.
           */
          @com.google.api.client.util.Key
          private java.lang.String pageToken;

          /** Optional. A page token, received from a previous `ListClusters` call. Provide this to retrieve the
         subsequent page. When paginating, all other parameters provided to `ListClusters` must match the
         call that provided the page token.
           */
          public java.lang.String getPageToken() {
            return pageToken;
          }

          /**
           * Optional. A page token, received from a previous `ListClusters` call. Provide this to
           * retrieve the subsequent page. When paginating, all other parameters provided to
           * `ListClusters` must match the call that provided the page token.
           */
          public List setPageToken(java.lang.String pageToken) {
            this.pageToken = pageToken;
            return this;
          }

          @Override
          public List set(String parameterName, Object value) {
            return (List) super.set(parameterName, value);
          }
        }
        /**
         * Updates the properties of a single cluster.
         *
         * Create a request for the method "clusters.patch".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Patch#execute()} method to invoke the remote operation.
         *
         * @param name Identifier. The name of the cluster. Structured like:
         *        projects/{project_number}/locations/{location}/clusters/{cluster_id}
         * @param content the {@link com.google.api.services.managedkafka.v1.model.Cluster}
         * @return the request
         */
        public Patch patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.Cluster content) throws java.io.IOException {
          Patch result = new Patch(name, content);
          initialize(result);
          return result;
        }

        public class Patch extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Operation> {

          private static final String REST_PATH = "v1/{+name}";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");

          /**
           * Updates the properties of a single cluster.
           *
           * Create a request for the method "clusters.patch".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Patch#execute()} method to invoke the remote operation.
           * <p> {@link
           * Patch#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
           * be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name Identifier. The name of the cluster. Structured like:
         *        projects/{project_number}/locations/{location}/clusters/{cluster_id}
           * @param content the {@link com.google.api.services.managedkafka.v1.model.Cluster}
           * @since 1.13
           */
          protected Patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.Cluster content) {
            super(ManagedKafka.this, "PATCH", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Operation.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
            }
          }

          @Override
          public Patch set$Xgafv(java.lang.String $Xgafv) {
            return (Patch) super.set$Xgafv($Xgafv);
          }

          @Override
          public Patch setAccessToken(java.lang.String accessToken) {
            return (Patch) super.setAccessToken(accessToken);
          }

          @Override
          public Patch setAlt(java.lang.String alt) {
            return (Patch) super.setAlt(alt);
          }

          @Override
          public Patch setCallback(java.lang.String callback) {
            return (Patch) super.setCallback(callback);
          }

          @Override
          public Patch setFields(java.lang.String fields) {
            return (Patch) super.setFields(fields);
          }

          @Override
          public Patch setKey(java.lang.String key) {
            return (Patch) super.setKey(key);
          }

          @Override
          public Patch setOauthToken(java.lang.String oauthToken) {
            return (Patch) super.setOauthToken(oauthToken);
          }

          @Override
          public Patch setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Patch) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Patch setQuotaUser(java.lang.String quotaUser) {
            return (Patch) super.setQuotaUser(quotaUser);
          }

          @Override
          public Patch setUploadType(java.lang.String uploadType) {
            return (Patch) super.setUploadType(uploadType);
          }

          @Override
          public Patch setUploadProtocol(java.lang.String uploadProtocol) {
            return (Patch) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Identifier. The name of the cluster. Structured like:
           * projects/{project_number}/locations/{location}/clusters/{cluster_id}
           */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** Identifier. The name of the cluster. Structured like:
         projects/{project_number}/locations/{location}/clusters/{cluster_id}
           */
          public java.lang.String getName() {
            return name;
          }

          /**
           * Identifier. The name of the cluster. Structured like:
           * projects/{project_number}/locations/{location}/clusters/{cluster_id}
           */
          public Patch setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
            }
            this.name = name;
            return this;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          @com.google.api.client.util.Key
          private java.lang.String requestId;

          /** Optional. An optional request ID to identify requests. Specify a unique request ID to avoid
         duplication of requests. If a request times out or fails, retrying with the same ID allows the
         server to recognize the previous attempt. For at least 60 minutes, the server ignores duplicate
         requests bearing the same ID. For example, consider a situation where you make an initial request
         and the request times out. If you make the request again with the same request ID within 60 minutes
         of the last request, the server checks if an original operation with the same request ID was
         received. If so, the server ignores the second request. The request ID must be a valid UUID. A zero
         UUID is not supported (00000000-0000-0000-0000-000000000000).
           */
          public java.lang.String getRequestId() {
            return requestId;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          public Patch setRequestId(java.lang.String requestId) {
            this.requestId = requestId;
            return this;
          }

          /**
           * Required. Field mask is used to specify the fields to be overwritten in the cluster
           * resource by the update. The fields specified in the update_mask are relative to the
           * resource, not the full request. A field will be overwritten if it is in the mask. The
           * mask is required and a value of * will update all fields.
           */
          @com.google.api.client.util.Key
          private String updateMask;

          /** Required. Field mask is used to specify the fields to be overwritten in the cluster resource by the
         update. The fields specified in the update_mask are relative to the resource, not the full request.
         A field will be overwritten if it is in the mask. The mask is required and a value of * will update
         all fields.
           */
          public String getUpdateMask() {
            return updateMask;
          }

          /**
           * Required. Field mask is used to specify the fields to be overwritten in the cluster
           * resource by the update. The fields specified in the update_mask are relative to the
           * resource, not the full request. A field will be overwritten if it is in the mask. The
           * mask is required and a value of * will update all fields.
           */
          public Patch setUpdateMask(String updateMask) {
            this.updateMask = updateMask;
            return this;
          }

          @Override
          public Patch set(String parameterName, Object value) {
            return (Patch) super.set(parameterName, value);
          }
        }

        /**
         * An accessor for creating requests from the Acls collection.
         *
         * <p>The typical use is:</p>
         * <pre>
         *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
         *   {@code ManagedKafka.Acls.List request = managedkafka.acls().list(parameters ...)}
         * </pre>
         *
         * @return the resource collection
         */
        public Acls acls() {
          return new Acls();
        }

        /**
         * The "acls" collection of methods.
         */
        public class Acls {

          /**
           * Incremental update: Adds an acl entry to an acl. Creates the acl if it does not exist yet.
           *
           * Create a request for the method "acls.addAclEntry".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link AddAclEntry#execute()} method to invoke the remote operation.
           *
           * @param acl Required. The name of the acl to add the acl entry to. Structured like:
           *        `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure
           *        of `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of
           *        the acl. See `Acl.name` for details.
           * @param content the {@link com.google.api.services.managedkafka.v1.model.AclEntry}
           * @return the request
           */
          public AddAclEntry addAclEntry(java.lang.String acl, com.google.api.services.managedkafka.v1.model.AclEntry content) throws java.io.IOException {
            AddAclEntry result = new AddAclEntry(acl, content);
            initialize(result);
            return result;
          }

          public class AddAclEntry extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.AddAclEntryResponse> {

            private static final String REST_PATH = "v1/{+acl}:addAclEntry";

            private final java.util.regex.Pattern ACL_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");

            /**
             * Incremental update: Adds an acl entry to an acl. Creates the acl if it does not exist yet.
             *
             * Create a request for the method "acls.addAclEntry".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link AddAclEntry#execute()} method to invoke the remote
             * operation. <p> {@link
             * AddAclEntry#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param acl Required. The name of the acl to add the acl entry to. Structured like:
           *        `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure
           *        of `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of
           *        the acl. See `Acl.name` for details.
             * @param content the {@link com.google.api.services.managedkafka.v1.model.AclEntry}
             * @since 1.13
             */
            protected AddAclEntry(java.lang.String acl, com.google.api.services.managedkafka.v1.model.AclEntry content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.AddAclEntryResponse.class);
              this.acl = com.google.api.client.util.Preconditions.checkNotNull(acl, "Required parameter acl must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(ACL_PATTERN.matcher(acl).matches(),
                    "Parameter acl must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
            }

            @Override
            public AddAclEntry set$Xgafv(java.lang.String $Xgafv) {
              return (AddAclEntry) super.set$Xgafv($Xgafv);
            }

            @Override
            public AddAclEntry setAccessToken(java.lang.String accessToken) {
              return (AddAclEntry) super.setAccessToken(accessToken);
            }

            @Override
            public AddAclEntry setAlt(java.lang.String alt) {
              return (AddAclEntry) super.setAlt(alt);
            }

            @Override
            public AddAclEntry setCallback(java.lang.String callback) {
              return (AddAclEntry) super.setCallback(callback);
            }

            @Override
            public AddAclEntry setFields(java.lang.String fields) {
              return (AddAclEntry) super.setFields(fields);
            }

            @Override
            public AddAclEntry setKey(java.lang.String key) {
              return (AddAclEntry) super.setKey(key);
            }

            @Override
            public AddAclEntry setOauthToken(java.lang.String oauthToken) {
              return (AddAclEntry) super.setOauthToken(oauthToken);
            }

            @Override
            public AddAclEntry setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (AddAclEntry) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public AddAclEntry setQuotaUser(java.lang.String quotaUser) {
              return (AddAclEntry) super.setQuotaUser(quotaUser);
            }

            @Override
            public AddAclEntry setUploadType(java.lang.String uploadType) {
              return (AddAclEntry) super.setUploadType(uploadType);
            }

            @Override
            public AddAclEntry setUploadProtocol(java.lang.String uploadProtocol) {
              return (AddAclEntry) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the acl to add the acl entry to. Structured like:
             * `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. See `Acl.name` for details.
             */
            @com.google.api.client.util.Key
            private java.lang.String acl;

            /** Required. The name of the acl to add the acl entry to. Structured like:
           `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure of
           `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of the acl. See
           `Acl.name` for details.
             */
            public java.lang.String getAcl() {
              return acl;
            }

            /**
             * Required. The name of the acl to add the acl entry to. Structured like:
             * `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. See `Acl.name` for details.
             */
            public AddAclEntry setAcl(java.lang.String acl) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(ACL_PATTERN.matcher(acl).matches(),
                    "Parameter acl must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
              this.acl = acl;
              return this;
            }

            @Override
            public AddAclEntry set(String parameterName, Object value) {
              return (AddAclEntry) super.set(parameterName, value);
            }
          }
          /**
           * Creates a new acl in the given project, location, and cluster.
           *
           * Create a request for the method "acls.create".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Create#execute()} method to invoke the remote operation.
           *
           * @param parent Required. The parent cluster in which to create the acl. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
           * @param content the {@link com.google.api.services.managedkafka.v1.model.Acl}
           * @return the request
           */
          public Create create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.Acl content) throws java.io.IOException {
            Create result = new Create(parent, content);
            initialize(result);
            return result;
          }

          public class Create extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Acl> {

            private static final String REST_PATH = "v1/{+parent}/acls";

            private final java.util.regex.Pattern PARENT_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");

            /**
             * Creates a new acl in the given project, location, and cluster.
             *
             * Create a request for the method "acls.create".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
             * <p> {@link
             * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param parent Required. The parent cluster in which to create the acl. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
             * @param content the {@link com.google.api.services.managedkafka.v1.model.Acl}
             * @since 1.13
             */
            protected Create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.Acl content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Acl.class);
              this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
            }

            @Override
            public Create set$Xgafv(java.lang.String $Xgafv) {
              return (Create) super.set$Xgafv($Xgafv);
            }

            @Override
            public Create setAccessToken(java.lang.String accessToken) {
              return (Create) super.setAccessToken(accessToken);
            }

            @Override
            public Create setAlt(java.lang.String alt) {
              return (Create) super.setAlt(alt);
            }

            @Override
            public Create setCallback(java.lang.String callback) {
              return (Create) super.setCallback(callback);
            }

            @Override
            public Create setFields(java.lang.String fields) {
              return (Create) super.setFields(fields);
            }

            @Override
            public Create setKey(java.lang.String key) {
              return (Create) super.setKey(key);
            }

            @Override
            public Create setOauthToken(java.lang.String oauthToken) {
              return (Create) super.setOauthToken(oauthToken);
            }

            @Override
            public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Create) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Create setQuotaUser(java.lang.String quotaUser) {
              return (Create) super.setQuotaUser(quotaUser);
            }

            @Override
            public Create setUploadType(java.lang.String uploadType) {
              return (Create) super.setUploadType(uploadType);
            }

            @Override
            public Create setUploadProtocol(java.lang.String uploadProtocol) {
              return (Create) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The parent cluster in which to create the acl. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String parent;

            /** Required. The parent cluster in which to create the acl. Structured like
           `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public java.lang.String getParent() {
              return parent;
            }

            /**
             * Required. The parent cluster in which to create the acl. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public Create setParent(java.lang.String parent) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
              this.parent = parent;
              return this;
            }

            /**
             * Required. The ID to use for the acl, which will become the final component of the
             * acl's name. The structure of `acl_id` defines the Resource Pattern (resource_type,
             * resource_name, pattern_type) of the acl. `acl_id` is structured like one of the
             * following: For acls on the cluster: `cluster` For acls on a single resource within
             * the cluster: `topic/{resource_name}` `consumerGroup/{resource_name}`
             * `transactionalId/{resource_name}` For acls on all resources that match a prefix:
             * `topicPrefixed/{resource_name}` `consumerGroupPrefixed/{resource_name}`
             * `transactionalIdPrefixed/{resource_name}` For acls on all resources of a given type
             * (i.e. the wildcard literal "*"): `allTopics` (represents `topic`) `allConsumerGroups`
             * (represents `consumerGroup`) `allTransactionalIds` (represents `transactionalId`)
             */
            @com.google.api.client.util.Key
            private java.lang.String aclId;

            /** Required. The ID to use for the acl, which will become the final component of the acl's name. The
           structure of `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of
           the acl. `acl_id` is structured like one of the following: For acls on the cluster: `cluster` For
           acls on a single resource within the cluster: `topic/{resource_name}`
           `consumerGroup/{resource_name}` `transactionalId/{resource_name}` For acls on all resources that
           match a prefix: `topicPrefixed/{resource_name}` `consumerGroupPrefixed/{resource_name}`
           `transactionalIdPrefixed/{resource_name}` For acls on all resources of a given type (i.e. the
           wildcard literal "*"): `allTopics` (represents `topic`) `allConsumerGroups` (represents
           `consumerGroup`) `allTransactionalIds` (represents `transactionalId`)
             */
            public java.lang.String getAclId() {
              return aclId;
            }

            /**
             * Required. The ID to use for the acl, which will become the final component of the
             * acl's name. The structure of `acl_id` defines the Resource Pattern (resource_type,
             * resource_name, pattern_type) of the acl. `acl_id` is structured like one of the
             * following: For acls on the cluster: `cluster` For acls on a single resource within
             * the cluster: `topic/{resource_name}` `consumerGroup/{resource_name}`
             * `transactionalId/{resource_name}` For acls on all resources that match a prefix:
             * `topicPrefixed/{resource_name}` `consumerGroupPrefixed/{resource_name}`
             * `transactionalIdPrefixed/{resource_name}` For acls on all resources of a given type
             * (i.e. the wildcard literal "*"): `allTopics` (represents `topic`) `allConsumerGroups`
             * (represents `consumerGroup`) `allTransactionalIds` (represents `transactionalId`)
             */
            public Create setAclId(java.lang.String aclId) {
              this.aclId = aclId;
              return this;
            }

            @Override
            public Create set(String parameterName, Object value) {
              return (Create) super.set(parameterName, value);
            }
          }
          /**
           * Deletes an acl.
           *
           * Create a request for the method "acls.delete".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the acl to delete. Structured like:
           *        `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure
           *        of `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of
           *        the acl. See `Acl.name` for details.
           * @return the request
           */
          public Delete delete(java.lang.String name) throws java.io.IOException {
            Delete result = new Delete(name);
            initialize(result);
            return result;
          }

          public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Empty> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");

            /**
             * Deletes an acl.
             *
             * Create a request for the method "acls.delete".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
             * <p> {@link
             * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the acl to delete. Structured like:
           *        `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure
           *        of `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of
           *        the acl. See `Acl.name` for details.
             * @since 1.13
             */
            protected Delete(java.lang.String name) {
              super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Empty.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
            }

            @Override
            public Delete set$Xgafv(java.lang.String $Xgafv) {
              return (Delete) super.set$Xgafv($Xgafv);
            }

            @Override
            public Delete setAccessToken(java.lang.String accessToken) {
              return (Delete) super.setAccessToken(accessToken);
            }

            @Override
            public Delete setAlt(java.lang.String alt) {
              return (Delete) super.setAlt(alt);
            }

            @Override
            public Delete setCallback(java.lang.String callback) {
              return (Delete) super.setCallback(callback);
            }

            @Override
            public Delete setFields(java.lang.String fields) {
              return (Delete) super.setFields(fields);
            }

            @Override
            public Delete setKey(java.lang.String key) {
              return (Delete) super.setKey(key);
            }

            @Override
            public Delete setOauthToken(java.lang.String oauthToken) {
              return (Delete) super.setOauthToken(oauthToken);
            }

            @Override
            public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Delete) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Delete setQuotaUser(java.lang.String quotaUser) {
              return (Delete) super.setQuotaUser(quotaUser);
            }

            @Override
            public Delete setUploadType(java.lang.String uploadType) {
              return (Delete) super.setUploadType(uploadType);
            }

            @Override
            public Delete setUploadProtocol(java.lang.String uploadProtocol) {
              return (Delete) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the acl to delete. Structured like:
             * `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. See `Acl.name` for details.
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the acl to delete. Structured like:
           `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure of
           `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of the acl. See
           `Acl.name` for details.
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the acl to delete. Structured like:
             * `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. See `Acl.name` for details.
             */
            public Delete setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Delete set(String parameterName, Object value) {
              return (Delete) super.set(parameterName, value);
            }
          }
          /**
           * Returns the properties of a single acl.
           *
           * Create a request for the method "acls.get".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Get#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the acl to return. Structured like:
           *        `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure
           *        of `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of
           *        the acl. See `Acl.name` for details.
           * @return the request
           */
          public Get get(java.lang.String name) throws java.io.IOException {
            Get result = new Get(name);
            initialize(result);
            return result;
          }

          public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Acl> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");

            /**
             * Returns the properties of a single acl.
             *
             * Create a request for the method "acls.get".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
             * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the acl to return. Structured like:
           *        `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure
           *        of `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of
           *        the acl. See `Acl.name` for details.
             * @since 1.13
             */
            protected Get(java.lang.String name) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Acl.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public Get set$Xgafv(java.lang.String $Xgafv) {
              return (Get) super.set$Xgafv($Xgafv);
            }

            @Override
            public Get setAccessToken(java.lang.String accessToken) {
              return (Get) super.setAccessToken(accessToken);
            }

            @Override
            public Get setAlt(java.lang.String alt) {
              return (Get) super.setAlt(alt);
            }

            @Override
            public Get setCallback(java.lang.String callback) {
              return (Get) super.setCallback(callback);
            }

            @Override
            public Get setFields(java.lang.String fields) {
              return (Get) super.setFields(fields);
            }

            @Override
            public Get setKey(java.lang.String key) {
              return (Get) super.setKey(key);
            }

            @Override
            public Get setOauthToken(java.lang.String oauthToken) {
              return (Get) super.setOauthToken(oauthToken);
            }

            @Override
            public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Get) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Get setQuotaUser(java.lang.String quotaUser) {
              return (Get) super.setQuotaUser(quotaUser);
            }

            @Override
            public Get setUploadType(java.lang.String uploadType) {
              return (Get) super.setUploadType(uploadType);
            }

            @Override
            public Get setUploadProtocol(java.lang.String uploadProtocol) {
              return (Get) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the acl to return. Structured like:
             * `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. See `Acl.name` for details.
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the acl to return. Structured like:
           `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure of
           `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of the acl. See
           `Acl.name` for details.
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the acl to return. Structured like:
             * `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. See `Acl.name` for details.
             */
            public Get setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Get set(String parameterName, Object value) {
              return (Get) super.set(parameterName, value);
            }
          }
          /**
           * Lists the acls in a given cluster.
           *
           * Create a request for the method "acls.list".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link List#execute()} method to invoke the remote operation.
           *
           * @param parent Required. The parent cluster whose acls are to be listed. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
           * @return the request
           */
          public List list(java.lang.String parent) throws java.io.IOException {
            List result = new List(parent);
            initialize(result);
            return result;
          }

          public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ListAclsResponse> {

            private static final String REST_PATH = "v1/{+parent}/acls";

            private final java.util.regex.Pattern PARENT_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");

            /**
             * Lists the acls in a given cluster.
             *
             * Create a request for the method "acls.list".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
             * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param parent Required. The parent cluster whose acls are to be listed. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
             * @since 1.13
             */
            protected List(java.lang.String parent) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ListAclsResponse.class);
              this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public List set$Xgafv(java.lang.String $Xgafv) {
              return (List) super.set$Xgafv($Xgafv);
            }

            @Override
            public List setAccessToken(java.lang.String accessToken) {
              return (List) super.setAccessToken(accessToken);
            }

            @Override
            public List setAlt(java.lang.String alt) {
              return (List) super.setAlt(alt);
            }

            @Override
            public List setCallback(java.lang.String callback) {
              return (List) super.setCallback(callback);
            }

            @Override
            public List setFields(java.lang.String fields) {
              return (List) super.setFields(fields);
            }

            @Override
            public List setKey(java.lang.String key) {
              return (List) super.setKey(key);
            }

            @Override
            public List setOauthToken(java.lang.String oauthToken) {
              return (List) super.setOauthToken(oauthToken);
            }

            @Override
            public List setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (List) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public List setQuotaUser(java.lang.String quotaUser) {
              return (List) super.setQuotaUser(quotaUser);
            }

            @Override
            public List setUploadType(java.lang.String uploadType) {
              return (List) super.setUploadType(uploadType);
            }

            @Override
            public List setUploadProtocol(java.lang.String uploadProtocol) {
              return (List) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The parent cluster whose acls are to be listed. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String parent;

            /** Required. The parent cluster whose acls are to be listed. Structured like
           `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public java.lang.String getParent() {
              return parent;
            }

            /**
             * Required. The parent cluster whose acls are to be listed. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public List setParent(java.lang.String parent) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
              this.parent = parent;
              return this;
            }

            /**
             * Optional. The maximum number of acls to return. The service may return fewer than
             * this value. If unset or zero, all acls for the parent is returned.
             */
            @com.google.api.client.util.Key
            private java.lang.Integer pageSize;

            /** Optional. The maximum number of acls to return. The service may return fewer than this value. If
           unset or zero, all acls for the parent is returned.
             */
            public java.lang.Integer getPageSize() {
              return pageSize;
            }

            /**
             * Optional. The maximum number of acls to return. The service may return fewer than
             * this value. If unset or zero, all acls for the parent is returned.
             */
            public List setPageSize(java.lang.Integer pageSize) {
              this.pageSize = pageSize;
              return this;
            }

            /**
             * Optional. A page token, received from a previous `ListAcls` call. Provide this to
             * retrieve the subsequent page. When paginating, all other parameters provided to
             * `ListAcls` must match the call that provided the page token.
             */
            @com.google.api.client.util.Key
            private java.lang.String pageToken;

            /** Optional. A page token, received from a previous `ListAcls` call. Provide this to retrieve the
           subsequent page. When paginating, all other parameters provided to `ListAcls` must match the call
           that provided the page token.
             */
            public java.lang.String getPageToken() {
              return pageToken;
            }

            /**
             * Optional. A page token, received from a previous `ListAcls` call. Provide this to
             * retrieve the subsequent page. When paginating, all other parameters provided to
             * `ListAcls` must match the call that provided the page token.
             */
            public List setPageToken(java.lang.String pageToken) {
              this.pageToken = pageToken;
              return this;
            }

            @Override
            public List set(String parameterName, Object value) {
              return (List) super.set(parameterName, value);
            }
          }
          /**
           * Updates the properties of a single acl.
           *
           * Create a request for the method "acls.patch".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Patch#execute()} method to invoke the remote operation.
           *
           * @param name Identifier. The name for the acl. Represents a single Resource Pattern. Structured like:
           *        projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id} The structure of
           *        `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of the
           *        acl. `acl_id` is structured like one of the following: For acls on the cluster: `cluster`
           *        For acls on a single resource within the cluster: `topic/{resource_name}`
           *        `consumerGroup/{resource_name}` `transactionalId/{resource_name}` For acls on all
           *        resources that match a prefix: `topicPrefixed/{resource_name}`
           *        `consumerGroupPrefixed/{resource_name}` `transactionalIdPrefixed/{resource_name}` For acls
           *        on all resources of a given type (i.e. the wildcard literal "*"): `allTopics` (represents
           *        `topic`) `allConsumerGroups` (represents `consumerGroup`) `allTransactionalIds`
           *        (represents `transactionalId`)
           * @param content the {@link com.google.api.services.managedkafka.v1.model.Acl}
           * @return the request
           */
          public Patch patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.Acl content) throws java.io.IOException {
            Patch result = new Patch(name, content);
            initialize(result);
            return result;
          }

          public class Patch extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Acl> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");

            /**
             * Updates the properties of a single acl.
             *
             * Create a request for the method "acls.patch".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Patch#execute()} method to invoke the remote operation.
             * <p> {@link
             * Patch#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Identifier. The name for the acl. Represents a single Resource Pattern. Structured like:
           *        projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id} The structure of
           *        `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of the
           *        acl. `acl_id` is structured like one of the following: For acls on the cluster: `cluster`
           *        For acls on a single resource within the cluster: `topic/{resource_name}`
           *        `consumerGroup/{resource_name}` `transactionalId/{resource_name}` For acls on all
           *        resources that match a prefix: `topicPrefixed/{resource_name}`
           *        `consumerGroupPrefixed/{resource_name}` `transactionalIdPrefixed/{resource_name}` For acls
           *        on all resources of a given type (i.e. the wildcard literal "*"): `allTopics` (represents
           *        `topic`) `allConsumerGroups` (represents `consumerGroup`) `allTransactionalIds`
           *        (represents `transactionalId`)
             * @param content the {@link com.google.api.services.managedkafka.v1.model.Acl}
             * @since 1.13
             */
            protected Patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.Acl content) {
              super(ManagedKafka.this, "PATCH", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Acl.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
            }

            @Override
            public Patch set$Xgafv(java.lang.String $Xgafv) {
              return (Patch) super.set$Xgafv($Xgafv);
            }

            @Override
            public Patch setAccessToken(java.lang.String accessToken) {
              return (Patch) super.setAccessToken(accessToken);
            }

            @Override
            public Patch setAlt(java.lang.String alt) {
              return (Patch) super.setAlt(alt);
            }

            @Override
            public Patch setCallback(java.lang.String callback) {
              return (Patch) super.setCallback(callback);
            }

            @Override
            public Patch setFields(java.lang.String fields) {
              return (Patch) super.setFields(fields);
            }

            @Override
            public Patch setKey(java.lang.String key) {
              return (Patch) super.setKey(key);
            }

            @Override
            public Patch setOauthToken(java.lang.String oauthToken) {
              return (Patch) super.setOauthToken(oauthToken);
            }

            @Override
            public Patch setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Patch) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Patch setQuotaUser(java.lang.String quotaUser) {
              return (Patch) super.setQuotaUser(quotaUser);
            }

            @Override
            public Patch setUploadType(java.lang.String uploadType) {
              return (Patch) super.setUploadType(uploadType);
            }

            @Override
            public Patch setUploadProtocol(java.lang.String uploadProtocol) {
              return (Patch) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Identifier. The name for the acl. Represents a single Resource Pattern. Structured
             * like: projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id} The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. `acl_id` is structured like one of the following: For acls
             * on the cluster: `cluster` For acls on a single resource within the cluster:
             * `topic/{resource_name}` `consumerGroup/{resource_name}`
             * `transactionalId/{resource_name}` For acls on all resources that match a prefix:
             * `topicPrefixed/{resource_name}` `consumerGroupPrefixed/{resource_name}`
             * `transactionalIdPrefixed/{resource_name}` For acls on all resources of a given type
             * (i.e. the wildcard literal "*"): `allTopics` (represents `topic`) `allConsumerGroups`
             * (represents `consumerGroup`) `allTransactionalIds` (represents `transactionalId`)
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Identifier. The name for the acl. Represents a single Resource Pattern. Structured like:
           projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id} The structure of `acl_id`
           defines the Resource Pattern (resource_type, resource_name, pattern_type) of the acl. `acl_id` is
           structured like one of the following: For acls on the cluster: `cluster` For acls on a single
           resource within the cluster: `topic/{resource_name}` `consumerGroup/{resource_name}`
           `transactionalId/{resource_name}` For acls on all resources that match a prefix:
           `topicPrefixed/{resource_name}` `consumerGroupPrefixed/{resource_name}`
           `transactionalIdPrefixed/{resource_name}` For acls on all resources of a given type (i.e. the
           wildcard literal "*"): `allTopics` (represents `topic`) `allConsumerGroups` (represents
           `consumerGroup`) `allTransactionalIds` (represents `transactionalId`)
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Identifier. The name for the acl. Represents a single Resource Pattern. Structured
             * like: projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id} The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. `acl_id` is structured like one of the following: For acls
             * on the cluster: `cluster` For acls on a single resource within the cluster:
             * `topic/{resource_name}` `consumerGroup/{resource_name}`
             * `transactionalId/{resource_name}` For acls on all resources that match a prefix:
             * `topicPrefixed/{resource_name}` `consumerGroupPrefixed/{resource_name}`
             * `transactionalIdPrefixed/{resource_name}` For acls on all resources of a given type
             * (i.e. the wildcard literal "*"): `allTopics` (represents `topic`) `allConsumerGroups`
             * (represents `consumerGroup`) `allTransactionalIds` (represents `transactionalId`)
             */
            public Patch setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
              this.name = name;
              return this;
            }

            /**
             * Optional. Field mask is used to specify the fields to be overwritten in the Acl
             * resource by the update. The fields specified in the update_mask are relative to the
             * resource, not the full request. A field will be overwritten if it is in the mask.
             */
            @com.google.api.client.util.Key
            private String updateMask;

            /** Optional. Field mask is used to specify the fields to be overwritten in the Acl resource by the
           update. The fields specified in the update_mask are relative to the resource, not the full request.
           A field will be overwritten if it is in the mask.
             */
            public String getUpdateMask() {
              return updateMask;
            }

            /**
             * Optional. Field mask is used to specify the fields to be overwritten in the Acl
             * resource by the update. The fields specified in the update_mask are relative to the
             * resource, not the full request. A field will be overwritten if it is in the mask.
             */
            public Patch setUpdateMask(String updateMask) {
              this.updateMask = updateMask;
              return this;
            }

            @Override
            public Patch set(String parameterName, Object value) {
              return (Patch) super.set(parameterName, value);
            }
          }
          /**
           * Incremental update: Removes an acl entry from an acl. Deletes the acl if its acl entries become
           * empty (i.e. if the removed entry was the last one in the acl).
           *
           * Create a request for the method "acls.removeAclEntry".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link RemoveAclEntry#execute()} method to invoke the remote operation.
           *
           * @param acl Required. The name of the acl to remove the acl entry from. Structured like:
           *        `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure
           *        of `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of
           *        the acl. See `Acl.name` for details.
           * @param content the {@link com.google.api.services.managedkafka.v1.model.AclEntry}
           * @return the request
           */
          public RemoveAclEntry removeAclEntry(java.lang.String acl, com.google.api.services.managedkafka.v1.model.AclEntry content) throws java.io.IOException {
            RemoveAclEntry result = new RemoveAclEntry(acl, content);
            initialize(result);
            return result;
          }

          public class RemoveAclEntry extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.RemoveAclEntryResponse> {

            private static final String REST_PATH = "v1/{+acl}:removeAclEntry";

            private final java.util.regex.Pattern ACL_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");

            /**
             * Incremental update: Removes an acl entry from an acl. Deletes the acl if its acl entries become
             * empty (i.e. if the removed entry was the last one in the acl).
             *
             * Create a request for the method "acls.removeAclEntry".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link RemoveAclEntry#execute()} method to invoke the remote
             * operation. <p> {@link RemoveAclEntry#initialize(com.google.api.client.googleapis.services.Abstr
             * actGoogleClientRequest)} must be called to initialize this instance immediately after invoking
             * the constructor. </p>
             *
             * @param acl Required. The name of the acl to remove the acl entry from. Structured like:
           *        `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure
           *        of `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of
           *        the acl. See `Acl.name` for details.
             * @param content the {@link com.google.api.services.managedkafka.v1.model.AclEntry}
             * @since 1.13
             */
            protected RemoveAclEntry(java.lang.String acl, com.google.api.services.managedkafka.v1.model.AclEntry content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.RemoveAclEntryResponse.class);
              this.acl = com.google.api.client.util.Preconditions.checkNotNull(acl, "Required parameter acl must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(ACL_PATTERN.matcher(acl).matches(),
                    "Parameter acl must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
            }

            @Override
            public RemoveAclEntry set$Xgafv(java.lang.String $Xgafv) {
              return (RemoveAclEntry) super.set$Xgafv($Xgafv);
            }

            @Override
            public RemoveAclEntry setAccessToken(java.lang.String accessToken) {
              return (RemoveAclEntry) super.setAccessToken(accessToken);
            }

            @Override
            public RemoveAclEntry setAlt(java.lang.String alt) {
              return (RemoveAclEntry) super.setAlt(alt);
            }

            @Override
            public RemoveAclEntry setCallback(java.lang.String callback) {
              return (RemoveAclEntry) super.setCallback(callback);
            }

            @Override
            public RemoveAclEntry setFields(java.lang.String fields) {
              return (RemoveAclEntry) super.setFields(fields);
            }

            @Override
            public RemoveAclEntry setKey(java.lang.String key) {
              return (RemoveAclEntry) super.setKey(key);
            }

            @Override
            public RemoveAclEntry setOauthToken(java.lang.String oauthToken) {
              return (RemoveAclEntry) super.setOauthToken(oauthToken);
            }

            @Override
            public RemoveAclEntry setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (RemoveAclEntry) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public RemoveAclEntry setQuotaUser(java.lang.String quotaUser) {
              return (RemoveAclEntry) super.setQuotaUser(quotaUser);
            }

            @Override
            public RemoveAclEntry setUploadType(java.lang.String uploadType) {
              return (RemoveAclEntry) super.setUploadType(uploadType);
            }

            @Override
            public RemoveAclEntry setUploadProtocol(java.lang.String uploadProtocol) {
              return (RemoveAclEntry) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the acl to remove the acl entry from. Structured like:
             * `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. See `Acl.name` for details.
             */
            @com.google.api.client.util.Key
            private java.lang.String acl;

            /** Required. The name of the acl to remove the acl entry from. Structured like:
           `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure of
           `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of the acl. See
           `Acl.name` for details.
             */
            public java.lang.String getAcl() {
              return acl;
            }

            /**
             * Required. The name of the acl to remove the acl entry from. Structured like:
             * `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. See `Acl.name` for details.
             */
            public RemoveAclEntry setAcl(java.lang.String acl) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(ACL_PATTERN.matcher(acl).matches(),
                    "Parameter acl must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
              this.acl = acl;
              return this;
            }

            @Override
            public RemoveAclEntry set(String parameterName, Object value) {
              return (RemoveAclEntry) super.set(parameterName, value);
            }
          }

        }
        /**
         * An accessor for creating requests from the ConsumerGroups collection.
         *
         * <p>The typical use is:</p>
         * <pre>
         *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
         *   {@code ManagedKafka.ConsumerGroups.List request = managedkafka.consumerGroups().list(parameters ...)}
         * </pre>
         *
         * @return the resource collection
         */
        public ConsumerGroups consumerGroups() {
          return new ConsumerGroups();
        }

        /**
         * The "consumerGroups" collection of methods.
         */
        public class ConsumerGroups {

          /**
           * Deletes a single consumer group.
           *
           * Create a request for the method "consumerGroups.delete".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the consumer group to delete.
           *        `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}
           *        `.
           * @return the request
           */
          public Delete delete(java.lang.String name) throws java.io.IOException {
            Delete result = new Delete(name);
            initialize(result);
            return result;
          }

          public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Empty> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/consumerGroups/.*$");

            /**
             * Deletes a single consumer group.
             *
             * Create a request for the method "consumerGroups.delete".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
             * <p> {@link
             * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the consumer group to delete.
           *        `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}
           *        `.
             * @since 1.13
             */
            protected Delete(java.lang.String name) {
              super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Empty.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/consumerGroups/.*$");
              }
            }

            @Override
            public Delete set$Xgafv(java.lang.String $Xgafv) {
              return (Delete) super.set$Xgafv($Xgafv);
            }

            @Override
            public Delete setAccessToken(java.lang.String accessToken) {
              return (Delete) super.setAccessToken(accessToken);
            }

            @Override
            public Delete setAlt(java.lang.String alt) {
              return (Delete) super.setAlt(alt);
            }

            @Override
            public Delete setCallback(java.lang.String callback) {
              return (Delete) super.setCallback(callback);
            }

            @Override
            public Delete setFields(java.lang.String fields) {
              return (Delete) super.setFields(fields);
            }

            @Override
            public Delete setKey(java.lang.String key) {
              return (Delete) super.setKey(key);
            }

            @Override
            public Delete setOauthToken(java.lang.String oauthToken) {
              return (Delete) super.setOauthToken(oauthToken);
            }

            @Override
            public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Delete) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Delete setQuotaUser(java.lang.String quotaUser) {
              return (Delete) super.setQuotaUser(quotaUser);
            }

            @Override
            public Delete setUploadType(java.lang.String uploadType) {
              return (Delete) super.setUploadType(uploadType);
            }

            @Override
            public Delete setUploadProtocol(java.lang.String uploadProtocol) {
              return (Delete) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the consumer group to delete. `projects/{project}/locations/{lo
             * cation}/clusters/{cluster}/consumerGroups/{consumerGroup}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the consumer group to delete.
           `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}`.
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the consumer group to delete. `projects/{project}/locations/{lo
             * cation}/clusters/{cluster}/consumerGroups/{consumerGroup}`.
             */
            public Delete setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/consumerGroups/.*$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Delete set(String parameterName, Object value) {
              return (Delete) super.set(parameterName, value);
            }
          }
          /**
           * Returns the properties of a single consumer group.
           *
           * Create a request for the method "consumerGroups.get".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Get#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the consumer group whose configuration to return.
           *        `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}
           *        `.
           * @return the request
           */
          public Get get(java.lang.String name) throws java.io.IOException {
            Get result = new Get(name);
            initialize(result);
            return result;
          }

          public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ConsumerGroup> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/consumerGroups/.*$");

            /**
             * Returns the properties of a single consumer group.
             *
             * Create a request for the method "consumerGroups.get".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
             * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the consumer group whose configuration to return.
           *        `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}
           *        `.
             * @since 1.13
             */
            protected Get(java.lang.String name) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ConsumerGroup.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/consumerGroups/.*$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public Get set$Xgafv(java.lang.String $Xgafv) {
              return (Get) super.set$Xgafv($Xgafv);
            }

            @Override
            public Get setAccessToken(java.lang.String accessToken) {
              return (Get) super.setAccessToken(accessToken);
            }

            @Override
            public Get setAlt(java.lang.String alt) {
              return (Get) super.setAlt(alt);
            }

            @Override
            public Get setCallback(java.lang.String callback) {
              return (Get) super.setCallback(callback);
            }

            @Override
            public Get setFields(java.lang.String fields) {
              return (Get) super.setFields(fields);
            }

            @Override
            public Get setKey(java.lang.String key) {
              return (Get) super.setKey(key);
            }

            @Override
            public Get setOauthToken(java.lang.String oauthToken) {
              return (Get) super.setOauthToken(oauthToken);
            }

            @Override
            public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Get) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Get setQuotaUser(java.lang.String quotaUser) {
              return (Get) super.setQuotaUser(quotaUser);
            }

            @Override
            public Get setUploadType(java.lang.String uploadType) {
              return (Get) super.setUploadType(uploadType);
            }

            @Override
            public Get setUploadProtocol(java.lang.String uploadProtocol) {
              return (Get) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the consumer group whose configuration to return. `projects/{pr
             * oject}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the consumer group whose configuration to return.
           `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}`.
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the consumer group whose configuration to return. `projects/{pr
             * oject}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}`.
             */
            public Get setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/consumerGroups/.*$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Get set(String parameterName, Object value) {
              return (Get) super.set(parameterName, value);
            }
          }
          /**
           * Lists the consumer groups in a given cluster.
           *
           * Create a request for the method "consumerGroups.list".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link List#execute()} method to invoke the remote operation.
           *
           * @param parent Required. The parent cluster whose consumer groups are to be listed. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
           * @return the request
           */
          public List list(java.lang.String parent) throws java.io.IOException {
            List result = new List(parent);
            initialize(result);
            return result;
          }

          public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ListConsumerGroupsResponse> {

            private static final String REST_PATH = "v1/{+parent}/consumerGroups";

            private final java.util.regex.Pattern PARENT_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");

            /**
             * Lists the consumer groups in a given cluster.
             *
             * Create a request for the method "consumerGroups.list".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
             * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param parent Required. The parent cluster whose consumer groups are to be listed. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
             * @since 1.13
             */
            protected List(java.lang.String parent) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ListConsumerGroupsResponse.class);
              this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public List set$Xgafv(java.lang.String $Xgafv) {
              return (List) super.set$Xgafv($Xgafv);
            }

            @Override
            public List setAccessToken(java.lang.String accessToken) {
              return (List) super.setAccessToken(accessToken);
            }

            @Override
            public List setAlt(java.lang.String alt) {
              return (List) super.setAlt(alt);
            }

            @Override
            public List setCallback(java.lang.String callback) {
              return (List) super.setCallback(callback);
            }

            @Override
            public List setFields(java.lang.String fields) {
              return (List) super.setFields(fields);
            }

            @Override
            public List setKey(java.lang.String key) {
              return (List) super.setKey(key);
            }

            @Override
            public List setOauthToken(java.lang.String oauthToken) {
              return (List) super.setOauthToken(oauthToken);
            }

            @Override
            public List setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (List) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public List setQuotaUser(java.lang.String quotaUser) {
              return (List) super.setQuotaUser(quotaUser);
            }

            @Override
            public List setUploadType(java.lang.String uploadType) {
              return (List) super.setUploadType(uploadType);
            }

            @Override
            public List setUploadProtocol(java.lang.String uploadProtocol) {
              return (List) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The parent cluster whose consumer groups are to be listed. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String parent;

            /** Required. The parent cluster whose consumer groups are to be listed. Structured like
           `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public java.lang.String getParent() {
              return parent;
            }

            /**
             * Required. The parent cluster whose consumer groups are to be listed. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public List setParent(java.lang.String parent) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
              this.parent = parent;
              return this;
            }

            /**
             * Optional. The maximum number of consumer groups to return. The service may return
             * fewer than this value. If unset or zero, all consumer groups for the parent is
             * returned.
             */
            @com.google.api.client.util.Key
            private java.lang.Integer pageSize;

            /** Optional. The maximum number of consumer groups to return. The service may return fewer than this
           value. If unset or zero, all consumer groups for the parent is returned.
             */
            public java.lang.Integer getPageSize() {
              return pageSize;
            }

            /**
             * Optional. The maximum number of consumer groups to return. The service may return
             * fewer than this value. If unset or zero, all consumer groups for the parent is
             * returned.
             */
            public List setPageSize(java.lang.Integer pageSize) {
              this.pageSize = pageSize;
              return this;
            }

            /**
             * Optional. A page token, received from a previous `ListConsumerGroups` call. Provide
             * this to retrieve the subsequent page. When paginating, all other parameters provided
             * to `ListConsumerGroups` must match the call that provided the page token.
             */
            @com.google.api.client.util.Key
            private java.lang.String pageToken;

            /** Optional. A page token, received from a previous `ListConsumerGroups` call. Provide this to
           retrieve the subsequent page. When paginating, all other parameters provided to
           `ListConsumerGroups` must match the call that provided the page token.
             */
            public java.lang.String getPageToken() {
              return pageToken;
            }

            /**
             * Optional. A page token, received from a previous `ListConsumerGroups` call. Provide
             * this to retrieve the subsequent page. When paginating, all other parameters provided
             * to `ListConsumerGroups` must match the call that provided the page token.
             */
            public List setPageToken(java.lang.String pageToken) {
              this.pageToken = pageToken;
              return this;
            }

            @Override
            public List set(String parameterName, Object value) {
              return (List) super.set(parameterName, value);
            }
          }
          /**
           * Updates the properties of a single consumer group.
           *
           * Create a request for the method "consumerGroups.patch".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Patch#execute()} method to invoke the remote operation.
           *
           * @param name Identifier. The name of the consumer group. The `consumer_group` segment is used when connecting
           *        directly to the cluster. Structured like:
           *        projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumer_group}
           * @param content the {@link com.google.api.services.managedkafka.v1.model.ConsumerGroup}
           * @return the request
           */
          public Patch patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.ConsumerGroup content) throws java.io.IOException {
            Patch result = new Patch(name, content);
            initialize(result);
            return result;
          }

          public class Patch extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ConsumerGroup> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/consumerGroups/.*$");

            /**
             * Updates the properties of a single consumer group.
             *
             * Create a request for the method "consumerGroups.patch".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Patch#execute()} method to invoke the remote operation.
             * <p> {@link
             * Patch#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Identifier. The name of the consumer group. The `consumer_group` segment is used when connecting
           *        directly to the cluster. Structured like:
           *        projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumer_group}
             * @param content the {@link com.google.api.services.managedkafka.v1.model.ConsumerGroup}
             * @since 1.13
             */
            protected Patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.ConsumerGroup content) {
              super(ManagedKafka.this, "PATCH", REST_PATH, content, com.google.api.services.managedkafka.v1.model.ConsumerGroup.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/consumerGroups/.*$");
              }
            }

            @Override
            public Patch set$Xgafv(java.lang.String $Xgafv) {
              return (Patch) super.set$Xgafv($Xgafv);
            }

            @Override
            public Patch setAccessToken(java.lang.String accessToken) {
              return (Patch) super.setAccessToken(accessToken);
            }

            @Override
            public Patch setAlt(java.lang.String alt) {
              return (Patch) super.setAlt(alt);
            }

            @Override
            public Patch setCallback(java.lang.String callback) {
              return (Patch) super.setCallback(callback);
            }

            @Override
            public Patch setFields(java.lang.String fields) {
              return (Patch) super.setFields(fields);
            }

            @Override
            public Patch setKey(java.lang.String key) {
              return (Patch) super.setKey(key);
            }

            @Override
            public Patch setOauthToken(java.lang.String oauthToken) {
              return (Patch) super.setOauthToken(oauthToken);
            }

            @Override
            public Patch setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Patch) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Patch setQuotaUser(java.lang.String quotaUser) {
              return (Patch) super.setQuotaUser(quotaUser);
            }

            @Override
            public Patch setUploadType(java.lang.String uploadType) {
              return (Patch) super.setUploadType(uploadType);
            }

            @Override
            public Patch setUploadProtocol(java.lang.String uploadProtocol) {
              return (Patch) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Identifier. The name of the consumer group. The `consumer_group` segment is used when
             * connecting directly to the cluster. Structured like: projects/{project}/locations/{lo
             * cation}/clusters/{cluster}/consumerGroups/{consumer_group}
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Identifier. The name of the consumer group. The `consumer_group` segment is used when connecting
           directly to the cluster. Structured like:
           projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumer_group}
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Identifier. The name of the consumer group. The `consumer_group` segment is used when
             * connecting directly to the cluster. Structured like: projects/{project}/locations/{lo
             * cation}/clusters/{cluster}/consumerGroups/{consumer_group}
             */
            public Patch setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/consumerGroups/.*$");
              }
              this.name = name;
              return this;
            }

            /**
             * Required. Field mask is used to specify the fields to be overwritten in the
             * ConsumerGroup resource by the update. The fields specified in the update_mask are
             * relative to the resource, not the full request. A field will be overwritten if it is
             * in the mask. The mask is required and a value of * will update all fields.
             */
            @com.google.api.client.util.Key
            private String updateMask;

            /** Required. Field mask is used to specify the fields to be overwritten in the ConsumerGroup resource
           by the update. The fields specified in the update_mask are relative to the resource, not the full
           request. A field will be overwritten if it is in the mask. The mask is required and a value of *
           will update all fields.
             */
            public String getUpdateMask() {
              return updateMask;
            }

            /**
             * Required. Field mask is used to specify the fields to be overwritten in the
             * ConsumerGroup resource by the update. The fields specified in the update_mask are
             * relative to the resource, not the full request. A field will be overwritten if it is
             * in the mask. The mask is required and a value of * will update all fields.
             */
            public Patch setUpdateMask(String updateMask) {
              this.updateMask = updateMask;
              return this;
            }

            @Override
            public Patch set(String parameterName, Object value) {
              return (Patch) super.set(parameterName, value);
            }
          }

        }
        /**
         * An accessor for creating requests from the Topics collection.
         *
         * <p>The typical use is:</p>
         * <pre>
         *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
         *   {@code ManagedKafka.Topics.List request = managedkafka.topics().list(parameters ...)}
         * </pre>
         *
         * @return the resource collection
         */
        public Topics topics() {
          return new Topics();
        }

        /**
         * The "topics" collection of methods.
         */
        public class Topics {

          /**
           * Creates a new topic in a given project and location.
           *
           * Create a request for the method "topics.create".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Create#execute()} method to invoke the remote operation.
           *
           * @param parent Required. The parent cluster in which to create the topic. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
           * @param content the {@link com.google.api.services.managedkafka.v1.model.Topic}
           * @return the request
           */
          public Create create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.Topic content) throws java.io.IOException {
            Create result = new Create(parent, content);
            initialize(result);
            return result;
          }

          public class Create extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Topic> {

            private static final String REST_PATH = "v1/{+parent}/topics";

            private final java.util.regex.Pattern PARENT_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");

            /**
             * Creates a new topic in a given project and location.
             *
             * Create a request for the method "topics.create".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
             * <p> {@link
             * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param parent Required. The parent cluster in which to create the topic. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
             * @param content the {@link com.google.api.services.managedkafka.v1.model.Topic}
             * @since 1.13
             */
            protected Create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.Topic content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Topic.class);
              this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
            }

            @Override
            public Create set$Xgafv(java.lang.String $Xgafv) {
              return (Create) super.set$Xgafv($Xgafv);
            }

            @Override
            public Create setAccessToken(java.lang.String accessToken) {
              return (Create) super.setAccessToken(accessToken);
            }

            @Override
            public Create setAlt(java.lang.String alt) {
              return (Create) super.setAlt(alt);
            }

            @Override
            public Create setCallback(java.lang.String callback) {
              return (Create) super.setCallback(callback);
            }

            @Override
            public Create setFields(java.lang.String fields) {
              return (Create) super.setFields(fields);
            }

            @Override
            public Create setKey(java.lang.String key) {
              return (Create) super.setKey(key);
            }

            @Override
            public Create setOauthToken(java.lang.String oauthToken) {
              return (Create) super.setOauthToken(oauthToken);
            }

            @Override
            public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Create) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Create setQuotaUser(java.lang.String quotaUser) {
              return (Create) super.setQuotaUser(quotaUser);
            }

            @Override
            public Create setUploadType(java.lang.String uploadType) {
              return (Create) super.setUploadType(uploadType);
            }

            @Override
            public Create setUploadProtocol(java.lang.String uploadProtocol) {
              return (Create) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The parent cluster in which to create the topic. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String parent;

            /** Required. The parent cluster in which to create the topic. Structured like
           `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public java.lang.String getParent() {
              return parent;
            }

            /**
             * Required. The parent cluster in which to create the topic. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public Create setParent(java.lang.String parent) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
              this.parent = parent;
              return this;
            }

            /**
             * Required. The ID to use for the topic, which will become the final component of the
             * topic's name. This value is structured like: `my-topic-name`.
             */
            @com.google.api.client.util.Key
            private java.lang.String topicId;

            /** Required. The ID to use for the topic, which will become the final component of the topic's name.
           This value is structured like: `my-topic-name`.
             */
            public java.lang.String getTopicId() {
              return topicId;
            }

            /**
             * Required. The ID to use for the topic, which will become the final component of the
             * topic's name. This value is structured like: `my-topic-name`.
             */
            public Create setTopicId(java.lang.String topicId) {
              this.topicId = topicId;
              return this;
            }

            @Override
            public Create set(String parameterName, Object value) {
              return (Create) super.set(parameterName, value);
            }
          }
          /**
           * Deletes a single topic.
           *
           * Create a request for the method "topics.delete".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the topic to delete.
           *        `projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}`.
           * @return the request
           */
          public Delete delete(java.lang.String name) throws java.io.IOException {
            Delete result = new Delete(name);
            initialize(result);
            return result;
          }

          public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Empty> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/topics/[^/]+$");

            /**
             * Deletes a single topic.
             *
             * Create a request for the method "topics.delete".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
             * <p> {@link
             * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the topic to delete.
           *        `projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}`.
             * @since 1.13
             */
            protected Delete(java.lang.String name) {
              super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Empty.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/topics/[^/]+$");
              }
            }

            @Override
            public Delete set$Xgafv(java.lang.String $Xgafv) {
              return (Delete) super.set$Xgafv($Xgafv);
            }

            @Override
            public Delete setAccessToken(java.lang.String accessToken) {
              return (Delete) super.setAccessToken(accessToken);
            }

            @Override
            public Delete setAlt(java.lang.String alt) {
              return (Delete) super.setAlt(alt);
            }

            @Override
            public Delete setCallback(java.lang.String callback) {
              return (Delete) super.setCallback(callback);
            }

            @Override
            public Delete setFields(java.lang.String fields) {
              return (Delete) super.setFields(fields);
            }

            @Override
            public Delete setKey(java.lang.String key) {
              return (Delete) super.setKey(key);
            }

            @Override
            public Delete setOauthToken(java.lang.String oauthToken) {
              return (Delete) super.setOauthToken(oauthToken);
            }

            @Override
            public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Delete) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Delete setQuotaUser(java.lang.String quotaUser) {
              return (Delete) super.setQuotaUser(quotaUser);
            }

            @Override
            public Delete setUploadType(java.lang.String uploadType) {
              return (Delete) super.setUploadType(uploadType);
            }

            @Override
            public Delete setUploadProtocol(java.lang.String uploadProtocol) {
              return (Delete) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the topic to delete.
             * `projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the topic to delete.
           `projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}`.
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the topic to delete.
             * `projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}`.
             */
            public Delete setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/topics/[^/]+$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Delete set(String parameterName, Object value) {
              return (Delete) super.set(parameterName, value);
            }
          }
          /**
           * Returns the properties of a single topic.
           *
           * Create a request for the method "topics.get".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Get#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the topic whose configuration to return. Structured like:
           *        projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}.
           * @return the request
           */
          public Get get(java.lang.String name) throws java.io.IOException {
            Get result = new Get(name);
            initialize(result);
            return result;
          }

          public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Topic> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/topics/[^/]+$");

            /**
             * Returns the properties of a single topic.
             *
             * Create a request for the method "topics.get".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
             * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the topic whose configuration to return. Structured like:
           *        projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}.
             * @since 1.13
             */
            protected Get(java.lang.String name) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Topic.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/topics/[^/]+$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public Get set$Xgafv(java.lang.String $Xgafv) {
              return (Get) super.set$Xgafv($Xgafv);
            }

            @Override
            public Get setAccessToken(java.lang.String accessToken) {
              return (Get) super.setAccessToken(accessToken);
            }

            @Override
            public Get setAlt(java.lang.String alt) {
              return (Get) super.setAlt(alt);
            }

            @Override
            public Get setCallback(java.lang.String callback) {
              return (Get) super.setCallback(callback);
            }

            @Override
            public Get setFields(java.lang.String fields) {
              return (Get) super.setFields(fields);
            }

            @Override
            public Get setKey(java.lang.String key) {
              return (Get) super.setKey(key);
            }

            @Override
            public Get setOauthToken(java.lang.String oauthToken) {
              return (Get) super.setOauthToken(oauthToken);
            }

            @Override
            public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Get) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Get setQuotaUser(java.lang.String quotaUser) {
              return (Get) super.setQuotaUser(quotaUser);
            }

            @Override
            public Get setUploadType(java.lang.String uploadType) {
              return (Get) super.setUploadType(uploadType);
            }

            @Override
            public Get setUploadProtocol(java.lang.String uploadProtocol) {
              return (Get) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the topic whose configuration to return. Structured like:
             * projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}.
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the topic whose configuration to return. Structured like:
           projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}.
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the topic whose configuration to return. Structured like:
             * projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}.
             */
            public Get setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/topics/[^/]+$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Get set(String parameterName, Object value) {
              return (Get) super.set(parameterName, value);
            }
          }
          /**
           * Lists the topics in a given cluster.
           *
           * Create a request for the method "topics.list".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link List#execute()} method to invoke the remote operation.
           *
           * @param parent Required. The parent cluster whose topics are to be listed. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
           * @return the request
           */
          public List list(java.lang.String parent) throws java.io.IOException {
            List result = new List(parent);
            initialize(result);
            return result;
          }

          public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ListTopicsResponse> {

            private static final String REST_PATH = "v1/{+parent}/topics";

            private final java.util.regex.Pattern PARENT_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");

            /**
             * Lists the topics in a given cluster.
             *
             * Create a request for the method "topics.list".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
             * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param parent Required. The parent cluster whose topics are to be listed. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
             * @since 1.13
             */
            protected List(java.lang.String parent) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ListTopicsResponse.class);
              this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public List set$Xgafv(java.lang.String $Xgafv) {
              return (List) super.set$Xgafv($Xgafv);
            }

            @Override
            public List setAccessToken(java.lang.String accessToken) {
              return (List) super.setAccessToken(accessToken);
            }

            @Override
            public List setAlt(java.lang.String alt) {
              return (List) super.setAlt(alt);
            }

            @Override
            public List setCallback(java.lang.String callback) {
              return (List) super.setCallback(callback);
            }

            @Override
            public List setFields(java.lang.String fields) {
              return (List) super.setFields(fields);
            }

            @Override
            public List setKey(java.lang.String key) {
              return (List) super.setKey(key);
            }

            @Override
            public List setOauthToken(java.lang.String oauthToken) {
              return (List) super.setOauthToken(oauthToken);
            }

            @Override
            public List setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (List) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public List setQuotaUser(java.lang.String quotaUser) {
              return (List) super.setQuotaUser(quotaUser);
            }

            @Override
            public List setUploadType(java.lang.String uploadType) {
              return (List) super.setUploadType(uploadType);
            }

            @Override
            public List setUploadProtocol(java.lang.String uploadProtocol) {
              return (List) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The parent cluster whose topics are to be listed. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String parent;

            /** Required. The parent cluster whose topics are to be listed. Structured like
           `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public java.lang.String getParent() {
              return parent;
            }

            /**
             * Required. The parent cluster whose topics are to be listed. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public List setParent(java.lang.String parent) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
              this.parent = parent;
              return this;
            }

            /**
             * Optional. The maximum number of topics to return. The service may return fewer than
             * this value. If unset or zero, all topics for the parent is returned.
             */
            @com.google.api.client.util.Key
            private java.lang.Integer pageSize;

            /** Optional. The maximum number of topics to return. The service may return fewer than this value. If
           unset or zero, all topics for the parent is returned.
             */
            public java.lang.Integer getPageSize() {
              return pageSize;
            }

            /**
             * Optional. The maximum number of topics to return. The service may return fewer than
             * this value. If unset or zero, all topics for the parent is returned.
             */
            public List setPageSize(java.lang.Integer pageSize) {
              this.pageSize = pageSize;
              return this;
            }

            /**
             * Optional. A page token, received from a previous `ListTopics` call. Provide this to
             * retrieve the subsequent page. When paginating, all other parameters provided to
             * `ListTopics` must match the call that provided the page token.
             */
            @com.google.api.client.util.Key
            private java.lang.String pageToken;

            /** Optional. A page token, received from a previous `ListTopics` call. Provide this to retrieve the
           subsequent page. When paginating, all other parameters provided to `ListTopics` must match the call
           that provided the page token.
             */
            public java.lang.String getPageToken() {
              return pageToken;
            }

            /**
             * Optional. A page token, received from a previous `ListTopics` call. Provide this to
             * retrieve the subsequent page. When paginating, all other parameters provided to
             * `ListTopics` must match the call that provided the page token.
             */
            public List setPageToken(java.lang.String pageToken) {
              this.pageToken = pageToken;
              return this;
            }

            @Override
            public List set(String parameterName, Object value) {
              return (List) super.set(parameterName, value);
            }
          }
          /**
           * Updates the properties of a single topic.
           *
           * Create a request for the method "topics.patch".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Patch#execute()} method to invoke the remote operation.
           *
           * @param name Identifier. The name of the topic. The `topic` segment is used when connecting directly to the
           *        cluster. Structured like:
           *        projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
           * @param content the {@link com.google.api.services.managedkafka.v1.model.Topic}
           * @return the request
           */
          public Patch patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.Topic content) throws java.io.IOException {
            Patch result = new Patch(name, content);
            initialize(result);
            return result;
          }

          public class Patch extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Topic> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/topics/[^/]+$");

            /**
             * Updates the properties of a single topic.
             *
             * Create a request for the method "topics.patch".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Patch#execute()} method to invoke the remote operation.
             * <p> {@link
             * Patch#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Identifier. The name of the topic. The `topic` segment is used when connecting directly to the
           *        cluster. Structured like:
           *        projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
             * @param content the {@link com.google.api.services.managedkafka.v1.model.Topic}
             * @since 1.13
             */
            protected Patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.Topic content) {
              super(ManagedKafka.this, "PATCH", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Topic.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/topics/[^/]+$");
              }
            }

            @Override
            public Patch set$Xgafv(java.lang.String $Xgafv) {
              return (Patch) super.set$Xgafv($Xgafv);
            }

            @Override
            public Patch setAccessToken(java.lang.String accessToken) {
              return (Patch) super.setAccessToken(accessToken);
            }

            @Override
            public Patch setAlt(java.lang.String alt) {
              return (Patch) super.setAlt(alt);
            }

            @Override
            public Patch setCallback(java.lang.String callback) {
              return (Patch) super.setCallback(callback);
            }

            @Override
            public Patch setFields(java.lang.String fields) {
              return (Patch) super.setFields(fields);
            }

            @Override
            public Patch setKey(java.lang.String key) {
              return (Patch) super.setKey(key);
            }

            @Override
            public Patch setOauthToken(java.lang.String oauthToken) {
              return (Patch) super.setOauthToken(oauthToken);
            }

            @Override
            public Patch setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Patch) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Patch setQuotaUser(java.lang.String quotaUser) {
              return (Patch) super.setQuotaUser(quotaUser);
            }

            @Override
            public Patch setUploadType(java.lang.String uploadType) {
              return (Patch) super.setUploadType(uploadType);
            }

            @Override
            public Patch setUploadProtocol(java.lang.String uploadProtocol) {
              return (Patch) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Identifier. The name of the topic. The `topic` segment is used when connecting
             * directly to the cluster. Structured like:
             * projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Identifier. The name of the topic. The `topic` segment is used when connecting directly to the
           cluster. Structured like: projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Identifier. The name of the topic. The `topic` segment is used when connecting
             * directly to the cluster. Structured like:
             * projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
             */
            public Patch setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/topics/[^/]+$");
              }
              this.name = name;
              return this;
            }

            /**
             * Required. Field mask is used to specify the fields to be overwritten in the Topic
             * resource by the update. The fields specified in the update_mask are relative to the
             * resource, not the full request. A field will be overwritten if it is in the mask. The
             * mask is required and a value of * will update all fields.
             */
            @com.google.api.client.util.Key
            private String updateMask;

            /** Required. Field mask is used to specify the fields to be overwritten in the Topic resource by the
           update. The fields specified in the update_mask are relative to the resource, not the full request.
           A field will be overwritten if it is in the mask. The mask is required and a value of * will update
           all fields.
             */
            public String getUpdateMask() {
              return updateMask;
            }

            /**
             * Required. Field mask is used to specify the fields to be overwritten in the Topic
             * resource by the update. The fields specified in the update_mask are relative to the
             * resource, not the full request. A field will be overwritten if it is in the mask. The
             * mask is required and a value of * will update all fields.
             */
            public Patch setUpdateMask(String updateMask) {
              this.updateMask = updateMask;
              return this;
            }

            @Override
            public Patch set(String parameterName, Object value) {
              return (Patch) super.set(parameterName, value);
            }
          }

        }
      }
      /**
       * An accessor for creating requests from the ConnectClusters collection.
       *
       * <p>The typical use is:</p>
       * <pre>
       *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
       *   {@code ManagedKafka.ConnectClusters.List request = managedkafka.connectClusters().list(parameters ...)}
       * </pre>
       *
       * @return the resource collection
       */
      public ConnectClusters connectClusters() {
        return new ConnectClusters();
      }

      /**
       * The "connectClusters" collection of methods.
       */
      public class ConnectClusters {

        /**
         * Creates a new Kafka Connect cluster in a given project and location.
         *
         * Create a request for the method "connectClusters.create".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Create#execute()} method to invoke the remote operation.
         *
         * @param parent Required. The parent project/location in which to create the Kafka Connect cluster. Structured like
         *        `projects/{project}/locations/{location}/`.
         * @param content the {@link com.google.api.services.managedkafka.v1.model.ConnectCluster}
         * @return the request
         */
        public Create create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.ConnectCluster content) throws java.io.IOException {
          Create result = new Create(parent, content);
          initialize(result);
          return result;
        }

        public class Create extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Operation> {

          private static final String REST_PATH = "v1/{+parent}/connectClusters";

          private final java.util.regex.Pattern PARENT_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+$");

          /**
           * Creates a new Kafka Connect cluster in a given project and location.
           *
           * Create a request for the method "connectClusters.create".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
           * <p> {@link
           * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
           * be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param parent Required. The parent project/location in which to create the Kafka Connect cluster. Structured like
         *        `projects/{project}/locations/{location}/`.
           * @param content the {@link com.google.api.services.managedkafka.v1.model.ConnectCluster}
           * @since 1.13
           */
          protected Create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.ConnectCluster content) {
            super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Operation.class);
            this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
          }

          @Override
          public Create set$Xgafv(java.lang.String $Xgafv) {
            return (Create) super.set$Xgafv($Xgafv);
          }

          @Override
          public Create setAccessToken(java.lang.String accessToken) {
            return (Create) super.setAccessToken(accessToken);
          }

          @Override
          public Create setAlt(java.lang.String alt) {
            return (Create) super.setAlt(alt);
          }

          @Override
          public Create setCallback(java.lang.String callback) {
            return (Create) super.setCallback(callback);
          }

          @Override
          public Create setFields(java.lang.String fields) {
            return (Create) super.setFields(fields);
          }

          @Override
          public Create setKey(java.lang.String key) {
            return (Create) super.setKey(key);
          }

          @Override
          public Create setOauthToken(java.lang.String oauthToken) {
            return (Create) super.setOauthToken(oauthToken);
          }

          @Override
          public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Create) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Create setQuotaUser(java.lang.String quotaUser) {
            return (Create) super.setQuotaUser(quotaUser);
          }

          @Override
          public Create setUploadType(java.lang.String uploadType) {
            return (Create) super.setUploadType(uploadType);
          }

          @Override
          public Create setUploadProtocol(java.lang.String uploadProtocol) {
            return (Create) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Required. The parent project/location in which to create the Kafka Connect cluster.
           * Structured like `projects/{project}/locations/{location}/`.
           */
          @com.google.api.client.util.Key
          private java.lang.String parent;

          /** Required. The parent project/location in which to create the Kafka Connect cluster. Structured like
         `projects/{project}/locations/{location}/`.
           */
          public java.lang.String getParent() {
            return parent;
          }

          /**
           * Required. The parent project/location in which to create the Kafka Connect cluster.
           * Structured like `projects/{project}/locations/{location}/`.
           */
          public Create setParent(java.lang.String parent) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
            this.parent = parent;
            return this;
          }

          /**
           * Required. The ID to use for the Connect cluster, which will become the final component
           * of the cluster's name. The ID must be 1-63 characters long, and match the regular
           * expression `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value is
           * structured like: `my-cluster-id`.
           */
          @com.google.api.client.util.Key
          private java.lang.String connectClusterId;

          /** Required. The ID to use for the Connect cluster, which will become the final component of the
         cluster's name. The ID must be 1-63 characters long, and match the regular expression
         `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value is structured like: `my-cluster-
         id`.
           */
          public java.lang.String getConnectClusterId() {
            return connectClusterId;
          }

          /**
           * Required. The ID to use for the Connect cluster, which will become the final component
           * of the cluster's name. The ID must be 1-63 characters long, and match the regular
           * expression `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value is
           * structured like: `my-cluster-id`.
           */
          public Create setConnectClusterId(java.lang.String connectClusterId) {
            this.connectClusterId = connectClusterId;
            return this;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          @com.google.api.client.util.Key
          private java.lang.String requestId;

          /** Optional. An optional request ID to identify requests. Specify a unique request ID to avoid
         duplication of requests. If a request times out or fails, retrying with the same ID allows the
         server to recognize the previous attempt. For at least 60 minutes, the server ignores duplicate
         requests bearing the same ID. For example, consider a situation where you make an initial request
         and the request times out. If you make the request again with the same request ID within 60 minutes
         of the last request, the server checks if an original operation with the same request ID was
         received. If so, the server ignores the second request. The request ID must be a valid UUID. A zero
         UUID is not supported (00000000-0000-0000-0000-000000000000).
           */
          public java.lang.String getRequestId() {
            return requestId;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          public Create setRequestId(java.lang.String requestId) {
            this.requestId = requestId;
            return this;
          }

          @Override
          public Create set(String parameterName, Object value) {
            return (Create) super.set(parameterName, value);
          }
        }
        /**
         * Deletes a single Connect cluster.
         *
         * Create a request for the method "connectClusters.delete".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
         *
         * @param name Required. The name of the Kafka Connect cluster to delete. Structured like
         *        `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
         * @return the request
         */
        public Delete delete(java.lang.String name) throws java.io.IOException {
          Delete result = new Delete(name);
          initialize(result);
          return result;
        }

        public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Operation> {

          private static final String REST_PATH = "v1/{+name}";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");

          /**
           * Deletes a single Connect cluster.
           *
           * Create a request for the method "connectClusters.delete".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
           * <p> {@link
           * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
           * be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name Required. The name of the Kafka Connect cluster to delete. Structured like
         *        `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           * @since 1.13
           */
          protected Delete(java.lang.String name) {
            super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Operation.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
            }
          }

          @Override
          public Delete set$Xgafv(java.lang.String $Xgafv) {
            return (Delete) super.set$Xgafv($Xgafv);
          }

          @Override
          public Delete setAccessToken(java.lang.String accessToken) {
            return (Delete) super.setAccessToken(accessToken);
          }

          @Override
          public Delete setAlt(java.lang.String alt) {
            return (Delete) super.setAlt(alt);
          }

          @Override
          public Delete setCallback(java.lang.String callback) {
            return (Delete) super.setCallback(callback);
          }

          @Override
          public Delete setFields(java.lang.String fields) {
            return (Delete) super.setFields(fields);
          }

          @Override
          public Delete setKey(java.lang.String key) {
            return (Delete) super.setKey(key);
          }

          @Override
          public Delete setOauthToken(java.lang.String oauthToken) {
            return (Delete) super.setOauthToken(oauthToken);
          }

          @Override
          public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Delete) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Delete setQuotaUser(java.lang.String quotaUser) {
            return (Delete) super.setQuotaUser(quotaUser);
          }

          @Override
          public Delete setUploadType(java.lang.String uploadType) {
            return (Delete) super.setUploadType(uploadType);
          }

          @Override
          public Delete setUploadProtocol(java.lang.String uploadProtocol) {
            return (Delete) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Required. The name of the Kafka Connect cluster to delete. Structured like
           * `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** Required. The name of the Kafka Connect cluster to delete. Structured like
         `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           */
          public java.lang.String getName() {
            return name;
          }

          /**
           * Required. The name of the Kafka Connect cluster to delete. Structured like
           * `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           */
          public Delete setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
            }
            this.name = name;
            return this;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          @com.google.api.client.util.Key
          private java.lang.String requestId;

          /** Optional. An optional request ID to identify requests. Specify a unique request ID to avoid
         duplication of requests. If a request times out or fails, retrying with the same ID allows the
         server to recognize the previous attempt. For at least 60 minutes, the server ignores duplicate
         requests bearing the same ID. For example, consider a situation where you make an initial request
         and the request times out. If you make the request again with the same request ID within 60 minutes
         of the last request, the server checks if an original operation with the same request ID was
         received. If so, the server ignores the second request. The request ID must be a valid UUID. A zero
         UUID is not supported (00000000-0000-0000-0000-000000000000).
           */
          public java.lang.String getRequestId() {
            return requestId;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          public Delete setRequestId(java.lang.String requestId) {
            this.requestId = requestId;
            return this;
          }

          @Override
          public Delete set(String parameterName, Object value) {
            return (Delete) super.set(parameterName, value);
          }
        }
        /**
         * Returns the properties of a single Kafka Connect cluster.
         *
         * Create a request for the method "connectClusters.get".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Get#execute()} method to invoke the remote operation.
         *
         * @param name Required. The name of the Kafka Connect cluster whose configuration to return. Structured like
         *        `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
         * @return the request
         */
        public Get get(java.lang.String name) throws java.io.IOException {
          Get result = new Get(name);
          initialize(result);
          return result;
        }

        public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ConnectCluster> {

          private static final String REST_PATH = "v1/{+name}";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");

          /**
           * Returns the properties of a single Kafka Connect cluster.
           *
           * Create a request for the method "connectClusters.get".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
           * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
           * must be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name Required. The name of the Kafka Connect cluster whose configuration to return. Structured like
         *        `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           * @since 1.13
           */
          protected Get(java.lang.String name) {
            super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ConnectCluster.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
            }
          }

          @Override
          public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
            return super.executeUsingHead();
          }

          @Override
          public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
            return super.buildHttpRequestUsingHead();
          }

          @Override
          public Get set$Xgafv(java.lang.String $Xgafv) {
            return (Get) super.set$Xgafv($Xgafv);
          }

          @Override
          public Get setAccessToken(java.lang.String accessToken) {
            return (Get) super.setAccessToken(accessToken);
          }

          @Override
          public Get setAlt(java.lang.String alt) {
            return (Get) super.setAlt(alt);
          }

          @Override
          public Get setCallback(java.lang.String callback) {
            return (Get) super.setCallback(callback);
          }

          @Override
          public Get setFields(java.lang.String fields) {
            return (Get) super.setFields(fields);
          }

          @Override
          public Get setKey(java.lang.String key) {
            return (Get) super.setKey(key);
          }

          @Override
          public Get setOauthToken(java.lang.String oauthToken) {
            return (Get) super.setOauthToken(oauthToken);
          }

          @Override
          public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Get) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Get setQuotaUser(java.lang.String quotaUser) {
            return (Get) super.setQuotaUser(quotaUser);
          }

          @Override
          public Get setUploadType(java.lang.String uploadType) {
            return (Get) super.setUploadType(uploadType);
          }

          @Override
          public Get setUploadProtocol(java.lang.String uploadProtocol) {
            return (Get) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Required. The name of the Kafka Connect cluster whose configuration to return.
           * Structured like
           * `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** Required. The name of the Kafka Connect cluster whose configuration to return. Structured like
         `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           */
          public java.lang.String getName() {
            return name;
          }

          /**
           * Required. The name of the Kafka Connect cluster whose configuration to return.
           * Structured like
           * `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           */
          public Get setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
            }
            this.name = name;
            return this;
          }

          @Override
          public Get set(String parameterName, Object value) {
            return (Get) super.set(parameterName, value);
          }
        }
        /**
         * Lists the Kafka Connect clusters in a given project and location.
         *
         * Create a request for the method "connectClusters.list".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link List#execute()} method to invoke the remote operation.
         *
         * @param parent Required. The parent project/location whose Connect clusters are to be listed. Structured like
         *        `projects/{project}/locations/{location}`.
         * @return the request
         */
        public List list(java.lang.String parent) throws java.io.IOException {
          List result = new List(parent);
          initialize(result);
          return result;
        }

        public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ListConnectClustersResponse> {

          private static final String REST_PATH = "v1/{+parent}/connectClusters";

          private final java.util.regex.Pattern PARENT_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+$");

          /**
           * Lists the Kafka Connect clusters in a given project and location.
           *
           * Create a request for the method "connectClusters.list".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
           * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
           * must be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param parent Required. The parent project/location whose Connect clusters are to be listed. Structured like
         *        `projects/{project}/locations/{location}`.
           * @since 1.13
           */
          protected List(java.lang.String parent) {
            super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ListConnectClustersResponse.class);
            this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
          }

          @Override
          public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
            return super.executeUsingHead();
          }

          @Override
          public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
            return super.buildHttpRequestUsingHead();
          }

          @Override
          public List set$Xgafv(java.lang.String $Xgafv) {
            return (List) super.set$Xgafv($Xgafv);
          }

          @Override
          public List setAccessToken(java.lang.String accessToken) {
            return (List) super.setAccessToken(accessToken);
          }

          @Override
          public List setAlt(java.lang.String alt) {
            return (List) super.setAlt(alt);
          }

          @Override
          public List setCallback(java.lang.String callback) {
            return (List) super.setCallback(callback);
          }

          @Override
          public List setFields(java.lang.String fields) {
            return (List) super.setFields(fields);
          }

          @Override
          public List setKey(java.lang.String key) {
            return (List) super.setKey(key);
          }

          @Override
          public List setOauthToken(java.lang.String oauthToken) {
            return (List) super.setOauthToken(oauthToken);
          }

          @Override
          public List setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (List) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public List setQuotaUser(java.lang.String quotaUser) {
            return (List) super.setQuotaUser(quotaUser);
          }

          @Override
          public List setUploadType(java.lang.String uploadType) {
            return (List) super.setUploadType(uploadType);
          }

          @Override
          public List setUploadProtocol(java.lang.String uploadProtocol) {
            return (List) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Required. The parent project/location whose Connect clusters are to be listed.
           * Structured like `projects/{project}/locations/{location}`.
           */
          @com.google.api.client.util.Key
          private java.lang.String parent;

          /** Required. The parent project/location whose Connect clusters are to be listed. Structured like
         `projects/{project}/locations/{location}`.
           */
          public java.lang.String getParent() {
            return parent;
          }

          /**
           * Required. The parent project/location whose Connect clusters are to be listed.
           * Structured like `projects/{project}/locations/{location}`.
           */
          public List setParent(java.lang.String parent) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
            this.parent = parent;
            return this;
          }

          /** Optional. Filter expression for the result. */
          @com.google.api.client.util.Key
          private java.lang.String filter;

          /** Optional. Filter expression for the result.
           */
          public java.lang.String getFilter() {
            return filter;
          }

          /** Optional. Filter expression for the result. */
          public List setFilter(java.lang.String filter) {
            this.filter = filter;
            return this;
          }

          /** Optional. Order by fields for the result. */
          @com.google.api.client.util.Key
          private java.lang.String orderBy;

          /** Optional. Order by fields for the result.
           */
          public java.lang.String getOrderBy() {
            return orderBy;
          }

          /** Optional. Order by fields for the result. */
          public List setOrderBy(java.lang.String orderBy) {
            this.orderBy = orderBy;
            return this;
          }

          /**
           * Optional. The maximum number of Connect clusters to return. The service may return
           * fewer than this value. If unspecified, server will pick an appropriate default.
           */
          @com.google.api.client.util.Key
          private java.lang.Integer pageSize;

          /** Optional. The maximum number of Connect clusters to return. The service may return fewer than this
         value. If unspecified, server will pick an appropriate default.
           */
          public java.lang.Integer getPageSize() {
            return pageSize;
          }

          /**
           * Optional. The maximum number of Connect clusters to return. The service may return
           * fewer than this value. If unspecified, server will pick an appropriate default.
           */
          public List setPageSize(java.lang.Integer pageSize) {
            this.pageSize = pageSize;
            return this;
          }

          /**
           * Optional. A page token, received from a previous `ListConnectClusters` call. Provide
           * this to retrieve the subsequent page. When paginating, all other parameters provided to
           * `ListConnectClusters` must match the call that provided the page token.
           */
          @com.google.api.client.util.Key
          private java.lang.String pageToken;

          /** Optional. A page token, received from a previous `ListConnectClusters` call. Provide this to
         retrieve the subsequent page. When paginating, all other parameters provided to
         `ListConnectClusters` must match the call that provided the page token.
           */
          public java.lang.String getPageToken() {
            return pageToken;
          }

          /**
           * Optional. A page token, received from a previous `ListConnectClusters` call. Provide
           * this to retrieve the subsequent page. When paginating, all other parameters provided to
           * `ListConnectClusters` must match the call that provided the page token.
           */
          public List setPageToken(java.lang.String pageToken) {
            this.pageToken = pageToken;
            return this;
          }

          @Override
          public List set(String parameterName, Object value) {
            return (List) super.set(parameterName, value);
          }
        }
        /**
         * Updates the properties of a single Kafka Connect cluster.
         *
         * Create a request for the method "connectClusters.patch".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Patch#execute()} method to invoke the remote operation.
         *
         * @param name Identifier. The name of the Kafka Connect cluster. Structured like:
         *        projects/{project_number}/locations/{location}/connectClusters/{connect_cluster_id}
         * @param content the {@link com.google.api.services.managedkafka.v1.model.ConnectCluster}
         * @return the request
         */
        public Patch patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.ConnectCluster content) throws java.io.IOException {
          Patch result = new Patch(name, content);
          initialize(result);
          return result;
        }

        public class Patch extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Operation> {

          private static final String REST_PATH = "v1/{+name}";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");

          /**
           * Updates the properties of a single Kafka Connect cluster.
           *
           * Create a request for the method "connectClusters.patch".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Patch#execute()} method to invoke the remote operation.
           * <p> {@link
           * Patch#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
           * be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name Identifier. The name of the Kafka Connect cluster. Structured like:
         *        projects/{project_number}/locations/{location}/connectClusters/{connect_cluster_id}
           * @param content the {@link com.google.api.services.managedkafka.v1.model.ConnectCluster}
           * @since 1.13
           */
          protected Patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.ConnectCluster content) {
            super(ManagedKafka.this, "PATCH", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Operation.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
            }
          }

          @Override
          public Patch set$Xgafv(java.lang.String $Xgafv) {
            return (Patch) super.set$Xgafv($Xgafv);
          }

          @Override
          public Patch setAccessToken(java.lang.String accessToken) {
            return (Patch) super.setAccessToken(accessToken);
          }

          @Override
          public Patch setAlt(java.lang.String alt) {
            return (Patch) super.setAlt(alt);
          }

          @Override
          public Patch setCallback(java.lang.String callback) {
            return (Patch) super.setCallback(callback);
          }

          @Override
          public Patch setFields(java.lang.String fields) {
            return (Patch) super.setFields(fields);
          }

          @Override
          public Patch setKey(java.lang.String key) {
            return (Patch) super.setKey(key);
          }

          @Override
          public Patch setOauthToken(java.lang.String oauthToken) {
            return (Patch) super.setOauthToken(oauthToken);
          }

          @Override
          public Patch setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Patch) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Patch setQuotaUser(java.lang.String quotaUser) {
            return (Patch) super.setQuotaUser(quotaUser);
          }

          @Override
          public Patch setUploadType(java.lang.String uploadType) {
            return (Patch) super.setUploadType(uploadType);
          }

          @Override
          public Patch setUploadProtocol(java.lang.String uploadProtocol) {
            return (Patch) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Identifier. The name of the Kafka Connect cluster. Structured like:
           * projects/{project_number}/locations/{location}/connectClusters/{connect_cluster_id}
           */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** Identifier. The name of the Kafka Connect cluster. Structured like:
         projects/{project_number}/locations/{location}/connectClusters/{connect_cluster_id}
           */
          public java.lang.String getName() {
            return name;
          }

          /**
           * Identifier. The name of the Kafka Connect cluster. Structured like:
           * projects/{project_number}/locations/{location}/connectClusters/{connect_cluster_id}
           */
          public Patch setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
            }
            this.name = name;
            return this;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          @com.google.api.client.util.Key
          private java.lang.String requestId;

          /** Optional. An optional request ID to identify requests. Specify a unique request ID to avoid
         duplication of requests. If a request times out or fails, retrying with the same ID allows the
         server to recognize the previous attempt. For at least 60 minutes, the server ignores duplicate
         requests bearing the same ID. For example, consider a situation where you make an initial request
         and the request times out. If you make the request again with the same request ID within 60 minutes
         of the last request, the server checks if an original operation with the same request ID was
         received. If so, the server ignores the second request. The request ID must be a valid UUID. A zero
         UUID is not supported (00000000-0000-0000-0000-000000000000).
           */
          public java.lang.String getRequestId() {
            return requestId;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          public Patch setRequestId(java.lang.String requestId) {
            this.requestId = requestId;
            return this;
          }

          /**
           * Required. Field mask is used to specify the fields to be overwritten in the cluster
           * resource by the update. The fields specified in the update_mask are relative to the
           * resource, not the full request. A field will be overwritten if it is in the mask. The
           * mask is required and a value of * will update all fields.
           */
          @com.google.api.client.util.Key
          private String updateMask;

          /** Required. Field mask is used to specify the fields to be overwritten in the cluster resource by the
         update. The fields specified in the update_mask are relative to the resource, not the full request.
         A field will be overwritten if it is in the mask. The mask is required and a value of * will update
         all fields.
           */
          public String getUpdateMask() {
            return updateMask;
          }

          /**
           * Required. Field mask is used to specify the fields to be overwritten in the cluster
           * resource by the update. The fields specified in the update_mask are relative to the
           * resource, not the full request. A field will be overwritten if it is in the mask. The
           * mask is required and a value of * will update all fields.
           */
          public Patch setUpdateMask(String updateMask) {
            this.updateMask = updateMask;
            return this;
          }

          @Override
          public Patch set(String parameterName, Object value) {
            return (Patch) super.set(parameterName, value);
          }
        }

        /**
         * An accessor for creating requests from the Connectors collection.
         *
         * <p>The typical use is:</p>
         * <pre>
         *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
         *   {@code ManagedKafka.Connectors.List request = managedkafka.connectors().list(parameters ...)}
         * </pre>
         *
         * @return the resource collection
         */
        public Connectors connectors() {
          return new Connectors();
        }

        /**
         * The "connectors" collection of methods.
         */
        public class Connectors {

          /**
           * Creates a new connector in a given Connect cluster.
           *
           * Create a request for the method "connectors.create".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Create#execute()} method to invoke the remote operation.
           *
           * @param parent Required. The parent Connect cluster in which to create the connector. Structured like
           *        `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           * @param content the {@link com.google.api.services.managedkafka.v1.model.Connector}
           * @return the request
           */
          public Create create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.Connector content) throws java.io.IOException {
            Create result = new Create(parent, content);
            initialize(result);
            return result;
          }

          public class Create extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Connector> {

            private static final String REST_PATH = "v1/{+parent}/connectors";

            private final java.util.regex.Pattern PARENT_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");

            /**
             * Creates a new connector in a given Connect cluster.
             *
             * Create a request for the method "connectors.create".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
             * <p> {@link
             * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param parent Required. The parent Connect cluster in which to create the connector. Structured like
           *        `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
             * @param content the {@link com.google.api.services.managedkafka.v1.model.Connector}
             * @since 1.13
             */
            protected Create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.Connector content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Connector.class);
              this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
              }
            }

            @Override
            public Create set$Xgafv(java.lang.String $Xgafv) {
              return (Create) super.set$Xgafv($Xgafv);
            }

            @Override
            public Create setAccessToken(java.lang.String accessToken) {
              return (Create) super.setAccessToken(accessToken);
            }

            @Override
            public Create setAlt(java.lang.String alt) {
              return (Create) super.setAlt(alt);
            }

            @Override
            public Create setCallback(java.lang.String callback) {
              return (Create) super.setCallback(callback);
            }

            @Override
            public Create setFields(java.lang.String fields) {
              return (Create) super.setFields(fields);
            }

            @Override
            public Create setKey(java.lang.String key) {
              return (Create) super.setKey(key);
            }

            @Override
            public Create setOauthToken(java.lang.String oauthToken) {
              return (Create) super.setOauthToken(oauthToken);
            }

            @Override
            public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Create) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Create setQuotaUser(java.lang.String quotaUser) {
              return (Create) super.setQuotaUser(quotaUser);
            }

            @Override
            public Create setUploadType(java.lang.String uploadType) {
              return (Create) super.setUploadType(uploadType);
            }

            @Override
            public Create setUploadProtocol(java.lang.String uploadProtocol) {
              return (Create) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The parent Connect cluster in which to create the connector. Structured
             * like `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String parent;

            /** Required. The parent Connect cluster in which to create the connector. Structured like
           `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
             */
            public java.lang.String getParent() {
              return parent;
            }

            /**
             * Required. The parent Connect cluster in which to create the connector. Structured
             * like `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
             */
            public Create setParent(java.lang.String parent) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
              }
              this.parent = parent;
              return this;
            }

            /**
             * Required. The ID to use for the connector, which will become the final component of
             * the connector's name. The ID must be 1-63 characters long, and match the regular
             * expression `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value is
             * structured like: `my-connector-id`.
             */
            @com.google.api.client.util.Key
            private java.lang.String connectorId;

            /** Required. The ID to use for the connector, which will become the final component of the connector's
           name. The ID must be 1-63 characters long, and match the regular expression
           `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value is structured like: `my-connector-
           id`.
             */
            public java.lang.String getConnectorId() {
              return connectorId;
            }

            /**
             * Required. The ID to use for the connector, which will become the final component of
             * the connector's name. The ID must be 1-63 characters long, and match the regular
             * expression `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value is
             * structured like: `my-connector-id`.
             */
            public Create setConnectorId(java.lang.String connectorId) {
              this.connectorId = connectorId;
              return this;
            }

            @Override
            public Create set(String parameterName, Object value) {
              return (Create) super.set(parameterName, value);
            }
          }
          /**
           * Deletes a connector.
           *
           * Create a request for the method "connectors.delete".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the connector to delete. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
           * @return the request
           */
          public Delete delete(java.lang.String name) throws java.io.IOException {
            Delete result = new Delete(name);
            initialize(result);
            return result;
          }

          public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Empty> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");

            /**
             * Deletes a connector.
             *
             * Create a request for the method "connectors.delete".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
             * <p> {@link
             * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the connector to delete. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
             * @since 1.13
             */
            protected Delete(java.lang.String name) {
              super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Empty.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
            }

            @Override
            public Delete set$Xgafv(java.lang.String $Xgafv) {
              return (Delete) super.set$Xgafv($Xgafv);
            }

            @Override
            public Delete setAccessToken(java.lang.String accessToken) {
              return (Delete) super.setAccessToken(accessToken);
            }

            @Override
            public Delete setAlt(java.lang.String alt) {
              return (Delete) super.setAlt(alt);
            }

            @Override
            public Delete setCallback(java.lang.String callback) {
              return (Delete) super.setCallback(callback);
            }

            @Override
            public Delete setFields(java.lang.String fields) {
              return (Delete) super.setFields(fields);
            }

            @Override
            public Delete setKey(java.lang.String key) {
              return (Delete) super.setKey(key);
            }

            @Override
            public Delete setOauthToken(java.lang.String oauthToken) {
              return (Delete) super.setOauthToken(oauthToken);
            }

            @Override
            public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Delete) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Delete setQuotaUser(java.lang.String quotaUser) {
              return (Delete) super.setQuotaUser(quotaUser);
            }

            @Override
            public Delete setUploadType(java.lang.String uploadType) {
              return (Delete) super.setUploadType(uploadType);
            }

            @Override
            public Delete setUploadProtocol(java.lang.String uploadProtocol) {
              return (Delete) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the connector to delete. Structured like: projects/{project}/lo
             * cations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the connector to delete. Structured like:
           projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the connector to delete. Structured like: projects/{project}/lo
             * cations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public Delete setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Delete set(String parameterName, Object value) {
              return (Delete) super.set(parameterName, value);
            }
          }
          /**
           * Returns the properties of a single connector.
           *
           * Create a request for the method "connectors.get".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Get#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the connector whose configuration to return. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
           * @return the request
           */
          public Get get(java.lang.String name) throws java.io.IOException {
            Get result = new Get(name);
            initialize(result);
            return result;
          }

          public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Connector> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");

            /**
             * Returns the properties of a single connector.
             *
             * Create a request for the method "connectors.get".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
             * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the connector whose configuration to return. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
             * @since 1.13
             */
            protected Get(java.lang.String name) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Connector.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public Get set$Xgafv(java.lang.String $Xgafv) {
              return (Get) super.set$Xgafv($Xgafv);
            }

            @Override
            public Get setAccessToken(java.lang.String accessToken) {
              return (Get) super.setAccessToken(accessToken);
            }

            @Override
            public Get setAlt(java.lang.String alt) {
              return (Get) super.setAlt(alt);
            }

            @Override
            public Get setCallback(java.lang.String callback) {
              return (Get) super.setCallback(callback);
            }

            @Override
            public Get setFields(java.lang.String fields) {
              return (Get) super.setFields(fields);
            }

            @Override
            public Get setKey(java.lang.String key) {
              return (Get) super.setKey(key);
            }

            @Override
            public Get setOauthToken(java.lang.String oauthToken) {
              return (Get) super.setOauthToken(oauthToken);
            }

            @Override
            public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Get) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Get setQuotaUser(java.lang.String quotaUser) {
              return (Get) super.setQuotaUser(quotaUser);
            }

            @Override
            public Get setUploadType(java.lang.String uploadType) {
              return (Get) super.setUploadType(uploadType);
            }

            @Override
            public Get setUploadProtocol(java.lang.String uploadProtocol) {
              return (Get) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the connector whose configuration to return. Structured like: p
             * rojects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{c
             * onnector}
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the connector whose configuration to return. Structured like:
           projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the connector whose configuration to return. Structured like: p
             * rojects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{c
             * onnector}
             */
            public Get setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Get set(String parameterName, Object value) {
              return (Get) super.set(parameterName, value);
            }
          }
          /**
           * Lists the connectors in a given Connect cluster.
           *
           * Create a request for the method "connectors.list".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link List#execute()} method to invoke the remote operation.
           *
           * @param parent Required. The parent Connect cluster whose connectors are to be listed. Structured like
           *        `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           * @return the request
           */
          public List list(java.lang.String parent) throws java.io.IOException {
            List result = new List(parent);
            initialize(result);
            return result;
          }

          public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ListConnectorsResponse> {

            private static final String REST_PATH = "v1/{+parent}/connectors";

            private final java.util.regex.Pattern PARENT_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");

            /**
             * Lists the connectors in a given Connect cluster.
             *
             * Create a request for the method "connectors.list".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
             * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param parent Required. The parent Connect cluster whose connectors are to be listed. Structured like
           *        `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
             * @since 1.13
             */
            protected List(java.lang.String parent) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ListConnectorsResponse.class);
              this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public List set$Xgafv(java.lang.String $Xgafv) {
              return (List) super.set$Xgafv($Xgafv);
            }

            @Override
            public List setAccessToken(java.lang.String accessToken) {
              return (List) super.setAccessToken(accessToken);
            }

            @Override
            public List setAlt(java.lang.String alt) {
              return (List) super.setAlt(alt);
            }

            @Override
            public List setCallback(java.lang.String callback) {
              return (List) super.setCallback(callback);
            }

            @Override
            public List setFields(java.lang.String fields) {
              return (List) super.setFields(fields);
            }

            @Override
            public List setKey(java.lang.String key) {
              return (List) super.setKey(key);
            }

            @Override
            public List setOauthToken(java.lang.String oauthToken) {
              return (List) super.setOauthToken(oauthToken);
            }

            @Override
            public List setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (List) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public List setQuotaUser(java.lang.String quotaUser) {
              return (List) super.setQuotaUser(quotaUser);
            }

            @Override
            public List setUploadType(java.lang.String uploadType) {
              return (List) super.setUploadType(uploadType);
            }

            @Override
            public List setUploadProtocol(java.lang.String uploadProtocol) {
              return (List) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The parent Connect cluster whose connectors are to be listed. Structured
             * like `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String parent;

            /** Required. The parent Connect cluster whose connectors are to be listed. Structured like
           `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
             */
            public java.lang.String getParent() {
              return parent;
            }

            /**
             * Required. The parent Connect cluster whose connectors are to be listed. Structured
             * like `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
             */
            public List setParent(java.lang.String parent) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
              }
              this.parent = parent;
              return this;
            }

            /**
             * Optional. The maximum number of connectors to return. The service may return fewer
             * than this value. If unspecified, server will pick an appropriate default.
             */
            @com.google.api.client.util.Key
            private java.lang.Integer pageSize;

            /** Optional. The maximum number of connectors to return. The service may return fewer than this value.
           If unspecified, server will pick an appropriate default.
             */
            public java.lang.Integer getPageSize() {
              return pageSize;
            }

            /**
             * Optional. The maximum number of connectors to return. The service may return fewer
             * than this value. If unspecified, server will pick an appropriate default.
             */
            public List setPageSize(java.lang.Integer pageSize) {
              this.pageSize = pageSize;
              return this;
            }

            /**
             * Optional. A page token, received from a previous `ListConnectors` call. Provide this
             * to retrieve the subsequent page. When paginating, all other parameters provided to
             * `ListConnectors` must match the call that provided the page token.
             */
            @com.google.api.client.util.Key
            private java.lang.String pageToken;

            /** Optional. A page token, received from a previous `ListConnectors` call. Provide this to retrieve
           the subsequent page. When paginating, all other parameters provided to `ListConnectors` must match
           the call that provided the page token.
             */
            public java.lang.String getPageToken() {
              return pageToken;
            }

            /**
             * Optional. A page token, received from a previous `ListConnectors` call. Provide this
             * to retrieve the subsequent page. When paginating, all other parameters provided to
             * `ListConnectors` must match the call that provided the page token.
             */
            public List setPageToken(java.lang.String pageToken) {
              this.pageToken = pageToken;
              return this;
            }

            @Override
            public List set(String parameterName, Object value) {
              return (List) super.set(parameterName, value);
            }
          }
          /**
           * Updates the properties of a connector.
           *
           * Create a request for the method "connectors.patch".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Patch#execute()} method to invoke the remote operation.
           *
           * @param name Identifier. The name of the connector. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connect_cluster}/connectors/{conn
           *        ector}
           * @param content the {@link com.google.api.services.managedkafka.v1.model.Connector}
           * @return the request
           */
          public Patch patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.Connector content) throws java.io.IOException {
            Patch result = new Patch(name, content);
            initialize(result);
            return result;
          }

          public class Patch extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Connector> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");

            /**
             * Updates the properties of a connector.
             *
             * Create a request for the method "connectors.patch".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Patch#execute()} method to invoke the remote operation.
             * <p> {@link
             * Patch#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Identifier. The name of the connector. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connect_cluster}/connectors/{conn
           *        ector}
             * @param content the {@link com.google.api.services.managedkafka.v1.model.Connector}
             * @since 1.13
             */
            protected Patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.Connector content) {
              super(ManagedKafka.this, "PATCH", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Connector.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
            }

            @Override
            public Patch set$Xgafv(java.lang.String $Xgafv) {
              return (Patch) super.set$Xgafv($Xgafv);
            }

            @Override
            public Patch setAccessToken(java.lang.String accessToken) {
              return (Patch) super.setAccessToken(accessToken);
            }

            @Override
            public Patch setAlt(java.lang.String alt) {
              return (Patch) super.setAlt(alt);
            }

            @Override
            public Patch setCallback(java.lang.String callback) {
              return (Patch) super.setCallback(callback);
            }

            @Override
            public Patch setFields(java.lang.String fields) {
              return (Patch) super.setFields(fields);
            }

            @Override
            public Patch setKey(java.lang.String key) {
              return (Patch) super.setKey(key);
            }

            @Override
            public Patch setOauthToken(java.lang.String oauthToken) {
              return (Patch) super.setOauthToken(oauthToken);
            }

            @Override
            public Patch setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Patch) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Patch setQuotaUser(java.lang.String quotaUser) {
              return (Patch) super.setQuotaUser(quotaUser);
            }

            @Override
            public Patch setUploadType(java.lang.String uploadType) {
              return (Patch) super.setUploadType(uploadType);
            }

            @Override
            public Patch setUploadProtocol(java.lang.String uploadProtocol) {
              return (Patch) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Identifier. The name of the connector. Structured like: projects/{project}/locations/
             * {location}/connectClusters/{connect_cluster}/connectors/{connector}
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Identifier. The name of the connector. Structured like:
           projects/{project}/locations/{location}/connectClusters/{connect_cluster}/connectors/{connector}
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Identifier. The name of the connector. Structured like: projects/{project}/locations/
             * {location}/connectClusters/{connect_cluster}/connectors/{connector}
             */
            public Patch setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
              this.name = name;
              return this;
            }

            /**
             * Required. Field mask is used to specify the fields to be overwritten in the cluster
             * resource by the update. The fields specified in the update_mask are relative to the
             * resource, not the full request. A field will be overwritten if it is in the mask. The
             * mask is required and a value of * will update all fields.
             */
            @com.google.api.client.util.Key
            private String updateMask;

            /** Required. Field mask is used to specify the fields to be overwritten in the cluster resource by the
           update. The fields specified in the update_mask are relative to the resource, not the full request.
           A field will be overwritten if it is in the mask. The mask is required and a value of * will update
           all fields.
             */
            public String getUpdateMask() {
              return updateMask;
            }

            /**
             * Required. Field mask is used to specify the fields to be overwritten in the cluster
             * resource by the update. The fields specified in the update_mask are relative to the
             * resource, not the full request. A field will be overwritten if it is in the mask. The
             * mask is required and a value of * will update all fields.
             */
            public Patch setUpdateMask(String updateMask) {
              this.updateMask = updateMask;
              return this;
            }

            @Override
            public Patch set(String parameterName, Object value) {
              return (Patch) super.set(parameterName, value);
            }
          }
          /**
           * Pauses the connector and its tasks.
           *
           * Create a request for the method "connectors.pause".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Pause#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the connector to pause. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
           * @param content the {@link com.google.api.services.managedkafka.v1.model.PauseConnectorRequest}
           * @return the request
           */
          public Pause pause(java.lang.String name, com.google.api.services.managedkafka.v1.model.PauseConnectorRequest content) throws java.io.IOException {
            Pause result = new Pause(name, content);
            initialize(result);
            return result;
          }

          public class Pause extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.PauseConnectorResponse> {

            private static final String REST_PATH = "v1/{+name}:pause";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");

            /**
             * Pauses the connector and its tasks.
             *
             * Create a request for the method "connectors.pause".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Pause#execute()} method to invoke the remote operation.
             * <p> {@link
             * Pause#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the connector to pause. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
             * @param content the {@link com.google.api.services.managedkafka.v1.model.PauseConnectorRequest}
             * @since 1.13
             */
            protected Pause(java.lang.String name, com.google.api.services.managedkafka.v1.model.PauseConnectorRequest content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.PauseConnectorResponse.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
            }

            @Override
            public Pause set$Xgafv(java.lang.String $Xgafv) {
              return (Pause) super.set$Xgafv($Xgafv);
            }

            @Override
            public Pause setAccessToken(java.lang.String accessToken) {
              return (Pause) super.setAccessToken(accessToken);
            }

            @Override
            public Pause setAlt(java.lang.String alt) {
              return (Pause) super.setAlt(alt);
            }

            @Override
            public Pause setCallback(java.lang.String callback) {
              return (Pause) super.setCallback(callback);
            }

            @Override
            public Pause setFields(java.lang.String fields) {
              return (Pause) super.setFields(fields);
            }

            @Override
            public Pause setKey(java.lang.String key) {
              return (Pause) super.setKey(key);
            }

            @Override
            public Pause setOauthToken(java.lang.String oauthToken) {
              return (Pause) super.setOauthToken(oauthToken);
            }

            @Override
            public Pause setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Pause) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Pause setQuotaUser(java.lang.String quotaUser) {
              return (Pause) super.setQuotaUser(quotaUser);
            }

            @Override
            public Pause setUploadType(java.lang.String uploadType) {
              return (Pause) super.setUploadType(uploadType);
            }

            @Override
            public Pause setUploadProtocol(java.lang.String uploadProtocol) {
              return (Pause) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the connector to pause. Structured like: projects/{project}/loc
             * ations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the connector to pause. Structured like:
           projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the connector to pause. Structured like: projects/{project}/loc
             * ations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public Pause setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Pause set(String parameterName, Object value) {
              return (Pause) super.set(parameterName, value);
            }
          }
          /**
           * Restarts the connector.
           *
           * Create a request for the method "connectors.restart".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Restart#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the connector to restart. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
           * @param content the {@link com.google.api.services.managedkafka.v1.model.RestartConnectorRequest}
           * @return the request
           */
          public Restart restart(java.lang.String name, com.google.api.services.managedkafka.v1.model.RestartConnectorRequest content) throws java.io.IOException {
            Restart result = new Restart(name, content);
            initialize(result);
            return result;
          }

          public class Restart extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.RestartConnectorResponse> {

            private static final String REST_PATH = "v1/{+name}:restart";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");

            /**
             * Restarts the connector.
             *
             * Create a request for the method "connectors.restart".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Restart#execute()} method to invoke the remote operation.
             * <p> {@link
             * Restart#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the connector to restart. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
             * @param content the {@link com.google.api.services.managedkafka.v1.model.RestartConnectorRequest}
             * @since 1.13
             */
            protected Restart(java.lang.String name, com.google.api.services.managedkafka.v1.model.RestartConnectorRequest content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.RestartConnectorResponse.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
            }

            @Override
            public Restart set$Xgafv(java.lang.String $Xgafv) {
              return (Restart) super.set$Xgafv($Xgafv);
            }

            @Override
            public Restart setAccessToken(java.lang.String accessToken) {
              return (Restart) super.setAccessToken(accessToken);
            }

            @Override
            public Restart setAlt(java.lang.String alt) {
              return (Restart) super.setAlt(alt);
            }

            @Override
            public Restart setCallback(java.lang.String callback) {
              return (Restart) super.setCallback(callback);
            }

            @Override
            public Restart setFields(java.lang.String fields) {
              return (Restart) super.setFields(fields);
            }

            @Override
            public Restart setKey(java.lang.String key) {
              return (Restart) super.setKey(key);
            }

            @Override
            public Restart setOauthToken(java.lang.String oauthToken) {
              return (Restart) super.setOauthToken(oauthToken);
            }

            @Override
            public Restart setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Restart) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Restart setQuotaUser(java.lang.String quotaUser) {
              return (Restart) super.setQuotaUser(quotaUser);
            }

            @Override
            public Restart setUploadType(java.lang.String uploadType) {
              return (Restart) super.setUploadType(uploadType);
            }

            @Override
            public Restart setUploadProtocol(java.lang.String uploadProtocol) {
              return (Restart) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the connector to restart. Structured like: projects/{project}/l
             * ocations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the connector to restart. Structured like:
           projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the connector to restart. Structured like: projects/{project}/l
             * ocations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public Restart setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Restart set(String parameterName, Object value) {
              return (Restart) super.set(parameterName, value);
            }
          }
          /**
           * Resumes the connector and its tasks.
           *
           * Create a request for the method "connectors.resume".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Resume#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the connector to pause. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
           * @param content the {@link com.google.api.services.managedkafka.v1.model.ResumeConnectorRequest}
           * @return the request
           */
          public Resume resume(java.lang.String name, com.google.api.services.managedkafka.v1.model.ResumeConnectorRequest content) throws java.io.IOException {
            Resume result = new Resume(name, content);
            initialize(result);
            return result;
          }

          public class Resume extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ResumeConnectorResponse> {

            private static final String REST_PATH = "v1/{+name}:resume";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");

            /**
             * Resumes the connector and its tasks.
             *
             * Create a request for the method "connectors.resume".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Resume#execute()} method to invoke the remote operation.
             * <p> {@link
             * Resume#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the connector to pause. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
             * @param content the {@link com.google.api.services.managedkafka.v1.model.ResumeConnectorRequest}
             * @since 1.13
             */
            protected Resume(java.lang.String name, com.google.api.services.managedkafka.v1.model.ResumeConnectorRequest content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.ResumeConnectorResponse.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
            }

            @Override
            public Resume set$Xgafv(java.lang.String $Xgafv) {
              return (Resume) super.set$Xgafv($Xgafv);
            }

            @Override
            public Resume setAccessToken(java.lang.String accessToken) {
              return (Resume) super.setAccessToken(accessToken);
            }

            @Override
            public Resume setAlt(java.lang.String alt) {
              return (Resume) super.setAlt(alt);
            }

            @Override
            public Resume setCallback(java.lang.String callback) {
              return (Resume) super.setCallback(callback);
            }

            @Override
            public Resume setFields(java.lang.String fields) {
              return (Resume) super.setFields(fields);
            }

            @Override
            public Resume setKey(java.lang.String key) {
              return (Resume) super.setKey(key);
            }

            @Override
            public Resume setOauthToken(java.lang.String oauthToken) {
              return (Resume) super.setOauthToken(oauthToken);
            }

            @Override
            public Resume setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Resume) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Resume setQuotaUser(java.lang.String quotaUser) {
              return (Resume) super.setQuotaUser(quotaUser);
            }

            @Override
            public Resume setUploadType(java.lang.String uploadType) {
              return (Resume) super.setUploadType(uploadType);
            }

            @Override
            public Resume setUploadProtocol(java.lang.String uploadProtocol) {
              return (Resume) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the connector to pause. Structured like: projects/{project}/loc
             * ations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the connector to pause. Structured like:
           projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the connector to pause. Structured like: projects/{project}/loc
             * ations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public Resume setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Resume set(String parameterName, Object value) {
              return (Resume) super.set(parameterName, value);
            }
          }
          /**
           * Stops the connector.
           *
           * Create a request for the method "connectors.stop".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Stop#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the connector to stop. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
           * @param content the {@link com.google.api.services.managedkafka.v1.model.StopConnectorRequest}
           * @return the request
           */
          public Stop stop(java.lang.String name, com.google.api.services.managedkafka.v1.model.StopConnectorRequest content) throws java.io.IOException {
            Stop result = new Stop(name, content);
            initialize(result);
            return result;
          }

          public class Stop extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.StopConnectorResponse> {

            private static final String REST_PATH = "v1/{+name}:stop";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");

            /**
             * Stops the connector.
             *
             * Create a request for the method "connectors.stop".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Stop#execute()} method to invoke the remote operation. <p>
             * {@link Stop#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the connector to stop. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
             * @param content the {@link com.google.api.services.managedkafka.v1.model.StopConnectorRequest}
             * @since 1.13
             */
            protected Stop(java.lang.String name, com.google.api.services.managedkafka.v1.model.StopConnectorRequest content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.StopConnectorResponse.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
            }

            @Override
            public Stop set$Xgafv(java.lang.String $Xgafv) {
              return (Stop) super.set$Xgafv($Xgafv);
            }

            @Override
            public Stop setAccessToken(java.lang.String accessToken) {
              return (Stop) super.setAccessToken(accessToken);
            }

            @Override
            public Stop setAlt(java.lang.String alt) {
              return (Stop) super.setAlt(alt);
            }

            @Override
            public Stop setCallback(java.lang.String callback) {
              return (Stop) super.setCallback(callback);
            }

            @Override
            public Stop setFields(java.lang.String fields) {
              return (Stop) super.setFields(fields);
            }

            @Override
            public Stop setKey(java.lang.String key) {
              return (Stop) super.setKey(key);
            }

            @Override
            public Stop setOauthToken(java.lang.String oauthToken) {
              return (Stop) super.setOauthToken(oauthToken);
            }

            @Override
            public Stop setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Stop) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Stop setQuotaUser(java.lang.String quotaUser) {
              return (Stop) super.setQuotaUser(quotaUser);
            }

            @Override
            public Stop setUploadType(java.lang.String uploadType) {
              return (Stop) super.setUploadType(uploadType);
            }

            @Override
            public Stop setUploadProtocol(java.lang.String uploadProtocol) {
              return (Stop) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the connector to stop. Structured like: projects/{project}/loca
             * tions/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the connector to stop. Structured like:
           projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the connector to stop. Structured like: projects/{project}/loca
             * tions/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public Stop setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Stop set(String parameterName, Object value) {
              return (Stop) super.set(parameterName, value);
            }
          }

        }
      }
      /**
       * An accessor for creating requests from the Operations collection.
       *
       * <p>The typical use is:</p>
       * <pre>
       *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
       *   {@code ManagedKafka.Operations.List request = managedkafka.operations().list(parameters ...)}
       * </pre>
       *
       * @return the resource collection
       */
      public Operations operations() {
        return new Operations();
      }

      /**
       * The "operations" collection of methods.
       */
      public class Operations {

        /**
         * Starts asynchronous cancellation on a long-running operation. The server makes a best effort to
         * cancel the operation, but success is not guaranteed. If the server doesn't support this method,
         * it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other
         * methods to check whether the cancellation succeeded or whether the operation completed despite
         * cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an
         * operation with an Operation.error value with a google.rpc.Status.code of `1`, corresponding to
         * `Code.CANCELLED`.
         *
         * Create a request for the method "operations.cancel".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Cancel#execute()} method to invoke the remote operation.
         *
         * @param name The name of the operation resource to be cancelled.
         * @param content the {@link com.google.api.services.managedkafka.v1.model.CancelOperationRequest}
         * @return the request
         */
        public Cancel cancel(java.lang.String name, com.google.api.services.managedkafka.v1.model.CancelOperationRequest content) throws java.io.IOException {
          Cancel result = new Cancel(name, content);
          initialize(result);
          return result;
        }

        public class Cancel extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Empty> {

          private static final String REST_PATH = "v1/{+name}:cancel";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/operations/[^/]+$");

          /**
           * Starts asynchronous cancellation on a long-running operation. The server makes a best effort to
           * cancel the operation, but success is not guaranteed. If the server doesn't support this method,
           * it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other
           * methods to check whether the cancellation succeeded or whether the operation completed despite
           * cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an
           * operation with an Operation.error value with a google.rpc.Status.code of `1`, corresponding to
           * `Code.CANCELLED`.
           *
           * Create a request for the method "operations.cancel".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Cancel#execute()} method to invoke the remote operation.
           * <p> {@link
           * Cancel#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
           * be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name The name of the operation resource to be cancelled.
           * @param content the {@link com.google.api.services.managedkafka.v1.model.CancelOperationRequest}
           * @since 1.13
           */
          protected Cancel(java.lang.String name, com.google.api.services.managedkafka.v1.model.CancelOperationRequest content) {
            super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Empty.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/operations/[^/]+$");
            }
          }

          @Override
          public Cancel set$Xgafv(java.lang.String $Xgafv) {
            return (Cancel) super.set$Xgafv($Xgafv);
          }

          @Override
          public Cancel setAccessToken(java.lang.String accessToken) {
            return (Cancel) super.setAccessToken(accessToken);
          }

          @Override
          public Cancel setAlt(java.lang.String alt) {
            return (Cancel) super.setAlt(alt);
          }

          @Override
          public Cancel setCallback(java.lang.String callback) {
            return (Cancel) super.setCallback(callback);
          }

          @Override
          public Cancel setFields(java.lang.String fields) {
            return (Cancel) super.setFields(fields);
          }

          @Override
          public Cancel setKey(java.lang.String key) {
            return (Cancel) super.setKey(key);
          }

          @Override
          public Cancel setOauthToken(java.lang.String oauthToken) {
            return (Cancel) super.setOauthToken(oauthToken);
          }

          @Override
          public Cancel setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Cancel) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Cancel setQuotaUser(java.lang.String quotaUser) {
            return (Cancel) super.setQuotaUser(quotaUser);
          }

          @Override
          public Cancel setUploadType(java.lang.String uploadType) {
            return (Cancel) super.setUploadType(uploadType);
          }

          @Override
          public Cancel setUploadProtocol(java.lang.String uploadProtocol) {
            return (Cancel) super.setUploadProtocol(uploadProtocol);
          }

          /** The name of the operation resource to be cancelled. */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** The name of the operation resource to be cancelled.
           */
          public java.lang.String getName() {
            return name;
          }

          /** The name of the operation resource to be cancelled. */
          public Cancel setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/operations/[^/]+$");
            }
            this.name = name;
            return this;
          }

          @Override
          public Cancel set(String parameterName, Object value) {
            return (Cancel) super.set(parameterName, value);
          }
        }
        /**
         * Deletes a long-running operation. This method indicates that the client is no longer interested
         * in the operation result. It does not cancel the operation. If the server doesn't support this
         * method, it returns `google.rpc.Code.UNIMPLEMENTED`.
         *
         * Create a request for the method "operations.delete".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
         *
         * @param name The name of the operation resource to be deleted.
         * @return the request
         */
        public Delete delete(java.lang.String name) throws java.io.IOException {
          Delete result = new Delete(name);
          initialize(result);
          return result;
        }

        public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Empty> {

          private static final String REST_PATH = "v1/{+name}";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/operations/[^/]+$");

          /**
           * Deletes a long-running operation. This method indicates that the client is no longer interested
           * in the operation result. It does not cancel the operation. If the server doesn't support this
           * method, it returns `google.rpc.Code.UNIMPLEMENTED`.
           *
           * Create a request for the method "operations.delete".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
           * <p> {@link
           * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
           * be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name The name of the operation resource to be deleted.
           * @since 1.13
           */
          protected Delete(java.lang.String name) {
            super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Empty.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/operations/[^/]+$");
            }
          }

          @Override
          public Delete set$Xgafv(java.lang.String $Xgafv) {
            return (Delete) super.set$Xgafv($Xgafv);
          }

          @Override
          public Delete setAccessToken(java.lang.String accessToken) {
            return (Delete) super.setAccessToken(accessToken);
          }

          @Override
          public Delete setAlt(java.lang.String alt) {
            return (Delete) super.setAlt(alt);
          }

          @Override
          public Delete setCallback(java.lang.String callback) {
            return (Delete) super.setCallback(callback);
          }

          @Override
          public Delete setFields(java.lang.String fields) {
            return (Delete) super.setFields(fields);
          }

          @Override
          public Delete setKey(java.lang.String key) {
            return (Delete) super.setKey(key);
          }

          @Override
          public Delete setOauthToken(java.lang.String oauthToken) {
            return (Delete) super.setOauthToken(oauthToken);
          }

          @Override
          public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Delete) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Delete setQuotaUser(java.lang.String quotaUser) {
            return (Delete) super.setQuotaUser(quotaUser);
          }

          @Override
          public Delete setUploadType(java.lang.String uploadType) {
            return (Delete) super.setUploadType(uploadType);
          }

          @Override
          public Delete setUploadProtocol(java.lang.String uploadProtocol) {
            return (Delete) super.setUploadProtocol(uploadProtocol);
          }

          /** The name of the operation resource to be deleted. */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** The name of the operation resource to be deleted.
           */
          public java.lang.String getName() {
            return name;
          }

          /** The name of the operation resource to be deleted. */
          public Delete setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/operations/[^/]+$");
            }
            this.name = name;
            return this;
          }

          @Override
          public Delete set(String parameterName, Object value) {
            return (Delete) super.set(parameterName, value);
          }
        }
        /**
         * Gets the latest state of a long-running operation. Clients can use this method to poll the
         * operation result at intervals as recommended by the API service.
         *
         * Create a request for the method "operations.get".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Get#execute()} method to invoke the remote operation.
         *
         * @param name The name of the operation resource.
         * @return the request
         */
        public Get get(java.lang.String name) throws java.io.IOException {
          Get result = new Get(name);
          initialize(result);
          return result;
        }

        public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Operation> {

          private static final String REST_PATH = "v1/{+name}";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/operations/[^/]+$");

          /**
           * Gets the latest state of a long-running operation. Clients can use this method to poll the
           * operation result at intervals as recommended by the API service.
           *
           * Create a request for the method "operations.get".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
           * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
           * must be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name The name of the operation resource.
           * @since 1.13
           */
          protected Get(java.lang.String name) {
            super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Operation.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/operations/[^/]+$");
            }
          }

          @Override
          public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
            return super.executeUsingHead();
          }

          @Override
          public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
            return super.buildHttpRequestUsingHead();
          }

          @Override
          public Get set$Xgafv(java.lang.String $Xgafv) {
            return (Get) super.set$Xgafv($Xgafv);
          }

          @Override
          public Get setAccessToken(java.lang.String accessToken) {
            return (Get) super.setAccessToken(accessToken);
          }

          @Override
          public Get setAlt(java.lang.String alt) {
            return (Get) super.setAlt(alt);
          }

          @Override
          public Get setCallback(java.lang.String callback) {
            return (Get) super.setCallback(callback);
          }

          @Override
          public Get setFields(java.lang.String fields) {
            return (Get) super.setFields(fields);
          }

          @Override
          public Get setKey(java.lang.String key) {
            return (Get) super.setKey(key);
          }

          @Override
          public Get setOauthToken(java.lang.String oauthToken) {
            return (Get) super.setOauthToken(oauthToken);
          }

          @Override
          public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Get) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Get setQuotaUser(java.lang.String quotaUser) {
            return (Get) super.setQuotaUser(quotaUser);
          }

          @Override
          public Get setUploadType(java.lang.String uploadType) {
            return (Get) super.setUploadType(uploadType);
          }

          @Override
          public Get setUploadProtocol(java.lang.String uploadProtocol) {
            return (Get) super.setUploadProtocol(uploadProtocol);
          }

          /** The name of the operation resource. */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** The name of the operation resource.
           */
          public java.lang.String getName() {
            return name;
          }

          /** The name of the operation resource. */
          public Get setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/operations/[^/]+$");
            }
            this.name = name;
            return this;
          }

          @Override
          public Get set(String parameterName, Object value) {
            return (Get) super.set(parameterName, value);
          }
        }
        /**
         * Lists operations that match the specified filter in the request. If the server doesn't support
         * this method, it returns `UNIMPLEMENTED`.
         *
         * Create a request for the method "operations.list".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link List#execute()} method to invoke the remote operation.
         *
         * @param name The name of the operation's parent resource.
         * @return the request
         */
        public List list(java.lang.String name) throws java.io.IOException {
          List result = new List(name);
          initialize(result);
          return result;
        }

        public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ListOperationsResponse> {

          private static final String REST_PATH = "v1/{+name}/operations";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+$");

          /**
           * Lists operations that match the specified filter in the request. If the server doesn't support
           * this method, it returns `UNIMPLEMENTED`.
           *
           * Create a request for the method "operations.list".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
           * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
           * must be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name The name of the operation's parent resource.
           * @since 1.13
           */
          protected List(java.lang.String name) {
            super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ListOperationsResponse.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
          }

          @Override
          public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
            return super.executeUsingHead();
          }

          @Override
          public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
            return super.buildHttpRequestUsingHead();
          }

          @Override
          public List set$Xgafv(java.lang.String $Xgafv) {
            return (List) super.set$Xgafv($Xgafv);
          }

          @Override
          public List setAccessToken(java.lang.String accessToken) {
            return (List) super.setAccessToken(accessToken);
          }

          @Override
          public List setAlt(java.lang.String alt) {
            return (List) super.setAlt(alt);
          }

          @Override
          public List setCallback(java.lang.String callback) {
            return (List) super.setCallback(callback);
          }

          @Override
          public List setFields(java.lang.String fields) {
            return (List) super.setFields(fields);
          }

          @Override
          public List setKey(java.lang.String key) {
            return (List) super.setKey(key);
          }

          @Override
          public List setOauthToken(java.lang.String oauthToken) {
            return (List) super.setOauthToken(oauthToken);
          }

          @Override
          public List setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (List) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public List setQuotaUser(java.lang.String quotaUser) {
            return (List) super.setQuotaUser(quotaUser);
          }

          @Override
          public List setUploadType(java.lang.String uploadType) {
            return (List) super.setUploadType(uploadType);
          }

          @Override
          public List setUploadProtocol(java.lang.String uploadProtocol) {
            return (List) super.setUploadProtocol(uploadProtocol);
          }

          /** The name of the operation's parent resource. */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** The name of the operation's parent resource.
           */
          public java.lang.String getName() {
            return name;
          }

          /** The name of the operation's parent resource. */
          public List setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
            this.name = name;
            return this;
          }

          /** The standard list filter. */
          @com.google.api.client.util.Key
          private java.lang.String filter;

          /** The standard list filter.
           */
          public java.lang.String getFilter() {
            return filter;
          }

          /** The standard list filter. */
          public List setFilter(java.lang.String filter) {
            this.filter = filter;
            return this;
          }

          /** The standard list page size. */
          @com.google.api.client.util.Key
          private java.lang.Integer pageSize;

          /** The standard list page size.
           */
          public java.lang.Integer getPageSize() {
            return pageSize;
          }

          /** The standard list page size. */
          public List setPageSize(java.lang.Integer pageSize) {
            this.pageSize = pageSize;
            return this;
          }

          /** The standard list page token. */
          @com.google.api.client.util.Key
          private java.lang.String pageToken;

          /** The standard list page token.
           */
          public java.lang.String getPageToken() {
            return pageToken;
          }

          /** The standard list page token. */
          public List setPageToken(java.lang.String pageToken) {
            this.pageToken = pageToken;
            return this;
          }

          @Override
          public List set(String parameterName, Object value) {
            return (List) super.set(parameterName, value);
          }
        }

      }
    }
  }

  /**
   * Builder for {@link ManagedKafka}.
   *
   * <p>
   * Implementation is not thread-safe.
   * </p>
   *
   * @since 1.3.0
   */
  public static final class Builder extends com.google.api.client.googleapis.services.json.AbstractGoogleJsonClient.Builder {

    private static String chooseEndpoint(com.google.api.client.http.HttpTransport transport) {
      // If the GOOGLE_API_USE_MTLS_ENDPOINT environment variable value is "always", use mTLS endpoint.
      // If the env variable is "auto", use mTLS endpoint if and only if the transport is mTLS.
      // Use the regular endpoint for all other cases.
      String useMtlsEndpoint = System.getenv("GOOGLE_API_USE_MTLS_ENDPOINT");
      useMtlsEndpoint = useMtlsEndpoint == null ? "auto" : useMtlsEndpoint;
      if ("always".equals(useMtlsEndpoint) || ("auto".equals(useMtlsEndpoint) && transport != null && transport.isMtls())) {
        return DEFAULT_MTLS_ROOT_URL;
      }
      return DEFAULT_ROOT_URL;
    }

    /**
     * Returns an instance of a new builder.
     *
     * @param transport HTTP transport, which should normally be:
     *        <ul>
     *        <li>Google App Engine:
     *        {@code com.google.api.client.extensions.appengine.http.UrlFetchTransport}</li>
     *        <li>Android: {@code newCompatibleTransport} from
     *        {@code com.google.api.client.extensions.android.http.AndroidHttp}</li>
     *        <li>Java: {@link com.google.api.client.googleapis.javanet.GoogleNetHttpTransport#newTrustedTransport()}
     *        </li>
     *        </ul>
     * @param jsonFactory JSON factory, which may be:
     *        <ul>
     *        <li>Jackson: {@code com.google.api.client.json.jackson2.JacksonFactory}</li>
     *        <li>Google GSON: {@code com.google.api.client.json.gson.GsonFactory}</li>
     *        <li>Android Honeycomb or higher:
     *        {@code com.google.api.client.extensions.android.json.AndroidJsonFactory}</li>
     *        </ul>
     * @param httpRequestInitializer HTTP request initializer or {@code null} for none
     * @since 1.7
     */
    public Builder(com.google.api.client.http.HttpTransport transport, com.google.api.client.json.JsonFactory jsonFactory,
        com.google.api.client.http.HttpRequestInitializer httpRequestInitializer) {
      super(
          transport,
          jsonFactory,
          Builder.chooseEndpoint(transport),
          DEFAULT_SERVICE_PATH,
          httpRequestInitializer,
          false);
      setBatchPath(DEFAULT_BATCH_PATH);
    }

    /** Builds a new instance of {@link ManagedKafka}. */
    @Override
    public ManagedKafka build() {
      return new ManagedKafka(this);
    }

    @Override
    public Builder setRootUrl(String rootUrl) {
      return (Builder) super.setRootUrl(rootUrl);
    }

    @Override
    public Builder setServicePath(String servicePath) {
      return (Builder) super.setServicePath(servicePath);
    }

    @Override
    public Builder setBatchPath(String batchPath) {
      return (Builder) super.setBatchPath(batchPath);
    }

    @Override
    public Builder setHttpRequestInitializer(com.google.api.client.http.HttpRequestInitializer httpRequestInitializer) {
      return (Builder) super.setHttpRequestInitializer(httpRequestInitializer);
    }

    @Override
    public Builder setApplicationName(String applicationName) {
      return (Builder) super.setApplicationName(applicationName);
    }

    @Override
    public Builder setSuppressPatternChecks(boolean suppressPatternChecks) {
      return (Builder) super.setSuppressPatternChecks(suppressPatternChecks);
    }

    @Override
    public Builder setSuppressRequiredParameterChecks(boolean suppressRequiredParameterChecks) {
      return (Builder) super.setSuppressRequiredParameterChecks(suppressRequiredParameterChecks);
    }

    @Override
    public Builder setSuppressAllChecks(boolean suppressAllChecks) {
      return (Builder) super.setSuppressAllChecks(suppressAllChecks);
    }

    /**
     * Set the {@link ManagedKafkaRequestInitializer}.
     *
     * @since 1.12
     */
    public Builder setManagedKafkaRequestInitializer(
        ManagedKafkaRequestInitializer managedkafkaRequestInitializer) {
      return (Builder) super.setGoogleClientRequestInitializer(managedkafkaRequestInitializer);
    }

    @Override
    public Builder setGoogleClientRequestInitializer(
        com.google.api.client.googleapis.services.GoogleClientRequestInitializer googleClientRequestInitializer) {
      return (Builder) super.setGoogleClientRequestInitializer(googleClientRequestInitializer);
    }

    @Override
    public Builder setUniverseDomain(String universeDomain) {
      return (Builder) super.setUniverseDomain(universeDomain);
    }
  }
}
