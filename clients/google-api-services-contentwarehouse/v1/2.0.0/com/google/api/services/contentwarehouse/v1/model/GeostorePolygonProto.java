/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.contentwarehouse.v1.model;

/**
 * A general non-self-intersecting spherical polygon, consisting of one or more loops defining
 * multiple disconnected regions possibly with holes. All loops should be oriented CCW around the
 * region they define. This applies to the exterior loop(s) as well as any holes. Within MapFacts
 * (and underlying infrastructure) the data fields may be replaced by a single shape_id stored in
 * internal_feature. Any such PolygonProtos shouldn't be expected to work with public functions in
 * //geostore/base/public/polygon.h.
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the Document AI Warehouse API. For a detailed explanation
 * see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class GeostorePolygonProto extends com.google.api.client.json.GenericJson {

  /**
   * The polygon loops above are basically flat: each point has a latitude and a longitude but no
   * altitude. We don't want to build real 3D models here, but we do want to be able to generate
   * 2.5D models. A 2.5D model is built by translating the flat polygon upward some distance (base)
   * then extruding it upward some additional distance (height). The elevation of the bottom of the
   * extruded polygon (above ground level).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Float baseMeters;

  /**
   * ** DEPRECATED ** This is part of a splitting strategy for large polygons, which was never fully
   * launched and we decided not to pursue. For features with very complex polygonal geometry, we
   * break up the polygon into pieces that align with S2 cells at various levels. We do this for
   * performance reasons as some geometry operations have quadratic complexity with regards to the
   * total number of vertices. In these cases, we store the S2 cell ID corresponding to the piece of
   * the overall polygon that is described by this specific PolygonProto message. Each polygon piece
   * is expected to be fully contained by the S2 cell corresponding to this cell ID. However, note
   * that the S2 cell ID is not required to correspond to the smallest S2 cell that fully contains
   * the polygon (and often won't be). In addition, polygon pieces are required to not have any
   * overlap (which translates to having entirely disjoint S2 cell IDs, i.e. one can not be parent
   * (or grand parent, etc.) of another).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.math.BigInteger cellId;

  /**
   * Encoding of the polygon using S2Polygon::Encode()'s compressed representation.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String encoded;

  /**
   * The distance from the bottom of the extruded polygon to the top.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Float heightMeters;

  /**
   * ** DEPRECATED ** We have switched to using exclusively the encoded form in the wire format to
   * and from MapFacts, so this field should never be populated there. See go/encoded-polygons for
   * more info. "Classic" polygon representation, defined by one or more loops. The last vertex of
   * each polyline is implicitly connected to the first vertex. All loops should be specified in CCW
   * order.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostorePolyLineProto> loop;

  static {
    // hack to force ProGuard to consider GeostorePolyLineProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostorePolyLineProto.class);
  }

  /**
   * Field-level metadata for this polygon.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFieldMetadataProto metadata;

  /**
   * A place for clients to attach arbitrary data to a polygon. Never set in MapFacts.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private Proto2BridgeMessageSet temporaryData;

  /**
   * Some polygons are known to be rough proxies for a feature's "real" polygonal representation.
   * Such polygons are generally unsuitable for display. Rendering clients should not show these in
   * most cases. Polygons unsuitable for display do have other uses, such as user location or
   * containment analysis, or as an input to learning algorithms. This is an orthogonal concept to
   * FeatureProto.synthetic_geometry, which only pertains to the method by which a polygon was
   * created, rather than its fidelity to ground truth. For features that have multiple polygons,
   * this bit should be consistently set to the same value on all polygons.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean unsuitableForDisplay;

  /**
   * The polygon loops above are basically flat: each point has a latitude and a longitude but no
   * altitude. We don't want to build real 3D models here, but we do want to be able to generate
   * 2.5D models. A 2.5D model is built by translating the flat polygon upward some distance (base)
   * then extruding it upward some additional distance (height). The elevation of the bottom of the
   * extruded polygon (above ground level).
   * @return value or {@code null} for none
   */
  public java.lang.Float getBaseMeters() {
    return baseMeters;
  }

  /**
   * The polygon loops above are basically flat: each point has a latitude and a longitude but no
   * altitude. We don't want to build real 3D models here, but we do want to be able to generate
   * 2.5D models. A 2.5D model is built by translating the flat polygon upward some distance (base)
   * then extruding it upward some additional distance (height). The elevation of the bottom of the
   * extruded polygon (above ground level).
   * @param baseMeters baseMeters or {@code null} for none
   */
  public GeostorePolygonProto setBaseMeters(java.lang.Float baseMeters) {
    this.baseMeters = baseMeters;
    return this;
  }

  /**
   * ** DEPRECATED ** This is part of a splitting strategy for large polygons, which was never fully
   * launched and we decided not to pursue. For features with very complex polygonal geometry, we
   * break up the polygon into pieces that align with S2 cells at various levels. We do this for
   * performance reasons as some geometry operations have quadratic complexity with regards to the
   * total number of vertices. In these cases, we store the S2 cell ID corresponding to the piece of
   * the overall polygon that is described by this specific PolygonProto message. Each polygon piece
   * is expected to be fully contained by the S2 cell corresponding to this cell ID. However, note
   * that the S2 cell ID is not required to correspond to the smallest S2 cell that fully contains
   * the polygon (and often won't be). In addition, polygon pieces are required to not have any
   * overlap (which translates to having entirely disjoint S2 cell IDs, i.e. one can not be parent
   * (or grand parent, etc.) of another).
   * @return value or {@code null} for none
   */
  public java.math.BigInteger getCellId() {
    return cellId;
  }

  /**
   * ** DEPRECATED ** This is part of a splitting strategy for large polygons, which was never fully
   * launched and we decided not to pursue. For features with very complex polygonal geometry, we
   * break up the polygon into pieces that align with S2 cells at various levels. We do this for
   * performance reasons as some geometry operations have quadratic complexity with regards to the
   * total number of vertices. In these cases, we store the S2 cell ID corresponding to the piece of
   * the overall polygon that is described by this specific PolygonProto message. Each polygon piece
   * is expected to be fully contained by the S2 cell corresponding to this cell ID. However, note
   * that the S2 cell ID is not required to correspond to the smallest S2 cell that fully contains
   * the polygon (and often won't be). In addition, polygon pieces are required to not have any
   * overlap (which translates to having entirely disjoint S2 cell IDs, i.e. one can not be parent
   * (or grand parent, etc.) of another).
   * @param cellId cellId or {@code null} for none
   */
  public GeostorePolygonProto setCellId(java.math.BigInteger cellId) {
    this.cellId = cellId;
    return this;
  }

  /**
   * Encoding of the polygon using S2Polygon::Encode()'s compressed representation.
   * @see #decodeEncoded()
   * @return value or {@code null} for none
   */
  public java.lang.String getEncoded() {
    return encoded;
  }

  /**
   * Encoding of the polygon using S2Polygon::Encode()'s compressed representation.
   * @see #getEncoded()
   * @return Base64 decoded value or {@code null} for none
   *
   * @since 1.14
   */
  public byte[] decodeEncoded() {
    return com.google.api.client.util.Base64.decodeBase64(encoded);
  }

  /**
   * Encoding of the polygon using S2Polygon::Encode()'s compressed representation.
   * @see #encodeEncoded()
   * @param encoded encoded or {@code null} for none
   */
  public GeostorePolygonProto setEncoded(java.lang.String encoded) {
    this.encoded = encoded;
    return this;
  }

  /**
   * Encoding of the polygon using S2Polygon::Encode()'s compressed representation.
   * @see #setEncoded()
   *
   * <p>
   * The value is encoded Base64 or {@code null} for none.
   * </p>
   *
   * @since 1.14
   */
  public GeostorePolygonProto encodeEncoded(byte[] encoded) {
    this.encoded = com.google.api.client.util.Base64.encodeBase64URLSafeString(encoded);
    return this;
  }

  /**
   * The distance from the bottom of the extruded polygon to the top.
   * @return value or {@code null} for none
   */
  public java.lang.Float getHeightMeters() {
    return heightMeters;
  }

  /**
   * The distance from the bottom of the extruded polygon to the top.
   * @param heightMeters heightMeters or {@code null} for none
   */
  public GeostorePolygonProto setHeightMeters(java.lang.Float heightMeters) {
    this.heightMeters = heightMeters;
    return this;
  }

  /**
   * ** DEPRECATED ** We have switched to using exclusively the encoded form in the wire format to
   * and from MapFacts, so this field should never be populated there. See go/encoded-polygons for
   * more info. "Classic" polygon representation, defined by one or more loops. The last vertex of
   * each polyline is implicitly connected to the first vertex. All loops should be specified in CCW
   * order.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostorePolyLineProto> getLoop() {
    return loop;
  }

  /**
   * ** DEPRECATED ** We have switched to using exclusively the encoded form in the wire format to
   * and from MapFacts, so this field should never be populated there. See go/encoded-polygons for
   * more info. "Classic" polygon representation, defined by one or more loops. The last vertex of
   * each polyline is implicitly connected to the first vertex. All loops should be specified in CCW
   * order.
   * @param loop loop or {@code null} for none
   */
  public GeostorePolygonProto setLoop(java.util.List<GeostorePolyLineProto> loop) {
    this.loop = loop;
    return this;
  }

  /**
   * Field-level metadata for this polygon.
   * @return value or {@code null} for none
   */
  public GeostoreFieldMetadataProto getMetadata() {
    return metadata;
  }

  /**
   * Field-level metadata for this polygon.
   * @param metadata metadata or {@code null} for none
   */
  public GeostorePolygonProto setMetadata(GeostoreFieldMetadataProto metadata) {
    this.metadata = metadata;
    return this;
  }

  /**
   * A place for clients to attach arbitrary data to a polygon. Never set in MapFacts.
   * @return value or {@code null} for none
   */
  public Proto2BridgeMessageSet getTemporaryData() {
    return temporaryData;
  }

  /**
   * A place for clients to attach arbitrary data to a polygon. Never set in MapFacts.
   * @param temporaryData temporaryData or {@code null} for none
   */
  public GeostorePolygonProto setTemporaryData(Proto2BridgeMessageSet temporaryData) {
    this.temporaryData = temporaryData;
    return this;
  }

  /**
   * Some polygons are known to be rough proxies for a feature's "real" polygonal representation.
   * Such polygons are generally unsuitable for display. Rendering clients should not show these in
   * most cases. Polygons unsuitable for display do have other uses, such as user location or
   * containment analysis, or as an input to learning algorithms. This is an orthogonal concept to
   * FeatureProto.synthetic_geometry, which only pertains to the method by which a polygon was
   * created, rather than its fidelity to ground truth. For features that have multiple polygons,
   * this bit should be consistently set to the same value on all polygons.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getUnsuitableForDisplay() {
    return unsuitableForDisplay;
  }

  /**
   * Some polygons are known to be rough proxies for a feature's "real" polygonal representation.
   * Such polygons are generally unsuitable for display. Rendering clients should not show these in
   * most cases. Polygons unsuitable for display do have other uses, such as user location or
   * containment analysis, or as an input to learning algorithms. This is an orthogonal concept to
   * FeatureProto.synthetic_geometry, which only pertains to the method by which a polygon was
   * created, rather than its fidelity to ground truth. For features that have multiple polygons,
   * this bit should be consistently set to the same value on all polygons.
   * @param unsuitableForDisplay unsuitableForDisplay or {@code null} for none
   */
  public GeostorePolygonProto setUnsuitableForDisplay(java.lang.Boolean unsuitableForDisplay) {
    this.unsuitableForDisplay = unsuitableForDisplay;
    return this;
  }

  @Override
  public GeostorePolygonProto set(String fieldName, Object value) {
    return (GeostorePolygonProto) super.set(fieldName, value);
  }

  @Override
  public GeostorePolygonProto clone() {
    return (GeostorePolygonProto) super.clone();
  }

}
