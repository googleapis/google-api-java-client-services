/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.contentwarehouse.v1.model;

/**
 * This is an optional container of arbitrary data that can be added to a FetchReplyData. This data
 * is meant to be logged, but not sent back in a fetch reply (it should be added *after* the reply
 * is prepared). Use FetchResponsePreparatorImpl::AddTrawlerPrivateDataToFetchReplyData to add. See
 * also the comment in fetch_response_preparator_impl.cc. Next Tag: 44
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the Document AI Warehouse API. For a detailed explanation
 * see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class TrawlerTrawlerPrivateFetchReplyData extends com.google.api.client.json.GenericJson {

  /**
   * If we fetched using BotFetchAgent, what is the BotGroupName?
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("BotGroupName")
  private java.lang.String botGroupName;

  /**
   * This is the HOPE server that we sent the url to. We log the HOPE backend cell and hope server
   * shard number (e.g., 'qf:6'). This allows us to understand how we are balancing our load to the
   * HOPE servers.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("BotHostname")
  private java.lang.String botHostname;

  /**
   * Present if the reply is from the trawler cache. This is the requestorid of the trawler client
   * that populated the cache with the data we are reusing.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("CacheRequestorID")
  private java.lang.String cacheRequestorID;

  /**
   * Which Trawler fetcher task fetched this URL.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("FetcherTaskNumber")
  private java.lang.Integer fetcherTaskNumber;

  /**
   * HTTP Strict-Transport-Security (RFC6797) header value. We log this so we can generate a list of
   * hosts that prefer HTTPS over HTTP.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("HSTSHeaderValue")
  private java.lang.String hSTSHeaderValue;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("HadInMemCacheHit")
  private java.lang.Boolean hadInMemCacheHit;

  /**
   * If we do not have Endpoints in FetchReplyData (e.g., url rejected due to hostload limit), do we
   * have a guess of the server IPAddress (e.g., from robots fetch)? This helps us classify URLs
   * based on country code, etc. The field is filled with IPAddress::ToPackedString().
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("HintIPAddress")
  private java.lang.String hintIPAddress;

  /**
   * Represents if the HostId belongs to HostId set in 5xx url patterns, it can work as a tag when
   * emitting requestor minute summary, this helps us to aggregate traffic affected by 5xx patterns,
   * and test if there are any fetching changes.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("Is5xxHostId")
  private java.lang.Boolean is5xxHostId;

  /**
   * Was this an internally-initiated robots.txt fetch?
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("IsRobotsFetch")
  private java.lang.Boolean isRobotsFetch;

  /**
   * What's the post data size (in bytes) if it's a post request.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("PostDataSize") @com.google.api.client.json.JsonString
  private java.lang.Long postDataSize;

  /**
   * Note TrawlerPrivateFetchReplyData is never sent back to clients. The following field is just
   * for Trawler and Multiverse internal tracking, and clients should not look at this field at all.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("Producer")
  private java.lang.String producer;

  /**
   * If set, this fetch was done through a proxy (e.g., fetchproxy).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("ProxyInstance")
  private java.lang.String proxyInstance;

  /**
   * Log the loas username in trawler private to help with debugging. Store the username in trawler
   * private so clients won't see it from FetchReply. To reduce disk usage, we only log the loas
   * username if the requestorid being used does not have ClientUsernameRestrictions.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("RequestUserName")
  private java.lang.String requestUserName;

  /**
   * The number of bytes we sent back to the client.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("ResponseBytes") @com.google.api.client.json.JsonString
  private java.lang.Long responseBytes;

  /**
   * If this was a robots.txt fetch (IsRobotsFetch above), this may contain the robots.txt body. (It
   * may not, for instance, 404s are omitted; current policy is URL_CRAWLED + partially crawled)
   * This includes http headers + body.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("RobotsBody")
  private java.lang.String robotsBody;

  /**
   * RPC deadline left at the end of url control flow. Can be useful for debugging rpc deadline
   * exceeded error received by clients, this field is only recorded if it's small enough.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("RpcEndDeadlineLeftMs")
  private java.lang.Integer rpcEndDeadlineLeftMs;

  /**
   * RPC deadline left at the start of url control flow. Can be useful for debugging rpc deadline
   * exceeded error received by clients, this field is only recorded if RpcEndDeadlineLeftMs is
   * small enough.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("RpcStartDeadlineLeftMs")
  private java.lang.Integer rpcStartDeadlineLeftMs;

  /**
   * An arbitrary string signature identifying the remote server type/version. In the case of HTTP,
   * this would be the contents of the "Server:" header.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("ServerSignature")
  private java.lang.String serverSignature;

  /**
   * Which Trawler cell was this response fetched in? (e.g. "HR" or "YQ")
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("TrawlerInstance")
  private java.lang.String trawlerInstance;

  /**
   * The useragent string sent to the remote webserver. It corresponds to UserAgentToSend field in
   * FetchParams.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("UserAgentSent")
  private java.lang.String userAgentSent;

  /**
   * The fp2011 of useragent sent to the remote webserver, note it corresponds to UserAgentToSend
   * field in FetchParams
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("UserAgentSentFp") @com.google.api.client.json.JsonString
  private java.math.BigInteger userAgentSentFp;

  /**
   * Stores the OAuth authentication method.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String authenticationInfo;

  /**
   * Cache hit for this url, bypassed host_overfull error.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean bypassedHostOverfull;

  /**
   * Corresponds to AcceptableAfterDate field in FetchParams.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer cacheAcceptableAfterDate;

  /**
   * Corresponds to AcceptableAge field in FetchParams.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer cacheAcceptableAge;

  /**
   * Only set if the fetch uses cache content (is_cache_fetch is true).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String cacheHitType;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String cdnProvider;

  /**
   * How many concurrent streams are on the connection when the request finishes (including this
   * request). Export this value to monitor the stream multiplexing for HTTP/2.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long concurrentStreamNum;

  /**
   * Dependent fetch type
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String dependentFetchType;

  /**
   * If the response header contains Content-Disposition header "attachment; filename="google.zip":
   * the download_file_name would be "google.zip"
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String downloadFileName;

  /**
   * Stores the HTTP version we used in the last hop.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String httpVersion;

  /**
   * Whether this is a bidirectional streaming fetch.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean isBidiStreamingFetch;

  /**
   * Whether or not this is a Floonet fetch request. Floonet requests have inherent lower
   * availability (due to HOPE rejections when HOPE is in degraded mode, and other Floonet specific
   * reasons). Therefore, it is important for debugging and for our availability SLO to know whether
   * of not it is a floonet fetch. IMPORTANT NOTE: This field is only currently set for traffic that
   * explicitly requires Floonet and can not failover to use Googlebot (i.e. "transparent" or
   * "implicit" Floonet fetches).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean isFloonetFetch;

  /**
   * Whether or not this response is sent from gRPC proxy service.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean isFromGrpcProxy;

  /**
   * Set if the fetch goes through the virtual private cloud path so we can track the VPC traffic.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean isVpcTraffic;

  /**
   * Set to the hit location (CNS filename) if cache comes from large store.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String largeStoreHitLocation;

  /**
   * Multiverse client information
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private TrawlerMultiverseClientIdentifier multiverseClientIdentifier;

  /**
   * Number of times we drop the content of a stream reply or the final reply, which can only be
   * caused by REJECTED_NO_RPC_BUFFERS now.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long numDroppedReplies;

  /**
   * Store the original client information.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private TrawlerOriginalClientParams originalClientParams;

  /**
   * If the requestor shares resource bucket with other requestorids, we will store the resource
   * bucket name in these fields.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String resourceBucket;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String subResourceBucket;

  /**
   * Service tier info will be used in traffic grapher for ploting per tier graph.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String tier;

  /**
   * The following are vpc information that's only set if is_vpc_traffic is true.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private TrawlerLoggedVPCDestination vpcDestination;

  /**
   * If we fetched using BotFetchAgent, what is the BotGroupName?
   * @return value or {@code null} for none
   */
  public java.lang.String getBotGroupName() {
    return botGroupName;
  }

  /**
   * If we fetched using BotFetchAgent, what is the BotGroupName?
   * @param botGroupName botGroupName or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setBotGroupName(java.lang.String botGroupName) {
    this.botGroupName = botGroupName;
    return this;
  }

  /**
   * This is the HOPE server that we sent the url to. We log the HOPE backend cell and hope server
   * shard number (e.g., 'qf:6'). This allows us to understand how we are balancing our load to the
   * HOPE servers.
   * @return value or {@code null} for none
   */
  public java.lang.String getBotHostname() {
    return botHostname;
  }

  /**
   * This is the HOPE server that we sent the url to. We log the HOPE backend cell and hope server
   * shard number (e.g., 'qf:6'). This allows us to understand how we are balancing our load to the
   * HOPE servers.
   * @param botHostname botHostname or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setBotHostname(java.lang.String botHostname) {
    this.botHostname = botHostname;
    return this;
  }

  /**
   * Present if the reply is from the trawler cache. This is the requestorid of the trawler client
   * that populated the cache with the data we are reusing.
   * @return value or {@code null} for none
   */
  public java.lang.String getCacheRequestorID() {
    return cacheRequestorID;
  }

  /**
   * Present if the reply is from the trawler cache. This is the requestorid of the trawler client
   * that populated the cache with the data we are reusing.
   * @param cacheRequestorID cacheRequestorID or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setCacheRequestorID(java.lang.String cacheRequestorID) {
    this.cacheRequestorID = cacheRequestorID;
    return this;
  }

  /**
   * Which Trawler fetcher task fetched this URL.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getFetcherTaskNumber() {
    return fetcherTaskNumber;
  }

  /**
   * Which Trawler fetcher task fetched this URL.
   * @param fetcherTaskNumber fetcherTaskNumber or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setFetcherTaskNumber(java.lang.Integer fetcherTaskNumber) {
    this.fetcherTaskNumber = fetcherTaskNumber;
    return this;
  }

  /**
   * HTTP Strict-Transport-Security (RFC6797) header value. We log this so we can generate a list of
   * hosts that prefer HTTPS over HTTP.
   * @return value or {@code null} for none
   */
  public java.lang.String getHSTSHeaderValue() {
    return hSTSHeaderValue;
  }

  /**
   * HTTP Strict-Transport-Security (RFC6797) header value. We log this so we can generate a list of
   * hosts that prefer HTTPS over HTTP.
   * @param hSTSHeaderValue hSTSHeaderValue or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setHSTSHeaderValue(java.lang.String hSTSHeaderValue) {
    this.hSTSHeaderValue = hSTSHeaderValue;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getHadInMemCacheHit() {
    return hadInMemCacheHit;
  }

  /**
   * @param hadInMemCacheHit hadInMemCacheHit or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setHadInMemCacheHit(java.lang.Boolean hadInMemCacheHit) {
    this.hadInMemCacheHit = hadInMemCacheHit;
    return this;
  }

  /**
   * If we do not have Endpoints in FetchReplyData (e.g., url rejected due to hostload limit), do we
   * have a guess of the server IPAddress (e.g., from robots fetch)? This helps us classify URLs
   * based on country code, etc. The field is filled with IPAddress::ToPackedString().
   * @see #decodeHintIPAddress()
   * @return value or {@code null} for none
   */
  public java.lang.String getHintIPAddress() {
    return hintIPAddress;
  }

  /**
   * If we do not have Endpoints in FetchReplyData (e.g., url rejected due to hostload limit), do we
   * have a guess of the server IPAddress (e.g., from robots fetch)? This helps us classify URLs
   * based on country code, etc. The field is filled with IPAddress::ToPackedString().
   * @see #getHintIPAddress()
   * @return Base64 decoded value or {@code null} for none
   *
   * @since 1.14
   */
  public byte[] decodeHintIPAddress() {
    return com.google.api.client.util.Base64.decodeBase64(hintIPAddress);
  }

  /**
   * If we do not have Endpoints in FetchReplyData (e.g., url rejected due to hostload limit), do we
   * have a guess of the server IPAddress (e.g., from robots fetch)? This helps us classify URLs
   * based on country code, etc. The field is filled with IPAddress::ToPackedString().
   * @see #encodeHintIPAddress()
   * @param hintIPAddress hintIPAddress or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setHintIPAddress(java.lang.String hintIPAddress) {
    this.hintIPAddress = hintIPAddress;
    return this;
  }

  /**
   * If we do not have Endpoints in FetchReplyData (e.g., url rejected due to hostload limit), do we
   * have a guess of the server IPAddress (e.g., from robots fetch)? This helps us classify URLs
   * based on country code, etc. The field is filled with IPAddress::ToPackedString().
   * @see #setHintIPAddress()
   *
   * <p>
   * The value is encoded Base64 or {@code null} for none.
   * </p>
   *
   * @since 1.14
   */
  public TrawlerTrawlerPrivateFetchReplyData encodeHintIPAddress(byte[] hintIPAddress) {
    this.hintIPAddress = com.google.api.client.util.Base64.encodeBase64URLSafeString(hintIPAddress);
    return this;
  }

  /**
   * Represents if the HostId belongs to HostId set in 5xx url patterns, it can work as a tag when
   * emitting requestor minute summary, this helps us to aggregate traffic affected by 5xx patterns,
   * and test if there are any fetching changes.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getIs5xxHostId() {
    return is5xxHostId;
  }

  /**
   * Represents if the HostId belongs to HostId set in 5xx url patterns, it can work as a tag when
   * emitting requestor minute summary, this helps us to aggregate traffic affected by 5xx patterns,
   * and test if there are any fetching changes.
   * @param is5xxHostId is5xxHostId or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setIs5xxHostId(java.lang.Boolean is5xxHostId) {
    this.is5xxHostId = is5xxHostId;
    return this;
  }

  /**
   * Was this an internally-initiated robots.txt fetch?
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getIsRobotsFetch() {
    return isRobotsFetch;
  }

  /**
   * Was this an internally-initiated robots.txt fetch?
   * @param isRobotsFetch isRobotsFetch or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setIsRobotsFetch(java.lang.Boolean isRobotsFetch) {
    this.isRobotsFetch = isRobotsFetch;
    return this;
  }

  /**
   * What's the post data size (in bytes) if it's a post request.
   * @return value or {@code null} for none
   */
  public java.lang.Long getPostDataSize() {
    return postDataSize;
  }

  /**
   * What's the post data size (in bytes) if it's a post request.
   * @param postDataSize postDataSize or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setPostDataSize(java.lang.Long postDataSize) {
    this.postDataSize = postDataSize;
    return this;
  }

  /**
   * Note TrawlerPrivateFetchReplyData is never sent back to clients. The following field is just
   * for Trawler and Multiverse internal tracking, and clients should not look at this field at all.
   * @return value or {@code null} for none
   */
  public java.lang.String getProducer() {
    return producer;
  }

  /**
   * Note TrawlerPrivateFetchReplyData is never sent back to clients. The following field is just
   * for Trawler and Multiverse internal tracking, and clients should not look at this field at all.
   * @param producer producer or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setProducer(java.lang.String producer) {
    this.producer = producer;
    return this;
  }

  /**
   * If set, this fetch was done through a proxy (e.g., fetchproxy).
   * @return value or {@code null} for none
   */
  public java.lang.String getProxyInstance() {
    return proxyInstance;
  }

  /**
   * If set, this fetch was done through a proxy (e.g., fetchproxy).
   * @param proxyInstance proxyInstance or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setProxyInstance(java.lang.String proxyInstance) {
    this.proxyInstance = proxyInstance;
    return this;
  }

  /**
   * Log the loas username in trawler private to help with debugging. Store the username in trawler
   * private so clients won't see it from FetchReply. To reduce disk usage, we only log the loas
   * username if the requestorid being used does not have ClientUsernameRestrictions.
   * @return value or {@code null} for none
   */
  public java.lang.String getRequestUserName() {
    return requestUserName;
  }

  /**
   * Log the loas username in trawler private to help with debugging. Store the username in trawler
   * private so clients won't see it from FetchReply. To reduce disk usage, we only log the loas
   * username if the requestorid being used does not have ClientUsernameRestrictions.
   * @param requestUserName requestUserName or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setRequestUserName(java.lang.String requestUserName) {
    this.requestUserName = requestUserName;
    return this;
  }

  /**
   * The number of bytes we sent back to the client.
   * @return value or {@code null} for none
   */
  public java.lang.Long getResponseBytes() {
    return responseBytes;
  }

  /**
   * The number of bytes we sent back to the client.
   * @param responseBytes responseBytes or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setResponseBytes(java.lang.Long responseBytes) {
    this.responseBytes = responseBytes;
    return this;
  }

  /**
   * If this was a robots.txt fetch (IsRobotsFetch above), this may contain the robots.txt body. (It
   * may not, for instance, 404s are omitted; current policy is URL_CRAWLED + partially crawled)
   * This includes http headers + body.
   * @return value or {@code null} for none
   */
  public java.lang.String getRobotsBody() {
    return robotsBody;
  }

  /**
   * If this was a robots.txt fetch (IsRobotsFetch above), this may contain the robots.txt body. (It
   * may not, for instance, 404s are omitted; current policy is URL_CRAWLED + partially crawled)
   * This includes http headers + body.
   * @param robotsBody robotsBody or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setRobotsBody(java.lang.String robotsBody) {
    this.robotsBody = robotsBody;
    return this;
  }

  /**
   * RPC deadline left at the end of url control flow. Can be useful for debugging rpc deadline
   * exceeded error received by clients, this field is only recorded if it's small enough.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getRpcEndDeadlineLeftMs() {
    return rpcEndDeadlineLeftMs;
  }

  /**
   * RPC deadline left at the end of url control flow. Can be useful for debugging rpc deadline
   * exceeded error received by clients, this field is only recorded if it's small enough.
   * @param rpcEndDeadlineLeftMs rpcEndDeadlineLeftMs or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setRpcEndDeadlineLeftMs(java.lang.Integer rpcEndDeadlineLeftMs) {
    this.rpcEndDeadlineLeftMs = rpcEndDeadlineLeftMs;
    return this;
  }

  /**
   * RPC deadline left at the start of url control flow. Can be useful for debugging rpc deadline
   * exceeded error received by clients, this field is only recorded if RpcEndDeadlineLeftMs is
   * small enough.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getRpcStartDeadlineLeftMs() {
    return rpcStartDeadlineLeftMs;
  }

  /**
   * RPC deadline left at the start of url control flow. Can be useful for debugging rpc deadline
   * exceeded error received by clients, this field is only recorded if RpcEndDeadlineLeftMs is
   * small enough.
   * @param rpcStartDeadlineLeftMs rpcStartDeadlineLeftMs or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setRpcStartDeadlineLeftMs(java.lang.Integer rpcStartDeadlineLeftMs) {
    this.rpcStartDeadlineLeftMs = rpcStartDeadlineLeftMs;
    return this;
  }

  /**
   * An arbitrary string signature identifying the remote server type/version. In the case of HTTP,
   * this would be the contents of the "Server:" header.
   * @return value or {@code null} for none
   */
  public java.lang.String getServerSignature() {
    return serverSignature;
  }

  /**
   * An arbitrary string signature identifying the remote server type/version. In the case of HTTP,
   * this would be the contents of the "Server:" header.
   * @param serverSignature serverSignature or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setServerSignature(java.lang.String serverSignature) {
    this.serverSignature = serverSignature;
    return this;
  }

  /**
   * Which Trawler cell was this response fetched in? (e.g. "HR" or "YQ")
   * @return value or {@code null} for none
   */
  public java.lang.String getTrawlerInstance() {
    return trawlerInstance;
  }

  /**
   * Which Trawler cell was this response fetched in? (e.g. "HR" or "YQ")
   * @param trawlerInstance trawlerInstance or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setTrawlerInstance(java.lang.String trawlerInstance) {
    this.trawlerInstance = trawlerInstance;
    return this;
  }

  /**
   * The useragent string sent to the remote webserver. It corresponds to UserAgentToSend field in
   * FetchParams.
   * @return value or {@code null} for none
   */
  public java.lang.String getUserAgentSent() {
    return userAgentSent;
  }

  /**
   * The useragent string sent to the remote webserver. It corresponds to UserAgentToSend field in
   * FetchParams.
   * @param userAgentSent userAgentSent or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setUserAgentSent(java.lang.String userAgentSent) {
    this.userAgentSent = userAgentSent;
    return this;
  }

  /**
   * The fp2011 of useragent sent to the remote webserver, note it corresponds to UserAgentToSend
   * field in FetchParams
   * @return value or {@code null} for none
   */
  public java.math.BigInteger getUserAgentSentFp() {
    return userAgentSentFp;
  }

  /**
   * The fp2011 of useragent sent to the remote webserver, note it corresponds to UserAgentToSend
   * field in FetchParams
   * @param userAgentSentFp userAgentSentFp or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setUserAgentSentFp(java.math.BigInteger userAgentSentFp) {
    this.userAgentSentFp = userAgentSentFp;
    return this;
  }

  /**
   * Stores the OAuth authentication method.
   * @return value or {@code null} for none
   */
  public java.lang.String getAuthenticationInfo() {
    return authenticationInfo;
  }

  /**
   * Stores the OAuth authentication method.
   * @param authenticationInfo authenticationInfo or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setAuthenticationInfo(java.lang.String authenticationInfo) {
    this.authenticationInfo = authenticationInfo;
    return this;
  }

  /**
   * Cache hit for this url, bypassed host_overfull error.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getBypassedHostOverfull() {
    return bypassedHostOverfull;
  }

  /**
   * Cache hit for this url, bypassed host_overfull error.
   * @param bypassedHostOverfull bypassedHostOverfull or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setBypassedHostOverfull(java.lang.Boolean bypassedHostOverfull) {
    this.bypassedHostOverfull = bypassedHostOverfull;
    return this;
  }

  /**
   * Corresponds to AcceptableAfterDate field in FetchParams.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getCacheAcceptableAfterDate() {
    return cacheAcceptableAfterDate;
  }

  /**
   * Corresponds to AcceptableAfterDate field in FetchParams.
   * @param cacheAcceptableAfterDate cacheAcceptableAfterDate or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setCacheAcceptableAfterDate(java.lang.Integer cacheAcceptableAfterDate) {
    this.cacheAcceptableAfterDate = cacheAcceptableAfterDate;
    return this;
  }

  /**
   * Corresponds to AcceptableAge field in FetchParams.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getCacheAcceptableAge() {
    return cacheAcceptableAge;
  }

  /**
   * Corresponds to AcceptableAge field in FetchParams.
   * @param cacheAcceptableAge cacheAcceptableAge or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setCacheAcceptableAge(java.lang.Integer cacheAcceptableAge) {
    this.cacheAcceptableAge = cacheAcceptableAge;
    return this;
  }

  /**
   * Only set if the fetch uses cache content (is_cache_fetch is true).
   * @return value or {@code null} for none
   */
  public java.lang.String getCacheHitType() {
    return cacheHitType;
  }

  /**
   * Only set if the fetch uses cache content (is_cache_fetch is true).
   * @param cacheHitType cacheHitType or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setCacheHitType(java.lang.String cacheHitType) {
    this.cacheHitType = cacheHitType;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.String getCdnProvider() {
    return cdnProvider;
  }

  /**
   * @param cdnProvider cdnProvider or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setCdnProvider(java.lang.String cdnProvider) {
    this.cdnProvider = cdnProvider;
    return this;
  }

  /**
   * How many concurrent streams are on the connection when the request finishes (including this
   * request). Export this value to monitor the stream multiplexing for HTTP/2.
   * @return value or {@code null} for none
   */
  public java.lang.Long getConcurrentStreamNum() {
    return concurrentStreamNum;
  }

  /**
   * How many concurrent streams are on the connection when the request finishes (including this
   * request). Export this value to monitor the stream multiplexing for HTTP/2.
   * @param concurrentStreamNum concurrentStreamNum or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setConcurrentStreamNum(java.lang.Long concurrentStreamNum) {
    this.concurrentStreamNum = concurrentStreamNum;
    return this;
  }

  /**
   * Dependent fetch type
   * @return value or {@code null} for none
   */
  public java.lang.String getDependentFetchType() {
    return dependentFetchType;
  }

  /**
   * Dependent fetch type
   * @param dependentFetchType dependentFetchType or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setDependentFetchType(java.lang.String dependentFetchType) {
    this.dependentFetchType = dependentFetchType;
    return this;
  }

  /**
   * If the response header contains Content-Disposition header "attachment; filename="google.zip":
   * the download_file_name would be "google.zip"
   * @return value or {@code null} for none
   */
  public java.lang.String getDownloadFileName() {
    return downloadFileName;
  }

  /**
   * If the response header contains Content-Disposition header "attachment; filename="google.zip":
   * the download_file_name would be "google.zip"
   * @param downloadFileName downloadFileName or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setDownloadFileName(java.lang.String downloadFileName) {
    this.downloadFileName = downloadFileName;
    return this;
  }

  /**
   * Stores the HTTP version we used in the last hop.
   * @return value or {@code null} for none
   */
  public java.lang.String getHttpVersion() {
    return httpVersion;
  }

  /**
   * Stores the HTTP version we used in the last hop.
   * @param httpVersion httpVersion or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setHttpVersion(java.lang.String httpVersion) {
    this.httpVersion = httpVersion;
    return this;
  }

  /**
   * Whether this is a bidirectional streaming fetch.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getIsBidiStreamingFetch() {
    return isBidiStreamingFetch;
  }

  /**
   * Whether this is a bidirectional streaming fetch.
   * @param isBidiStreamingFetch isBidiStreamingFetch or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setIsBidiStreamingFetch(java.lang.Boolean isBidiStreamingFetch) {
    this.isBidiStreamingFetch = isBidiStreamingFetch;
    return this;
  }

  /**
   * Whether or not this is a Floonet fetch request. Floonet requests have inherent lower
   * availability (due to HOPE rejections when HOPE is in degraded mode, and other Floonet specific
   * reasons). Therefore, it is important for debugging and for our availability SLO to know whether
   * of not it is a floonet fetch. IMPORTANT NOTE: This field is only currently set for traffic that
   * explicitly requires Floonet and can not failover to use Googlebot (i.e. "transparent" or
   * "implicit" Floonet fetches).
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getIsFloonetFetch() {
    return isFloonetFetch;
  }

  /**
   * Whether or not this is a Floonet fetch request. Floonet requests have inherent lower
   * availability (due to HOPE rejections when HOPE is in degraded mode, and other Floonet specific
   * reasons). Therefore, it is important for debugging and for our availability SLO to know whether
   * of not it is a floonet fetch. IMPORTANT NOTE: This field is only currently set for traffic that
   * explicitly requires Floonet and can not failover to use Googlebot (i.e. "transparent" or
   * "implicit" Floonet fetches).
   * @param isFloonetFetch isFloonetFetch or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setIsFloonetFetch(java.lang.Boolean isFloonetFetch) {
    this.isFloonetFetch = isFloonetFetch;
    return this;
  }

  /**
   * Whether or not this response is sent from gRPC proxy service.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getIsFromGrpcProxy() {
    return isFromGrpcProxy;
  }

  /**
   * Whether or not this response is sent from gRPC proxy service.
   * @param isFromGrpcProxy isFromGrpcProxy or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setIsFromGrpcProxy(java.lang.Boolean isFromGrpcProxy) {
    this.isFromGrpcProxy = isFromGrpcProxy;
    return this;
  }

  /**
   * Set if the fetch goes through the virtual private cloud path so we can track the VPC traffic.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getIsVpcTraffic() {
    return isVpcTraffic;
  }

  /**
   * Set if the fetch goes through the virtual private cloud path so we can track the VPC traffic.
   * @param isVpcTraffic isVpcTraffic or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setIsVpcTraffic(java.lang.Boolean isVpcTraffic) {
    this.isVpcTraffic = isVpcTraffic;
    return this;
  }

  /**
   * Set to the hit location (CNS filename) if cache comes from large store.
   * @return value or {@code null} for none
   */
  public java.lang.String getLargeStoreHitLocation() {
    return largeStoreHitLocation;
  }

  /**
   * Set to the hit location (CNS filename) if cache comes from large store.
   * @param largeStoreHitLocation largeStoreHitLocation or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setLargeStoreHitLocation(java.lang.String largeStoreHitLocation) {
    this.largeStoreHitLocation = largeStoreHitLocation;
    return this;
  }

  /**
   * Multiverse client information
   * @return value or {@code null} for none
   */
  public TrawlerMultiverseClientIdentifier getMultiverseClientIdentifier() {
    return multiverseClientIdentifier;
  }

  /**
   * Multiverse client information
   * @param multiverseClientIdentifier multiverseClientIdentifier or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setMultiverseClientIdentifier(TrawlerMultiverseClientIdentifier multiverseClientIdentifier) {
    this.multiverseClientIdentifier = multiverseClientIdentifier;
    return this;
  }

  /**
   * Number of times we drop the content of a stream reply or the final reply, which can only be
   * caused by REJECTED_NO_RPC_BUFFERS now.
   * @return value or {@code null} for none
   */
  public java.lang.Long getNumDroppedReplies() {
    return numDroppedReplies;
  }

  /**
   * Number of times we drop the content of a stream reply or the final reply, which can only be
   * caused by REJECTED_NO_RPC_BUFFERS now.
   * @param numDroppedReplies numDroppedReplies or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setNumDroppedReplies(java.lang.Long numDroppedReplies) {
    this.numDroppedReplies = numDroppedReplies;
    return this;
  }

  /**
   * Store the original client information.
   * @return value or {@code null} for none
   */
  public TrawlerOriginalClientParams getOriginalClientParams() {
    return originalClientParams;
  }

  /**
   * Store the original client information.
   * @param originalClientParams originalClientParams or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setOriginalClientParams(TrawlerOriginalClientParams originalClientParams) {
    this.originalClientParams = originalClientParams;
    return this;
  }

  /**
   * If the requestor shares resource bucket with other requestorids, we will store the resource
   * bucket name in these fields.
   * @return value or {@code null} for none
   */
  public java.lang.String getResourceBucket() {
    return resourceBucket;
  }

  /**
   * If the requestor shares resource bucket with other requestorids, we will store the resource
   * bucket name in these fields.
   * @param resourceBucket resourceBucket or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setResourceBucket(java.lang.String resourceBucket) {
    this.resourceBucket = resourceBucket;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.String getSubResourceBucket() {
    return subResourceBucket;
  }

  /**
   * @param subResourceBucket subResourceBucket or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setSubResourceBucket(java.lang.String subResourceBucket) {
    this.subResourceBucket = subResourceBucket;
    return this;
  }

  /**
   * Service tier info will be used in traffic grapher for ploting per tier graph.
   * @return value or {@code null} for none
   */
  public java.lang.String getTier() {
    return tier;
  }

  /**
   * Service tier info will be used in traffic grapher for ploting per tier graph.
   * @param tier tier or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setTier(java.lang.String tier) {
    this.tier = tier;
    return this;
  }

  /**
   * The following are vpc information that's only set if is_vpc_traffic is true.
   * @return value or {@code null} for none
   */
  public TrawlerLoggedVPCDestination getVpcDestination() {
    return vpcDestination;
  }

  /**
   * The following are vpc information that's only set if is_vpc_traffic is true.
   * @param vpcDestination vpcDestination or {@code null} for none
   */
  public TrawlerTrawlerPrivateFetchReplyData setVpcDestination(TrawlerLoggedVPCDestination vpcDestination) {
    this.vpcDestination = vpcDestination;
    return this;
  }

  @Override
  public TrawlerTrawlerPrivateFetchReplyData set(String fieldName, Object value) {
    return (TrawlerTrawlerPrivateFetchReplyData) super.set(fieldName, value);
  }

  @Override
  public TrawlerTrawlerPrivateFetchReplyData clone() {
    return (TrawlerTrawlerPrivateFetchReplyData) super.clone();
  }

}
