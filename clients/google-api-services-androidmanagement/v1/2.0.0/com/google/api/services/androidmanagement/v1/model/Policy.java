/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.androidmanagement.v1.model;

/**
 * A policy resource represents a group of settings that govern the behavior of a managed device and
 * the apps installed on it.
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the Android Management API. For a detailed explanation
 * see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class Policy extends com.google.api.client.json.GenericJson {

  /**
   * Account types that can't be managed by the user.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.String> accountTypesWithManagementDisabled;

  /**
   * Whether adding new users and profiles is disabled. For devices where managementMode is
   * DEVICE_OWNER this field is ignored and the user is never allowed to add or remove users.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean addUserDisabled;

  /**
   * Whether adjusting the master volume is disabled. Also mutes the device. The setting has effect
   * only on fully managed devices.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean adjustVolumeDisabled;

  /**
   * Advanced security settings. In most cases, setting these is not needed.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private AdvancedSecurityOverrides advancedSecurityOverrides;

  /**
   * Configuration for an always-on VPN connection. Use with vpn_config_disabled to prevent
   * modification of this setting.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private AlwaysOnVpnPackage alwaysOnVpnPackage;

  /**
   * This setting is not supported. Any value is ignored.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.String> androidDevicePolicyTracks;

  /**
   * Recommended alternative: autoUpdateMode which is set per app, provides greater flexibility
   * around update frequency.When autoUpdateMode is set to AUTO_UPDATE_POSTPONED or
   * AUTO_UPDATE_HIGH_PRIORITY, this field has no effect.The app auto update policy, which controls
   * when automatic app updates can be applied.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String appAutoUpdatePolicy;

  /**
   * Policy applied to apps. This can have at most 3,000 elements.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<ApplicationPolicy> applications;

  static {
    // hack to force ProGuard to consider ApplicationPolicy used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(ApplicationPolicy.class);
  }

  /**
   * Optional. Controls whether AssistContent
   * (https://developer.android.com/reference/android/app/assist/AssistContent) is allowed to be
   * sent to a privileged app such as an assistant app. AssistContent includes screenshots and
   * information about an app, such as package name. This is supported on Android 15 and above.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String assistContentPolicy;

  /**
   * Whether auto date, time, and time zone are enabled on a company-owned device. If this is set,
   * then autoTimeRequired is ignored.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String autoDateAndTimeZone;

  /**
   * Whether auto time is required, which prevents the user from manually setting the date and time.
   * If autoDateAndTimeZone is set, this field is ignored.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean autoTimeRequired;

  /**
   * Whether applications other than the ones configured in applications are blocked from being
   * installed. When set, applications that were installed under a previous policy but no longer
   * appear in the policy are automatically uninstalled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean blockApplicationsEnabled;

  /**
   * Whether configuring bluetooth is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean bluetoothConfigDisabled;

  /**
   * Whether bluetooth contact sharing is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean bluetoothContactSharingDisabled;

  /**
   * Whether bluetooth is disabled. Prefer this setting over bluetooth_config_disabled because
   * bluetooth_config_disabled can be bypassed by the user.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean bluetoothDisabled;

  /**
   * Controls the use of the camera and whether the user has access to the camera access toggle.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String cameraAccess;

  /**
   * If camera_access is set to any value other than CAMERA_ACCESS_UNSPECIFIED, this has no effect.
   * Otherwise this field controls whether cameras are disabled: If true, all cameras are disabled,
   * otherwise they are available. For fully managed devices this field applies for all apps on the
   * device. For work profiles, this field applies only to apps in the work profile, and the camera
   * access of apps outside the work profile is unaffected.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean cameraDisabled;

  /**
   * Whether configuring cell broadcast is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean cellBroadcastsConfigDisabled;

  /**
   * Rules for determining apps' access to private keys. See ChoosePrivateKeyRule for details. This
   * must be empty if any application has CERT_SELECTION delegation scope.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<ChoosePrivateKeyRule> choosePrivateKeyRules;

  static {
    // hack to force ProGuard to consider ChoosePrivateKeyRule used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(ChoosePrivateKeyRule.class);
  }

  /**
   * Rules declaring which mitigating actions to take when a device is not compliant with its
   * policy. When the conditions for multiple rules are satisfied, all of the mitigating actions for
   * the rules are taken. There is a maximum limit of 100 rules. Use policy enforcement rules
   * instead.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<ComplianceRule> complianceRules;

  static {
    // hack to force ProGuard to consider ComplianceRule used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(ComplianceRule.class);
  }

  /**
   * Whether creating windows besides app windows is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean createWindowsDisabled;

  /**
   * Controls which apps are allowed to act as credential providers on Android 14 and above. These
   * apps store credentials, see this (https://developer.android.com/training/sign-in/passkeys) and
   * this (https://developer.android.com/reference/androidx/credentials/CredentialManager) for
   * details. See also credentialProviderPolicy.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String credentialProviderPolicyDefault;

  /**
   * Whether configuring user credentials is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean credentialsConfigDisabled;

  /**
   * Cross-profile policies applied on the device.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private CrossProfilePolicies crossProfilePolicies;

  /**
   * Whether roaming data services are disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean dataRoamingDisabled;

  /**
   * Whether the user is allowed to enable debugging features.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean debuggingFeaturesAllowed;

  /**
   * The default permission policy for runtime permission requests.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String defaultPermissionPolicy;

  /**
   * Covers controls for device connectivity such as Wi-Fi, USB data access, keyboard/mouse
   * connections, and more.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private DeviceConnectivityManagement deviceConnectivityManagement;

  /**
   * The device owner information to be shown on the lock screen.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private UserFacingMessage deviceOwnerLockScreenInfo;

  /**
   * Covers controls for radio state such as Wi-Fi, bluetooth, and more.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private DeviceRadioState deviceRadioState;

  /**
   * Optional. Controls for the display settings.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private DisplaySettings displaySettings;

  /**
   * Whether encryption is enabled
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String encryptionPolicy;

  /**
   * Whether app verification is force-enabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean ensureVerifyAppsEnabled;

  /**
   * Whether factory resetting from settings is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean factoryResetDisabled;

  /**
   * Email addresses of device administrators for factory reset protection. When the device is
   * factory reset, it will require one of these admins to log in with the Google account email and
   * password to unlock the device. If no admins are specified, the device won't provide factory
   * reset protection.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.String> frpAdminEmails;

  /**
   * Whether the user is allowed to have fun. Controls whether the Easter egg game in Settings is
   * disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean funDisabled;

  /**
   * Whether user installation of apps is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean installAppsDisabled;

  /**
   * This field has no effect.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean installUnknownSourcesAllowed;

  /**
   * If true, this disables the Lock Screen
   * (https://source.android.com/docs/core/display/multi_display/lock-screen) for primary and/or
   * secondary displays. This policy is supported only in dedicated device management mode.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean keyguardDisabled;

  /**
   * Disabled keyguard customizations, such as widgets.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.String> keyguardDisabledFeatures;

  /**
   * Whether the kiosk custom launcher is enabled. This replaces the home screen with a launcher
   * that locks down the device to the apps installed via the applications setting. Apps appear on a
   * single page in alphabetical order. Use kioskCustomization to further configure the kiosk device
   * behavior.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean kioskCustomLauncherEnabled;

  /**
   * Settings controlling the behavior of a device in kiosk mode. To enable kiosk mode, set
   * kioskCustomLauncherEnabled to true or specify an app in the policy with installType KIOSK.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KioskCustomization kioskCustomization;

  /**
   * The degree of location detection enabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String locationMode;

  /**
   * A message displayed to the user in the device administators settings screen.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private UserFacingMessage longSupportMessage;

  /**
   * Maximum time in milliseconds for user activity until the device locks. A value of 0 means there
   * is no restriction.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long maximumTimeToLock;

  /**
   * Controls the use of the microphone and whether the user has access to the microphone access
   * toggle. This applies only on fully managed devices.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String microphoneAccess;

  /**
   * The minimum allowed Android API level.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer minimumApiLevel;

  /**
   * Whether configuring mobile networks is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean mobileNetworksConfigDisabled;

  /**
   * Whether adding or removing accounts is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean modifyAccountsDisabled;

  /**
   * Whether the user mounting physical external media is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean mountPhysicalMediaDisabled;

  /**
   * The name of the policy in the form enterprises/{enterpriseId}/policies/{policyId}.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String name;

  /**
   * Whether the network escape hatch is enabled. If a network connection can't be made at boot
   * time, the escape hatch prompts the user to temporarily connect to a network in order to refresh
   * the device policy. After applying policy, the temporary network will be forgotten and the
   * device will continue booting. This prevents being unable to connect to a network if there is no
   * suitable network in the last policy and the device boots into an app in lock task mode, or the
   * user is otherwise unable to reach device settings.Note: Setting wifiConfigDisabled to true will
   * override this setting under specific circumstances. Please see wifiConfigDisabled for further
   * details. Setting configureWifi to DISALLOW_CONFIGURING_WIFI will override this setting under
   * specific circumstances. Please see DISALLOW_CONFIGURING_WIFI for further details.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean networkEscapeHatchEnabled;

  /**
   * Whether resetting network settings is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean networkResetDisabled;

  /**
   * This feature is not generally available.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<OncCertificateProvider> oncCertificateProviders;

  static {
    // hack to force ProGuard to consider OncCertificateProvider used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(OncCertificateProvider.class);
  }

  /**
   * Network configuration for the device. See configure networks for more information.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.Map<String, java.lang.Object> openNetworkConfiguration;

  /**
   * Whether using NFC to beam data from apps is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean outgoingBeamDisabled;

  /**
   * Whether outgoing calls are disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean outgoingCallsDisabled;

  /**
   * Password requirement policies. Different policies can be set for work profile or fully managed
   * devices by setting the password_scope field in the policy.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<PasswordRequirements> passwordPolicies;

  static {
    // hack to force ProGuard to consider PasswordRequirements used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(PasswordRequirements.class);
  }

  /**
   * Password requirements. The field password_requirements.require_password_unlock must not be set.
   * DEPRECATED - Use passwordPolicies.Note:Complexity-based values of PasswordQuality, that is,
   * COMPLEXITY_LOW, COMPLEXITY_MEDIUM, and COMPLEXITY_HIGH, cannot be used here.
   * unified_lock_settings cannot be used here.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private PasswordRequirements passwordRequirements;

  /**
   * Explicit permission or group grants or denials for all apps. These values override the
   * default_permission_policy.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<PermissionGrant> permissionGrants;

  static {
    // hack to force ProGuard to consider PermissionGrant used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(PermissionGrant.class);
  }

  /**
   * Specifies permitted accessibility services. If the field is not set, any accessibility service
   * can be used. If the field is set, only the accessibility services in this list and the system's
   * built-in accessibility service can be used. In particular, if the field is set to empty, only
   * the system's built-in accessibility servicess can be used. This can be set on fully managed
   * devices and on work profiles. When applied to a work profile, this affects both the personal
   * profile and the work profile.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private PackageNameList permittedAccessibilityServices;

  /**
   * If present, only the input methods provided by packages in this list are permitted. If this
   * field is present, but the list is empty, then only system input methods are permitted.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private PackageNameList permittedInputMethods;

  /**
   * Default intent handler activities.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<PersistentPreferredActivity> persistentPreferredActivities;

  static {
    // hack to force ProGuard to consider PersistentPreferredActivity used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(PersistentPreferredActivity.class);
  }

  /**
   * Policies managing personal usage on a company-owned device.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private PersonalUsagePolicies personalUsagePolicies;

  /**
   * This mode controls which apps are available to the user in the Play Store and the behavior on
   * the device when apps are removed from the policy.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String playStoreMode;

  /**
   * Rules that define the behavior when a particular policy can not be applied on device
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<PolicyEnforcementRule> policyEnforcementRules;

  /**
   * Controls whether preferential network service is enabled on the work profile. For example, an
   * organization may have an agreement with a carrier that all of the work data from its employees'
   * devices will be sent via a network service dedicated for enterprise use. An example of a
   * supported preferential network service is the enterprise slice on 5G networks. This has no
   * effect on fully managed devices.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String preferentialNetworkService;

  /**
   * Optional. Controls whether printing is allowed. This is supported on devices running Android 9
   * and above. .
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String printingPolicy;

  /**
   * Allows showing UI on a device for a user to choose a private key alias if there are no matching
   * rules in ChoosePrivateKeyRules. For devices below Android P, setting this may leave enterprise
   * keys vulnerable. This value will have no effect if any application has CERT_SELECTION
   * delegation scope.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean privateKeySelectionEnabled;

  /**
   * The network-independent global HTTP proxy. Typically proxies should be configured per-network
   * in open_network_configuration. However for unusual configurations like general internal
   * filtering a global HTTP proxy may be useful. If the proxy is not accessible, network access may
   * break. The global proxy is only a recommendation and some apps may ignore it.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private ProxyInfo recommendedGlobalProxy;

  /**
   * Whether removing other users is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean removeUserDisabled;

  /**
   * Whether rebooting the device into safe boot is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean safeBootDisabled;

  /**
   * Whether screen capture is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean screenCaptureDisabled;

  /**
   * Whether changing the user icon is disabled. The setting has effect only on fully managed
   * devices.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean setUserIconDisabled;

  /**
   * Whether changing the wallpaper is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean setWallpaperDisabled;

  /**
   * Action to take during the setup process. At most one action may be specified.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<SetupAction> setupActions;

  /**
   * Whether location sharing is disabled. share_location_disabled is supported for both fully
   * managed devices and personally owned work profiles.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean shareLocationDisabled;

  /**
   * A message displayed to the user in the settings screen wherever functionality has been disabled
   * by the admin. If the message is longer than 200 characters it may be truncated.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private UserFacingMessage shortSupportMessage;

  /**
   * Flag to skip hints on the first use. Enterprise admin can enable the system recommendation for
   * apps to skip their user tutorial and other introductory hints on first start-up.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean skipFirstUseHintsEnabled;

  /**
   * Whether sending and receiving SMS messages is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean smsDisabled;

  /**
   * Whether the status bar is disabled. This disables notifications, quick settings, and other
   * screen overlays that allow escape from full-screen mode. DEPRECATED. To disable the status bar
   * on a kiosk device, use InstallType KIOSK or kioskCustomLauncherEnabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean statusBarDisabled;

  /**
   * Status reporting settings
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private StatusReportingSettings statusReportingSettings;

  /**
   * The battery plugged in modes for which the device stays on. When using this setting, it is
   * recommended to clear maximum_time_to_lock so that the device doesn't lock itself while it stays
   * on.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.String> stayOnPluggedModes;

  /**
   * The system update policy, which controls how OS updates are applied. If the update type is
   * WINDOWED, the update window will automatically apply to Play app updates as well.Note: Google
   * Play system updates (https://source.android.com/docs/core/ota/modular-system) (also called
   * Mainline updates) are automatically downloaded and require a device reboot to be installed.
   * Refer to the mainline section in Manage system updates
   * (https://developer.android.com/work/dpc/system-updates#mainline) for further details.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private SystemUpdate systemUpdate;

  /**
   * Whether configuring tethering and portable hotspots is disabled. If tetheringSettings is set to
   * anything other than TETHERING_SETTINGS_UNSPECIFIED, this setting is ignored.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean tetheringConfigDisabled;

  /**
   * Whether user uninstallation of applications is disabled. This prevents apps from being
   * uninstalled, even those removed using applications
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean uninstallAppsDisabled;

  /**
   * If microphone_access is set to any value other than MICROPHONE_ACCESS_UNSPECIFIED, this has no
   * effect. Otherwise this field controls whether microphones are disabled: If true, all
   * microphones are disabled, otherwise they are available. This is available only on fully managed
   * devices.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean unmuteMicrophoneDisabled;

  /**
   * Configuration of device activity logging.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private UsageLog usageLog;

  /**
   * Whether transferring files over USB is disabled. This is supported only on company-owned
   * devices.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean usbFileTransferDisabled;

  /**
   * Whether USB storage is enabled. Deprecated.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean usbMassStorageEnabled;

  /**
   * The version of the policy. This is a read-only field. The version is incremented each time the
   * policy is updated.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long version;

  /**
   * Whether configuring VPN is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean vpnConfigDisabled;

  /**
   * Whether configuring Wi-Fi networks is disabled. Supported on fully managed devices and work
   * profiles on company-owned devices. For fully managed devices, setting this to true removes all
   * configured networks and retains only the networks configured using openNetworkConfiguration.
   * For work profiles on company-owned devices, existing configured networks are not affected and
   * the user is not allowed to add, remove, or modify Wi-Fi networks. If configureWifi is set to
   * anything other than CONFIGURE_WIFI_UNSPECIFIED, this setting is ignored. Note: If a network
   * connection can't be made at boot time and configuring Wi-Fi is disabled then network escape
   * hatch will be shown in order to refresh the device policy (see networkEscapeHatchEnabled).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean wifiConfigDisabled;

  /**
   * This is deprecated.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean wifiConfigsLockdownEnabled;

  /**
   * Account types that can't be managed by the user.
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.String> getAccountTypesWithManagementDisabled() {
    return accountTypesWithManagementDisabled;
  }

  /**
   * Account types that can't be managed by the user.
   * @param accountTypesWithManagementDisabled accountTypesWithManagementDisabled or {@code null} for none
   */
  public Policy setAccountTypesWithManagementDisabled(java.util.List<java.lang.String> accountTypesWithManagementDisabled) {
    this.accountTypesWithManagementDisabled = accountTypesWithManagementDisabled;
    return this;
  }

  /**
   * Whether adding new users and profiles is disabled. For devices where managementMode is
   * DEVICE_OWNER this field is ignored and the user is never allowed to add or remove users.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getAddUserDisabled() {
    return addUserDisabled;
  }

  /**
   * Whether adding new users and profiles is disabled. For devices where managementMode is
   * DEVICE_OWNER this field is ignored and the user is never allowed to add or remove users.
   * @param addUserDisabled addUserDisabled or {@code null} for none
   */
  public Policy setAddUserDisabled(java.lang.Boolean addUserDisabled) {
    this.addUserDisabled = addUserDisabled;
    return this;
  }

  /**
   * Whether adjusting the master volume is disabled. Also mutes the device. The setting has effect
   * only on fully managed devices.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getAdjustVolumeDisabled() {
    return adjustVolumeDisabled;
  }

  /**
   * Whether adjusting the master volume is disabled. Also mutes the device. The setting has effect
   * only on fully managed devices.
   * @param adjustVolumeDisabled adjustVolumeDisabled or {@code null} for none
   */
  public Policy setAdjustVolumeDisabled(java.lang.Boolean adjustVolumeDisabled) {
    this.adjustVolumeDisabled = adjustVolumeDisabled;
    return this;
  }

  /**
   * Advanced security settings. In most cases, setting these is not needed.
   * @return value or {@code null} for none
   */
  public AdvancedSecurityOverrides getAdvancedSecurityOverrides() {
    return advancedSecurityOverrides;
  }

  /**
   * Advanced security settings. In most cases, setting these is not needed.
   * @param advancedSecurityOverrides advancedSecurityOverrides or {@code null} for none
   */
  public Policy setAdvancedSecurityOverrides(AdvancedSecurityOverrides advancedSecurityOverrides) {
    this.advancedSecurityOverrides = advancedSecurityOverrides;
    return this;
  }

  /**
   * Configuration for an always-on VPN connection. Use with vpn_config_disabled to prevent
   * modification of this setting.
   * @return value or {@code null} for none
   */
  public AlwaysOnVpnPackage getAlwaysOnVpnPackage() {
    return alwaysOnVpnPackage;
  }

  /**
   * Configuration for an always-on VPN connection. Use with vpn_config_disabled to prevent
   * modification of this setting.
   * @param alwaysOnVpnPackage alwaysOnVpnPackage or {@code null} for none
   */
  public Policy setAlwaysOnVpnPackage(AlwaysOnVpnPackage alwaysOnVpnPackage) {
    this.alwaysOnVpnPackage = alwaysOnVpnPackage;
    return this;
  }

  /**
   * This setting is not supported. Any value is ignored.
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.String> getAndroidDevicePolicyTracks() {
    return androidDevicePolicyTracks;
  }

  /**
   * This setting is not supported. Any value is ignored.
   * @param androidDevicePolicyTracks androidDevicePolicyTracks or {@code null} for none
   */
  public Policy setAndroidDevicePolicyTracks(java.util.List<java.lang.String> androidDevicePolicyTracks) {
    this.androidDevicePolicyTracks = androidDevicePolicyTracks;
    return this;
  }

  /**
   * Recommended alternative: autoUpdateMode which is set per app, provides greater flexibility
   * around update frequency.When autoUpdateMode is set to AUTO_UPDATE_POSTPONED or
   * AUTO_UPDATE_HIGH_PRIORITY, this field has no effect.The app auto update policy, which controls
   * when automatic app updates can be applied.
   * @return value or {@code null} for none
   */
  public java.lang.String getAppAutoUpdatePolicy() {
    return appAutoUpdatePolicy;
  }

  /**
   * Recommended alternative: autoUpdateMode which is set per app, provides greater flexibility
   * around update frequency.When autoUpdateMode is set to AUTO_UPDATE_POSTPONED or
   * AUTO_UPDATE_HIGH_PRIORITY, this field has no effect.The app auto update policy, which controls
   * when automatic app updates can be applied.
   * @param appAutoUpdatePolicy appAutoUpdatePolicy or {@code null} for none
   */
  public Policy setAppAutoUpdatePolicy(java.lang.String appAutoUpdatePolicy) {
    this.appAutoUpdatePolicy = appAutoUpdatePolicy;
    return this;
  }

  /**
   * Policy applied to apps. This can have at most 3,000 elements.
   * @return value or {@code null} for none
   */
  public java.util.List<ApplicationPolicy> getApplications() {
    return applications;
  }

  /**
   * Policy applied to apps. This can have at most 3,000 elements.
   * @param applications applications or {@code null} for none
   */
  public Policy setApplications(java.util.List<ApplicationPolicy> applications) {
    this.applications = applications;
    return this;
  }

  /**
   * Optional. Controls whether AssistContent
   * (https://developer.android.com/reference/android/app/assist/AssistContent) is allowed to be
   * sent to a privileged app such as an assistant app. AssistContent includes screenshots and
   * information about an app, such as package name. This is supported on Android 15 and above.
   * @return value or {@code null} for none
   */
  public java.lang.String getAssistContentPolicy() {
    return assistContentPolicy;
  }

  /**
   * Optional. Controls whether AssistContent
   * (https://developer.android.com/reference/android/app/assist/AssistContent) is allowed to be
   * sent to a privileged app such as an assistant app. AssistContent includes screenshots and
   * information about an app, such as package name. This is supported on Android 15 and above.
   * @param assistContentPolicy assistContentPolicy or {@code null} for none
   */
  public Policy setAssistContentPolicy(java.lang.String assistContentPolicy) {
    this.assistContentPolicy = assistContentPolicy;
    return this;
  }

  /**
   * Whether auto date, time, and time zone are enabled on a company-owned device. If this is set,
   * then autoTimeRequired is ignored.
   * @return value or {@code null} for none
   */
  public java.lang.String getAutoDateAndTimeZone() {
    return autoDateAndTimeZone;
  }

  /**
   * Whether auto date, time, and time zone are enabled on a company-owned device. If this is set,
   * then autoTimeRequired is ignored.
   * @param autoDateAndTimeZone autoDateAndTimeZone or {@code null} for none
   */
  public Policy setAutoDateAndTimeZone(java.lang.String autoDateAndTimeZone) {
    this.autoDateAndTimeZone = autoDateAndTimeZone;
    return this;
  }

  /**
   * Whether auto time is required, which prevents the user from manually setting the date and time.
   * If autoDateAndTimeZone is set, this field is ignored.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getAutoTimeRequired() {
    return autoTimeRequired;
  }

  /**
   * Whether auto time is required, which prevents the user from manually setting the date and time.
   * If autoDateAndTimeZone is set, this field is ignored.
   * @param autoTimeRequired autoTimeRequired or {@code null} for none
   */
  public Policy setAutoTimeRequired(java.lang.Boolean autoTimeRequired) {
    this.autoTimeRequired = autoTimeRequired;
    return this;
  }

  /**
   * Whether applications other than the ones configured in applications are blocked from being
   * installed. When set, applications that were installed under a previous policy but no longer
   * appear in the policy are automatically uninstalled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getBlockApplicationsEnabled() {
    return blockApplicationsEnabled;
  }

  /**
   * Whether applications other than the ones configured in applications are blocked from being
   * installed. When set, applications that were installed under a previous policy but no longer
   * appear in the policy are automatically uninstalled.
   * @param blockApplicationsEnabled blockApplicationsEnabled or {@code null} for none
   */
  public Policy setBlockApplicationsEnabled(java.lang.Boolean blockApplicationsEnabled) {
    this.blockApplicationsEnabled = blockApplicationsEnabled;
    return this;
  }

  /**
   * Whether configuring bluetooth is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getBluetoothConfigDisabled() {
    return bluetoothConfigDisabled;
  }

  /**
   * Whether configuring bluetooth is disabled.
   * @param bluetoothConfigDisabled bluetoothConfigDisabled or {@code null} for none
   */
  public Policy setBluetoothConfigDisabled(java.lang.Boolean bluetoothConfigDisabled) {
    this.bluetoothConfigDisabled = bluetoothConfigDisabled;
    return this;
  }

  /**
   * Whether bluetooth contact sharing is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getBluetoothContactSharingDisabled() {
    return bluetoothContactSharingDisabled;
  }

  /**
   * Whether bluetooth contact sharing is disabled.
   * @param bluetoothContactSharingDisabled bluetoothContactSharingDisabled or {@code null} for none
   */
  public Policy setBluetoothContactSharingDisabled(java.lang.Boolean bluetoothContactSharingDisabled) {
    this.bluetoothContactSharingDisabled = bluetoothContactSharingDisabled;
    return this;
  }

  /**
   * Whether bluetooth is disabled. Prefer this setting over bluetooth_config_disabled because
   * bluetooth_config_disabled can be bypassed by the user.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getBluetoothDisabled() {
    return bluetoothDisabled;
  }

  /**
   * Whether bluetooth is disabled. Prefer this setting over bluetooth_config_disabled because
   * bluetooth_config_disabled can be bypassed by the user.
   * @param bluetoothDisabled bluetoothDisabled or {@code null} for none
   */
  public Policy setBluetoothDisabled(java.lang.Boolean bluetoothDisabled) {
    this.bluetoothDisabled = bluetoothDisabled;
    return this;
  }

  /**
   * Controls the use of the camera and whether the user has access to the camera access toggle.
   * @return value or {@code null} for none
   */
  public java.lang.String getCameraAccess() {
    return cameraAccess;
  }

  /**
   * Controls the use of the camera and whether the user has access to the camera access toggle.
   * @param cameraAccess cameraAccess or {@code null} for none
   */
  public Policy setCameraAccess(java.lang.String cameraAccess) {
    this.cameraAccess = cameraAccess;
    return this;
  }

  /**
   * If camera_access is set to any value other than CAMERA_ACCESS_UNSPECIFIED, this has no effect.
   * Otherwise this field controls whether cameras are disabled: If true, all cameras are disabled,
   * otherwise they are available. For fully managed devices this field applies for all apps on the
   * device. For work profiles, this field applies only to apps in the work profile, and the camera
   * access of apps outside the work profile is unaffected.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getCameraDisabled() {
    return cameraDisabled;
  }

  /**
   * If camera_access is set to any value other than CAMERA_ACCESS_UNSPECIFIED, this has no effect.
   * Otherwise this field controls whether cameras are disabled: If true, all cameras are disabled,
   * otherwise they are available. For fully managed devices this field applies for all apps on the
   * device. For work profiles, this field applies only to apps in the work profile, and the camera
   * access of apps outside the work profile is unaffected.
   * @param cameraDisabled cameraDisabled or {@code null} for none
   */
  public Policy setCameraDisabled(java.lang.Boolean cameraDisabled) {
    this.cameraDisabled = cameraDisabled;
    return this;
  }

  /**
   * Whether configuring cell broadcast is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getCellBroadcastsConfigDisabled() {
    return cellBroadcastsConfigDisabled;
  }

  /**
   * Whether configuring cell broadcast is disabled.
   * @param cellBroadcastsConfigDisabled cellBroadcastsConfigDisabled or {@code null} for none
   */
  public Policy setCellBroadcastsConfigDisabled(java.lang.Boolean cellBroadcastsConfigDisabled) {
    this.cellBroadcastsConfigDisabled = cellBroadcastsConfigDisabled;
    return this;
  }

  /**
   * Rules for determining apps' access to private keys. See ChoosePrivateKeyRule for details. This
   * must be empty if any application has CERT_SELECTION delegation scope.
   * @return value or {@code null} for none
   */
  public java.util.List<ChoosePrivateKeyRule> getChoosePrivateKeyRules() {
    return choosePrivateKeyRules;
  }

  /**
   * Rules for determining apps' access to private keys. See ChoosePrivateKeyRule for details. This
   * must be empty if any application has CERT_SELECTION delegation scope.
   * @param choosePrivateKeyRules choosePrivateKeyRules or {@code null} for none
   */
  public Policy setChoosePrivateKeyRules(java.util.List<ChoosePrivateKeyRule> choosePrivateKeyRules) {
    this.choosePrivateKeyRules = choosePrivateKeyRules;
    return this;
  }

  /**
   * Rules declaring which mitigating actions to take when a device is not compliant with its
   * policy. When the conditions for multiple rules are satisfied, all of the mitigating actions for
   * the rules are taken. There is a maximum limit of 100 rules. Use policy enforcement rules
   * instead.
   * @return value or {@code null} for none
   */
  public java.util.List<ComplianceRule> getComplianceRules() {
    return complianceRules;
  }

  /**
   * Rules declaring which mitigating actions to take when a device is not compliant with its
   * policy. When the conditions for multiple rules are satisfied, all of the mitigating actions for
   * the rules are taken. There is a maximum limit of 100 rules. Use policy enforcement rules
   * instead.
   * @param complianceRules complianceRules or {@code null} for none
   */
  public Policy setComplianceRules(java.util.List<ComplianceRule> complianceRules) {
    this.complianceRules = complianceRules;
    return this;
  }

  /**
   * Whether creating windows besides app windows is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getCreateWindowsDisabled() {
    return createWindowsDisabled;
  }

  /**
   * Whether creating windows besides app windows is disabled.
   * @param createWindowsDisabled createWindowsDisabled or {@code null} for none
   */
  public Policy setCreateWindowsDisabled(java.lang.Boolean createWindowsDisabled) {
    this.createWindowsDisabled = createWindowsDisabled;
    return this;
  }

  /**
   * Controls which apps are allowed to act as credential providers on Android 14 and above. These
   * apps store credentials, see this (https://developer.android.com/training/sign-in/passkeys) and
   * this (https://developer.android.com/reference/androidx/credentials/CredentialManager) for
   * details. See also credentialProviderPolicy.
   * @return value or {@code null} for none
   */
  public java.lang.String getCredentialProviderPolicyDefault() {
    return credentialProviderPolicyDefault;
  }

  /**
   * Controls which apps are allowed to act as credential providers on Android 14 and above. These
   * apps store credentials, see this (https://developer.android.com/training/sign-in/passkeys) and
   * this (https://developer.android.com/reference/androidx/credentials/CredentialManager) for
   * details. See also credentialProviderPolicy.
   * @param credentialProviderPolicyDefault credentialProviderPolicyDefault or {@code null} for none
   */
  public Policy setCredentialProviderPolicyDefault(java.lang.String credentialProviderPolicyDefault) {
    this.credentialProviderPolicyDefault = credentialProviderPolicyDefault;
    return this;
  }

  /**
   * Whether configuring user credentials is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getCredentialsConfigDisabled() {
    return credentialsConfigDisabled;
  }

  /**
   * Whether configuring user credentials is disabled.
   * @param credentialsConfigDisabled credentialsConfigDisabled or {@code null} for none
   */
  public Policy setCredentialsConfigDisabled(java.lang.Boolean credentialsConfigDisabled) {
    this.credentialsConfigDisabled = credentialsConfigDisabled;
    return this;
  }

  /**
   * Cross-profile policies applied on the device.
   * @return value or {@code null} for none
   */
  public CrossProfilePolicies getCrossProfilePolicies() {
    return crossProfilePolicies;
  }

  /**
   * Cross-profile policies applied on the device.
   * @param crossProfilePolicies crossProfilePolicies or {@code null} for none
   */
  public Policy setCrossProfilePolicies(CrossProfilePolicies crossProfilePolicies) {
    this.crossProfilePolicies = crossProfilePolicies;
    return this;
  }

  /**
   * Whether roaming data services are disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getDataRoamingDisabled() {
    return dataRoamingDisabled;
  }

  /**
   * Whether roaming data services are disabled.
   * @param dataRoamingDisabled dataRoamingDisabled or {@code null} for none
   */
  public Policy setDataRoamingDisabled(java.lang.Boolean dataRoamingDisabled) {
    this.dataRoamingDisabled = dataRoamingDisabled;
    return this;
  }

  /**
   * Whether the user is allowed to enable debugging features.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getDebuggingFeaturesAllowed() {
    return debuggingFeaturesAllowed;
  }

  /**
   * Whether the user is allowed to enable debugging features.
   * @param debuggingFeaturesAllowed debuggingFeaturesAllowed or {@code null} for none
   */
  public Policy setDebuggingFeaturesAllowed(java.lang.Boolean debuggingFeaturesAllowed) {
    this.debuggingFeaturesAllowed = debuggingFeaturesAllowed;
    return this;
  }

  /**
   * The default permission policy for runtime permission requests.
   * @return value or {@code null} for none
   */
  public java.lang.String getDefaultPermissionPolicy() {
    return defaultPermissionPolicy;
  }

  /**
   * The default permission policy for runtime permission requests.
   * @param defaultPermissionPolicy defaultPermissionPolicy or {@code null} for none
   */
  public Policy setDefaultPermissionPolicy(java.lang.String defaultPermissionPolicy) {
    this.defaultPermissionPolicy = defaultPermissionPolicy;
    return this;
  }

  /**
   * Covers controls for device connectivity such as Wi-Fi, USB data access, keyboard/mouse
   * connections, and more.
   * @return value or {@code null} for none
   */
  public DeviceConnectivityManagement getDeviceConnectivityManagement() {
    return deviceConnectivityManagement;
  }

  /**
   * Covers controls for device connectivity such as Wi-Fi, USB data access, keyboard/mouse
   * connections, and more.
   * @param deviceConnectivityManagement deviceConnectivityManagement or {@code null} for none
   */
  public Policy setDeviceConnectivityManagement(DeviceConnectivityManagement deviceConnectivityManagement) {
    this.deviceConnectivityManagement = deviceConnectivityManagement;
    return this;
  }

  /**
   * The device owner information to be shown on the lock screen.
   * @return value or {@code null} for none
   */
  public UserFacingMessage getDeviceOwnerLockScreenInfo() {
    return deviceOwnerLockScreenInfo;
  }

  /**
   * The device owner information to be shown on the lock screen.
   * @param deviceOwnerLockScreenInfo deviceOwnerLockScreenInfo or {@code null} for none
   */
  public Policy setDeviceOwnerLockScreenInfo(UserFacingMessage deviceOwnerLockScreenInfo) {
    this.deviceOwnerLockScreenInfo = deviceOwnerLockScreenInfo;
    return this;
  }

  /**
   * Covers controls for radio state such as Wi-Fi, bluetooth, and more.
   * @return value or {@code null} for none
   */
  public DeviceRadioState getDeviceRadioState() {
    return deviceRadioState;
  }

  /**
   * Covers controls for radio state such as Wi-Fi, bluetooth, and more.
   * @param deviceRadioState deviceRadioState or {@code null} for none
   */
  public Policy setDeviceRadioState(DeviceRadioState deviceRadioState) {
    this.deviceRadioState = deviceRadioState;
    return this;
  }

  /**
   * Optional. Controls for the display settings.
   * @return value or {@code null} for none
   */
  public DisplaySettings getDisplaySettings() {
    return displaySettings;
  }

  /**
   * Optional. Controls for the display settings.
   * @param displaySettings displaySettings or {@code null} for none
   */
  public Policy setDisplaySettings(DisplaySettings displaySettings) {
    this.displaySettings = displaySettings;
    return this;
  }

  /**
   * Whether encryption is enabled
   * @return value or {@code null} for none
   */
  public java.lang.String getEncryptionPolicy() {
    return encryptionPolicy;
  }

  /**
   * Whether encryption is enabled
   * @param encryptionPolicy encryptionPolicy or {@code null} for none
   */
  public Policy setEncryptionPolicy(java.lang.String encryptionPolicy) {
    this.encryptionPolicy = encryptionPolicy;
    return this;
  }

  /**
   * Whether app verification is force-enabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getEnsureVerifyAppsEnabled() {
    return ensureVerifyAppsEnabled;
  }

  /**
   * Whether app verification is force-enabled.
   * @param ensureVerifyAppsEnabled ensureVerifyAppsEnabled or {@code null} for none
   */
  public Policy setEnsureVerifyAppsEnabled(java.lang.Boolean ensureVerifyAppsEnabled) {
    this.ensureVerifyAppsEnabled = ensureVerifyAppsEnabled;
    return this;
  }

  /**
   * Whether factory resetting from settings is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getFactoryResetDisabled() {
    return factoryResetDisabled;
  }

  /**
   * Whether factory resetting from settings is disabled.
   * @param factoryResetDisabled factoryResetDisabled or {@code null} for none
   */
  public Policy setFactoryResetDisabled(java.lang.Boolean factoryResetDisabled) {
    this.factoryResetDisabled = factoryResetDisabled;
    return this;
  }

  /**
   * Email addresses of device administrators for factory reset protection. When the device is
   * factory reset, it will require one of these admins to log in with the Google account email and
   * password to unlock the device. If no admins are specified, the device won't provide factory
   * reset protection.
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.String> getFrpAdminEmails() {
    return frpAdminEmails;
  }

  /**
   * Email addresses of device administrators for factory reset protection. When the device is
   * factory reset, it will require one of these admins to log in with the Google account email and
   * password to unlock the device. If no admins are specified, the device won't provide factory
   * reset protection.
   * @param frpAdminEmails frpAdminEmails or {@code null} for none
   */
  public Policy setFrpAdminEmails(java.util.List<java.lang.String> frpAdminEmails) {
    this.frpAdminEmails = frpAdminEmails;
    return this;
  }

  /**
   * Whether the user is allowed to have fun. Controls whether the Easter egg game in Settings is
   * disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getFunDisabled() {
    return funDisabled;
  }

  /**
   * Whether the user is allowed to have fun. Controls whether the Easter egg game in Settings is
   * disabled.
   * @param funDisabled funDisabled or {@code null} for none
   */
  public Policy setFunDisabled(java.lang.Boolean funDisabled) {
    this.funDisabled = funDisabled;
    return this;
  }

  /**
   * Whether user installation of apps is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getInstallAppsDisabled() {
    return installAppsDisabled;
  }

  /**
   * Whether user installation of apps is disabled.
   * @param installAppsDisabled installAppsDisabled or {@code null} for none
   */
  public Policy setInstallAppsDisabled(java.lang.Boolean installAppsDisabled) {
    this.installAppsDisabled = installAppsDisabled;
    return this;
  }

  /**
   * This field has no effect.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getInstallUnknownSourcesAllowed() {
    return installUnknownSourcesAllowed;
  }

  /**
   * This field has no effect.
   * @param installUnknownSourcesAllowed installUnknownSourcesAllowed or {@code null} for none
   */
  public Policy setInstallUnknownSourcesAllowed(java.lang.Boolean installUnknownSourcesAllowed) {
    this.installUnknownSourcesAllowed = installUnknownSourcesAllowed;
    return this;
  }

  /**
   * If true, this disables the Lock Screen
   * (https://source.android.com/docs/core/display/multi_display/lock-screen) for primary and/or
   * secondary displays. This policy is supported only in dedicated device management mode.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getKeyguardDisabled() {
    return keyguardDisabled;
  }

  /**
   * If true, this disables the Lock Screen
   * (https://source.android.com/docs/core/display/multi_display/lock-screen) for primary and/or
   * secondary displays. This policy is supported only in dedicated device management mode.
   * @param keyguardDisabled keyguardDisabled or {@code null} for none
   */
  public Policy setKeyguardDisabled(java.lang.Boolean keyguardDisabled) {
    this.keyguardDisabled = keyguardDisabled;
    return this;
  }

  /**
   * Disabled keyguard customizations, such as widgets.
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.String> getKeyguardDisabledFeatures() {
    return keyguardDisabledFeatures;
  }

  /**
   * Disabled keyguard customizations, such as widgets.
   * @param keyguardDisabledFeatures keyguardDisabledFeatures or {@code null} for none
   */
  public Policy setKeyguardDisabledFeatures(java.util.List<java.lang.String> keyguardDisabledFeatures) {
    this.keyguardDisabledFeatures = keyguardDisabledFeatures;
    return this;
  }

  /**
   * Whether the kiosk custom launcher is enabled. This replaces the home screen with a launcher
   * that locks down the device to the apps installed via the applications setting. Apps appear on a
   * single page in alphabetical order. Use kioskCustomization to further configure the kiosk device
   * behavior.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getKioskCustomLauncherEnabled() {
    return kioskCustomLauncherEnabled;
  }

  /**
   * Whether the kiosk custom launcher is enabled. This replaces the home screen with a launcher
   * that locks down the device to the apps installed via the applications setting. Apps appear on a
   * single page in alphabetical order. Use kioskCustomization to further configure the kiosk device
   * behavior.
   * @param kioskCustomLauncherEnabled kioskCustomLauncherEnabled or {@code null} for none
   */
  public Policy setKioskCustomLauncherEnabled(java.lang.Boolean kioskCustomLauncherEnabled) {
    this.kioskCustomLauncherEnabled = kioskCustomLauncherEnabled;
    return this;
  }

  /**
   * Settings controlling the behavior of a device in kiosk mode. To enable kiosk mode, set
   * kioskCustomLauncherEnabled to true or specify an app in the policy with installType KIOSK.
   * @return value or {@code null} for none
   */
  public KioskCustomization getKioskCustomization() {
    return kioskCustomization;
  }

  /**
   * Settings controlling the behavior of a device in kiosk mode. To enable kiosk mode, set
   * kioskCustomLauncherEnabled to true or specify an app in the policy with installType KIOSK.
   * @param kioskCustomization kioskCustomization or {@code null} for none
   */
  public Policy setKioskCustomization(KioskCustomization kioskCustomization) {
    this.kioskCustomization = kioskCustomization;
    return this;
  }

  /**
   * The degree of location detection enabled.
   * @return value or {@code null} for none
   */
  public java.lang.String getLocationMode() {
    return locationMode;
  }

  /**
   * The degree of location detection enabled.
   * @param locationMode locationMode or {@code null} for none
   */
  public Policy setLocationMode(java.lang.String locationMode) {
    this.locationMode = locationMode;
    return this;
  }

  /**
   * A message displayed to the user in the device administators settings screen.
   * @return value or {@code null} for none
   */
  public UserFacingMessage getLongSupportMessage() {
    return longSupportMessage;
  }

  /**
   * A message displayed to the user in the device administators settings screen.
   * @param longSupportMessage longSupportMessage or {@code null} for none
   */
  public Policy setLongSupportMessage(UserFacingMessage longSupportMessage) {
    this.longSupportMessage = longSupportMessage;
    return this;
  }

  /**
   * Maximum time in milliseconds for user activity until the device locks. A value of 0 means there
   * is no restriction.
   * @return value or {@code null} for none
   */
  public java.lang.Long getMaximumTimeToLock() {
    return maximumTimeToLock;
  }

  /**
   * Maximum time in milliseconds for user activity until the device locks. A value of 0 means there
   * is no restriction.
   * @param maximumTimeToLock maximumTimeToLock or {@code null} for none
   */
  public Policy setMaximumTimeToLock(java.lang.Long maximumTimeToLock) {
    this.maximumTimeToLock = maximumTimeToLock;
    return this;
  }

  /**
   * Controls the use of the microphone and whether the user has access to the microphone access
   * toggle. This applies only on fully managed devices.
   * @return value or {@code null} for none
   */
  public java.lang.String getMicrophoneAccess() {
    return microphoneAccess;
  }

  /**
   * Controls the use of the microphone and whether the user has access to the microphone access
   * toggle. This applies only on fully managed devices.
   * @param microphoneAccess microphoneAccess or {@code null} for none
   */
  public Policy setMicrophoneAccess(java.lang.String microphoneAccess) {
    this.microphoneAccess = microphoneAccess;
    return this;
  }

  /**
   * The minimum allowed Android API level.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getMinimumApiLevel() {
    return minimumApiLevel;
  }

  /**
   * The minimum allowed Android API level.
   * @param minimumApiLevel minimumApiLevel or {@code null} for none
   */
  public Policy setMinimumApiLevel(java.lang.Integer minimumApiLevel) {
    this.minimumApiLevel = minimumApiLevel;
    return this;
  }

  /**
   * Whether configuring mobile networks is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getMobileNetworksConfigDisabled() {
    return mobileNetworksConfigDisabled;
  }

  /**
   * Whether configuring mobile networks is disabled.
   * @param mobileNetworksConfigDisabled mobileNetworksConfigDisabled or {@code null} for none
   */
  public Policy setMobileNetworksConfigDisabled(java.lang.Boolean mobileNetworksConfigDisabled) {
    this.mobileNetworksConfigDisabled = mobileNetworksConfigDisabled;
    return this;
  }

  /**
   * Whether adding or removing accounts is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getModifyAccountsDisabled() {
    return modifyAccountsDisabled;
  }

  /**
   * Whether adding or removing accounts is disabled.
   * @param modifyAccountsDisabled modifyAccountsDisabled or {@code null} for none
   */
  public Policy setModifyAccountsDisabled(java.lang.Boolean modifyAccountsDisabled) {
    this.modifyAccountsDisabled = modifyAccountsDisabled;
    return this;
  }

  /**
   * Whether the user mounting physical external media is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getMountPhysicalMediaDisabled() {
    return mountPhysicalMediaDisabled;
  }

  /**
   * Whether the user mounting physical external media is disabled.
   * @param mountPhysicalMediaDisabled mountPhysicalMediaDisabled or {@code null} for none
   */
  public Policy setMountPhysicalMediaDisabled(java.lang.Boolean mountPhysicalMediaDisabled) {
    this.mountPhysicalMediaDisabled = mountPhysicalMediaDisabled;
    return this;
  }

  /**
   * The name of the policy in the form enterprises/{enterpriseId}/policies/{policyId}.
   * @return value or {@code null} for none
   */
  public java.lang.String getName() {
    return name;
  }

  /**
   * The name of the policy in the form enterprises/{enterpriseId}/policies/{policyId}.
   * @param name name or {@code null} for none
   */
  public Policy setName(java.lang.String name) {
    this.name = name;
    return this;
  }

  /**
   * Whether the network escape hatch is enabled. If a network connection can't be made at boot
   * time, the escape hatch prompts the user to temporarily connect to a network in order to refresh
   * the device policy. After applying policy, the temporary network will be forgotten and the
   * device will continue booting. This prevents being unable to connect to a network if there is no
   * suitable network in the last policy and the device boots into an app in lock task mode, or the
   * user is otherwise unable to reach device settings.Note: Setting wifiConfigDisabled to true will
   * override this setting under specific circumstances. Please see wifiConfigDisabled for further
   * details. Setting configureWifi to DISALLOW_CONFIGURING_WIFI will override this setting under
   * specific circumstances. Please see DISALLOW_CONFIGURING_WIFI for further details.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getNetworkEscapeHatchEnabled() {
    return networkEscapeHatchEnabled;
  }

  /**
   * Whether the network escape hatch is enabled. If a network connection can't be made at boot
   * time, the escape hatch prompts the user to temporarily connect to a network in order to refresh
   * the device policy. After applying policy, the temporary network will be forgotten and the
   * device will continue booting. This prevents being unable to connect to a network if there is no
   * suitable network in the last policy and the device boots into an app in lock task mode, or the
   * user is otherwise unable to reach device settings.Note: Setting wifiConfigDisabled to true will
   * override this setting under specific circumstances. Please see wifiConfigDisabled for further
   * details. Setting configureWifi to DISALLOW_CONFIGURING_WIFI will override this setting under
   * specific circumstances. Please see DISALLOW_CONFIGURING_WIFI for further details.
   * @param networkEscapeHatchEnabled networkEscapeHatchEnabled or {@code null} for none
   */
  public Policy setNetworkEscapeHatchEnabled(java.lang.Boolean networkEscapeHatchEnabled) {
    this.networkEscapeHatchEnabled = networkEscapeHatchEnabled;
    return this;
  }

  /**
   * Whether resetting network settings is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getNetworkResetDisabled() {
    return networkResetDisabled;
  }

  /**
   * Whether resetting network settings is disabled.
   * @param networkResetDisabled networkResetDisabled or {@code null} for none
   */
  public Policy setNetworkResetDisabled(java.lang.Boolean networkResetDisabled) {
    this.networkResetDisabled = networkResetDisabled;
    return this;
  }

  /**
   * This feature is not generally available.
   * @return value or {@code null} for none
   */
  public java.util.List<OncCertificateProvider> getOncCertificateProviders() {
    return oncCertificateProviders;
  }

  /**
   * This feature is not generally available.
   * @param oncCertificateProviders oncCertificateProviders or {@code null} for none
   */
  public Policy setOncCertificateProviders(java.util.List<OncCertificateProvider> oncCertificateProviders) {
    this.oncCertificateProviders = oncCertificateProviders;
    return this;
  }

  /**
   * Network configuration for the device. See configure networks for more information.
   * @return value or {@code null} for none
   */
  public java.util.Map<String, java.lang.Object> getOpenNetworkConfiguration() {
    return openNetworkConfiguration;
  }

  /**
   * Network configuration for the device. See configure networks for more information.
   * @param openNetworkConfiguration openNetworkConfiguration or {@code null} for none
   */
  public Policy setOpenNetworkConfiguration(java.util.Map<String, java.lang.Object> openNetworkConfiguration) {
    this.openNetworkConfiguration = openNetworkConfiguration;
    return this;
  }

  /**
   * Whether using NFC to beam data from apps is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getOutgoingBeamDisabled() {
    return outgoingBeamDisabled;
  }

  /**
   * Whether using NFC to beam data from apps is disabled.
   * @param outgoingBeamDisabled outgoingBeamDisabled or {@code null} for none
   */
  public Policy setOutgoingBeamDisabled(java.lang.Boolean outgoingBeamDisabled) {
    this.outgoingBeamDisabled = outgoingBeamDisabled;
    return this;
  }

  /**
   * Whether outgoing calls are disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getOutgoingCallsDisabled() {
    return outgoingCallsDisabled;
  }

  /**
   * Whether outgoing calls are disabled.
   * @param outgoingCallsDisabled outgoingCallsDisabled or {@code null} for none
   */
  public Policy setOutgoingCallsDisabled(java.lang.Boolean outgoingCallsDisabled) {
    this.outgoingCallsDisabled = outgoingCallsDisabled;
    return this;
  }

  /**
   * Password requirement policies. Different policies can be set for work profile or fully managed
   * devices by setting the password_scope field in the policy.
   * @return value or {@code null} for none
   */
  public java.util.List<PasswordRequirements> getPasswordPolicies() {
    return passwordPolicies;
  }

  /**
   * Password requirement policies. Different policies can be set for work profile or fully managed
   * devices by setting the password_scope field in the policy.
   * @param passwordPolicies passwordPolicies or {@code null} for none
   */
  public Policy setPasswordPolicies(java.util.List<PasswordRequirements> passwordPolicies) {
    this.passwordPolicies = passwordPolicies;
    return this;
  }

  /**
   * Password requirements. The field password_requirements.require_password_unlock must not be set.
   * DEPRECATED - Use passwordPolicies.Note:Complexity-based values of PasswordQuality, that is,
   * COMPLEXITY_LOW, COMPLEXITY_MEDIUM, and COMPLEXITY_HIGH, cannot be used here.
   * unified_lock_settings cannot be used here.
   * @return value or {@code null} for none
   */
  public PasswordRequirements getPasswordRequirements() {
    return passwordRequirements;
  }

  /**
   * Password requirements. The field password_requirements.require_password_unlock must not be set.
   * DEPRECATED - Use passwordPolicies.Note:Complexity-based values of PasswordQuality, that is,
   * COMPLEXITY_LOW, COMPLEXITY_MEDIUM, and COMPLEXITY_HIGH, cannot be used here.
   * unified_lock_settings cannot be used here.
   * @param passwordRequirements passwordRequirements or {@code null} for none
   */
  public Policy setPasswordRequirements(PasswordRequirements passwordRequirements) {
    this.passwordRequirements = passwordRequirements;
    return this;
  }

  /**
   * Explicit permission or group grants or denials for all apps. These values override the
   * default_permission_policy.
   * @return value or {@code null} for none
   */
  public java.util.List<PermissionGrant> getPermissionGrants() {
    return permissionGrants;
  }

  /**
   * Explicit permission or group grants or denials for all apps. These values override the
   * default_permission_policy.
   * @param permissionGrants permissionGrants or {@code null} for none
   */
  public Policy setPermissionGrants(java.util.List<PermissionGrant> permissionGrants) {
    this.permissionGrants = permissionGrants;
    return this;
  }

  /**
   * Specifies permitted accessibility services. If the field is not set, any accessibility service
   * can be used. If the field is set, only the accessibility services in this list and the system's
   * built-in accessibility service can be used. In particular, if the field is set to empty, only
   * the system's built-in accessibility servicess can be used. This can be set on fully managed
   * devices and on work profiles. When applied to a work profile, this affects both the personal
   * profile and the work profile.
   * @return value or {@code null} for none
   */
  public PackageNameList getPermittedAccessibilityServices() {
    return permittedAccessibilityServices;
  }

  /**
   * Specifies permitted accessibility services. If the field is not set, any accessibility service
   * can be used. If the field is set, only the accessibility services in this list and the system's
   * built-in accessibility service can be used. In particular, if the field is set to empty, only
   * the system's built-in accessibility servicess can be used. This can be set on fully managed
   * devices and on work profiles. When applied to a work profile, this affects both the personal
   * profile and the work profile.
   * @param permittedAccessibilityServices permittedAccessibilityServices or {@code null} for none
   */
  public Policy setPermittedAccessibilityServices(PackageNameList permittedAccessibilityServices) {
    this.permittedAccessibilityServices = permittedAccessibilityServices;
    return this;
  }

  /**
   * If present, only the input methods provided by packages in this list are permitted. If this
   * field is present, but the list is empty, then only system input methods are permitted.
   * @return value or {@code null} for none
   */
  public PackageNameList getPermittedInputMethods() {
    return permittedInputMethods;
  }

  /**
   * If present, only the input methods provided by packages in this list are permitted. If this
   * field is present, but the list is empty, then only system input methods are permitted.
   * @param permittedInputMethods permittedInputMethods or {@code null} for none
   */
  public Policy setPermittedInputMethods(PackageNameList permittedInputMethods) {
    this.permittedInputMethods = permittedInputMethods;
    return this;
  }

  /**
   * Default intent handler activities.
   * @return value or {@code null} for none
   */
  public java.util.List<PersistentPreferredActivity> getPersistentPreferredActivities() {
    return persistentPreferredActivities;
  }

  /**
   * Default intent handler activities.
   * @param persistentPreferredActivities persistentPreferredActivities or {@code null} for none
   */
  public Policy setPersistentPreferredActivities(java.util.List<PersistentPreferredActivity> persistentPreferredActivities) {
    this.persistentPreferredActivities = persistentPreferredActivities;
    return this;
  }

  /**
   * Policies managing personal usage on a company-owned device.
   * @return value or {@code null} for none
   */
  public PersonalUsagePolicies getPersonalUsagePolicies() {
    return personalUsagePolicies;
  }

  /**
   * Policies managing personal usage on a company-owned device.
   * @param personalUsagePolicies personalUsagePolicies or {@code null} for none
   */
  public Policy setPersonalUsagePolicies(PersonalUsagePolicies personalUsagePolicies) {
    this.personalUsagePolicies = personalUsagePolicies;
    return this;
  }

  /**
   * This mode controls which apps are available to the user in the Play Store and the behavior on
   * the device when apps are removed from the policy.
   * @return value or {@code null} for none
   */
  public java.lang.String getPlayStoreMode() {
    return playStoreMode;
  }

  /**
   * This mode controls which apps are available to the user in the Play Store and the behavior on
   * the device when apps are removed from the policy.
   * @param playStoreMode playStoreMode or {@code null} for none
   */
  public Policy setPlayStoreMode(java.lang.String playStoreMode) {
    this.playStoreMode = playStoreMode;
    return this;
  }

  /**
   * Rules that define the behavior when a particular policy can not be applied on device
   * @return value or {@code null} for none
   */
  public java.util.List<PolicyEnforcementRule> getPolicyEnforcementRules() {
    return policyEnforcementRules;
  }

  /**
   * Rules that define the behavior when a particular policy can not be applied on device
   * @param policyEnforcementRules policyEnforcementRules or {@code null} for none
   */
  public Policy setPolicyEnforcementRules(java.util.List<PolicyEnforcementRule> policyEnforcementRules) {
    this.policyEnforcementRules = policyEnforcementRules;
    return this;
  }

  /**
   * Controls whether preferential network service is enabled on the work profile. For example, an
   * organization may have an agreement with a carrier that all of the work data from its employees'
   * devices will be sent via a network service dedicated for enterprise use. An example of a
   * supported preferential network service is the enterprise slice on 5G networks. This has no
   * effect on fully managed devices.
   * @return value or {@code null} for none
   */
  public java.lang.String getPreferentialNetworkService() {
    return preferentialNetworkService;
  }

  /**
   * Controls whether preferential network service is enabled on the work profile. For example, an
   * organization may have an agreement with a carrier that all of the work data from its employees'
   * devices will be sent via a network service dedicated for enterprise use. An example of a
   * supported preferential network service is the enterprise slice on 5G networks. This has no
   * effect on fully managed devices.
   * @param preferentialNetworkService preferentialNetworkService or {@code null} for none
   */
  public Policy setPreferentialNetworkService(java.lang.String preferentialNetworkService) {
    this.preferentialNetworkService = preferentialNetworkService;
    return this;
  }

  /**
   * Optional. Controls whether printing is allowed. This is supported on devices running Android 9
   * and above. .
   * @return value or {@code null} for none
   */
  public java.lang.String getPrintingPolicy() {
    return printingPolicy;
  }

  /**
   * Optional. Controls whether printing is allowed. This is supported on devices running Android 9
   * and above. .
   * @param printingPolicy printingPolicy or {@code null} for none
   */
  public Policy setPrintingPolicy(java.lang.String printingPolicy) {
    this.printingPolicy = printingPolicy;
    return this;
  }

  /**
   * Allows showing UI on a device for a user to choose a private key alias if there are no matching
   * rules in ChoosePrivateKeyRules. For devices below Android P, setting this may leave enterprise
   * keys vulnerable. This value will have no effect if any application has CERT_SELECTION
   * delegation scope.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getPrivateKeySelectionEnabled() {
    return privateKeySelectionEnabled;
  }

  /**
   * Allows showing UI on a device for a user to choose a private key alias if there are no matching
   * rules in ChoosePrivateKeyRules. For devices below Android P, setting this may leave enterprise
   * keys vulnerable. This value will have no effect if any application has CERT_SELECTION
   * delegation scope.
   * @param privateKeySelectionEnabled privateKeySelectionEnabled or {@code null} for none
   */
  public Policy setPrivateKeySelectionEnabled(java.lang.Boolean privateKeySelectionEnabled) {
    this.privateKeySelectionEnabled = privateKeySelectionEnabled;
    return this;
  }

  /**
   * The network-independent global HTTP proxy. Typically proxies should be configured per-network
   * in open_network_configuration. However for unusual configurations like general internal
   * filtering a global HTTP proxy may be useful. If the proxy is not accessible, network access may
   * break. The global proxy is only a recommendation and some apps may ignore it.
   * @return value or {@code null} for none
   */
  public ProxyInfo getRecommendedGlobalProxy() {
    return recommendedGlobalProxy;
  }

  /**
   * The network-independent global HTTP proxy. Typically proxies should be configured per-network
   * in open_network_configuration. However for unusual configurations like general internal
   * filtering a global HTTP proxy may be useful. If the proxy is not accessible, network access may
   * break. The global proxy is only a recommendation and some apps may ignore it.
   * @param recommendedGlobalProxy recommendedGlobalProxy or {@code null} for none
   */
  public Policy setRecommendedGlobalProxy(ProxyInfo recommendedGlobalProxy) {
    this.recommendedGlobalProxy = recommendedGlobalProxy;
    return this;
  }

  /**
   * Whether removing other users is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getRemoveUserDisabled() {
    return removeUserDisabled;
  }

  /**
   * Whether removing other users is disabled.
   * @param removeUserDisabled removeUserDisabled or {@code null} for none
   */
  public Policy setRemoveUserDisabled(java.lang.Boolean removeUserDisabled) {
    this.removeUserDisabled = removeUserDisabled;
    return this;
  }

  /**
   * Whether rebooting the device into safe boot is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getSafeBootDisabled() {
    return safeBootDisabled;
  }

  /**
   * Whether rebooting the device into safe boot is disabled.
   * @param safeBootDisabled safeBootDisabled or {@code null} for none
   */
  public Policy setSafeBootDisabled(java.lang.Boolean safeBootDisabled) {
    this.safeBootDisabled = safeBootDisabled;
    return this;
  }

  /**
   * Whether screen capture is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getScreenCaptureDisabled() {
    return screenCaptureDisabled;
  }

  /**
   * Whether screen capture is disabled.
   * @param screenCaptureDisabled screenCaptureDisabled or {@code null} for none
   */
  public Policy setScreenCaptureDisabled(java.lang.Boolean screenCaptureDisabled) {
    this.screenCaptureDisabled = screenCaptureDisabled;
    return this;
  }

  /**
   * Whether changing the user icon is disabled. The setting has effect only on fully managed
   * devices.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getSetUserIconDisabled() {
    return setUserIconDisabled;
  }

  /**
   * Whether changing the user icon is disabled. The setting has effect only on fully managed
   * devices.
   * @param setUserIconDisabled setUserIconDisabled or {@code null} for none
   */
  public Policy setSetUserIconDisabled(java.lang.Boolean setUserIconDisabled) {
    this.setUserIconDisabled = setUserIconDisabled;
    return this;
  }

  /**
   * Whether changing the wallpaper is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getSetWallpaperDisabled() {
    return setWallpaperDisabled;
  }

  /**
   * Whether changing the wallpaper is disabled.
   * @param setWallpaperDisabled setWallpaperDisabled or {@code null} for none
   */
  public Policy setSetWallpaperDisabled(java.lang.Boolean setWallpaperDisabled) {
    this.setWallpaperDisabled = setWallpaperDisabled;
    return this;
  }

  /**
   * Action to take during the setup process. At most one action may be specified.
   * @return value or {@code null} for none
   */
  public java.util.List<SetupAction> getSetupActions() {
    return setupActions;
  }

  /**
   * Action to take during the setup process. At most one action may be specified.
   * @param setupActions setupActions or {@code null} for none
   */
  public Policy setSetupActions(java.util.List<SetupAction> setupActions) {
    this.setupActions = setupActions;
    return this;
  }

  /**
   * Whether location sharing is disabled. share_location_disabled is supported for both fully
   * managed devices and personally owned work profiles.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getShareLocationDisabled() {
    return shareLocationDisabled;
  }

  /**
   * Whether location sharing is disabled. share_location_disabled is supported for both fully
   * managed devices and personally owned work profiles.
   * @param shareLocationDisabled shareLocationDisabled or {@code null} for none
   */
  public Policy setShareLocationDisabled(java.lang.Boolean shareLocationDisabled) {
    this.shareLocationDisabled = shareLocationDisabled;
    return this;
  }

  /**
   * A message displayed to the user in the settings screen wherever functionality has been disabled
   * by the admin. If the message is longer than 200 characters it may be truncated.
   * @return value or {@code null} for none
   */
  public UserFacingMessage getShortSupportMessage() {
    return shortSupportMessage;
  }

  /**
   * A message displayed to the user in the settings screen wherever functionality has been disabled
   * by the admin. If the message is longer than 200 characters it may be truncated.
   * @param shortSupportMessage shortSupportMessage or {@code null} for none
   */
  public Policy setShortSupportMessage(UserFacingMessage shortSupportMessage) {
    this.shortSupportMessage = shortSupportMessage;
    return this;
  }

  /**
   * Flag to skip hints on the first use. Enterprise admin can enable the system recommendation for
   * apps to skip their user tutorial and other introductory hints on first start-up.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getSkipFirstUseHintsEnabled() {
    return skipFirstUseHintsEnabled;
  }

  /**
   * Flag to skip hints on the first use. Enterprise admin can enable the system recommendation for
   * apps to skip their user tutorial and other introductory hints on first start-up.
   * @param skipFirstUseHintsEnabled skipFirstUseHintsEnabled or {@code null} for none
   */
  public Policy setSkipFirstUseHintsEnabled(java.lang.Boolean skipFirstUseHintsEnabled) {
    this.skipFirstUseHintsEnabled = skipFirstUseHintsEnabled;
    return this;
  }

  /**
   * Whether sending and receiving SMS messages is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getSmsDisabled() {
    return smsDisabled;
  }

  /**
   * Whether sending and receiving SMS messages is disabled.
   * @param smsDisabled smsDisabled or {@code null} for none
   */
  public Policy setSmsDisabled(java.lang.Boolean smsDisabled) {
    this.smsDisabled = smsDisabled;
    return this;
  }

  /**
   * Whether the status bar is disabled. This disables notifications, quick settings, and other
   * screen overlays that allow escape from full-screen mode. DEPRECATED. To disable the status bar
   * on a kiosk device, use InstallType KIOSK or kioskCustomLauncherEnabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getStatusBarDisabled() {
    return statusBarDisabled;
  }

  /**
   * Whether the status bar is disabled. This disables notifications, quick settings, and other
   * screen overlays that allow escape from full-screen mode. DEPRECATED. To disable the status bar
   * on a kiosk device, use InstallType KIOSK or kioskCustomLauncherEnabled.
   * @param statusBarDisabled statusBarDisabled or {@code null} for none
   */
  public Policy setStatusBarDisabled(java.lang.Boolean statusBarDisabled) {
    this.statusBarDisabled = statusBarDisabled;
    return this;
  }

  /**
   * Status reporting settings
   * @return value or {@code null} for none
   */
  public StatusReportingSettings getStatusReportingSettings() {
    return statusReportingSettings;
  }

  /**
   * Status reporting settings
   * @param statusReportingSettings statusReportingSettings or {@code null} for none
   */
  public Policy setStatusReportingSettings(StatusReportingSettings statusReportingSettings) {
    this.statusReportingSettings = statusReportingSettings;
    return this;
  }

  /**
   * The battery plugged in modes for which the device stays on. When using this setting, it is
   * recommended to clear maximum_time_to_lock so that the device doesn't lock itself while it stays
   * on.
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.String> getStayOnPluggedModes() {
    return stayOnPluggedModes;
  }

  /**
   * The battery plugged in modes for which the device stays on. When using this setting, it is
   * recommended to clear maximum_time_to_lock so that the device doesn't lock itself while it stays
   * on.
   * @param stayOnPluggedModes stayOnPluggedModes or {@code null} for none
   */
  public Policy setStayOnPluggedModes(java.util.List<java.lang.String> stayOnPluggedModes) {
    this.stayOnPluggedModes = stayOnPluggedModes;
    return this;
  }

  /**
   * The system update policy, which controls how OS updates are applied. If the update type is
   * WINDOWED, the update window will automatically apply to Play app updates as well.Note: Google
   * Play system updates (https://source.android.com/docs/core/ota/modular-system) (also called
   * Mainline updates) are automatically downloaded and require a device reboot to be installed.
   * Refer to the mainline section in Manage system updates
   * (https://developer.android.com/work/dpc/system-updates#mainline) for further details.
   * @return value or {@code null} for none
   */
  public SystemUpdate getSystemUpdate() {
    return systemUpdate;
  }

  /**
   * The system update policy, which controls how OS updates are applied. If the update type is
   * WINDOWED, the update window will automatically apply to Play app updates as well.Note: Google
   * Play system updates (https://source.android.com/docs/core/ota/modular-system) (also called
   * Mainline updates) are automatically downloaded and require a device reboot to be installed.
   * Refer to the mainline section in Manage system updates
   * (https://developer.android.com/work/dpc/system-updates#mainline) for further details.
   * @param systemUpdate systemUpdate or {@code null} for none
   */
  public Policy setSystemUpdate(SystemUpdate systemUpdate) {
    this.systemUpdate = systemUpdate;
    return this;
  }

  /**
   * Whether configuring tethering and portable hotspots is disabled. If tetheringSettings is set to
   * anything other than TETHERING_SETTINGS_UNSPECIFIED, this setting is ignored.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getTetheringConfigDisabled() {
    return tetheringConfigDisabled;
  }

  /**
   * Whether configuring tethering and portable hotspots is disabled. If tetheringSettings is set to
   * anything other than TETHERING_SETTINGS_UNSPECIFIED, this setting is ignored.
   * @param tetheringConfigDisabled tetheringConfigDisabled or {@code null} for none
   */
  public Policy setTetheringConfigDisabled(java.lang.Boolean tetheringConfigDisabled) {
    this.tetheringConfigDisabled = tetheringConfigDisabled;
    return this;
  }

  /**
   * Whether user uninstallation of applications is disabled. This prevents apps from being
   * uninstalled, even those removed using applications
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getUninstallAppsDisabled() {
    return uninstallAppsDisabled;
  }

  /**
   * Whether user uninstallation of applications is disabled. This prevents apps from being
   * uninstalled, even those removed using applications
   * @param uninstallAppsDisabled uninstallAppsDisabled or {@code null} for none
   */
  public Policy setUninstallAppsDisabled(java.lang.Boolean uninstallAppsDisabled) {
    this.uninstallAppsDisabled = uninstallAppsDisabled;
    return this;
  }

  /**
   * If microphone_access is set to any value other than MICROPHONE_ACCESS_UNSPECIFIED, this has no
   * effect. Otherwise this field controls whether microphones are disabled: If true, all
   * microphones are disabled, otherwise they are available. This is available only on fully managed
   * devices.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getUnmuteMicrophoneDisabled() {
    return unmuteMicrophoneDisabled;
  }

  /**
   * If microphone_access is set to any value other than MICROPHONE_ACCESS_UNSPECIFIED, this has no
   * effect. Otherwise this field controls whether microphones are disabled: If true, all
   * microphones are disabled, otherwise they are available. This is available only on fully managed
   * devices.
   * @param unmuteMicrophoneDisabled unmuteMicrophoneDisabled or {@code null} for none
   */
  public Policy setUnmuteMicrophoneDisabled(java.lang.Boolean unmuteMicrophoneDisabled) {
    this.unmuteMicrophoneDisabled = unmuteMicrophoneDisabled;
    return this;
  }

  /**
   * Configuration of device activity logging.
   * @return value or {@code null} for none
   */
  public UsageLog getUsageLog() {
    return usageLog;
  }

  /**
   * Configuration of device activity logging.
   * @param usageLog usageLog or {@code null} for none
   */
  public Policy setUsageLog(UsageLog usageLog) {
    this.usageLog = usageLog;
    return this;
  }

  /**
   * Whether transferring files over USB is disabled. This is supported only on company-owned
   * devices.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getUsbFileTransferDisabled() {
    return usbFileTransferDisabled;
  }

  /**
   * Whether transferring files over USB is disabled. This is supported only on company-owned
   * devices.
   * @param usbFileTransferDisabled usbFileTransferDisabled or {@code null} for none
   */
  public Policy setUsbFileTransferDisabled(java.lang.Boolean usbFileTransferDisabled) {
    this.usbFileTransferDisabled = usbFileTransferDisabled;
    return this;
  }

  /**
   * Whether USB storage is enabled. Deprecated.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getUsbMassStorageEnabled() {
    return usbMassStorageEnabled;
  }

  /**
   * Whether USB storage is enabled. Deprecated.
   * @param usbMassStorageEnabled usbMassStorageEnabled or {@code null} for none
   */
  public Policy setUsbMassStorageEnabled(java.lang.Boolean usbMassStorageEnabled) {
    this.usbMassStorageEnabled = usbMassStorageEnabled;
    return this;
  }

  /**
   * The version of the policy. This is a read-only field. The version is incremented each time the
   * policy is updated.
   * @return value or {@code null} for none
   */
  public java.lang.Long getVersion() {
    return version;
  }

  /**
   * The version of the policy. This is a read-only field. The version is incremented each time the
   * policy is updated.
   * @param version version or {@code null} for none
   */
  public Policy setVersion(java.lang.Long version) {
    this.version = version;
    return this;
  }

  /**
   * Whether configuring VPN is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getVpnConfigDisabled() {
    return vpnConfigDisabled;
  }

  /**
   * Whether configuring VPN is disabled.
   * @param vpnConfigDisabled vpnConfigDisabled or {@code null} for none
   */
  public Policy setVpnConfigDisabled(java.lang.Boolean vpnConfigDisabled) {
    this.vpnConfigDisabled = vpnConfigDisabled;
    return this;
  }

  /**
   * Whether configuring Wi-Fi networks is disabled. Supported on fully managed devices and work
   * profiles on company-owned devices. For fully managed devices, setting this to true removes all
   * configured networks and retains only the networks configured using openNetworkConfiguration.
   * For work profiles on company-owned devices, existing configured networks are not affected and
   * the user is not allowed to add, remove, or modify Wi-Fi networks. If configureWifi is set to
   * anything other than CONFIGURE_WIFI_UNSPECIFIED, this setting is ignored. Note: If a network
   * connection can't be made at boot time and configuring Wi-Fi is disabled then network escape
   * hatch will be shown in order to refresh the device policy (see networkEscapeHatchEnabled).
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getWifiConfigDisabled() {
    return wifiConfigDisabled;
  }

  /**
   * Whether configuring Wi-Fi networks is disabled. Supported on fully managed devices and work
   * profiles on company-owned devices. For fully managed devices, setting this to true removes all
   * configured networks and retains only the networks configured using openNetworkConfiguration.
   * For work profiles on company-owned devices, existing configured networks are not affected and
   * the user is not allowed to add, remove, or modify Wi-Fi networks. If configureWifi is set to
   * anything other than CONFIGURE_WIFI_UNSPECIFIED, this setting is ignored. Note: If a network
   * connection can't be made at boot time and configuring Wi-Fi is disabled then network escape
   * hatch will be shown in order to refresh the device policy (see networkEscapeHatchEnabled).
   * @param wifiConfigDisabled wifiConfigDisabled or {@code null} for none
   */
  public Policy setWifiConfigDisabled(java.lang.Boolean wifiConfigDisabled) {
    this.wifiConfigDisabled = wifiConfigDisabled;
    return this;
  }

  /**
   * This is deprecated.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getWifiConfigsLockdownEnabled() {
    return wifiConfigsLockdownEnabled;
  }

  /**
   * This is deprecated.
   * @param wifiConfigsLockdownEnabled wifiConfigsLockdownEnabled or {@code null} for none
   */
  public Policy setWifiConfigsLockdownEnabled(java.lang.Boolean wifiConfigsLockdownEnabled) {
    this.wifiConfigsLockdownEnabled = wifiConfigsLockdownEnabled;
    return this;
  }

  @Override
  public Policy set(String fieldName, Object value) {
    return (Policy) super.set(fieldName, value);
  }

  @Override
  public Policy clone() {
    return (Policy) super.clone();
  }

}
