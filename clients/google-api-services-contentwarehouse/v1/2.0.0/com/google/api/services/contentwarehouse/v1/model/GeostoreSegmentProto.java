/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.contentwarehouse.v1.model;

/**
 * --------------------------------------------------------------------------- WARNING - if you add
 * new fields to SegmentProto (or to other protos used by SegmentProto), you need to: - ensure that
 * the ShortSegmentsMerger class (in geostore/tools/internal/mr-mergesegments.cc) is aware of them,
 * otherwise the new fields will be discarded randomly. - consider whether they should be cleared in
 * the ClearFeature() function (in maps/render/process-high-priority-roads.cc) if they are
 * irrelevant for rendering high priority roads at far-out zoom levels. - update the test cases that
 * ensure these two packages know all the SegmentProto fields in both mr-mergesegments_test.cc and
 * maps/render/process-high-priority-roads_test.cc or you will break the VersaTile build.
 * ---------------------------------------------------------------------------
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the Document AI Warehouse API. For a detailed explanation
 * see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class GeostoreSegmentProto extends com.google.api.client.json.GenericJson {

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreAppliedSpeedLimitProto> advisoryMaximumSpeed;

  static {
    // hack to force ProGuard to consider GeostoreAppliedSpeedLimitProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreAppliedSpeedLimitProto.class);
  }

  /**
   * RESERVED
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.Float> altitude;

  /**
   * The average speed that should be expected along this route under normal conditions, in
   * kilometers per hour. (Hopefully we'll replace this with something a lot more sophisticated.)
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Float avgSpeedKph;

  /**
   * Field-level metadata for the average speed.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFieldMetadataProto avgSpeedKphMetadata;

  /**
   * clang-format on
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String barrier;

  /**
   * Field-level metadata for the barrier.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFieldMetadataProto barrierMetadata;

  /**
   * clang-format on
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String bicycleFacility;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String bicycleSafety;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String condition;

  /**
   * Field-level metadata for the condition.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFieldMetadataProto conditionMetadata;

  /**
   * If known, the date that construction is scheduled to begin.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreDateTimeProto constructionBeginDate;

  /**
   * If known, the date that construction is scheduled to end.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreDateTimeProto constructionEndDate;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String constructionStatus;

  /**
   * Field-level metadata for the construction status.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFieldMetadataProto constructionStatusMetadata;

  /**
   * Whether the segment is covered by a roof etc. If this field is missing, the status is unknown.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean covered;

  /**
   * Average distance between the segment's polyline and edge of the road on this side in meters. It
   * need not be equal to the sum of width of all lanes in this direction. This width includes on-
   * street bicycle lanes but excludes off-street lanes such as sidewalks. The edge of the road is
   * the rightmost edge for segments in right side driving countries and leftmost edge for left side
   * driving countries. Width of the road is sum of this and sibling's distance_to_edge.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Float distanceToEdge;

  /**
   * Field-level metadata for distance_to_edge.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFieldMetadataProto distanceToEdgeMetadata;

  /**
   * These indicate for what portion of the segment does the outer curb of the segment follow the
   * segment polyline - i.e., where do the sweep curves connect along the outer curb. If
   * unspecified, may be assumed to be equal to lane retraction, preferring outermost lane.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Float edgeFollowsSegmentBeginFraction;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Float edgeFollowsSegmentEndFraction;

  /**
   * clang-format on
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String elevation;

  /**
   * Field-level metadata for the elevation.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFieldMetadataProto elevationMetadata;

  /**
   * clang-format on
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String endpoint;

  /**
   * Field-level metadata for the endpoint.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFieldMetadataProto endpointMetadata;

  /**
   * Detailed information about grade levels along the segment. If a GradeLevelProto is not present
   * for any point (index) along the segment, the default grade level is zero. In between two points
   * (indexes), the grade level of the segment is taken to be the max of the grade levels on either
   * side of it. See gradelevel.proto for semantics of repeated indexes.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreGradeLevelProto> gradeLevel;

  static {
    // hack to force ProGuard to consider GeostoreGradeLevelProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreGradeLevelProto.class);
  }

  /**
   * Internal-only data.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreInternalSegmentProto internal;

  /**
   * If specified, the perpendicular offset in meters from a road segment to an interpolated address
   * along that road segment. See go/synthetic-address-positions.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Float interpolationOffsetMeters;

  /**
   * The intersection feature corresponding to the destination of this segment. Intersections are
   * used to represent the connectivity between segments. Each intersection stores the segment ids
   * of all the incoming and outgoing segments that meet at that intersection. Turns can be made
   * from this segment to any of the outgoing segments of its intersection, unless there is a
   * restriction that explicitly disallows the turn (see below). Every segment has an intersection
   * object, even if there are no other segments to connect to (i.e., a cul-de-sac or dead end).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFeatureIdProto intersection;

  /**
   * Specifies whether the max_permitted_speed_kph was derived from a heuristic as opposed to coming
   * from an authoritative source.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean isMaxPermittedSpeedDerived;

  /**
   * Detailed information about each lane in this direction, if available. Lanes are numbered from
   * inside of the road outward, i.e. the lane next to the center line has lane_number 0. Note that
   * lanes that are valid for travel in both directions appear in both segments of a segment pair
   * (left turn lanes, one-lane roads, some passing lanes, reversing lanes). Some lanes may not be
   * usable by cars, such as bike lanes. Also, some lanes may not exist along the entire segment,
   * e.g. left- or right-turn lanes that appear just before the intersection.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreLaneProto> lane;

  static {
    // hack to force ProGuard to consider GeostoreLaneProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreLaneProto.class);
  }

  /**
   * The legal maximum, legal minimum, and advisory (recommended but non-legally binding) maximum
   * speed limits that are permitted on this segment. These should be the segment's legal limits;
   * however, note that it may contain estimated values based on country-wide defaults and other
   * heuristics (see 'AppliedSpeedLimitProto.trust_level'). Before exposing these fields to users as
   * the legal speed limit please consult with Google lawyers.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreAppliedSpeedLimitProto> legalMaximumSpeed;

  static {
    // hack to force ProGuard to consider GeostoreAppliedSpeedLimitProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreAppliedSpeedLimitProto.class);
  }

  /**
   * LINT.ThenChange(//depot/google3/geostore/base/internal/segment.cc:has_speed_limit)
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreAppliedSpeedLimitProto> legalMinimumSpeed;

  static {
    // hack to force ProGuard to consider GeostoreAppliedSpeedLimitProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreAppliedSpeedLimitProto.class);
  }

  /**
   * LINT.IfChange(speed_limits) The maximum speed that is permitted on this segment, in kilometers
   * per hour. This should be the segment's legal speed limit; however, note that it may contain
   * estimated values based on country-wide defaults and other heuristics (see
   * 'is_max_permitted_speed_derived' below). Before exposing this field to users as the legal speed
   * limit please consult with Google lawyers.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Float maxPermittedSpeedKph;

  /**
   * Field-level metadata for the maximum permitted speed.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFieldMetadataProto maxPermittedSpeedKphMetadata;

  /**
   * Specifies whether this segment carries right-hand traffic (cars keep to the right side of the
   * road) instead of left-hand traffic (cars keep to the left side). This is true for US roads and
   * false for UK roads, for example. See go/wikip/Left-_and_right-hand_traffic.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean onRight;

  /**
   * Defines the pedestrian crossing(s) between the end point of this segment and the start point of
   * this segment's sibling.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostorePedestrianCrossingProto pedestrianCrossing;

  /**
   * clang-format on
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String pedestrianFacility;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String pedestrianGrade;

  /**
   * LINT.ThenChange(//depot/google3/maps/pathfinder/pgraph/pgraph-segment-categories.cc)
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String priority;

  /**
   * Field-level metadata for the priority.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFieldMetadataProto priorityMetadata;

  /**
   * May only be set when the segment's usage is `USAGE_RAMP`.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreSegmentProtoRampProto ramp;

  /**
   * The set of restrictions that apply to this segment. Restrictions may make a single segment,
   * turn, or more complex maneuver along a set of segments unroutable for the specified travel
   * modes, or may only add penalties or warnings, depending on the restriction type. Turn
   * restrictions are one example of a restriction. By default, turns are allowed onto all outgoing
   * segments from this segment's intersection (including the sibling of this segment, i.e. U-turns
   * are allowed by default). If any of these turns are disallowed they will be listed as "subpath
   * restrictions". A subpath restriction disallows travel on given sequence of segments. In the
   * case of a disallowed turn, the subpath simply consists of the source and destination feature
   * ids. There may also be restrictions that apply to all travel on this segment (e.g. chains
   * required, or closed in winter), or restrictions that just apply to certain lanes (e.g. high
   * occupancy vehicle lanes).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreRestrictionProto> restriction;

  static {
    // hack to force ProGuard to consider GeostoreRestrictionProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreRestrictionProto.class);
  }

  /**
   * The road monitors that monitor this segment for traffic violations.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreFeatureIdProto> roadMonitor;

  static {
    // hack to force ProGuard to consider GeostoreFeatureIdProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreFeatureIdProto.class);
  }

  /**
   * The road sign(s) which this segment refers to. These are features of TYPE_ROAD_SIGN that are
   * applicable to this segment. For example, a sign that says "TO KIRKLAND" might apply to several
   * segments on a freeway off-ramp (until the end of the ramp). Note that this field makes it easy
   * to find the signs for a given road segment. The feature for the sign lists the segments that
   * refer to it.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreFeatureIdProto> roadSign;

  static {
    // hack to force ProGuard to consider GeostoreFeatureIdProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreFeatureIdProto.class);
  }

  /**
   * The route(s) to which this segment belongs.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreFeatureIdProto> route;

  static {
    // hack to force ProGuard to consider GeostoreFeatureIdProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreFeatureIdProto.class);
  }

  /**
   * Holds metadata about the associations between this segment and the route features listed in the
   * route field. This metadata need not be present; the only consistency requirement is that every
   * feature ID that appears inside 'route_association' must also appear in the repeated 'route'
   * field. If a route does not appear in route_association, consumers should assume that it has a
   * default initialized RouteAssociationProto.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreRouteAssociationProto> routeAssociation;

  static {
    // hack to force ProGuard to consider GeostoreRouteAssociationProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreRouteAssociationProto.class);
  }

  /**
   * Indicates whether the segment's opposing lanes of traffic are separated from this segment, and
   * hence have been represented in a separate feature. This means that there are two pairs of
   * siblings instead of one.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean separatedRoadways;

  /**
   * The other segment of this segment pair (see above). The segment that is referenced by the
   * sibling field refers to this feature back via the same sibling field. Both segment and sibling
   * should have the same properties such as geometry, country code, elevation, level relation,
   * priority etc. Since routes are required to have segment and sibling at the same time, the set
   * of routes on a segment is same to that of the sibling.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFeatureIdProto sibling;

  /**
   * Each slope instance is tied to a point along the segment polyline (unrelated to the vertices in
   * the segment's polyline) and represents the slope of the segment between that point and the
   * point tied to the next slope istance, or the end of the segment if it's the last slope
   * instance. A segment should have at least one slope.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreSlopeProto> slope;

  /**
   * clang-format on LINT.ThenChange(//depot/google3/geostore/base/proto/lane.proto) Specific lanes
   * may override this segment-level surface type.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String surface;

  /**
   * Field-level metadata for the surface.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFieldMetadataProto surfaceMetadata;

  /**
   * The geometric sweeps between this segment and nearby segments, used for real road width
   * rendering. A sweep describes the surface that connects to segments.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreSweepProto> sweep;

  /**
   * If this segment is part of a toll road. It would be nice to have data about the toll cost,
   * locations of toll booths, and so forth. Sadly, we don't have this data at this time.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean tollRoad;

  /**
   * clang-format on LINT.ThenChange(//depot/google3/maps/pathfinder/pgraph/pgraph-segment-
   * categories.cc)
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String usage;

  /**
   * A collection of landmarks that are visible when traveling along this segment and useful for
   * wayfinding to users following routes using this segment. The landmark need not be on the
   * segment. Each segment in a pair of siblings specifies its landmarks independently. A landmark
   * applicable to both appears in both.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreLandmarkReferenceProto> visibleLandmark;

  static {
    // hack to force ProGuard to consider GeostoreLandmarkReferenceProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreLandmarkReferenceProto.class);
  }

  /**
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreAppliedSpeedLimitProto> getAdvisoryMaximumSpeed() {
    return advisoryMaximumSpeed;
  }

  /**
   * @param advisoryMaximumSpeed advisoryMaximumSpeed or {@code null} for none
   */
  public GeostoreSegmentProto setAdvisoryMaximumSpeed(java.util.List<GeostoreAppliedSpeedLimitProto> advisoryMaximumSpeed) {
    this.advisoryMaximumSpeed = advisoryMaximumSpeed;
    return this;
  }

  /**
   * RESERVED
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.Float> getAltitude() {
    return altitude;
  }

  /**
   * RESERVED
   * @param altitude altitude or {@code null} for none
   */
  public GeostoreSegmentProto setAltitude(java.util.List<java.lang.Float> altitude) {
    this.altitude = altitude;
    return this;
  }

  /**
   * The average speed that should be expected along this route under normal conditions, in
   * kilometers per hour. (Hopefully we'll replace this with something a lot more sophisticated.)
   * @return value or {@code null} for none
   */
  public java.lang.Float getAvgSpeedKph() {
    return avgSpeedKph;
  }

  /**
   * The average speed that should be expected along this route under normal conditions, in
   * kilometers per hour. (Hopefully we'll replace this with something a lot more sophisticated.)
   * @param avgSpeedKph avgSpeedKph or {@code null} for none
   */
  public GeostoreSegmentProto setAvgSpeedKph(java.lang.Float avgSpeedKph) {
    this.avgSpeedKph = avgSpeedKph;
    return this;
  }

  /**
   * Field-level metadata for the average speed.
   * @return value or {@code null} for none
   */
  public GeostoreFieldMetadataProto getAvgSpeedKphMetadata() {
    return avgSpeedKphMetadata;
  }

  /**
   * Field-level metadata for the average speed.
   * @param avgSpeedKphMetadata avgSpeedKphMetadata or {@code null} for none
   */
  public GeostoreSegmentProto setAvgSpeedKphMetadata(GeostoreFieldMetadataProto avgSpeedKphMetadata) {
    this.avgSpeedKphMetadata = avgSpeedKphMetadata;
    return this;
  }

  /**
   * clang-format on
   * @return value or {@code null} for none
   */
  public java.lang.String getBarrier() {
    return barrier;
  }

  /**
   * clang-format on
   * @param barrier barrier or {@code null} for none
   */
  public GeostoreSegmentProto setBarrier(java.lang.String barrier) {
    this.barrier = barrier;
    return this;
  }

  /**
   * Field-level metadata for the barrier.
   * @return value or {@code null} for none
   */
  public GeostoreFieldMetadataProto getBarrierMetadata() {
    return barrierMetadata;
  }

  /**
   * Field-level metadata for the barrier.
   * @param barrierMetadata barrierMetadata or {@code null} for none
   */
  public GeostoreSegmentProto setBarrierMetadata(GeostoreFieldMetadataProto barrierMetadata) {
    this.barrierMetadata = barrierMetadata;
    return this;
  }

  /**
   * clang-format on
   * @return value or {@code null} for none
   */
  public java.lang.String getBicycleFacility() {
    return bicycleFacility;
  }

  /**
   * clang-format on
   * @param bicycleFacility bicycleFacility or {@code null} for none
   */
  public GeostoreSegmentProto setBicycleFacility(java.lang.String bicycleFacility) {
    this.bicycleFacility = bicycleFacility;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.String getBicycleSafety() {
    return bicycleSafety;
  }

  /**
   * @param bicycleSafety bicycleSafety or {@code null} for none
   */
  public GeostoreSegmentProto setBicycleSafety(java.lang.String bicycleSafety) {
    this.bicycleSafety = bicycleSafety;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.String getCondition() {
    return condition;
  }

  /**
   * @param condition condition or {@code null} for none
   */
  public GeostoreSegmentProto setCondition(java.lang.String condition) {
    this.condition = condition;
    return this;
  }

  /**
   * Field-level metadata for the condition.
   * @return value or {@code null} for none
   */
  public GeostoreFieldMetadataProto getConditionMetadata() {
    return conditionMetadata;
  }

  /**
   * Field-level metadata for the condition.
   * @param conditionMetadata conditionMetadata or {@code null} for none
   */
  public GeostoreSegmentProto setConditionMetadata(GeostoreFieldMetadataProto conditionMetadata) {
    this.conditionMetadata = conditionMetadata;
    return this;
  }

  /**
   * If known, the date that construction is scheduled to begin.
   * @return value or {@code null} for none
   */
  public GeostoreDateTimeProto getConstructionBeginDate() {
    return constructionBeginDate;
  }

  /**
   * If known, the date that construction is scheduled to begin.
   * @param constructionBeginDate constructionBeginDate or {@code null} for none
   */
  public GeostoreSegmentProto setConstructionBeginDate(GeostoreDateTimeProto constructionBeginDate) {
    this.constructionBeginDate = constructionBeginDate;
    return this;
  }

  /**
   * If known, the date that construction is scheduled to end.
   * @return value or {@code null} for none
   */
  public GeostoreDateTimeProto getConstructionEndDate() {
    return constructionEndDate;
  }

  /**
   * If known, the date that construction is scheduled to end.
   * @param constructionEndDate constructionEndDate or {@code null} for none
   */
  public GeostoreSegmentProto setConstructionEndDate(GeostoreDateTimeProto constructionEndDate) {
    this.constructionEndDate = constructionEndDate;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.String getConstructionStatus() {
    return constructionStatus;
  }

  /**
   * @param constructionStatus constructionStatus or {@code null} for none
   */
  public GeostoreSegmentProto setConstructionStatus(java.lang.String constructionStatus) {
    this.constructionStatus = constructionStatus;
    return this;
  }

  /**
   * Field-level metadata for the construction status.
   * @return value or {@code null} for none
   */
  public GeostoreFieldMetadataProto getConstructionStatusMetadata() {
    return constructionStatusMetadata;
  }

  /**
   * Field-level metadata for the construction status.
   * @param constructionStatusMetadata constructionStatusMetadata or {@code null} for none
   */
  public GeostoreSegmentProto setConstructionStatusMetadata(GeostoreFieldMetadataProto constructionStatusMetadata) {
    this.constructionStatusMetadata = constructionStatusMetadata;
    return this;
  }

  /**
   * Whether the segment is covered by a roof etc. If this field is missing, the status is unknown.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getCovered() {
    return covered;
  }

  /**
   * Whether the segment is covered by a roof etc. If this field is missing, the status is unknown.
   * @param covered covered or {@code null} for none
   */
  public GeostoreSegmentProto setCovered(java.lang.Boolean covered) {
    this.covered = covered;
    return this;
  }

  /**
   * Average distance between the segment's polyline and edge of the road on this side in meters. It
   * need not be equal to the sum of width of all lanes in this direction. This width includes on-
   * street bicycle lanes but excludes off-street lanes such as sidewalks. The edge of the road is
   * the rightmost edge for segments in right side driving countries and leftmost edge for left side
   * driving countries. Width of the road is sum of this and sibling's distance_to_edge.
   * @return value or {@code null} for none
   */
  public java.lang.Float getDistanceToEdge() {
    return distanceToEdge;
  }

  /**
   * Average distance between the segment's polyline and edge of the road on this side in meters. It
   * need not be equal to the sum of width of all lanes in this direction. This width includes on-
   * street bicycle lanes but excludes off-street lanes such as sidewalks. The edge of the road is
   * the rightmost edge for segments in right side driving countries and leftmost edge for left side
   * driving countries. Width of the road is sum of this and sibling's distance_to_edge.
   * @param distanceToEdge distanceToEdge or {@code null} for none
   */
  public GeostoreSegmentProto setDistanceToEdge(java.lang.Float distanceToEdge) {
    this.distanceToEdge = distanceToEdge;
    return this;
  }

  /**
   * Field-level metadata for distance_to_edge.
   * @return value or {@code null} for none
   */
  public GeostoreFieldMetadataProto getDistanceToEdgeMetadata() {
    return distanceToEdgeMetadata;
  }

  /**
   * Field-level metadata for distance_to_edge.
   * @param distanceToEdgeMetadata distanceToEdgeMetadata or {@code null} for none
   */
  public GeostoreSegmentProto setDistanceToEdgeMetadata(GeostoreFieldMetadataProto distanceToEdgeMetadata) {
    this.distanceToEdgeMetadata = distanceToEdgeMetadata;
    return this;
  }

  /**
   * These indicate for what portion of the segment does the outer curb of the segment follow the
   * segment polyline - i.e., where do the sweep curves connect along the outer curb. If
   * unspecified, may be assumed to be equal to lane retraction, preferring outermost lane.
   * @return value or {@code null} for none
   */
  public java.lang.Float getEdgeFollowsSegmentBeginFraction() {
    return edgeFollowsSegmentBeginFraction;
  }

  /**
   * These indicate for what portion of the segment does the outer curb of the segment follow the
   * segment polyline - i.e., where do the sweep curves connect along the outer curb. If
   * unspecified, may be assumed to be equal to lane retraction, preferring outermost lane.
   * @param edgeFollowsSegmentBeginFraction edgeFollowsSegmentBeginFraction or {@code null} for none
   */
  public GeostoreSegmentProto setEdgeFollowsSegmentBeginFraction(java.lang.Float edgeFollowsSegmentBeginFraction) {
    this.edgeFollowsSegmentBeginFraction = edgeFollowsSegmentBeginFraction;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Float getEdgeFollowsSegmentEndFraction() {
    return edgeFollowsSegmentEndFraction;
  }

  /**
   * @param edgeFollowsSegmentEndFraction edgeFollowsSegmentEndFraction or {@code null} for none
   */
  public GeostoreSegmentProto setEdgeFollowsSegmentEndFraction(java.lang.Float edgeFollowsSegmentEndFraction) {
    this.edgeFollowsSegmentEndFraction = edgeFollowsSegmentEndFraction;
    return this;
  }

  /**
   * clang-format on
   * @return value or {@code null} for none
   */
  public java.lang.String getElevation() {
    return elevation;
  }

  /**
   * clang-format on
   * @param elevation elevation or {@code null} for none
   */
  public GeostoreSegmentProto setElevation(java.lang.String elevation) {
    this.elevation = elevation;
    return this;
  }

  /**
   * Field-level metadata for the elevation.
   * @return value or {@code null} for none
   */
  public GeostoreFieldMetadataProto getElevationMetadata() {
    return elevationMetadata;
  }

  /**
   * Field-level metadata for the elevation.
   * @param elevationMetadata elevationMetadata or {@code null} for none
   */
  public GeostoreSegmentProto setElevationMetadata(GeostoreFieldMetadataProto elevationMetadata) {
    this.elevationMetadata = elevationMetadata;
    return this;
  }

  /**
   * clang-format on
   * @return value or {@code null} for none
   */
  public java.lang.String getEndpoint() {
    return endpoint;
  }

  /**
   * clang-format on
   * @param endpoint endpoint or {@code null} for none
   */
  public GeostoreSegmentProto setEndpoint(java.lang.String endpoint) {
    this.endpoint = endpoint;
    return this;
  }

  /**
   * Field-level metadata for the endpoint.
   * @return value or {@code null} for none
   */
  public GeostoreFieldMetadataProto getEndpointMetadata() {
    return endpointMetadata;
  }

  /**
   * Field-level metadata for the endpoint.
   * @param endpointMetadata endpointMetadata or {@code null} for none
   */
  public GeostoreSegmentProto setEndpointMetadata(GeostoreFieldMetadataProto endpointMetadata) {
    this.endpointMetadata = endpointMetadata;
    return this;
  }

  /**
   * Detailed information about grade levels along the segment. If a GradeLevelProto is not present
   * for any point (index) along the segment, the default grade level is zero. In between two points
   * (indexes), the grade level of the segment is taken to be the max of the grade levels on either
   * side of it. See gradelevel.proto for semantics of repeated indexes.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreGradeLevelProto> getGradeLevel() {
    return gradeLevel;
  }

  /**
   * Detailed information about grade levels along the segment. If a GradeLevelProto is not present
   * for any point (index) along the segment, the default grade level is zero. In between two points
   * (indexes), the grade level of the segment is taken to be the max of the grade levels on either
   * side of it. See gradelevel.proto for semantics of repeated indexes.
   * @param gradeLevel gradeLevel or {@code null} for none
   */
  public GeostoreSegmentProto setGradeLevel(java.util.List<GeostoreGradeLevelProto> gradeLevel) {
    this.gradeLevel = gradeLevel;
    return this;
  }

  /**
   * Internal-only data.
   * @return value or {@code null} for none
   */
  public GeostoreInternalSegmentProto getInternal() {
    return internal;
  }

  /**
   * Internal-only data.
   * @param internal internal or {@code null} for none
   */
  public GeostoreSegmentProto setInternal(GeostoreInternalSegmentProto internal) {
    this.internal = internal;
    return this;
  }

  /**
   * If specified, the perpendicular offset in meters from a road segment to an interpolated address
   * along that road segment. See go/synthetic-address-positions.
   * @return value or {@code null} for none
   */
  public java.lang.Float getInterpolationOffsetMeters() {
    return interpolationOffsetMeters;
  }

  /**
   * If specified, the perpendicular offset in meters from a road segment to an interpolated address
   * along that road segment. See go/synthetic-address-positions.
   * @param interpolationOffsetMeters interpolationOffsetMeters or {@code null} for none
   */
  public GeostoreSegmentProto setInterpolationOffsetMeters(java.lang.Float interpolationOffsetMeters) {
    this.interpolationOffsetMeters = interpolationOffsetMeters;
    return this;
  }

  /**
   * The intersection feature corresponding to the destination of this segment. Intersections are
   * used to represent the connectivity between segments. Each intersection stores the segment ids
   * of all the incoming and outgoing segments that meet at that intersection. Turns can be made
   * from this segment to any of the outgoing segments of its intersection, unless there is a
   * restriction that explicitly disallows the turn (see below). Every segment has an intersection
   * object, even if there are no other segments to connect to (i.e., a cul-de-sac or dead end).
   * @return value or {@code null} for none
   */
  public GeostoreFeatureIdProto getIntersection() {
    return intersection;
  }

  /**
   * The intersection feature corresponding to the destination of this segment. Intersections are
   * used to represent the connectivity between segments. Each intersection stores the segment ids
   * of all the incoming and outgoing segments that meet at that intersection. Turns can be made
   * from this segment to any of the outgoing segments of its intersection, unless there is a
   * restriction that explicitly disallows the turn (see below). Every segment has an intersection
   * object, even if there are no other segments to connect to (i.e., a cul-de-sac or dead end).
   * @param intersection intersection or {@code null} for none
   */
  public GeostoreSegmentProto setIntersection(GeostoreFeatureIdProto intersection) {
    this.intersection = intersection;
    return this;
  }

  /**
   * Specifies whether the max_permitted_speed_kph was derived from a heuristic as opposed to coming
   * from an authoritative source.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getIsMaxPermittedSpeedDerived() {
    return isMaxPermittedSpeedDerived;
  }

  /**
   * Specifies whether the max_permitted_speed_kph was derived from a heuristic as opposed to coming
   * from an authoritative source.
   * @param isMaxPermittedSpeedDerived isMaxPermittedSpeedDerived or {@code null} for none
   */
  public GeostoreSegmentProto setIsMaxPermittedSpeedDerived(java.lang.Boolean isMaxPermittedSpeedDerived) {
    this.isMaxPermittedSpeedDerived = isMaxPermittedSpeedDerived;
    return this;
  }

  /**
   * Detailed information about each lane in this direction, if available. Lanes are numbered from
   * inside of the road outward, i.e. the lane next to the center line has lane_number 0. Note that
   * lanes that are valid for travel in both directions appear in both segments of a segment pair
   * (left turn lanes, one-lane roads, some passing lanes, reversing lanes). Some lanes may not be
   * usable by cars, such as bike lanes. Also, some lanes may not exist along the entire segment,
   * e.g. left- or right-turn lanes that appear just before the intersection.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreLaneProto> getLane() {
    return lane;
  }

  /**
   * Detailed information about each lane in this direction, if available. Lanes are numbered from
   * inside of the road outward, i.e. the lane next to the center line has lane_number 0. Note that
   * lanes that are valid for travel in both directions appear in both segments of a segment pair
   * (left turn lanes, one-lane roads, some passing lanes, reversing lanes). Some lanes may not be
   * usable by cars, such as bike lanes. Also, some lanes may not exist along the entire segment,
   * e.g. left- or right-turn lanes that appear just before the intersection.
   * @param lane lane or {@code null} for none
   */
  public GeostoreSegmentProto setLane(java.util.List<GeostoreLaneProto> lane) {
    this.lane = lane;
    return this;
  }

  /**
   * The legal maximum, legal minimum, and advisory (recommended but non-legally binding) maximum
   * speed limits that are permitted on this segment. These should be the segment's legal limits;
   * however, note that it may contain estimated values based on country-wide defaults and other
   * heuristics (see 'AppliedSpeedLimitProto.trust_level'). Before exposing these fields to users as
   * the legal speed limit please consult with Google lawyers.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreAppliedSpeedLimitProto> getLegalMaximumSpeed() {
    return legalMaximumSpeed;
  }

  /**
   * The legal maximum, legal minimum, and advisory (recommended but non-legally binding) maximum
   * speed limits that are permitted on this segment. These should be the segment's legal limits;
   * however, note that it may contain estimated values based on country-wide defaults and other
   * heuristics (see 'AppliedSpeedLimitProto.trust_level'). Before exposing these fields to users as
   * the legal speed limit please consult with Google lawyers.
   * @param legalMaximumSpeed legalMaximumSpeed or {@code null} for none
   */
  public GeostoreSegmentProto setLegalMaximumSpeed(java.util.List<GeostoreAppliedSpeedLimitProto> legalMaximumSpeed) {
    this.legalMaximumSpeed = legalMaximumSpeed;
    return this;
  }

  /**
   * LINT.ThenChange(//depot/google3/geostore/base/internal/segment.cc:has_speed_limit)
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreAppliedSpeedLimitProto> getLegalMinimumSpeed() {
    return legalMinimumSpeed;
  }

  /**
   * LINT.ThenChange(//depot/google3/geostore/base/internal/segment.cc:has_speed_limit)
   * @param legalMinimumSpeed legalMinimumSpeed or {@code null} for none
   */
  public GeostoreSegmentProto setLegalMinimumSpeed(java.util.List<GeostoreAppliedSpeedLimitProto> legalMinimumSpeed) {
    this.legalMinimumSpeed = legalMinimumSpeed;
    return this;
  }

  /**
   * LINT.IfChange(speed_limits) The maximum speed that is permitted on this segment, in kilometers
   * per hour. This should be the segment's legal speed limit; however, note that it may contain
   * estimated values based on country-wide defaults and other heuristics (see
   * 'is_max_permitted_speed_derived' below). Before exposing this field to users as the legal speed
   * limit please consult with Google lawyers.
   * @return value or {@code null} for none
   */
  public java.lang.Float getMaxPermittedSpeedKph() {
    return maxPermittedSpeedKph;
  }

  /**
   * LINT.IfChange(speed_limits) The maximum speed that is permitted on this segment, in kilometers
   * per hour. This should be the segment's legal speed limit; however, note that it may contain
   * estimated values based on country-wide defaults and other heuristics (see
   * 'is_max_permitted_speed_derived' below). Before exposing this field to users as the legal speed
   * limit please consult with Google lawyers.
   * @param maxPermittedSpeedKph maxPermittedSpeedKph or {@code null} for none
   */
  public GeostoreSegmentProto setMaxPermittedSpeedKph(java.lang.Float maxPermittedSpeedKph) {
    this.maxPermittedSpeedKph = maxPermittedSpeedKph;
    return this;
  }

  /**
   * Field-level metadata for the maximum permitted speed.
   * @return value or {@code null} for none
   */
  public GeostoreFieldMetadataProto getMaxPermittedSpeedKphMetadata() {
    return maxPermittedSpeedKphMetadata;
  }

  /**
   * Field-level metadata for the maximum permitted speed.
   * @param maxPermittedSpeedKphMetadata maxPermittedSpeedKphMetadata or {@code null} for none
   */
  public GeostoreSegmentProto setMaxPermittedSpeedKphMetadata(GeostoreFieldMetadataProto maxPermittedSpeedKphMetadata) {
    this.maxPermittedSpeedKphMetadata = maxPermittedSpeedKphMetadata;
    return this;
  }

  /**
   * Specifies whether this segment carries right-hand traffic (cars keep to the right side of the
   * road) instead of left-hand traffic (cars keep to the left side). This is true for US roads and
   * false for UK roads, for example. See go/wikip/Left-_and_right-hand_traffic.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getOnRight() {
    return onRight;
  }

  /**
   * Specifies whether this segment carries right-hand traffic (cars keep to the right side of the
   * road) instead of left-hand traffic (cars keep to the left side). This is true for US roads and
   * false for UK roads, for example. See go/wikip/Left-_and_right-hand_traffic.
   * @param onRight onRight or {@code null} for none
   */
  public GeostoreSegmentProto setOnRight(java.lang.Boolean onRight) {
    this.onRight = onRight;
    return this;
  }

  /**
   * Defines the pedestrian crossing(s) between the end point of this segment and the start point of
   * this segment's sibling.
   * @return value or {@code null} for none
   */
  public GeostorePedestrianCrossingProto getPedestrianCrossing() {
    return pedestrianCrossing;
  }

  /**
   * Defines the pedestrian crossing(s) between the end point of this segment and the start point of
   * this segment's sibling.
   * @param pedestrianCrossing pedestrianCrossing or {@code null} for none
   */
  public GeostoreSegmentProto setPedestrianCrossing(GeostorePedestrianCrossingProto pedestrianCrossing) {
    this.pedestrianCrossing = pedestrianCrossing;
    return this;
  }

  /**
   * clang-format on
   * @return value or {@code null} for none
   */
  public java.lang.String getPedestrianFacility() {
    return pedestrianFacility;
  }

  /**
   * clang-format on
   * @param pedestrianFacility pedestrianFacility or {@code null} for none
   */
  public GeostoreSegmentProto setPedestrianFacility(java.lang.String pedestrianFacility) {
    this.pedestrianFacility = pedestrianFacility;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.String getPedestrianGrade() {
    return pedestrianGrade;
  }

  /**
   * @param pedestrianGrade pedestrianGrade or {@code null} for none
   */
  public GeostoreSegmentProto setPedestrianGrade(java.lang.String pedestrianGrade) {
    this.pedestrianGrade = pedestrianGrade;
    return this;
  }

  /**
   * LINT.ThenChange(//depot/google3/maps/pathfinder/pgraph/pgraph-segment-categories.cc)
   * @return value or {@code null} for none
   */
  public java.lang.String getPriority() {
    return priority;
  }

  /**
   * LINT.ThenChange(//depot/google3/maps/pathfinder/pgraph/pgraph-segment-categories.cc)
   * @param priority priority or {@code null} for none
   */
  public GeostoreSegmentProto setPriority(java.lang.String priority) {
    this.priority = priority;
    return this;
  }

  /**
   * Field-level metadata for the priority.
   * @return value or {@code null} for none
   */
  public GeostoreFieldMetadataProto getPriorityMetadata() {
    return priorityMetadata;
  }

  /**
   * Field-level metadata for the priority.
   * @param priorityMetadata priorityMetadata or {@code null} for none
   */
  public GeostoreSegmentProto setPriorityMetadata(GeostoreFieldMetadataProto priorityMetadata) {
    this.priorityMetadata = priorityMetadata;
    return this;
  }

  /**
   * May only be set when the segment's usage is `USAGE_RAMP`.
   * @return value or {@code null} for none
   */
  public GeostoreSegmentProtoRampProto getRamp() {
    return ramp;
  }

  /**
   * May only be set when the segment's usage is `USAGE_RAMP`.
   * @param ramp ramp or {@code null} for none
   */
  public GeostoreSegmentProto setRamp(GeostoreSegmentProtoRampProto ramp) {
    this.ramp = ramp;
    return this;
  }

  /**
   * The set of restrictions that apply to this segment. Restrictions may make a single segment,
   * turn, or more complex maneuver along a set of segments unroutable for the specified travel
   * modes, or may only add penalties or warnings, depending on the restriction type. Turn
   * restrictions are one example of a restriction. By default, turns are allowed onto all outgoing
   * segments from this segment's intersection (including the sibling of this segment, i.e. U-turns
   * are allowed by default). If any of these turns are disallowed they will be listed as "subpath
   * restrictions". A subpath restriction disallows travel on given sequence of segments. In the
   * case of a disallowed turn, the subpath simply consists of the source and destination feature
   * ids. There may also be restrictions that apply to all travel on this segment (e.g. chains
   * required, or closed in winter), or restrictions that just apply to certain lanes (e.g. high
   * occupancy vehicle lanes).
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreRestrictionProto> getRestriction() {
    return restriction;
  }

  /**
   * The set of restrictions that apply to this segment. Restrictions may make a single segment,
   * turn, or more complex maneuver along a set of segments unroutable for the specified travel
   * modes, or may only add penalties or warnings, depending on the restriction type. Turn
   * restrictions are one example of a restriction. By default, turns are allowed onto all outgoing
   * segments from this segment's intersection (including the sibling of this segment, i.e. U-turns
   * are allowed by default). If any of these turns are disallowed they will be listed as "subpath
   * restrictions". A subpath restriction disallows travel on given sequence of segments. In the
   * case of a disallowed turn, the subpath simply consists of the source and destination feature
   * ids. There may also be restrictions that apply to all travel on this segment (e.g. chains
   * required, or closed in winter), or restrictions that just apply to certain lanes (e.g. high
   * occupancy vehicle lanes).
   * @param restriction restriction or {@code null} for none
   */
  public GeostoreSegmentProto setRestriction(java.util.List<GeostoreRestrictionProto> restriction) {
    this.restriction = restriction;
    return this;
  }

  /**
   * The road monitors that monitor this segment for traffic violations.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreFeatureIdProto> getRoadMonitor() {
    return roadMonitor;
  }

  /**
   * The road monitors that monitor this segment for traffic violations.
   * @param roadMonitor roadMonitor or {@code null} for none
   */
  public GeostoreSegmentProto setRoadMonitor(java.util.List<GeostoreFeatureIdProto> roadMonitor) {
    this.roadMonitor = roadMonitor;
    return this;
  }

  /**
   * The road sign(s) which this segment refers to. These are features of TYPE_ROAD_SIGN that are
   * applicable to this segment. For example, a sign that says "TO KIRKLAND" might apply to several
   * segments on a freeway off-ramp (until the end of the ramp). Note that this field makes it easy
   * to find the signs for a given road segment. The feature for the sign lists the segments that
   * refer to it.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreFeatureIdProto> getRoadSign() {
    return roadSign;
  }

  /**
   * The road sign(s) which this segment refers to. These are features of TYPE_ROAD_SIGN that are
   * applicable to this segment. For example, a sign that says "TO KIRKLAND" might apply to several
   * segments on a freeway off-ramp (until the end of the ramp). Note that this field makes it easy
   * to find the signs for a given road segment. The feature for the sign lists the segments that
   * refer to it.
   * @param roadSign roadSign or {@code null} for none
   */
  public GeostoreSegmentProto setRoadSign(java.util.List<GeostoreFeatureIdProto> roadSign) {
    this.roadSign = roadSign;
    return this;
  }

  /**
   * The route(s) to which this segment belongs.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreFeatureIdProto> getRoute() {
    return route;
  }

  /**
   * The route(s) to which this segment belongs.
   * @param route route or {@code null} for none
   */
  public GeostoreSegmentProto setRoute(java.util.List<GeostoreFeatureIdProto> route) {
    this.route = route;
    return this;
  }

  /**
   * Holds metadata about the associations between this segment and the route features listed in the
   * route field. This metadata need not be present; the only consistency requirement is that every
   * feature ID that appears inside 'route_association' must also appear in the repeated 'route'
   * field. If a route does not appear in route_association, consumers should assume that it has a
   * default initialized RouteAssociationProto.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreRouteAssociationProto> getRouteAssociation() {
    return routeAssociation;
  }

  /**
   * Holds metadata about the associations between this segment and the route features listed in the
   * route field. This metadata need not be present; the only consistency requirement is that every
   * feature ID that appears inside 'route_association' must also appear in the repeated 'route'
   * field. If a route does not appear in route_association, consumers should assume that it has a
   * default initialized RouteAssociationProto.
   * @param routeAssociation routeAssociation or {@code null} for none
   */
  public GeostoreSegmentProto setRouteAssociation(java.util.List<GeostoreRouteAssociationProto> routeAssociation) {
    this.routeAssociation = routeAssociation;
    return this;
  }

  /**
   * Indicates whether the segment's opposing lanes of traffic are separated from this segment, and
   * hence have been represented in a separate feature. This means that there are two pairs of
   * siblings instead of one.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getSeparatedRoadways() {
    return separatedRoadways;
  }

  /**
   * Indicates whether the segment's opposing lanes of traffic are separated from this segment, and
   * hence have been represented in a separate feature. This means that there are two pairs of
   * siblings instead of one.
   * @param separatedRoadways separatedRoadways or {@code null} for none
   */
  public GeostoreSegmentProto setSeparatedRoadways(java.lang.Boolean separatedRoadways) {
    this.separatedRoadways = separatedRoadways;
    return this;
  }

  /**
   * The other segment of this segment pair (see above). The segment that is referenced by the
   * sibling field refers to this feature back via the same sibling field. Both segment and sibling
   * should have the same properties such as geometry, country code, elevation, level relation,
   * priority etc. Since routes are required to have segment and sibling at the same time, the set
   * of routes on a segment is same to that of the sibling.
   * @return value or {@code null} for none
   */
  public GeostoreFeatureIdProto getSibling() {
    return sibling;
  }

  /**
   * The other segment of this segment pair (see above). The segment that is referenced by the
   * sibling field refers to this feature back via the same sibling field. Both segment and sibling
   * should have the same properties such as geometry, country code, elevation, level relation,
   * priority etc. Since routes are required to have segment and sibling at the same time, the set
   * of routes on a segment is same to that of the sibling.
   * @param sibling sibling or {@code null} for none
   */
  public GeostoreSegmentProto setSibling(GeostoreFeatureIdProto sibling) {
    this.sibling = sibling;
    return this;
  }

  /**
   * Each slope instance is tied to a point along the segment polyline (unrelated to the vertices in
   * the segment's polyline) and represents the slope of the segment between that point and the
   * point tied to the next slope istance, or the end of the segment if it's the last slope
   * instance. A segment should have at least one slope.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreSlopeProto> getSlope() {
    return slope;
  }

  /**
   * Each slope instance is tied to a point along the segment polyline (unrelated to the vertices in
   * the segment's polyline) and represents the slope of the segment between that point and the
   * point tied to the next slope istance, or the end of the segment if it's the last slope
   * instance. A segment should have at least one slope.
   * @param slope slope or {@code null} for none
   */
  public GeostoreSegmentProto setSlope(java.util.List<GeostoreSlopeProto> slope) {
    this.slope = slope;
    return this;
  }

  /**
   * clang-format on LINT.ThenChange(//depot/google3/geostore/base/proto/lane.proto) Specific lanes
   * may override this segment-level surface type.
   * @return value or {@code null} for none
   */
  public java.lang.String getSurface() {
    return surface;
  }

  /**
   * clang-format on LINT.ThenChange(//depot/google3/geostore/base/proto/lane.proto) Specific lanes
   * may override this segment-level surface type.
   * @param surface surface or {@code null} for none
   */
  public GeostoreSegmentProto setSurface(java.lang.String surface) {
    this.surface = surface;
    return this;
  }

  /**
   * Field-level metadata for the surface.
   * @return value or {@code null} for none
   */
  public GeostoreFieldMetadataProto getSurfaceMetadata() {
    return surfaceMetadata;
  }

  /**
   * Field-level metadata for the surface.
   * @param surfaceMetadata surfaceMetadata or {@code null} for none
   */
  public GeostoreSegmentProto setSurfaceMetadata(GeostoreFieldMetadataProto surfaceMetadata) {
    this.surfaceMetadata = surfaceMetadata;
    return this;
  }

  /**
   * The geometric sweeps between this segment and nearby segments, used for real road width
   * rendering. A sweep describes the surface that connects to segments.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreSweepProto> getSweep() {
    return sweep;
  }

  /**
   * The geometric sweeps between this segment and nearby segments, used for real road width
   * rendering. A sweep describes the surface that connects to segments.
   * @param sweep sweep or {@code null} for none
   */
  public GeostoreSegmentProto setSweep(java.util.List<GeostoreSweepProto> sweep) {
    this.sweep = sweep;
    return this;
  }

  /**
   * If this segment is part of a toll road. It would be nice to have data about the toll cost,
   * locations of toll booths, and so forth. Sadly, we don't have this data at this time.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getTollRoad() {
    return tollRoad;
  }

  /**
   * If this segment is part of a toll road. It would be nice to have data about the toll cost,
   * locations of toll booths, and so forth. Sadly, we don't have this data at this time.
   * @param tollRoad tollRoad or {@code null} for none
   */
  public GeostoreSegmentProto setTollRoad(java.lang.Boolean tollRoad) {
    this.tollRoad = tollRoad;
    return this;
  }

  /**
   * clang-format on LINT.ThenChange(//depot/google3/maps/pathfinder/pgraph/pgraph-segment-
   * categories.cc)
   * @return value or {@code null} for none
   */
  public java.lang.String getUsage() {
    return usage;
  }

  /**
   * clang-format on LINT.ThenChange(//depot/google3/maps/pathfinder/pgraph/pgraph-segment-
   * categories.cc)
   * @param usage usage or {@code null} for none
   */
  public GeostoreSegmentProto setUsage(java.lang.String usage) {
    this.usage = usage;
    return this;
  }

  /**
   * A collection of landmarks that are visible when traveling along this segment and useful for
   * wayfinding to users following routes using this segment. The landmark need not be on the
   * segment. Each segment in a pair of siblings specifies its landmarks independently. A landmark
   * applicable to both appears in both.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreLandmarkReferenceProto> getVisibleLandmark() {
    return visibleLandmark;
  }

  /**
   * A collection of landmarks that are visible when traveling along this segment and useful for
   * wayfinding to users following routes using this segment. The landmark need not be on the
   * segment. Each segment in a pair of siblings specifies its landmarks independently. A landmark
   * applicable to both appears in both.
   * @param visibleLandmark visibleLandmark or {@code null} for none
   */
  public GeostoreSegmentProto setVisibleLandmark(java.util.List<GeostoreLandmarkReferenceProto> visibleLandmark) {
    this.visibleLandmark = visibleLandmark;
    return this;
  }

  @Override
  public GeostoreSegmentProto set(String fieldName, Object value) {
    return (GeostoreSegmentProto) super.set(fieldName, value);
  }

  @Override
  public GeostoreSegmentProto clone() {
    return (GeostoreSegmentProto) super.clone();
  }

}
