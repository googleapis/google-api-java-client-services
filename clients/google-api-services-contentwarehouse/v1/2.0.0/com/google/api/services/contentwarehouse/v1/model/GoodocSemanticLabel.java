/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.contentwarehouse.v1.model;

/**
 * Label identifying a logical part of the page content. This applies mostly at Block level or
 * Paragraph level (but can apply to Words or to arbitrary spans if needed).
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the Document AI Warehouse API. For a detailed explanation
 * see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class GoodocSemanticLabel extends com.google.api.client.json.GenericJson {

  /**
   * Alternate text for a sequence of the Goodoc, just for the element containing this label, or for
   * a sequence starting from this element to the EndOfSpanningLabel. Typically this is inserted by
   * automatic or manual OCR correction. We use text instead of editing the Goodoc directly since we
   * dont usually have accurate symbol level bboxes for the alternate text. Also the original values
   * from OCR are preserved. It is upto the application to do anything more intelligent like mapping
   * words and finding potential symbol/word bboxes.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("AlternateText")
  private java.lang.String alternateText;

  /**
   * Page elements can be given Attributes refining meaning/role. We keep this flexible by using
   * strings instead of pre-determined enum values. But it is useful to list all such Attributes in
   * use in ocr/goodoc/goodoc-semantics-attributes.h
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("Attribute")
  private java.util.List<java.lang.String> attribute;

  /**
   * Blocks that are at the beginning of chapters have this set:
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("ChapterStart")
  private java.lang.Boolean chapterStart;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("CleanupAnnotation")
  private java.util.List<java.lang.Integer> cleanupAnnotation;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("ContinuesFromPreviousPage")
  private java.lang.Boolean continuesFromPreviousPage;

  /**
   * When ContinuesFromPreviousPage=true, this bit can be set to note that the word fragment on the
   * previous page ends in a hyphen.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("ContinuesFromPreviousPageHyphenated")
  private java.lang.Boolean continuesFromPreviousPageHyphenated;

  /**
   * Paragraphs that span across pages can be identified with the following flags. Note that flows
   * just connect Blocks across pages. These continuation flags imply something more specific -- the
   * case of a single logical paragraph split over pages. Only the last Paragraph in the last Block
   * within a given FlowThread() on a page can have ContinuesOnNextPage set. Similarly, only the
   * first Paragraph in the first Block with a given FlowThread() on a page may have
   * ContinuesFromPreviousPage set.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("ContinuesOnNextPage")
  private java.lang.Boolean continuesOnNextPage;

  /**
   * Normally, a SemanticLabel applies exactly to the goodoc element that it is contained in
   * (usually Block or Paragraph, sometimes Word). Occasionally, we need a SemanticLabel to span
   * across the boundary or end before the boundary. For example, a URL may just be a few words
   * within a Paragraph. In such cases, the SemanticLabel is added to the first element of the span
   * and contains this LogicalEntity pointing to the last element of the span:
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("EndOfSpanningLabel")
  private GoodocLogicalEntity endOfSpanningLabel;

  /**
   * Message set for experimental algorithm data. Use case: We keep a set of features that was
   * computed for the unsupervised caption extraction and store it here. Agora question producer
   * will consume this message set to be embedded in a question. The experimental feature set can
   * then be used later to pair up with ground truth labels for designing a supervised algorithm.
   * Currently holding: o ocean/analysis/content/caption_data.proto's TextualElement
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("ExperimentalData")
  private Proto2BridgeMessageSet experimentalData;

  /**
   * Flow identifies a single sequential unit of text (or other content). It is only set on Blocks
   * -- a flow identifies a sequence of Blocks. The default, main flow is just the empty string. The
   * "FlowThread" of a block is the flow (if non-empty), suffixed with the block appearance. This is
   * computed by GoodocUtils::FlowThread(). Paragraphs may be split over blocks in the same
   * FlowThread, across pages. The following table shows how FlowThread gets computed: ## Flow
   * Appearance FlowThread (empty) UNSPECIFIED "UNSPECIFIED" foo BODY "foo:BODY" Please use lower-
   * case strings for flows (such as article-33-box). One useful way to think of flows is this: A
   * logical unit of interest in a a Document (for example, an article) would be identified by a
   * starting block, an ending block, and a list of flows of interest within the [start, end) span.
   * message Article { (page#, block#): article_start; (page#, block#): article_end; repeated string
   * flows; } The reading order of blocks, paragraphs/etc within this article would be the same
   * order as present in the goodoc itself. Some applications (such as rendering) may want to
   * process the article by running over all the flows together, others (such as indexing) may want
   * to deal with the FlowThreads one after the other.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("Flow")
  private java.lang.String flow;

  /**
   * This field can be used to record the steps by which AlternateText for a sequence of the Goodoc
   * is generated.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("ModificationRecord")
  private java.lang.String modificationRecord;

  /**
   * If Appearence is PAGE_NUMBER:
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key("PageNumberOrdinal")
  private GoodocOrdinal pageNumberOrdinal;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer appearance;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GoodocSemanticLabelColumnDetails columndetails;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GoodocSemanticLabelContentLink contentlink;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GoodocSemanticLabelEditCorrectionCandidate> editcorrectioncandidate;

  /**
   * Structure overrides: typically manual corrections to goodoc renderings.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GoodocOverrides overrides;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GoodocSemanticLabelSnippetFilter> snippetfilter;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GoodocSemanticLabelTableCellDetails tablecelldetails;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GoodocSemanticLabelTableDetails tabledetails;

  /**
   * Alternate text for a sequence of the Goodoc, just for the element containing this label, or for
   * a sequence starting from this element to the EndOfSpanningLabel. Typically this is inserted by
   * automatic or manual OCR correction. We use text instead of editing the Goodoc directly since we
   * dont usually have accurate symbol level bboxes for the alternate text. Also the original values
   * from OCR are preserved. It is upto the application to do anything more intelligent like mapping
   * words and finding potential symbol/word bboxes.
   * @return value or {@code null} for none
   */
  public java.lang.String getAlternateText() {
    return alternateText;
  }

  /**
   * Alternate text for a sequence of the Goodoc, just for the element containing this label, or for
   * a sequence starting from this element to the EndOfSpanningLabel. Typically this is inserted by
   * automatic or manual OCR correction. We use text instead of editing the Goodoc directly since we
   * dont usually have accurate symbol level bboxes for the alternate text. Also the original values
   * from OCR are preserved. It is upto the application to do anything more intelligent like mapping
   * words and finding potential symbol/word bboxes.
   * @param alternateText alternateText or {@code null} for none
   */
  public GoodocSemanticLabel setAlternateText(java.lang.String alternateText) {
    this.alternateText = alternateText;
    return this;
  }

  /**
   * Page elements can be given Attributes refining meaning/role. We keep this flexible by using
   * strings instead of pre-determined enum values. But it is useful to list all such Attributes in
   * use in ocr/goodoc/goodoc-semantics-attributes.h
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.String> getAttribute() {
    return attribute;
  }

  /**
   * Page elements can be given Attributes refining meaning/role. We keep this flexible by using
   * strings instead of pre-determined enum values. But it is useful to list all such Attributes in
   * use in ocr/goodoc/goodoc-semantics-attributes.h
   * @param attribute attribute or {@code null} for none
   */
  public GoodocSemanticLabel setAttribute(java.util.List<java.lang.String> attribute) {
    this.attribute = attribute;
    return this;
  }

  /**
   * Blocks that are at the beginning of chapters have this set:
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getChapterStart() {
    return chapterStart;
  }

  /**
   * Blocks that are at the beginning of chapters have this set:
   * @param chapterStart chapterStart or {@code null} for none
   */
  public GoodocSemanticLabel setChapterStart(java.lang.Boolean chapterStart) {
    this.chapterStart = chapterStart;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.Integer> getCleanupAnnotation() {
    return cleanupAnnotation;
  }

  /**
   * @param cleanupAnnotation cleanupAnnotation or {@code null} for none
   */
  public GoodocSemanticLabel setCleanupAnnotation(java.util.List<java.lang.Integer> cleanupAnnotation) {
    this.cleanupAnnotation = cleanupAnnotation;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getContinuesFromPreviousPage() {
    return continuesFromPreviousPage;
  }

  /**
   * @param continuesFromPreviousPage continuesFromPreviousPage or {@code null} for none
   */
  public GoodocSemanticLabel setContinuesFromPreviousPage(java.lang.Boolean continuesFromPreviousPage) {
    this.continuesFromPreviousPage = continuesFromPreviousPage;
    return this;
  }

  /**
   * When ContinuesFromPreviousPage=true, this bit can be set to note that the word fragment on the
   * previous page ends in a hyphen.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getContinuesFromPreviousPageHyphenated() {
    return continuesFromPreviousPageHyphenated;
  }

  /**
   * When ContinuesFromPreviousPage=true, this bit can be set to note that the word fragment on the
   * previous page ends in a hyphen.
   * @param continuesFromPreviousPageHyphenated continuesFromPreviousPageHyphenated or {@code null} for none
   */
  public GoodocSemanticLabel setContinuesFromPreviousPageHyphenated(java.lang.Boolean continuesFromPreviousPageHyphenated) {
    this.continuesFromPreviousPageHyphenated = continuesFromPreviousPageHyphenated;
    return this;
  }

  /**
   * Paragraphs that span across pages can be identified with the following flags. Note that flows
   * just connect Blocks across pages. These continuation flags imply something more specific -- the
   * case of a single logical paragraph split over pages. Only the last Paragraph in the last Block
   * within a given FlowThread() on a page can have ContinuesOnNextPage set. Similarly, only the
   * first Paragraph in the first Block with a given FlowThread() on a page may have
   * ContinuesFromPreviousPage set.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getContinuesOnNextPage() {
    return continuesOnNextPage;
  }

  /**
   * Paragraphs that span across pages can be identified with the following flags. Note that flows
   * just connect Blocks across pages. These continuation flags imply something more specific -- the
   * case of a single logical paragraph split over pages. Only the last Paragraph in the last Block
   * within a given FlowThread() on a page can have ContinuesOnNextPage set. Similarly, only the
   * first Paragraph in the first Block with a given FlowThread() on a page may have
   * ContinuesFromPreviousPage set.
   * @param continuesOnNextPage continuesOnNextPage or {@code null} for none
   */
  public GoodocSemanticLabel setContinuesOnNextPage(java.lang.Boolean continuesOnNextPage) {
    this.continuesOnNextPage = continuesOnNextPage;
    return this;
  }

  /**
   * Normally, a SemanticLabel applies exactly to the goodoc element that it is contained in
   * (usually Block or Paragraph, sometimes Word). Occasionally, we need a SemanticLabel to span
   * across the boundary or end before the boundary. For example, a URL may just be a few words
   * within a Paragraph. In such cases, the SemanticLabel is added to the first element of the span
   * and contains this LogicalEntity pointing to the last element of the span:
   * @return value or {@code null} for none
   */
  public GoodocLogicalEntity getEndOfSpanningLabel() {
    return endOfSpanningLabel;
  }

  /**
   * Normally, a SemanticLabel applies exactly to the goodoc element that it is contained in
   * (usually Block or Paragraph, sometimes Word). Occasionally, we need a SemanticLabel to span
   * across the boundary or end before the boundary. For example, a URL may just be a few words
   * within a Paragraph. In such cases, the SemanticLabel is added to the first element of the span
   * and contains this LogicalEntity pointing to the last element of the span:
   * @param endOfSpanningLabel endOfSpanningLabel or {@code null} for none
   */
  public GoodocSemanticLabel setEndOfSpanningLabel(GoodocLogicalEntity endOfSpanningLabel) {
    this.endOfSpanningLabel = endOfSpanningLabel;
    return this;
  }

  /**
   * Message set for experimental algorithm data. Use case: We keep a set of features that was
   * computed for the unsupervised caption extraction and store it here. Agora question producer
   * will consume this message set to be embedded in a question. The experimental feature set can
   * then be used later to pair up with ground truth labels for designing a supervised algorithm.
   * Currently holding: o ocean/analysis/content/caption_data.proto's TextualElement
   * @return value or {@code null} for none
   */
  public Proto2BridgeMessageSet getExperimentalData() {
    return experimentalData;
  }

  /**
   * Message set for experimental algorithm data. Use case: We keep a set of features that was
   * computed for the unsupervised caption extraction and store it here. Agora question producer
   * will consume this message set to be embedded in a question. The experimental feature set can
   * then be used later to pair up with ground truth labels for designing a supervised algorithm.
   * Currently holding: o ocean/analysis/content/caption_data.proto's TextualElement
   * @param experimentalData experimentalData or {@code null} for none
   */
  public GoodocSemanticLabel setExperimentalData(Proto2BridgeMessageSet experimentalData) {
    this.experimentalData = experimentalData;
    return this;
  }

  /**
   * Flow identifies a single sequential unit of text (or other content). It is only set on Blocks
   * -- a flow identifies a sequence of Blocks. The default, main flow is just the empty string. The
   * "FlowThread" of a block is the flow (if non-empty), suffixed with the block appearance. This is
   * computed by GoodocUtils::FlowThread(). Paragraphs may be split over blocks in the same
   * FlowThread, across pages. The following table shows how FlowThread gets computed: ## Flow
   * Appearance FlowThread (empty) UNSPECIFIED "UNSPECIFIED" foo BODY "foo:BODY" Please use lower-
   * case strings for flows (such as article-33-box). One useful way to think of flows is this: A
   * logical unit of interest in a a Document (for example, an article) would be identified by a
   * starting block, an ending block, and a list of flows of interest within the [start, end) span.
   * message Article { (page#, block#): article_start; (page#, block#): article_end; repeated string
   * flows; } The reading order of blocks, paragraphs/etc within this article would be the same
   * order as present in the goodoc itself. Some applications (such as rendering) may want to
   * process the article by running over all the flows together, others (such as indexing) may want
   * to deal with the FlowThreads one after the other.
   * @return value or {@code null} for none
   */
  public java.lang.String getFlow() {
    return flow;
  }

  /**
   * Flow identifies a single sequential unit of text (or other content). It is only set on Blocks
   * -- a flow identifies a sequence of Blocks. The default, main flow is just the empty string. The
   * "FlowThread" of a block is the flow (if non-empty), suffixed with the block appearance. This is
   * computed by GoodocUtils::FlowThread(). Paragraphs may be split over blocks in the same
   * FlowThread, across pages. The following table shows how FlowThread gets computed: ## Flow
   * Appearance FlowThread (empty) UNSPECIFIED "UNSPECIFIED" foo BODY "foo:BODY" Please use lower-
   * case strings for flows (such as article-33-box). One useful way to think of flows is this: A
   * logical unit of interest in a a Document (for example, an article) would be identified by a
   * starting block, an ending block, and a list of flows of interest within the [start, end) span.
   * message Article { (page#, block#): article_start; (page#, block#): article_end; repeated string
   * flows; } The reading order of blocks, paragraphs/etc within this article would be the same
   * order as present in the goodoc itself. Some applications (such as rendering) may want to
   * process the article by running over all the flows together, others (such as indexing) may want
   * to deal with the FlowThreads one after the other.
   * @param flow flow or {@code null} for none
   */
  public GoodocSemanticLabel setFlow(java.lang.String flow) {
    this.flow = flow;
    return this;
  }

  /**
   * This field can be used to record the steps by which AlternateText for a sequence of the Goodoc
   * is generated.
   * @return value or {@code null} for none
   */
  public java.lang.String getModificationRecord() {
    return modificationRecord;
  }

  /**
   * This field can be used to record the steps by which AlternateText for a sequence of the Goodoc
   * is generated.
   * @param modificationRecord modificationRecord or {@code null} for none
   */
  public GoodocSemanticLabel setModificationRecord(java.lang.String modificationRecord) {
    this.modificationRecord = modificationRecord;
    return this;
  }

  /**
   * If Appearence is PAGE_NUMBER:
   * @return value or {@code null} for none
   */
  public GoodocOrdinal getPageNumberOrdinal() {
    return pageNumberOrdinal;
  }

  /**
   * If Appearence is PAGE_NUMBER:
   * @param pageNumberOrdinal pageNumberOrdinal or {@code null} for none
   */
  public GoodocSemanticLabel setPageNumberOrdinal(GoodocOrdinal pageNumberOrdinal) {
    this.pageNumberOrdinal = pageNumberOrdinal;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getAppearance() {
    return appearance;
  }

  /**
   * @param appearance appearance or {@code null} for none
   */
  public GoodocSemanticLabel setAppearance(java.lang.Integer appearance) {
    this.appearance = appearance;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GoodocSemanticLabelColumnDetails getColumndetails() {
    return columndetails;
  }

  /**
   * @param columndetails columndetails or {@code null} for none
   */
  public GoodocSemanticLabel setColumndetails(GoodocSemanticLabelColumnDetails columndetails) {
    this.columndetails = columndetails;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GoodocSemanticLabelContentLink getContentlink() {
    return contentlink;
  }

  /**
   * @param contentlink contentlink or {@code null} for none
   */
  public GoodocSemanticLabel setContentlink(GoodocSemanticLabelContentLink contentlink) {
    this.contentlink = contentlink;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.util.List<GoodocSemanticLabelEditCorrectionCandidate> getEditcorrectioncandidate() {
    return editcorrectioncandidate;
  }

  /**
   * @param editcorrectioncandidate editcorrectioncandidate or {@code null} for none
   */
  public GoodocSemanticLabel setEditcorrectioncandidate(java.util.List<GoodocSemanticLabelEditCorrectionCandidate> editcorrectioncandidate) {
    this.editcorrectioncandidate = editcorrectioncandidate;
    return this;
  }

  /**
   * Structure overrides: typically manual corrections to goodoc renderings.
   * @return value or {@code null} for none
   */
  public GoodocOverrides getOverrides() {
    return overrides;
  }

  /**
   * Structure overrides: typically manual corrections to goodoc renderings.
   * @param overrides overrides or {@code null} for none
   */
  public GoodocSemanticLabel setOverrides(GoodocOverrides overrides) {
    this.overrides = overrides;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.util.List<GoodocSemanticLabelSnippetFilter> getSnippetfilter() {
    return snippetfilter;
  }

  /**
   * @param snippetfilter snippetfilter or {@code null} for none
   */
  public GoodocSemanticLabel setSnippetfilter(java.util.List<GoodocSemanticLabelSnippetFilter> snippetfilter) {
    this.snippetfilter = snippetfilter;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GoodocSemanticLabelTableCellDetails getTablecelldetails() {
    return tablecelldetails;
  }

  /**
   * @param tablecelldetails tablecelldetails or {@code null} for none
   */
  public GoodocSemanticLabel setTablecelldetails(GoodocSemanticLabelTableCellDetails tablecelldetails) {
    this.tablecelldetails = tablecelldetails;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GoodocSemanticLabelTableDetails getTabledetails() {
    return tabledetails;
  }

  /**
   * @param tabledetails tabledetails or {@code null} for none
   */
  public GoodocSemanticLabel setTabledetails(GoodocSemanticLabelTableDetails tabledetails) {
    this.tabledetails = tabledetails;
    return this;
  }

  @Override
  public GoodocSemanticLabel set(String fieldName, Object value) {
    return (GoodocSemanticLabel) super.set(fieldName, value);
  }

  @Override
  public GoodocSemanticLabel clone() {
    return (GoodocSemanticLabel) super.clone();
  }

}
