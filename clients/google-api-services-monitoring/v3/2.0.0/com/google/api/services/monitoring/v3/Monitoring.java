/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.monitoring.v3;

/**
 * Service definition for Monitoring (v3).
 *
 * <p>
 * Manages your Cloud Monitoring data and configurations.
 * </p>
 *
 * <p>
 * For more information about this service, see the
 * <a href="https://cloud.google.com/monitoring/api/" target="_blank">API Documentation</a>
 * </p>
 *
 * <p>
 * This service uses {@link MonitoringRequestInitializer} to initialize global parameters via its
 * {@link Builder}.
 * </p>
 *
 * @since 1.3
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public class Monitoring extends com.google.api.client.googleapis.services.json.AbstractGoogleJsonClient {

  // Note: Leave this static initializer at the top of the file.
  static {
    com.google.api.client.util.Preconditions.checkState(
        (com.google.api.client.googleapis.GoogleUtils.MAJOR_VERSION == 1 &&
        (com.google.api.client.googleapis.GoogleUtils.MINOR_VERSION >= 32 ||
        (com.google.api.client.googleapis.GoogleUtils.MINOR_VERSION == 31 &&
        com.google.api.client.googleapis.GoogleUtils.BUGFIX_VERSION >= 1))) ||
        com.google.api.client.googleapis.GoogleUtils.MAJOR_VERSION >= 2,
        "You are currently running with version %s of google-api-client. " +
        "You need at least version 1.31.1 of google-api-client to run version " +
        "2.0.0 of the Cloud Monitoring API library.", com.google.api.client.googleapis.GoogleUtils.VERSION);
  }

  /**
   * The default encoded root URL of the service. This is determined when the library is generated
   * and normally should not be changed.
   *
   * @since 1.7
   */
  public static final String DEFAULT_ROOT_URL = "https://monitoring.googleapis.com/";

  /**
   * The default encoded mTLS root URL of the service. This is determined when the library is generated
   * and normally should not be changed.
   *
   * @since 1.31
   */
  public static final String DEFAULT_MTLS_ROOT_URL = "https://monitoring.mtls.googleapis.com/";

  /**
   * The default encoded service path of the service. This is determined when the library is
   * generated and normally should not be changed.
   *
   * @since 1.7
   */
  public static final String DEFAULT_SERVICE_PATH = "";

  /**
   * The default encoded batch path of the service. This is determined when the library is
   * generated and normally should not be changed.
   *
   * @since 1.23
   */
  public static final String DEFAULT_BATCH_PATH = "batch";

  /**
   * The default encoded base URL of the service. This is determined when the library is generated
   * and normally should not be changed.
   */
  public static final String DEFAULT_BASE_URL = DEFAULT_ROOT_URL + DEFAULT_SERVICE_PATH;

  /**
   * Constructor.
   *
   * <p>
   * Use {@link Builder} if you need to specify any of the optional parameters.
   * </p>
   *
   * @param transport HTTP transport, which should normally be:
   *        <ul>
   *        <li>Google App Engine:
   *        {@code com.google.api.client.extensions.appengine.http.UrlFetchTransport}</li>
   *        <li>Android: {@code newCompatibleTransport} from
   *        {@code com.google.api.client.extensions.android.http.AndroidHttp}</li>
   *        <li>Java: {@link com.google.api.client.googleapis.javanet.GoogleNetHttpTransport#newTrustedTransport()}
   *        </li>
   *        </ul>
   * @param jsonFactory JSON factory, which may be:
   *        <ul>
   *        <li>Jackson: {@code com.google.api.client.json.jackson2.JacksonFactory}</li>
   *        <li>Google GSON: {@code com.google.api.client.json.gson.GsonFactory}</li>
   *        <li>Android Honeycomb or higher:
   *        {@code com.google.api.client.extensions.android.json.AndroidJsonFactory}</li>
   *        </ul>
   * @param httpRequestInitializer HTTP request initializer or {@code null} for none
   * @since 1.7
   */
  public Monitoring(com.google.api.client.http.HttpTransport transport, com.google.api.client.json.JsonFactory jsonFactory,
      com.google.api.client.http.HttpRequestInitializer httpRequestInitializer) {
    this(new Builder(transport, jsonFactory, httpRequestInitializer));
  }

  /**
   * @param builder builder
   */
  Monitoring(Builder builder) {
    super(builder);
  }

  @Override
  protected void initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest<?> httpClientRequest) throws java.io.IOException {
    super.initialize(httpClientRequest);
  }

  /**
   * An accessor for creating requests from the Folders collection.
   *
   * <p>The typical use is:</p>
   * <pre>
   *   {@code Monitoring monitoring = new Monitoring(...);}
   *   {@code Monitoring.Folders.List request = monitoring.folders().list(parameters ...)}
   * </pre>
   *
   * @return the resource collection
   */
  public Folders folders() {
    return new Folders();
  }

  /**
   * The "folders" collection of methods.
   */
  public class Folders {

    /**
     * An accessor for creating requests from the TimeSeries collection.
     *
     * <p>The typical use is:</p>
     * <pre>
     *   {@code Monitoring monitoring = new Monitoring(...);}
     *   {@code Monitoring.TimeSeries.List request = monitoring.timeSeries().list(parameters ...)}
     * </pre>
     *
     * @return the resource collection
     */
    public TimeSeries timeSeries() {
      return new TimeSeries();
    }

    /**
     * The "timeSeries" collection of methods.
     */
    public class TimeSeries {

      /**
       * Lists time series that match a filter.
       *
       * Create a request for the method "timeSeries.list".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link List#execute()} method to invoke the remote operation.
       *
       * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name), organization or
       *        folder on which to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
       *        organizations/[ORGANIZATION_ID] folders/[FOLDER_ID]
       * @return the request
       */
      public List list(java.lang.String name) throws java.io.IOException {
        List result = new List(name);
        initialize(result);
        return result;
      }

      public class List extends MonitoringRequest<com.google.api.services.monitoring.v3.model.ListTimeSeriesResponse> {

        private static final String REST_PATH = "v3/{+name}/timeSeries";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^folders/[^/]+$");

        /**
         * Lists time series that match a filter.
         *
         * Create a request for the method "timeSeries.list".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
         * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name), organization or
       *        folder on which to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
       *        organizations/[ORGANIZATION_ID] folders/[FOLDER_ID]
         * @since 1.13
         */
        protected List(java.lang.String name) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.ListTimeSeriesResponse.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^folders/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public List set$Xgafv(java.lang.String $Xgafv) {
          return (List) super.set$Xgafv($Xgafv);
        }

        @Override
        public List setAccessToken(java.lang.String accessToken) {
          return (List) super.setAccessToken(accessToken);
        }

        @Override
        public List setAlt(java.lang.String alt) {
          return (List) super.setAlt(alt);
        }

        @Override
        public List setCallback(java.lang.String callback) {
          return (List) super.setCallback(callback);
        }

        @Override
        public List setFields(java.lang.String fields) {
          return (List) super.setFields(fields);
        }

        @Override
        public List setKey(java.lang.String key) {
          return (List) super.setKey(key);
        }

        @Override
        public List setOauthToken(java.lang.String oauthToken) {
          return (List) super.setOauthToken(oauthToken);
        }

        @Override
        public List setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (List) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public List setQuotaUser(java.lang.String quotaUser) {
          return (List) super.setQuotaUser(quotaUser);
        }

        @Override
        public List setUploadType(java.lang.String uploadType) {
          return (List) super.setUploadType(uploadType);
        }

        @Override
        public List setUploadProtocol(java.lang.String uploadProtocol) {
          return (List) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name),
         * organization or folder on which to execute the request. The format is:
         * projects/[PROJECT_ID_OR_NUMBER] organizations/[ORGANIZATION_ID] folders/[FOLDER_ID]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The project (https://cloud.google.com/monitoring/api/v3#project_name), organization or
       folder on which to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
       organizations/[ORGANIZATION_ID] folders/[FOLDER_ID]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name),
         * organization or folder on which to execute the request. The format is:
         * projects/[PROJECT_ID_OR_NUMBER] organizations/[ORGANIZATION_ID] folders/[FOLDER_ID]
         */
        public List setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^folders/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /**
         * The alignment_period specifies a time interval, in seconds, that is used to divide the
         * data in all the time series into consistent blocks of time. This will be done before the
         * per-series aligner can be applied to the data.The value must be at least 60 seconds. If a
         * per-series aligner other than ALIGN_NONE is specified, this field is required or an error
         * is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is
         * specified, then this field is ignored.The maximum value of the alignment_period is 104
         * weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
         */
        @com.google.api.client.util.Key("aggregation.alignmentPeriod")
        private String aggregationAlignmentPeriod;

        /** The alignment_period specifies a time interval, in seconds, that is used to divide the data in all
       the time series into consistent blocks of time. This will be done before the per-series aligner can
       be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than
       ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner
       is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value
       of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for
       alerting policies.
         */
        public String getAggregationAlignmentPeriod() {
          return aggregationAlignmentPeriod;
        }

        /**
         * The alignment_period specifies a time interval, in seconds, that is used to divide the
         * data in all the time series into consistent blocks of time. This will be done before the
         * per-series aligner can be applied to the data.The value must be at least 60 seconds. If a
         * per-series aligner other than ALIGN_NONE is specified, this field is required or an error
         * is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is
         * specified, then this field is ignored.The maximum value of the alignment_period is 104
         * weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
         */
        public List setAggregationAlignmentPeriod(String aggregationAlignmentPeriod) {
          this.aggregationAlignmentPeriod = aggregationAlignmentPeriod;
          return this;
        }

        /**
         * The reduction operation to be used to combine time series into a single time series,
         * where the value of each data point in the resulting series is a function of all the
         * already aligned values in the input time series.Not all reducer operations can be applied
         * to all time series. The valid choices depend on the metric_kind and the value_type of the
         * original time series. Reduction can yield a time series with a different metric_kind or
         * value_type than the input time series.Time series data must first be aligned (see
         * per_series_aligner) in order to perform cross-time series reduction. If
         * cross_series_reducer is specified, then per_series_aligner must be specified, and must
         * not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is
         * returned.
         */
        @com.google.api.client.util.Key("aggregation.crossSeriesReducer")
        private java.lang.String aggregationCrossSeriesReducer;

        /** The reduction operation to be used to combine time series into a single time series, where the
       value of each data point in the resulting series is a function of all the already aligned values in
       the input time series.Not all reducer operations can be applied to all time series. The valid
       choices depend on the metric_kind and the value_type of the original time series. Reduction can
       yield a time series with a different metric_kind or value_type than the input time series.Time
       series data must first be aligned (see per_series_aligner) in order to perform cross-time series
       reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and
       must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is
       returned.
         */
        public java.lang.String getAggregationCrossSeriesReducer() {
          return aggregationCrossSeriesReducer;
        }

        /**
         * The reduction operation to be used to combine time series into a single time series,
         * where the value of each data point in the resulting series is a function of all the
         * already aligned values in the input time series.Not all reducer operations can be applied
         * to all time series. The valid choices depend on the metric_kind and the value_type of the
         * original time series. Reduction can yield a time series with a different metric_kind or
         * value_type than the input time series.Time series data must first be aligned (see
         * per_series_aligner) in order to perform cross-time series reduction. If
         * cross_series_reducer is specified, then per_series_aligner must be specified, and must
         * not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is
         * returned.
         */
        public List setAggregationCrossSeriesReducer(java.lang.String aggregationCrossSeriesReducer) {
          this.aggregationCrossSeriesReducer = aggregationCrossSeriesReducer;
          return this;
        }

        /**
         * The set of fields to preserve when cross_series_reducer is specified. The group_by_fields
         * determine how the time series are partitioned into subsets prior to applying the
         * aggregation operation. Each subset contains time series that have the same value for each
         * of the grouping fields. Each individual time series is a member of exactly one subset.
         * The cross_series_reducer is applied to each subset of time series. It is not possible to
         * reduce across different resource types, so this field implicitly contains resource.type.
         * Fields not specified in group_by_fields are aggregated away. If group_by_fields is not
         * specified and all the time series have the same resource type, then the time series are
         * aggregated into a single output time series. If cross_series_reducer is not defined, this
         * field is ignored.
         */
        @com.google.api.client.util.Key("aggregation.groupByFields")
        private java.util.List<java.lang.String> aggregationGroupByFields;

        /** The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine
       how the time series are partitioned into subsets prior to applying the aggregation operation. Each
       subset contains time series that have the same value for each of the grouping fields. Each
       individual time series is a member of exactly one subset. The cross_series_reducer is applied to
       each subset of time series. It is not possible to reduce across different resource types, so this
       field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated
       away. If group_by_fields is not specified and all the time series have the same resource type, then
       the time series are aggregated into a single output time series. If cross_series_reducer is not
       defined, this field is ignored.
         */
        public java.util.List<java.lang.String> getAggregationGroupByFields() {
          return aggregationGroupByFields;
        }

        /**
         * The set of fields to preserve when cross_series_reducer is specified. The group_by_fields
         * determine how the time series are partitioned into subsets prior to applying the
         * aggregation operation. Each subset contains time series that have the same value for each
         * of the grouping fields. Each individual time series is a member of exactly one subset.
         * The cross_series_reducer is applied to each subset of time series. It is not possible to
         * reduce across different resource types, so this field implicitly contains resource.type.
         * Fields not specified in group_by_fields are aggregated away. If group_by_fields is not
         * specified and all the time series have the same resource type, then the time series are
         * aggregated into a single output time series. If cross_series_reducer is not defined, this
         * field is ignored.
         */
        public List setAggregationGroupByFields(java.util.List<java.lang.String> aggregationGroupByFields) {
          this.aggregationGroupByFields = aggregationGroupByFields;
          return this;
        }

        /**
         * An Aligner describes how to bring the data points in a single time series into temporal
         * alignment. Except for ALIGN_NONE, all alignments cause all the data points in an
         * alignment_period to be mathematically grouped together, resulting in a single data point
         * for each alignment_period with end timestamp at the end of the period.Not all alignment
         * operations may be applied to all time series. The valid choices depend on the metric_kind
         * and value_type of the original time series. Alignment can change the metric_kind or the
         * value_type of the time series.Time series data must be aligned in order to perform cross-
         * time series reduction. If cross_series_reducer is specified, then per_series_aligner must
         * be specified and not equal to ALIGN_NONE and alignment_period must be specified;
         * otherwise, an error is returned.
         */
        @com.google.api.client.util.Key("aggregation.perSeriesAligner")
        private java.lang.String aggregationPerSeriesAligner;

        /** An Aligner describes how to bring the data points in a single time series into temporal alignment.
       Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be
       mathematically grouped together, resulting in a single data point for each alignment_period with
       end timestamp at the end of the period.Not all alignment operations may be applied to all time
       series. The valid choices depend on the metric_kind and value_type of the original time series.
       Alignment can change the metric_kind or the value_type of the time series.Time series data must be
       aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then
       per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be
       specified; otherwise, an error is returned.
         */
        public java.lang.String getAggregationPerSeriesAligner() {
          return aggregationPerSeriesAligner;
        }

        /**
         * An Aligner describes how to bring the data points in a single time series into temporal
         * alignment. Except for ALIGN_NONE, all alignments cause all the data points in an
         * alignment_period to be mathematically grouped together, resulting in a single data point
         * for each alignment_period with end timestamp at the end of the period.Not all alignment
         * operations may be applied to all time series. The valid choices depend on the metric_kind
         * and value_type of the original time series. Alignment can change the metric_kind or the
         * value_type of the time series.Time series data must be aligned in order to perform cross-
         * time series reduction. If cross_series_reducer is specified, then per_series_aligner must
         * be specified and not equal to ALIGN_NONE and alignment_period must be specified;
         * otherwise, an error is returned.
         */
        public List setAggregationPerSeriesAligner(java.lang.String aggregationPerSeriesAligner) {
          this.aggregationPerSeriesAligner = aggregationPerSeriesAligner;
          return this;
        }

        /**
         * Required. A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that
         * specifies which time series should be returned. The filter must specify a single metric
         * type, and can additionally specify metric labels and other information. For example:
         * metric.type = "compute.googleapis.com/instance/cpu/usage_time" AND
         * metric.labels.instance_name = "my-instance-name"
         */
        @com.google.api.client.util.Key
        private java.lang.String filter;

        /** Required. A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that specifies
       which time series should be returned. The filter must specify a single metric type, and can
       additionally specify metric labels and other information. For example: metric.type =
       "compute.googleapis.com/instance/cpu/usage_time" AND metric.labels.instance_name = "my-instance-
       name"
         */
        public java.lang.String getFilter() {
          return filter;
        }

        /**
         * Required. A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that
         * specifies which time series should be returned. The filter must specify a single metric
         * type, and can additionally specify metric labels and other information. For example:
         * metric.type = "compute.googleapis.com/instance/cpu/usage_time" AND
         * metric.labels.instance_name = "my-instance-name"
         */
        public List setFilter(java.lang.String filter) {
          this.filter = filter;
          return this;
        }

        /** Required. The end of the time interval. */
        @com.google.api.client.util.Key("interval.endTime")
        private String intervalEndTime;

        /** Required. The end of the time interval.
         */
        public String getIntervalEndTime() {
          return intervalEndTime;
        }

        /** Required. The end of the time interval. */
        public List setIntervalEndTime(String intervalEndTime) {
          this.intervalEndTime = intervalEndTime;
          return this;
        }

        /**
         * Optional. The beginning of the time interval. The default value for the start time is the
         * end time. The start time must not be later than the end time.
         */
        @com.google.api.client.util.Key("interval.startTime")
        private String intervalStartTime;

        /** Optional. The beginning of the time interval. The default value for the start time is the end time.
       The start time must not be later than the end time.
         */
        public String getIntervalStartTime() {
          return intervalStartTime;
        }

        /**
         * Optional. The beginning of the time interval. The default value for the start time is the
         * end time. The start time must not be later than the end time.
         */
        public List setIntervalStartTime(String intervalStartTime) {
          this.intervalStartTime = intervalStartTime;
          return this;
        }

        /**
         * Unsupported: must be left blank. The points in each time series are currently returned in
         * reverse time order (most recent to oldest).
         */
        @com.google.api.client.util.Key
        private java.lang.String orderBy;

        /** Unsupported: must be left blank. The points in each time series are currently returned in reverse
       time order (most recent to oldest).
         */
        public java.lang.String getOrderBy() {
          return orderBy;
        }

        /**
         * Unsupported: must be left blank. The points in each time series are currently returned in
         * reverse time order (most recent to oldest).
         */
        public List setOrderBy(java.lang.String orderBy) {
          this.orderBy = orderBy;
          return this;
        }

        /**
         * A positive number that is the maximum number of results to return. If page_size is empty
         * or more than 100,000 results, the effective page_size is 100,000 results. If view is set
         * to FULL, this is the maximum number of Points returned. If view is set to HEADERS, this
         * is the maximum number of TimeSeries returned.
         */
        @com.google.api.client.util.Key
        private java.lang.Integer pageSize;

        /** A positive number that is the maximum number of results to return. If page_size is empty or more
       than 100,000 results, the effective page_size is 100,000 results. If view is set to FULL, this is
       the maximum number of Points returned. If view is set to HEADERS, this is the maximum number of
       TimeSeries returned.
         */
        public java.lang.Integer getPageSize() {
          return pageSize;
        }

        /**
         * A positive number that is the maximum number of results to return. If page_size is empty
         * or more than 100,000 results, the effective page_size is 100,000 results. If view is set
         * to FULL, this is the maximum number of Points returned. If view is set to HEADERS, this
         * is the maximum number of TimeSeries returned.
         */
        public List setPageSize(java.lang.Integer pageSize) {
          this.pageSize = pageSize;
          return this;
        }

        /**
         * If this field is not empty then it must contain the nextPageToken value returned by a
         * previous call to this method. Using this field causes the method to return additional
         * results from the previous method call.
         */
        @com.google.api.client.util.Key
        private java.lang.String pageToken;

        /** If this field is not empty then it must contain the nextPageToken value returned by a previous call
       to this method. Using this field causes the method to return additional results from the previous
       method call.
         */
        public java.lang.String getPageToken() {
          return pageToken;
        }

        /**
         * If this field is not empty then it must contain the nextPageToken value returned by a
         * previous call to this method. Using this field causes the method to return additional
         * results from the previous method call.
         */
        public List setPageToken(java.lang.String pageToken) {
          this.pageToken = pageToken;
          return this;
        }

        /**
         * The alignment_period specifies a time interval, in seconds, that is used to divide the
         * data in all the time series into consistent blocks of time. This will be done before the
         * per-series aligner can be applied to the data.The value must be at least 60 seconds. If a
         * per-series aligner other than ALIGN_NONE is specified, this field is required or an error
         * is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is
         * specified, then this field is ignored.The maximum value of the alignment_period is 104
         * weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
         */
        @com.google.api.client.util.Key("secondaryAggregation.alignmentPeriod")
        private String secondaryAggregationAlignmentPeriod;

        /** The alignment_period specifies a time interval, in seconds, that is used to divide the data in all
       the time series into consistent blocks of time. This will be done before the per-series aligner can
       be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than
       ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner
       is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value
       of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for
       alerting policies.
         */
        public String getSecondaryAggregationAlignmentPeriod() {
          return secondaryAggregationAlignmentPeriod;
        }

        /**
         * The alignment_period specifies a time interval, in seconds, that is used to divide the
         * data in all the time series into consistent blocks of time. This will be done before the
         * per-series aligner can be applied to the data.The value must be at least 60 seconds. If a
         * per-series aligner other than ALIGN_NONE is specified, this field is required or an error
         * is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is
         * specified, then this field is ignored.The maximum value of the alignment_period is 104
         * weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
         */
        public List setSecondaryAggregationAlignmentPeriod(String secondaryAggregationAlignmentPeriod) {
          this.secondaryAggregationAlignmentPeriod = secondaryAggregationAlignmentPeriod;
          return this;
        }

        /**
         * The reduction operation to be used to combine time series into a single time series,
         * where the value of each data point in the resulting series is a function of all the
         * already aligned values in the input time series.Not all reducer operations can be applied
         * to all time series. The valid choices depend on the metric_kind and the value_type of the
         * original time series. Reduction can yield a time series with a different metric_kind or
         * value_type than the input time series.Time series data must first be aligned (see
         * per_series_aligner) in order to perform cross-time series reduction. If
         * cross_series_reducer is specified, then per_series_aligner must be specified, and must
         * not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is
         * returned.
         */
        @com.google.api.client.util.Key("secondaryAggregation.crossSeriesReducer")
        private java.lang.String secondaryAggregationCrossSeriesReducer;

        /** The reduction operation to be used to combine time series into a single time series, where the
       value of each data point in the resulting series is a function of all the already aligned values in
       the input time series.Not all reducer operations can be applied to all time series. The valid
       choices depend on the metric_kind and the value_type of the original time series. Reduction can
       yield a time series with a different metric_kind or value_type than the input time series.Time
       series data must first be aligned (see per_series_aligner) in order to perform cross-time series
       reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and
       must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is
       returned.
         */
        public java.lang.String getSecondaryAggregationCrossSeriesReducer() {
          return secondaryAggregationCrossSeriesReducer;
        }

        /**
         * The reduction operation to be used to combine time series into a single time series,
         * where the value of each data point in the resulting series is a function of all the
         * already aligned values in the input time series.Not all reducer operations can be applied
         * to all time series. The valid choices depend on the metric_kind and the value_type of the
         * original time series. Reduction can yield a time series with a different metric_kind or
         * value_type than the input time series.Time series data must first be aligned (see
         * per_series_aligner) in order to perform cross-time series reduction. If
         * cross_series_reducer is specified, then per_series_aligner must be specified, and must
         * not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is
         * returned.
         */
        public List setSecondaryAggregationCrossSeriesReducer(java.lang.String secondaryAggregationCrossSeriesReducer) {
          this.secondaryAggregationCrossSeriesReducer = secondaryAggregationCrossSeriesReducer;
          return this;
        }

        /**
         * The set of fields to preserve when cross_series_reducer is specified. The group_by_fields
         * determine how the time series are partitioned into subsets prior to applying the
         * aggregation operation. Each subset contains time series that have the same value for each
         * of the grouping fields. Each individual time series is a member of exactly one subset.
         * The cross_series_reducer is applied to each subset of time series. It is not possible to
         * reduce across different resource types, so this field implicitly contains resource.type.
         * Fields not specified in group_by_fields are aggregated away. If group_by_fields is not
         * specified and all the time series have the same resource type, then the time series are
         * aggregated into a single output time series. If cross_series_reducer is not defined, this
         * field is ignored.
         */
        @com.google.api.client.util.Key("secondaryAggregation.groupByFields")
        private java.util.List<java.lang.String> secondaryAggregationGroupByFields;

        /** The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine
       how the time series are partitioned into subsets prior to applying the aggregation operation. Each
       subset contains time series that have the same value for each of the grouping fields. Each
       individual time series is a member of exactly one subset. The cross_series_reducer is applied to
       each subset of time series. It is not possible to reduce across different resource types, so this
       field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated
       away. If group_by_fields is not specified and all the time series have the same resource type, then
       the time series are aggregated into a single output time series. If cross_series_reducer is not
       defined, this field is ignored.
         */
        public java.util.List<java.lang.String> getSecondaryAggregationGroupByFields() {
          return secondaryAggregationGroupByFields;
        }

        /**
         * The set of fields to preserve when cross_series_reducer is specified. The group_by_fields
         * determine how the time series are partitioned into subsets prior to applying the
         * aggregation operation. Each subset contains time series that have the same value for each
         * of the grouping fields. Each individual time series is a member of exactly one subset.
         * The cross_series_reducer is applied to each subset of time series. It is not possible to
         * reduce across different resource types, so this field implicitly contains resource.type.
         * Fields not specified in group_by_fields are aggregated away. If group_by_fields is not
         * specified and all the time series have the same resource type, then the time series are
         * aggregated into a single output time series. If cross_series_reducer is not defined, this
         * field is ignored.
         */
        public List setSecondaryAggregationGroupByFields(java.util.List<java.lang.String> secondaryAggregationGroupByFields) {
          this.secondaryAggregationGroupByFields = secondaryAggregationGroupByFields;
          return this;
        }

        /**
         * An Aligner describes how to bring the data points in a single time series into temporal
         * alignment. Except for ALIGN_NONE, all alignments cause all the data points in an
         * alignment_period to be mathematically grouped together, resulting in a single data point
         * for each alignment_period with end timestamp at the end of the period.Not all alignment
         * operations may be applied to all time series. The valid choices depend on the metric_kind
         * and value_type of the original time series. Alignment can change the metric_kind or the
         * value_type of the time series.Time series data must be aligned in order to perform cross-
         * time series reduction. If cross_series_reducer is specified, then per_series_aligner must
         * be specified and not equal to ALIGN_NONE and alignment_period must be specified;
         * otherwise, an error is returned.
         */
        @com.google.api.client.util.Key("secondaryAggregation.perSeriesAligner")
        private java.lang.String secondaryAggregationPerSeriesAligner;

        /** An Aligner describes how to bring the data points in a single time series into temporal alignment.
       Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be
       mathematically grouped together, resulting in a single data point for each alignment_period with
       end timestamp at the end of the period.Not all alignment operations may be applied to all time
       series. The valid choices depend on the metric_kind and value_type of the original time series.
       Alignment can change the metric_kind or the value_type of the time series.Time series data must be
       aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then
       per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be
       specified; otherwise, an error is returned.
         */
        public java.lang.String getSecondaryAggregationPerSeriesAligner() {
          return secondaryAggregationPerSeriesAligner;
        }

        /**
         * An Aligner describes how to bring the data points in a single time series into temporal
         * alignment. Except for ALIGN_NONE, all alignments cause all the data points in an
         * alignment_period to be mathematically grouped together, resulting in a single data point
         * for each alignment_period with end timestamp at the end of the period.Not all alignment
         * operations may be applied to all time series. The valid choices depend on the metric_kind
         * and value_type of the original time series. Alignment can change the metric_kind or the
         * value_type of the time series.Time series data must be aligned in order to perform cross-
         * time series reduction. If cross_series_reducer is specified, then per_series_aligner must
         * be specified and not equal to ALIGN_NONE and alignment_period must be specified;
         * otherwise, an error is returned.
         */
        public List setSecondaryAggregationPerSeriesAligner(java.lang.String secondaryAggregationPerSeriesAligner) {
          this.secondaryAggregationPerSeriesAligner = secondaryAggregationPerSeriesAligner;
          return this;
        }

        /** Required. Specifies which information is returned about the time series. */
        @com.google.api.client.util.Key
        private java.lang.String view;

        /** Required. Specifies which information is returned about the time series.
         */
        public java.lang.String getView() {
          return view;
        }

        /** Required. Specifies which information is returned about the time series. */
        public List setView(java.lang.String view) {
          this.view = view;
          return this;
        }

        @Override
        public List set(String parameterName, Object value) {
          return (List) super.set(parameterName, value);
        }
      }

    }
  }

  /**
   * An accessor for creating requests from the Organizations collection.
   *
   * <p>The typical use is:</p>
   * <pre>
   *   {@code Monitoring monitoring = new Monitoring(...);}
   *   {@code Monitoring.Organizations.List request = monitoring.organizations().list(parameters ...)}
   * </pre>
   *
   * @return the resource collection
   */
  public Organizations organizations() {
    return new Organizations();
  }

  /**
   * The "organizations" collection of methods.
   */
  public class Organizations {

    /**
     * An accessor for creating requests from the TimeSeries collection.
     *
     * <p>The typical use is:</p>
     * <pre>
     *   {@code Monitoring monitoring = new Monitoring(...);}
     *   {@code Monitoring.TimeSeries.List request = monitoring.timeSeries().list(parameters ...)}
     * </pre>
     *
     * @return the resource collection
     */
    public TimeSeries timeSeries() {
      return new TimeSeries();
    }

    /**
     * The "timeSeries" collection of methods.
     */
    public class TimeSeries {

      /**
       * Lists time series that match a filter.
       *
       * Create a request for the method "timeSeries.list".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link List#execute()} method to invoke the remote operation.
       *
       * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name), organization or
       *        folder on which to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
       *        organizations/[ORGANIZATION_ID] folders/[FOLDER_ID]
       * @return the request
       */
      public List list(java.lang.String name) throws java.io.IOException {
        List result = new List(name);
        initialize(result);
        return result;
      }

      public class List extends MonitoringRequest<com.google.api.services.monitoring.v3.model.ListTimeSeriesResponse> {

        private static final String REST_PATH = "v3/{+name}/timeSeries";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^organizations/[^/]+$");

        /**
         * Lists time series that match a filter.
         *
         * Create a request for the method "timeSeries.list".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
         * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name), organization or
       *        folder on which to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
       *        organizations/[ORGANIZATION_ID] folders/[FOLDER_ID]
         * @since 1.13
         */
        protected List(java.lang.String name) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.ListTimeSeriesResponse.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^organizations/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public List set$Xgafv(java.lang.String $Xgafv) {
          return (List) super.set$Xgafv($Xgafv);
        }

        @Override
        public List setAccessToken(java.lang.String accessToken) {
          return (List) super.setAccessToken(accessToken);
        }

        @Override
        public List setAlt(java.lang.String alt) {
          return (List) super.setAlt(alt);
        }

        @Override
        public List setCallback(java.lang.String callback) {
          return (List) super.setCallback(callback);
        }

        @Override
        public List setFields(java.lang.String fields) {
          return (List) super.setFields(fields);
        }

        @Override
        public List setKey(java.lang.String key) {
          return (List) super.setKey(key);
        }

        @Override
        public List setOauthToken(java.lang.String oauthToken) {
          return (List) super.setOauthToken(oauthToken);
        }

        @Override
        public List setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (List) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public List setQuotaUser(java.lang.String quotaUser) {
          return (List) super.setQuotaUser(quotaUser);
        }

        @Override
        public List setUploadType(java.lang.String uploadType) {
          return (List) super.setUploadType(uploadType);
        }

        @Override
        public List setUploadProtocol(java.lang.String uploadProtocol) {
          return (List) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name),
         * organization or folder on which to execute the request. The format is:
         * projects/[PROJECT_ID_OR_NUMBER] organizations/[ORGANIZATION_ID] folders/[FOLDER_ID]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The project (https://cloud.google.com/monitoring/api/v3#project_name), organization or
       folder on which to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
       organizations/[ORGANIZATION_ID] folders/[FOLDER_ID]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name),
         * organization or folder on which to execute the request. The format is:
         * projects/[PROJECT_ID_OR_NUMBER] organizations/[ORGANIZATION_ID] folders/[FOLDER_ID]
         */
        public List setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^organizations/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /**
         * The alignment_period specifies a time interval, in seconds, that is used to divide the
         * data in all the time series into consistent blocks of time. This will be done before the
         * per-series aligner can be applied to the data.The value must be at least 60 seconds. If a
         * per-series aligner other than ALIGN_NONE is specified, this field is required or an error
         * is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is
         * specified, then this field is ignored.The maximum value of the alignment_period is 104
         * weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
         */
        @com.google.api.client.util.Key("aggregation.alignmentPeriod")
        private String aggregationAlignmentPeriod;

        /** The alignment_period specifies a time interval, in seconds, that is used to divide the data in all
       the time series into consistent blocks of time. This will be done before the per-series aligner can
       be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than
       ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner
       is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value
       of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for
       alerting policies.
         */
        public String getAggregationAlignmentPeriod() {
          return aggregationAlignmentPeriod;
        }

        /**
         * The alignment_period specifies a time interval, in seconds, that is used to divide the
         * data in all the time series into consistent blocks of time. This will be done before the
         * per-series aligner can be applied to the data.The value must be at least 60 seconds. If a
         * per-series aligner other than ALIGN_NONE is specified, this field is required or an error
         * is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is
         * specified, then this field is ignored.The maximum value of the alignment_period is 104
         * weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
         */
        public List setAggregationAlignmentPeriod(String aggregationAlignmentPeriod) {
          this.aggregationAlignmentPeriod = aggregationAlignmentPeriod;
          return this;
        }

        /**
         * The reduction operation to be used to combine time series into a single time series,
         * where the value of each data point in the resulting series is a function of all the
         * already aligned values in the input time series.Not all reducer operations can be applied
         * to all time series. The valid choices depend on the metric_kind and the value_type of the
         * original time series. Reduction can yield a time series with a different metric_kind or
         * value_type than the input time series.Time series data must first be aligned (see
         * per_series_aligner) in order to perform cross-time series reduction. If
         * cross_series_reducer is specified, then per_series_aligner must be specified, and must
         * not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is
         * returned.
         */
        @com.google.api.client.util.Key("aggregation.crossSeriesReducer")
        private java.lang.String aggregationCrossSeriesReducer;

        /** The reduction operation to be used to combine time series into a single time series, where the
       value of each data point in the resulting series is a function of all the already aligned values in
       the input time series.Not all reducer operations can be applied to all time series. The valid
       choices depend on the metric_kind and the value_type of the original time series. Reduction can
       yield a time series with a different metric_kind or value_type than the input time series.Time
       series data must first be aligned (see per_series_aligner) in order to perform cross-time series
       reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and
       must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is
       returned.
         */
        public java.lang.String getAggregationCrossSeriesReducer() {
          return aggregationCrossSeriesReducer;
        }

        /**
         * The reduction operation to be used to combine time series into a single time series,
         * where the value of each data point in the resulting series is a function of all the
         * already aligned values in the input time series.Not all reducer operations can be applied
         * to all time series. The valid choices depend on the metric_kind and the value_type of the
         * original time series. Reduction can yield a time series with a different metric_kind or
         * value_type than the input time series.Time series data must first be aligned (see
         * per_series_aligner) in order to perform cross-time series reduction. If
         * cross_series_reducer is specified, then per_series_aligner must be specified, and must
         * not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is
         * returned.
         */
        public List setAggregationCrossSeriesReducer(java.lang.String aggregationCrossSeriesReducer) {
          this.aggregationCrossSeriesReducer = aggregationCrossSeriesReducer;
          return this;
        }

        /**
         * The set of fields to preserve when cross_series_reducer is specified. The group_by_fields
         * determine how the time series are partitioned into subsets prior to applying the
         * aggregation operation. Each subset contains time series that have the same value for each
         * of the grouping fields. Each individual time series is a member of exactly one subset.
         * The cross_series_reducer is applied to each subset of time series. It is not possible to
         * reduce across different resource types, so this field implicitly contains resource.type.
         * Fields not specified in group_by_fields are aggregated away. If group_by_fields is not
         * specified and all the time series have the same resource type, then the time series are
         * aggregated into a single output time series. If cross_series_reducer is not defined, this
         * field is ignored.
         */
        @com.google.api.client.util.Key("aggregation.groupByFields")
        private java.util.List<java.lang.String> aggregationGroupByFields;

        /** The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine
       how the time series are partitioned into subsets prior to applying the aggregation operation. Each
       subset contains time series that have the same value for each of the grouping fields. Each
       individual time series is a member of exactly one subset. The cross_series_reducer is applied to
       each subset of time series. It is not possible to reduce across different resource types, so this
       field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated
       away. If group_by_fields is not specified and all the time series have the same resource type, then
       the time series are aggregated into a single output time series. If cross_series_reducer is not
       defined, this field is ignored.
         */
        public java.util.List<java.lang.String> getAggregationGroupByFields() {
          return aggregationGroupByFields;
        }

        /**
         * The set of fields to preserve when cross_series_reducer is specified. The group_by_fields
         * determine how the time series are partitioned into subsets prior to applying the
         * aggregation operation. Each subset contains time series that have the same value for each
         * of the grouping fields. Each individual time series is a member of exactly one subset.
         * The cross_series_reducer is applied to each subset of time series. It is not possible to
         * reduce across different resource types, so this field implicitly contains resource.type.
         * Fields not specified in group_by_fields are aggregated away. If group_by_fields is not
         * specified and all the time series have the same resource type, then the time series are
         * aggregated into a single output time series. If cross_series_reducer is not defined, this
         * field is ignored.
         */
        public List setAggregationGroupByFields(java.util.List<java.lang.String> aggregationGroupByFields) {
          this.aggregationGroupByFields = aggregationGroupByFields;
          return this;
        }

        /**
         * An Aligner describes how to bring the data points in a single time series into temporal
         * alignment. Except for ALIGN_NONE, all alignments cause all the data points in an
         * alignment_period to be mathematically grouped together, resulting in a single data point
         * for each alignment_period with end timestamp at the end of the period.Not all alignment
         * operations may be applied to all time series. The valid choices depend on the metric_kind
         * and value_type of the original time series. Alignment can change the metric_kind or the
         * value_type of the time series.Time series data must be aligned in order to perform cross-
         * time series reduction. If cross_series_reducer is specified, then per_series_aligner must
         * be specified and not equal to ALIGN_NONE and alignment_period must be specified;
         * otherwise, an error is returned.
         */
        @com.google.api.client.util.Key("aggregation.perSeriesAligner")
        private java.lang.String aggregationPerSeriesAligner;

        /** An Aligner describes how to bring the data points in a single time series into temporal alignment.
       Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be
       mathematically grouped together, resulting in a single data point for each alignment_period with
       end timestamp at the end of the period.Not all alignment operations may be applied to all time
       series. The valid choices depend on the metric_kind and value_type of the original time series.
       Alignment can change the metric_kind or the value_type of the time series.Time series data must be
       aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then
       per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be
       specified; otherwise, an error is returned.
         */
        public java.lang.String getAggregationPerSeriesAligner() {
          return aggregationPerSeriesAligner;
        }

        /**
         * An Aligner describes how to bring the data points in a single time series into temporal
         * alignment. Except for ALIGN_NONE, all alignments cause all the data points in an
         * alignment_period to be mathematically grouped together, resulting in a single data point
         * for each alignment_period with end timestamp at the end of the period.Not all alignment
         * operations may be applied to all time series. The valid choices depend on the metric_kind
         * and value_type of the original time series. Alignment can change the metric_kind or the
         * value_type of the time series.Time series data must be aligned in order to perform cross-
         * time series reduction. If cross_series_reducer is specified, then per_series_aligner must
         * be specified and not equal to ALIGN_NONE and alignment_period must be specified;
         * otherwise, an error is returned.
         */
        public List setAggregationPerSeriesAligner(java.lang.String aggregationPerSeriesAligner) {
          this.aggregationPerSeriesAligner = aggregationPerSeriesAligner;
          return this;
        }

        /**
         * Required. A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that
         * specifies which time series should be returned. The filter must specify a single metric
         * type, and can additionally specify metric labels and other information. For example:
         * metric.type = "compute.googleapis.com/instance/cpu/usage_time" AND
         * metric.labels.instance_name = "my-instance-name"
         */
        @com.google.api.client.util.Key
        private java.lang.String filter;

        /** Required. A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that specifies
       which time series should be returned. The filter must specify a single metric type, and can
       additionally specify metric labels and other information. For example: metric.type =
       "compute.googleapis.com/instance/cpu/usage_time" AND metric.labels.instance_name = "my-instance-
       name"
         */
        public java.lang.String getFilter() {
          return filter;
        }

        /**
         * Required. A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that
         * specifies which time series should be returned. The filter must specify a single metric
         * type, and can additionally specify metric labels and other information. For example:
         * metric.type = "compute.googleapis.com/instance/cpu/usage_time" AND
         * metric.labels.instance_name = "my-instance-name"
         */
        public List setFilter(java.lang.String filter) {
          this.filter = filter;
          return this;
        }

        /** Required. The end of the time interval. */
        @com.google.api.client.util.Key("interval.endTime")
        private String intervalEndTime;

        /** Required. The end of the time interval.
         */
        public String getIntervalEndTime() {
          return intervalEndTime;
        }

        /** Required. The end of the time interval. */
        public List setIntervalEndTime(String intervalEndTime) {
          this.intervalEndTime = intervalEndTime;
          return this;
        }

        /**
         * Optional. The beginning of the time interval. The default value for the start time is the
         * end time. The start time must not be later than the end time.
         */
        @com.google.api.client.util.Key("interval.startTime")
        private String intervalStartTime;

        /** Optional. The beginning of the time interval. The default value for the start time is the end time.
       The start time must not be later than the end time.
         */
        public String getIntervalStartTime() {
          return intervalStartTime;
        }

        /**
         * Optional. The beginning of the time interval. The default value for the start time is the
         * end time. The start time must not be later than the end time.
         */
        public List setIntervalStartTime(String intervalStartTime) {
          this.intervalStartTime = intervalStartTime;
          return this;
        }

        /**
         * Unsupported: must be left blank. The points in each time series are currently returned in
         * reverse time order (most recent to oldest).
         */
        @com.google.api.client.util.Key
        private java.lang.String orderBy;

        /** Unsupported: must be left blank. The points in each time series are currently returned in reverse
       time order (most recent to oldest).
         */
        public java.lang.String getOrderBy() {
          return orderBy;
        }

        /**
         * Unsupported: must be left blank. The points in each time series are currently returned in
         * reverse time order (most recent to oldest).
         */
        public List setOrderBy(java.lang.String orderBy) {
          this.orderBy = orderBy;
          return this;
        }

        /**
         * A positive number that is the maximum number of results to return. If page_size is empty
         * or more than 100,000 results, the effective page_size is 100,000 results. If view is set
         * to FULL, this is the maximum number of Points returned. If view is set to HEADERS, this
         * is the maximum number of TimeSeries returned.
         */
        @com.google.api.client.util.Key
        private java.lang.Integer pageSize;

        /** A positive number that is the maximum number of results to return. If page_size is empty or more
       than 100,000 results, the effective page_size is 100,000 results. If view is set to FULL, this is
       the maximum number of Points returned. If view is set to HEADERS, this is the maximum number of
       TimeSeries returned.
         */
        public java.lang.Integer getPageSize() {
          return pageSize;
        }

        /**
         * A positive number that is the maximum number of results to return. If page_size is empty
         * or more than 100,000 results, the effective page_size is 100,000 results. If view is set
         * to FULL, this is the maximum number of Points returned. If view is set to HEADERS, this
         * is the maximum number of TimeSeries returned.
         */
        public List setPageSize(java.lang.Integer pageSize) {
          this.pageSize = pageSize;
          return this;
        }

        /**
         * If this field is not empty then it must contain the nextPageToken value returned by a
         * previous call to this method. Using this field causes the method to return additional
         * results from the previous method call.
         */
        @com.google.api.client.util.Key
        private java.lang.String pageToken;

        /** If this field is not empty then it must contain the nextPageToken value returned by a previous call
       to this method. Using this field causes the method to return additional results from the previous
       method call.
         */
        public java.lang.String getPageToken() {
          return pageToken;
        }

        /**
         * If this field is not empty then it must contain the nextPageToken value returned by a
         * previous call to this method. Using this field causes the method to return additional
         * results from the previous method call.
         */
        public List setPageToken(java.lang.String pageToken) {
          this.pageToken = pageToken;
          return this;
        }

        /**
         * The alignment_period specifies a time interval, in seconds, that is used to divide the
         * data in all the time series into consistent blocks of time. This will be done before the
         * per-series aligner can be applied to the data.The value must be at least 60 seconds. If a
         * per-series aligner other than ALIGN_NONE is specified, this field is required or an error
         * is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is
         * specified, then this field is ignored.The maximum value of the alignment_period is 104
         * weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
         */
        @com.google.api.client.util.Key("secondaryAggregation.alignmentPeriod")
        private String secondaryAggregationAlignmentPeriod;

        /** The alignment_period specifies a time interval, in seconds, that is used to divide the data in all
       the time series into consistent blocks of time. This will be done before the per-series aligner can
       be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than
       ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner
       is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value
       of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for
       alerting policies.
         */
        public String getSecondaryAggregationAlignmentPeriod() {
          return secondaryAggregationAlignmentPeriod;
        }

        /**
         * The alignment_period specifies a time interval, in seconds, that is used to divide the
         * data in all the time series into consistent blocks of time. This will be done before the
         * per-series aligner can be applied to the data.The value must be at least 60 seconds. If a
         * per-series aligner other than ALIGN_NONE is specified, this field is required or an error
         * is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is
         * specified, then this field is ignored.The maximum value of the alignment_period is 104
         * weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
         */
        public List setSecondaryAggregationAlignmentPeriod(String secondaryAggregationAlignmentPeriod) {
          this.secondaryAggregationAlignmentPeriod = secondaryAggregationAlignmentPeriod;
          return this;
        }

        /**
         * The reduction operation to be used to combine time series into a single time series,
         * where the value of each data point in the resulting series is a function of all the
         * already aligned values in the input time series.Not all reducer operations can be applied
         * to all time series. The valid choices depend on the metric_kind and the value_type of the
         * original time series. Reduction can yield a time series with a different metric_kind or
         * value_type than the input time series.Time series data must first be aligned (see
         * per_series_aligner) in order to perform cross-time series reduction. If
         * cross_series_reducer is specified, then per_series_aligner must be specified, and must
         * not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is
         * returned.
         */
        @com.google.api.client.util.Key("secondaryAggregation.crossSeriesReducer")
        private java.lang.String secondaryAggregationCrossSeriesReducer;

        /** The reduction operation to be used to combine time series into a single time series, where the
       value of each data point in the resulting series is a function of all the already aligned values in
       the input time series.Not all reducer operations can be applied to all time series. The valid
       choices depend on the metric_kind and the value_type of the original time series. Reduction can
       yield a time series with a different metric_kind or value_type than the input time series.Time
       series data must first be aligned (see per_series_aligner) in order to perform cross-time series
       reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and
       must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is
       returned.
         */
        public java.lang.String getSecondaryAggregationCrossSeriesReducer() {
          return secondaryAggregationCrossSeriesReducer;
        }

        /**
         * The reduction operation to be used to combine time series into a single time series,
         * where the value of each data point in the resulting series is a function of all the
         * already aligned values in the input time series.Not all reducer operations can be applied
         * to all time series. The valid choices depend on the metric_kind and the value_type of the
         * original time series. Reduction can yield a time series with a different metric_kind or
         * value_type than the input time series.Time series data must first be aligned (see
         * per_series_aligner) in order to perform cross-time series reduction. If
         * cross_series_reducer is specified, then per_series_aligner must be specified, and must
         * not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is
         * returned.
         */
        public List setSecondaryAggregationCrossSeriesReducer(java.lang.String secondaryAggregationCrossSeriesReducer) {
          this.secondaryAggregationCrossSeriesReducer = secondaryAggregationCrossSeriesReducer;
          return this;
        }

        /**
         * The set of fields to preserve when cross_series_reducer is specified. The group_by_fields
         * determine how the time series are partitioned into subsets prior to applying the
         * aggregation operation. Each subset contains time series that have the same value for each
         * of the grouping fields. Each individual time series is a member of exactly one subset.
         * The cross_series_reducer is applied to each subset of time series. It is not possible to
         * reduce across different resource types, so this field implicitly contains resource.type.
         * Fields not specified in group_by_fields are aggregated away. If group_by_fields is not
         * specified and all the time series have the same resource type, then the time series are
         * aggregated into a single output time series. If cross_series_reducer is not defined, this
         * field is ignored.
         */
        @com.google.api.client.util.Key("secondaryAggregation.groupByFields")
        private java.util.List<java.lang.String> secondaryAggregationGroupByFields;

        /** The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine
       how the time series are partitioned into subsets prior to applying the aggregation operation. Each
       subset contains time series that have the same value for each of the grouping fields. Each
       individual time series is a member of exactly one subset. The cross_series_reducer is applied to
       each subset of time series. It is not possible to reduce across different resource types, so this
       field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated
       away. If group_by_fields is not specified and all the time series have the same resource type, then
       the time series are aggregated into a single output time series. If cross_series_reducer is not
       defined, this field is ignored.
         */
        public java.util.List<java.lang.String> getSecondaryAggregationGroupByFields() {
          return secondaryAggregationGroupByFields;
        }

        /**
         * The set of fields to preserve when cross_series_reducer is specified. The group_by_fields
         * determine how the time series are partitioned into subsets prior to applying the
         * aggregation operation. Each subset contains time series that have the same value for each
         * of the grouping fields. Each individual time series is a member of exactly one subset.
         * The cross_series_reducer is applied to each subset of time series. It is not possible to
         * reduce across different resource types, so this field implicitly contains resource.type.
         * Fields not specified in group_by_fields are aggregated away. If group_by_fields is not
         * specified and all the time series have the same resource type, then the time series are
         * aggregated into a single output time series. If cross_series_reducer is not defined, this
         * field is ignored.
         */
        public List setSecondaryAggregationGroupByFields(java.util.List<java.lang.String> secondaryAggregationGroupByFields) {
          this.secondaryAggregationGroupByFields = secondaryAggregationGroupByFields;
          return this;
        }

        /**
         * An Aligner describes how to bring the data points in a single time series into temporal
         * alignment. Except for ALIGN_NONE, all alignments cause all the data points in an
         * alignment_period to be mathematically grouped together, resulting in a single data point
         * for each alignment_period with end timestamp at the end of the period.Not all alignment
         * operations may be applied to all time series. The valid choices depend on the metric_kind
         * and value_type of the original time series. Alignment can change the metric_kind or the
         * value_type of the time series.Time series data must be aligned in order to perform cross-
         * time series reduction. If cross_series_reducer is specified, then per_series_aligner must
         * be specified and not equal to ALIGN_NONE and alignment_period must be specified;
         * otherwise, an error is returned.
         */
        @com.google.api.client.util.Key("secondaryAggregation.perSeriesAligner")
        private java.lang.String secondaryAggregationPerSeriesAligner;

        /** An Aligner describes how to bring the data points in a single time series into temporal alignment.
       Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be
       mathematically grouped together, resulting in a single data point for each alignment_period with
       end timestamp at the end of the period.Not all alignment operations may be applied to all time
       series. The valid choices depend on the metric_kind and value_type of the original time series.
       Alignment can change the metric_kind or the value_type of the time series.Time series data must be
       aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then
       per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be
       specified; otherwise, an error is returned.
         */
        public java.lang.String getSecondaryAggregationPerSeriesAligner() {
          return secondaryAggregationPerSeriesAligner;
        }

        /**
         * An Aligner describes how to bring the data points in a single time series into temporal
         * alignment. Except for ALIGN_NONE, all alignments cause all the data points in an
         * alignment_period to be mathematically grouped together, resulting in a single data point
         * for each alignment_period with end timestamp at the end of the period.Not all alignment
         * operations may be applied to all time series. The valid choices depend on the metric_kind
         * and value_type of the original time series. Alignment can change the metric_kind or the
         * value_type of the time series.Time series data must be aligned in order to perform cross-
         * time series reduction. If cross_series_reducer is specified, then per_series_aligner must
         * be specified and not equal to ALIGN_NONE and alignment_period must be specified;
         * otherwise, an error is returned.
         */
        public List setSecondaryAggregationPerSeriesAligner(java.lang.String secondaryAggregationPerSeriesAligner) {
          this.secondaryAggregationPerSeriesAligner = secondaryAggregationPerSeriesAligner;
          return this;
        }

        /** Required. Specifies which information is returned about the time series. */
        @com.google.api.client.util.Key
        private java.lang.String view;

        /** Required. Specifies which information is returned about the time series.
         */
        public java.lang.String getView() {
          return view;
        }

        /** Required. Specifies which information is returned about the time series. */
        public List setView(java.lang.String view) {
          this.view = view;
          return this;
        }

        @Override
        public List set(String parameterName, Object value) {
          return (List) super.set(parameterName, value);
        }
      }

    }
  }

  /**
   * An accessor for creating requests from the Projects collection.
   *
   * <p>The typical use is:</p>
   * <pre>
   *   {@code Monitoring monitoring = new Monitoring(...);}
   *   {@code Monitoring.Projects.List request = monitoring.projects().list(parameters ...)}
   * </pre>
   *
   * @return the resource collection
   */
  public Projects projects() {
    return new Projects();
  }

  /**
   * The "projects" collection of methods.
   */
  public class Projects {

    /**
     * An accessor for creating requests from the AlertPolicies collection.
     *
     * <p>The typical use is:</p>
     * <pre>
     *   {@code Monitoring monitoring = new Monitoring(...);}
     *   {@code Monitoring.AlertPolicies.List request = monitoring.alertPolicies().list(parameters ...)}
     * </pre>
     *
     * @return the resource collection
     */
    public AlertPolicies alertPolicies() {
      return new AlertPolicies();
    }

    /**
     * The "alertPolicies" collection of methods.
     */
    public class AlertPolicies {

      /**
       * Creates a new alerting policy.Design your application to single-thread API calls that modify the
       * state of alerting policies in a single project. This includes calls to CreateAlertPolicy,
       * DeleteAlertPolicy and UpdateAlertPolicy.
       *
       * Create a request for the method "alertPolicies.create".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Create#execute()} method to invoke the remote operation.
       *
       * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which to create
       *        the alerting policy. The format is: projects/[PROJECT_ID_OR_NUMBER] Note that this field
       *        names the parent container in which the alerting policy will be written, not the name of
       *        the created policy. |name| must be a host project of a Metrics Scope, otherwise
       *        INVALID_ARGUMENT error will return. The alerting policy that is returned will have a name
       *        that contains a normalized representation of this name as a prefix but adds a suffix of
       *        the form /alertPolicies/[ALERT_POLICY_ID], identifying the policy in the container.
       * @param content the {@link com.google.api.services.monitoring.v3.model.AlertPolicy}
       * @return the request
       */
      public Create create(java.lang.String name, com.google.api.services.monitoring.v3.model.AlertPolicy content) throws java.io.IOException {
        Create result = new Create(name, content);
        initialize(result);
        return result;
      }

      public class Create extends MonitoringRequest<com.google.api.services.monitoring.v3.model.AlertPolicy> {

        private static final String REST_PATH = "v3/{+name}/alertPolicies";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Creates a new alerting policy.Design your application to single-thread API calls that modify
         * the state of alerting policies in a single project. This includes calls to CreateAlertPolicy,
         * DeleteAlertPolicy and UpdateAlertPolicy.
         *
         * Create a request for the method "alertPolicies.create".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
         * <p> {@link
         * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which to create
       *        the alerting policy. The format is: projects/[PROJECT_ID_OR_NUMBER] Note that this field
       *        names the parent container in which the alerting policy will be written, not the name of
       *        the created policy. |name| must be a host project of a Metrics Scope, otherwise
       *        INVALID_ARGUMENT error will return. The alerting policy that is returned will have a name
       *        that contains a normalized representation of this name as a prefix but adds a suffix of
       *        the form /alertPolicies/[ALERT_POLICY_ID], identifying the policy in the container.
         * @param content the {@link com.google.api.services.monitoring.v3.model.AlertPolicy}
         * @since 1.13
         */
        protected Create(java.lang.String name, com.google.api.services.monitoring.v3.model.AlertPolicy content) {
          super(Monitoring.this, "POST", REST_PATH, content, com.google.api.services.monitoring.v3.model.AlertPolicy.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public Create set$Xgafv(java.lang.String $Xgafv) {
          return (Create) super.set$Xgafv($Xgafv);
        }

        @Override
        public Create setAccessToken(java.lang.String accessToken) {
          return (Create) super.setAccessToken(accessToken);
        }

        @Override
        public Create setAlt(java.lang.String alt) {
          return (Create) super.setAlt(alt);
        }

        @Override
        public Create setCallback(java.lang.String callback) {
          return (Create) super.setCallback(callback);
        }

        @Override
        public Create setFields(java.lang.String fields) {
          return (Create) super.setFields(fields);
        }

        @Override
        public Create setKey(java.lang.String key) {
          return (Create) super.setKey(key);
        }

        @Override
        public Create setOauthToken(java.lang.String oauthToken) {
          return (Create) super.setOauthToken(oauthToken);
        }

        @Override
        public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Create) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Create setQuotaUser(java.lang.String quotaUser) {
          return (Create) super.setQuotaUser(quotaUser);
        }

        @Override
        public Create setUploadType(java.lang.String uploadType) {
          return (Create) super.setUploadType(uploadType);
        }

        @Override
        public Create setUploadProtocol(java.lang.String uploadProtocol) {
          return (Create) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which
         * to create the alerting policy. The format is: projects/[PROJECT_ID_OR_NUMBER] Note that
         * this field names the parent container in which the alerting policy will be written, not
         * the name of the created policy. |name| must be a host project of a Metrics Scope,
         * otherwise INVALID_ARGUMENT error will return. The alerting policy that is returned will
         * have a name that contains a normalized representation of this name as a prefix but adds a
         * suffix of the form /alertPolicies/[ALERT_POLICY_ID], identifying the policy in the
         * container.
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which to create
       the alerting policy. The format is: projects/[PROJECT_ID_OR_NUMBER] Note that this field names the
       parent container in which the alerting policy will be written, not the name of the created policy.
       |name| must be a host project of a Metrics Scope, otherwise INVALID_ARGUMENT error will return. The
       alerting policy that is returned will have a name that contains a normalized representation of this
       name as a prefix but adds a suffix of the form /alertPolicies/[ALERT_POLICY_ID], identifying the
       policy in the container.
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which
         * to create the alerting policy. The format is: projects/[PROJECT_ID_OR_NUMBER] Note that
         * this field names the parent container in which the alerting policy will be written, not
         * the name of the created policy. |name| must be a host project of a Metrics Scope,
         * otherwise INVALID_ARGUMENT error will return. The alerting policy that is returned will
         * have a name that contains a normalized representation of this name as a prefix but adds a
         * suffix of the form /alertPolicies/[ALERT_POLICY_ID], identifying the policy in the
         * container.
         */
        public Create setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Create set(String parameterName, Object value) {
          return (Create) super.set(parameterName, value);
        }
      }
      /**
       * Deletes an alerting policy.Design your application to single-thread API calls that modify the
       * state of alerting policies in a single project. This includes calls to CreateAlertPolicy,
       * DeleteAlertPolicy and UpdateAlertPolicy.
       *
       * Create a request for the method "alertPolicies.delete".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
       *
       * @param name Required. The alerting policy to delete. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID] For more information, see
       *        AlertPolicy.
       * @return the request
       */
      public Delete delete(java.lang.String name) throws java.io.IOException {
        Delete result = new Delete(name);
        initialize(result);
        return result;
      }

      public class Delete extends MonitoringRequest<com.google.api.services.monitoring.v3.model.Empty> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/alertPolicies/[^/]+$");

        /**
         * Deletes an alerting policy.Design your application to single-thread API calls that modify the
         * state of alerting policies in a single project. This includes calls to CreateAlertPolicy,
         * DeleteAlertPolicy and UpdateAlertPolicy.
         *
         * Create a request for the method "alertPolicies.delete".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
         * <p> {@link
         * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The alerting policy to delete. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID] For more information, see
       *        AlertPolicy.
         * @since 1.13
         */
        protected Delete(java.lang.String name) {
          super(Monitoring.this, "DELETE", REST_PATH, null, com.google.api.services.monitoring.v3.model.Empty.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/alertPolicies/[^/]+$");
          }
        }

        @Override
        public Delete set$Xgafv(java.lang.String $Xgafv) {
          return (Delete) super.set$Xgafv($Xgafv);
        }

        @Override
        public Delete setAccessToken(java.lang.String accessToken) {
          return (Delete) super.setAccessToken(accessToken);
        }

        @Override
        public Delete setAlt(java.lang.String alt) {
          return (Delete) super.setAlt(alt);
        }

        @Override
        public Delete setCallback(java.lang.String callback) {
          return (Delete) super.setCallback(callback);
        }

        @Override
        public Delete setFields(java.lang.String fields) {
          return (Delete) super.setFields(fields);
        }

        @Override
        public Delete setKey(java.lang.String key) {
          return (Delete) super.setKey(key);
        }

        @Override
        public Delete setOauthToken(java.lang.String oauthToken) {
          return (Delete) super.setOauthToken(oauthToken);
        }

        @Override
        public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Delete) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Delete setQuotaUser(java.lang.String quotaUser) {
          return (Delete) super.setQuotaUser(quotaUser);
        }

        @Override
        public Delete setUploadType(java.lang.String uploadType) {
          return (Delete) super.setUploadType(uploadType);
        }

        @Override
        public Delete setUploadProtocol(java.lang.String uploadProtocol) {
          return (Delete) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The alerting policy to delete. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID] For more information, see
         * AlertPolicy.
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The alerting policy to delete. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID] For more information, see
       AlertPolicy.
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The alerting policy to delete. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID] For more information, see
         * AlertPolicy.
         */
        public Delete setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/alertPolicies/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Delete set(String parameterName, Object value) {
          return (Delete) super.set(parameterName, value);
        }
      }
      /**
       * Gets a single alerting policy.
       *
       * Create a request for the method "alertPolicies.get".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Get#execute()} method to invoke the remote operation.
       *
       * @param name Required. The alerting policy to retrieve. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
       * @return the request
       */
      public Get get(java.lang.String name) throws java.io.IOException {
        Get result = new Get(name);
        initialize(result);
        return result;
      }

      public class Get extends MonitoringRequest<com.google.api.services.monitoring.v3.model.AlertPolicy> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/alertPolicies/[^/]+$");

        /**
         * Gets a single alerting policy.
         *
         * Create a request for the method "alertPolicies.get".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
         * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The alerting policy to retrieve. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
         * @since 1.13
         */
        protected Get(java.lang.String name) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.AlertPolicy.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/alertPolicies/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public Get set$Xgafv(java.lang.String $Xgafv) {
          return (Get) super.set$Xgafv($Xgafv);
        }

        @Override
        public Get setAccessToken(java.lang.String accessToken) {
          return (Get) super.setAccessToken(accessToken);
        }

        @Override
        public Get setAlt(java.lang.String alt) {
          return (Get) super.setAlt(alt);
        }

        @Override
        public Get setCallback(java.lang.String callback) {
          return (Get) super.setCallback(callback);
        }

        @Override
        public Get setFields(java.lang.String fields) {
          return (Get) super.setFields(fields);
        }

        @Override
        public Get setKey(java.lang.String key) {
          return (Get) super.setKey(key);
        }

        @Override
        public Get setOauthToken(java.lang.String oauthToken) {
          return (Get) super.setOauthToken(oauthToken);
        }

        @Override
        public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Get) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Get setQuotaUser(java.lang.String quotaUser) {
          return (Get) super.setQuotaUser(quotaUser);
        }

        @Override
        public Get setUploadType(java.lang.String uploadType) {
          return (Get) super.setUploadType(uploadType);
        }

        @Override
        public Get setUploadProtocol(java.lang.String uploadProtocol) {
          return (Get) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The alerting policy to retrieve. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The alerting policy to retrieve. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The alerting policy to retrieve. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
         */
        public Get setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/alertPolicies/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Get set(String parameterName, Object value) {
          return (Get) super.set(parameterName, value);
        }
      }
      /**
       * Lists the existing alerting policies for the workspace.
       *
       * Create a request for the method "alertPolicies.list".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link List#execute()} method to invoke the remote operation.
       *
       * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose alert policies
       *        are to be listed. The format is: projects/[PROJECT_ID_OR_NUMBER] Note that this field
       *        names the parent container in which the alerting policies to be listed are stored. To
       *        retrieve a single alerting policy by name, use the GetAlertPolicy operation, instead.
       * @return the request
       */
      public List list(java.lang.String name) throws java.io.IOException {
        List result = new List(name);
        initialize(result);
        return result;
      }

      public class List extends MonitoringRequest<com.google.api.services.monitoring.v3.model.ListAlertPoliciesResponse> {

        private static final String REST_PATH = "v3/{+name}/alertPolicies";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Lists the existing alerting policies for the workspace.
         *
         * Create a request for the method "alertPolicies.list".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
         * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose alert policies
       *        are to be listed. The format is: projects/[PROJECT_ID_OR_NUMBER] Note that this field
       *        names the parent container in which the alerting policies to be listed are stored. To
       *        retrieve a single alerting policy by name, use the GetAlertPolicy operation, instead.
         * @since 1.13
         */
        protected List(java.lang.String name) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.ListAlertPoliciesResponse.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public List set$Xgafv(java.lang.String $Xgafv) {
          return (List) super.set$Xgafv($Xgafv);
        }

        @Override
        public List setAccessToken(java.lang.String accessToken) {
          return (List) super.setAccessToken(accessToken);
        }

        @Override
        public List setAlt(java.lang.String alt) {
          return (List) super.setAlt(alt);
        }

        @Override
        public List setCallback(java.lang.String callback) {
          return (List) super.setCallback(callback);
        }

        @Override
        public List setFields(java.lang.String fields) {
          return (List) super.setFields(fields);
        }

        @Override
        public List setKey(java.lang.String key) {
          return (List) super.setKey(key);
        }

        @Override
        public List setOauthToken(java.lang.String oauthToken) {
          return (List) super.setOauthToken(oauthToken);
        }

        @Override
        public List setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (List) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public List setQuotaUser(java.lang.String quotaUser) {
          return (List) super.setQuotaUser(quotaUser);
        }

        @Override
        public List setUploadType(java.lang.String uploadType) {
          return (List) super.setUploadType(uploadType);
        }

        @Override
        public List setUploadProtocol(java.lang.String uploadProtocol) {
          return (List) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose
         * alert policies are to be listed. The format is: projects/[PROJECT_ID_OR_NUMBER] Note that
         * this field names the parent container in which the alerting policies to be listed are
         * stored. To retrieve a single alerting policy by name, use the GetAlertPolicy operation,
         * instead.
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose alert
       policies are to be listed. The format is: projects/[PROJECT_ID_OR_NUMBER] Note that this field
       names the parent container in which the alerting policies to be listed are stored. To retrieve a
       single alerting policy by name, use the GetAlertPolicy operation, instead.
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose
         * alert policies are to be listed. The format is: projects/[PROJECT_ID_OR_NUMBER] Note that
         * this field names the parent container in which the alerting policies to be listed are
         * stored. To retrieve a single alerting policy by name, use the GetAlertPolicy operation,
         * instead.
         */
        public List setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /**
         * If provided, this field specifies the criteria that must be met by alert policies to be
         * included in the response.For more details, see sorting and filtering
         * (https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
         */
        @com.google.api.client.util.Key
        private java.lang.String filter;

        /** If provided, this field specifies the criteria that must be met by alert policies to be included in
       the response.For more details, see sorting and filtering
       (https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
         */
        public java.lang.String getFilter() {
          return filter;
        }

        /**
         * If provided, this field specifies the criteria that must be met by alert policies to be
         * included in the response.For more details, see sorting and filtering
         * (https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
         */
        public List setFilter(java.lang.String filter) {
          this.filter = filter;
          return this;
        }

        /**
         * A comma-separated list of fields by which to sort the result. Supports the same set of
         * field references as the filter field. Entries can be prefixed with a minus sign to sort
         * by the field in descending order.For more details, see sorting and filtering
         * (https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
         */
        @com.google.api.client.util.Key
        private java.lang.String orderBy;

        /** A comma-separated list of fields by which to sort the result. Supports the same set of field
       references as the filter field. Entries can be prefixed with a minus sign to sort by the field in
       descending order.For more details, see sorting and filtering
       (https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
         */
        public java.lang.String getOrderBy() {
          return orderBy;
        }

        /**
         * A comma-separated list of fields by which to sort the result. Supports the same set of
         * field references as the filter field. Entries can be prefixed with a minus sign to sort
         * by the field in descending order.For more details, see sorting and filtering
         * (https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
         */
        public List setOrderBy(java.lang.String orderBy) {
          this.orderBy = orderBy;
          return this;
        }

        /** The maximum number of results to return in a single response. */
        @com.google.api.client.util.Key
        private java.lang.Integer pageSize;

        /** The maximum number of results to return in a single response.
         */
        public java.lang.Integer getPageSize() {
          return pageSize;
        }

        /** The maximum number of results to return in a single response. */
        public List setPageSize(java.lang.Integer pageSize) {
          this.pageSize = pageSize;
          return this;
        }

        /**
         * If this field is not empty then it must contain the nextPageToken value returned by a
         * previous call to this method. Using this field causes the method to return more results
         * from the previous method call.
         */
        @com.google.api.client.util.Key
        private java.lang.String pageToken;

        /** If this field is not empty then it must contain the nextPageToken value returned by a previous call
       to this method. Using this field causes the method to return more results from the previous method
       call.
         */
        public java.lang.String getPageToken() {
          return pageToken;
        }

        /**
         * If this field is not empty then it must contain the nextPageToken value returned by a
         * previous call to this method. Using this field causes the method to return more results
         * from the previous method call.
         */
        public List setPageToken(java.lang.String pageToken) {
          this.pageToken = pageToken;
          return this;
        }

        @Override
        public List set(String parameterName, Object value) {
          return (List) super.set(parameterName, value);
        }
      }
      /**
       * Updates an alerting policy. You can either replace the entire policy with a new one or replace
       * only certain fields in the current alerting policy by specifying the fields to be updated via
       * updateMask. Returns the updated alerting policy.Design your application to single-thread API
       * calls that modify the state of alerting policies in a single project. This includes calls to
       * CreateAlertPolicy, DeleteAlertPolicy and UpdateAlertPolicy.
       *
       * Create a request for the method "alertPolicies.patch".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Patch#execute()} method to invoke the remote operation.
       *
       * @param name Required if the policy exists. The resource name for this policy. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID] [ALERT_POLICY_ID] is
       *        assigned by Cloud Monitoring when the policy is created. When calling the
       *        alertPolicies.create method, do not include the name field in the alerting policy passed
       *        as part of the request.
       * @param content the {@link com.google.api.services.monitoring.v3.model.AlertPolicy}
       * @return the request
       */
      public Patch patch(java.lang.String name, com.google.api.services.monitoring.v3.model.AlertPolicy content) throws java.io.IOException {
        Patch result = new Patch(name, content);
        initialize(result);
        return result;
      }

      public class Patch extends MonitoringRequest<com.google.api.services.monitoring.v3.model.AlertPolicy> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/alertPolicies/[^/]+$");

        /**
         * Updates an alerting policy. You can either replace the entire policy with a new one or replace
         * only certain fields in the current alerting policy by specifying the fields to be updated via
         * updateMask. Returns the updated alerting policy.Design your application to single-thread API
         * calls that modify the state of alerting policies in a single project. This includes calls to
         * CreateAlertPolicy, DeleteAlertPolicy and UpdateAlertPolicy.
         *
         * Create a request for the method "alertPolicies.patch".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Patch#execute()} method to invoke the remote operation.
         * <p> {@link
         * Patch#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required if the policy exists. The resource name for this policy. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID] [ALERT_POLICY_ID] is
       *        assigned by Cloud Monitoring when the policy is created. When calling the
       *        alertPolicies.create method, do not include the name field in the alerting policy passed
       *        as part of the request.
         * @param content the {@link com.google.api.services.monitoring.v3.model.AlertPolicy}
         * @since 1.13
         */
        protected Patch(java.lang.String name, com.google.api.services.monitoring.v3.model.AlertPolicy content) {
          super(Monitoring.this, "PATCH", REST_PATH, content, com.google.api.services.monitoring.v3.model.AlertPolicy.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/alertPolicies/[^/]+$");
          }
        }

        @Override
        public Patch set$Xgafv(java.lang.String $Xgafv) {
          return (Patch) super.set$Xgafv($Xgafv);
        }

        @Override
        public Patch setAccessToken(java.lang.String accessToken) {
          return (Patch) super.setAccessToken(accessToken);
        }

        @Override
        public Patch setAlt(java.lang.String alt) {
          return (Patch) super.setAlt(alt);
        }

        @Override
        public Patch setCallback(java.lang.String callback) {
          return (Patch) super.setCallback(callback);
        }

        @Override
        public Patch setFields(java.lang.String fields) {
          return (Patch) super.setFields(fields);
        }

        @Override
        public Patch setKey(java.lang.String key) {
          return (Patch) super.setKey(key);
        }

        @Override
        public Patch setOauthToken(java.lang.String oauthToken) {
          return (Patch) super.setOauthToken(oauthToken);
        }

        @Override
        public Patch setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Patch) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Patch setQuotaUser(java.lang.String quotaUser) {
          return (Patch) super.setQuotaUser(quotaUser);
        }

        @Override
        public Patch setUploadType(java.lang.String uploadType) {
          return (Patch) super.setUploadType(uploadType);
        }

        @Override
        public Patch setUploadProtocol(java.lang.String uploadProtocol) {
          return (Patch) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required if the policy exists. The resource name for this policy. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID] [ALERT_POLICY_ID] is
         * assigned by Cloud Monitoring when the policy is created. When calling the
         * alertPolicies.create method, do not include the name field in the alerting policy passed
         * as part of the request.
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required if the policy exists. The resource name for this policy. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID] [ALERT_POLICY_ID] is assigned by
       Cloud Monitoring when the policy is created. When calling the alertPolicies.create method, do not
       include the name field in the alerting policy passed as part of the request.
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required if the policy exists. The resource name for this policy. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID] [ALERT_POLICY_ID] is
         * assigned by Cloud Monitoring when the policy is created. When calling the
         * alertPolicies.create method, do not include the name field in the alerting policy passed
         * as part of the request.
         */
        public Patch setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/alertPolicies/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /**
         * Optional. A list of alerting policy field names. If this field is not empty, each listed
         * field in the existing alerting policy is set to the value of the corresponding field in
         * the supplied policy (alert_policy), or to the field's default value if the field is not
         * in the supplied alerting policy. Fields not listed retain their previous value.Examples
         * of valid field masks include display_name, documentation, documentation.content,
         * documentation.mime_type, user_labels, user_label.nameofkey, enabled, conditions,
         * combiner, etc.If this field is empty, then the supplied alerting policy replaces the
         * existing policy. It is the same as deleting the existing policy and adding the supplied
         * policy, except for the following: The new policy will have the same [ALERT_POLICY_ID] as
         * the former policy. This gives you continuity with the former policy in your notifications
         * and incidents. Conditions in the new policy will keep their former [CONDITION_ID] if the
         * supplied condition includes the name field with that [CONDITION_ID]. If the supplied
         * condition omits the name field, then a new [CONDITION_ID] is created.
         */
        @com.google.api.client.util.Key
        private String updateMask;

        /** Optional. A list of alerting policy field names. If this field is not empty, each listed field in
       the existing alerting policy is set to the value of the corresponding field in the supplied policy
       (alert_policy), or to the field's default value if the field is not in the supplied alerting
       policy. Fields not listed retain their previous value.Examples of valid field masks include
       display_name, documentation, documentation.content, documentation.mime_type, user_labels,
       user_label.nameofkey, enabled, conditions, combiner, etc.If this field is empty, then the supplied
       alerting policy replaces the existing policy. It is the same as deleting the existing policy and
       adding the supplied policy, except for the following: The new policy will have the same
       [ALERT_POLICY_ID] as the former policy. This gives you continuity with the former policy in your
       notifications and incidents. Conditions in the new policy will keep their former [CONDITION_ID] if
       the supplied condition includes the name field with that [CONDITION_ID]. If the supplied condition
       omits the name field, then a new [CONDITION_ID] is created.
         */
        public String getUpdateMask() {
          return updateMask;
        }

        /**
         * Optional. A list of alerting policy field names. If this field is not empty, each listed
         * field in the existing alerting policy is set to the value of the corresponding field in
         * the supplied policy (alert_policy), or to the field's default value if the field is not
         * in the supplied alerting policy. Fields not listed retain their previous value.Examples
         * of valid field masks include display_name, documentation, documentation.content,
         * documentation.mime_type, user_labels, user_label.nameofkey, enabled, conditions,
         * combiner, etc.If this field is empty, then the supplied alerting policy replaces the
         * existing policy. It is the same as deleting the existing policy and adding the supplied
         * policy, except for the following: The new policy will have the same [ALERT_POLICY_ID] as
         * the former policy. This gives you continuity with the former policy in your notifications
         * and incidents. Conditions in the new policy will keep their former [CONDITION_ID] if the
         * supplied condition includes the name field with that [CONDITION_ID]. If the supplied
         * condition omits the name field, then a new [CONDITION_ID] is created.
         */
        public Patch setUpdateMask(String updateMask) {
          this.updateMask = updateMask;
          return this;
        }

        @Override
        public Patch set(String parameterName, Object value) {
          return (Patch) super.set(parameterName, value);
        }
      }

    }
    /**
     * An accessor for creating requests from the CollectdTimeSeries collection.
     *
     * <p>The typical use is:</p>
     * <pre>
     *   {@code Monitoring monitoring = new Monitoring(...);}
     *   {@code Monitoring.CollectdTimeSeries.List request = monitoring.collectdTimeSeries().list(parameters ...)}
     * </pre>
     *
     * @return the resource collection
     */
    public CollectdTimeSeries collectdTimeSeries() {
      return new CollectdTimeSeries();
    }

    /**
     * The "collectdTimeSeries" collection of methods.
     */
    public class CollectdTimeSeries {

      /**
       * Cloud Monitoring Agent only: Creates a new time series.This method is only for use by the Cloud
       * Monitoring Agent. Use projects.timeSeries.create instead.
       *
       * Create a request for the method "collectdTimeSeries.create".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Create#execute()} method to invoke the remote operation.
       *
       * @param name The project (https://cloud.google.com/monitoring/api/v3#project_name) in which to create the time
       *        series. The format is: projects/[PROJECT_ID_OR_NUMBER]
       * @param content the {@link com.google.api.services.monitoring.v3.model.CreateCollectdTimeSeriesRequest}
       * @return the request
       */
      public Create create(java.lang.String name, com.google.api.services.monitoring.v3.model.CreateCollectdTimeSeriesRequest content) throws java.io.IOException {
        Create result = new Create(name, content);
        initialize(result);
        return result;
      }

      public class Create extends MonitoringRequest<com.google.api.services.monitoring.v3.model.CreateCollectdTimeSeriesResponse> {

        private static final String REST_PATH = "v3/{+name}/collectdTimeSeries";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Cloud Monitoring Agent only: Creates a new time series.This method is only for use by the Cloud
         * Monitoring Agent. Use projects.timeSeries.create instead.
         *
         * Create a request for the method "collectdTimeSeries.create".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
         * <p> {@link
         * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name The project (https://cloud.google.com/monitoring/api/v3#project_name) in which to create the time
       *        series. The format is: projects/[PROJECT_ID_OR_NUMBER]
         * @param content the {@link com.google.api.services.monitoring.v3.model.CreateCollectdTimeSeriesRequest}
         * @since 1.13
         */
        protected Create(java.lang.String name, com.google.api.services.monitoring.v3.model.CreateCollectdTimeSeriesRequest content) {
          super(Monitoring.this, "POST", REST_PATH, content, com.google.api.services.monitoring.v3.model.CreateCollectdTimeSeriesResponse.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public Create set$Xgafv(java.lang.String $Xgafv) {
          return (Create) super.set$Xgafv($Xgafv);
        }

        @Override
        public Create setAccessToken(java.lang.String accessToken) {
          return (Create) super.setAccessToken(accessToken);
        }

        @Override
        public Create setAlt(java.lang.String alt) {
          return (Create) super.setAlt(alt);
        }

        @Override
        public Create setCallback(java.lang.String callback) {
          return (Create) super.setCallback(callback);
        }

        @Override
        public Create setFields(java.lang.String fields) {
          return (Create) super.setFields(fields);
        }

        @Override
        public Create setKey(java.lang.String key) {
          return (Create) super.setKey(key);
        }

        @Override
        public Create setOauthToken(java.lang.String oauthToken) {
          return (Create) super.setOauthToken(oauthToken);
        }

        @Override
        public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Create) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Create setQuotaUser(java.lang.String quotaUser) {
          return (Create) super.setQuotaUser(quotaUser);
        }

        @Override
        public Create setUploadType(java.lang.String uploadType) {
          return (Create) super.setUploadType(uploadType);
        }

        @Override
        public Create setUploadProtocol(java.lang.String uploadProtocol) {
          return (Create) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * The project (https://cloud.google.com/monitoring/api/v3#project_name) in which to create
         * the time series. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** The project (https://cloud.google.com/monitoring/api/v3#project_name) in which to create the time
       series. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * The project (https://cloud.google.com/monitoring/api/v3#project_name) in which to create
         * the time series. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public Create setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Create set(String parameterName, Object value) {
          return (Create) super.set(parameterName, value);
        }
      }

    }
    /**
     * An accessor for creating requests from the Groups collection.
     *
     * <p>The typical use is:</p>
     * <pre>
     *   {@code Monitoring monitoring = new Monitoring(...);}
     *   {@code Monitoring.Groups.List request = monitoring.groups().list(parameters ...)}
     * </pre>
     *
     * @return the resource collection
     */
    public Groups groups() {
      return new Groups();
    }

    /**
     * The "groups" collection of methods.
     */
    public class Groups {

      /**
       * Creates a new group.
       *
       * Create a request for the method "groups.create".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Create#execute()} method to invoke the remote operation.
       *
       * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which to create
       *        the group. The format is: projects/[PROJECT_ID_OR_NUMBER]
       * @param content the {@link com.google.api.services.monitoring.v3.model.Group}
       * @return the request
       */
      public Create create(java.lang.String name, com.google.api.services.monitoring.v3.model.Group content) throws java.io.IOException {
        Create result = new Create(name, content);
        initialize(result);
        return result;
      }

      public class Create extends MonitoringRequest<com.google.api.services.monitoring.v3.model.Group> {

        private static final String REST_PATH = "v3/{+name}/groups";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Creates a new group.
         *
         * Create a request for the method "groups.create".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
         * <p> {@link
         * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which to create
       *        the group. The format is: projects/[PROJECT_ID_OR_NUMBER]
         * @param content the {@link com.google.api.services.monitoring.v3.model.Group}
         * @since 1.13
         */
        protected Create(java.lang.String name, com.google.api.services.monitoring.v3.model.Group content) {
          super(Monitoring.this, "POST", REST_PATH, content, com.google.api.services.monitoring.v3.model.Group.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public Create set$Xgafv(java.lang.String $Xgafv) {
          return (Create) super.set$Xgafv($Xgafv);
        }

        @Override
        public Create setAccessToken(java.lang.String accessToken) {
          return (Create) super.setAccessToken(accessToken);
        }

        @Override
        public Create setAlt(java.lang.String alt) {
          return (Create) super.setAlt(alt);
        }

        @Override
        public Create setCallback(java.lang.String callback) {
          return (Create) super.setCallback(callback);
        }

        @Override
        public Create setFields(java.lang.String fields) {
          return (Create) super.setFields(fields);
        }

        @Override
        public Create setKey(java.lang.String key) {
          return (Create) super.setKey(key);
        }

        @Override
        public Create setOauthToken(java.lang.String oauthToken) {
          return (Create) super.setOauthToken(oauthToken);
        }

        @Override
        public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Create) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Create setQuotaUser(java.lang.String quotaUser) {
          return (Create) super.setQuotaUser(quotaUser);
        }

        @Override
        public Create setUploadType(java.lang.String uploadType) {
          return (Create) super.setUploadType(uploadType);
        }

        @Override
        public Create setUploadProtocol(java.lang.String uploadProtocol) {
          return (Create) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which
         * to create the group. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which to create
       the group. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which
         * to create the group. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public Create setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /** If true, validate this request but do not create the group. */
        @com.google.api.client.util.Key
        private java.lang.Boolean validateOnly;

        /** If true, validate this request but do not create the group.
         */
        public java.lang.Boolean getValidateOnly() {
          return validateOnly;
        }

        /** If true, validate this request but do not create the group. */
        public Create setValidateOnly(java.lang.Boolean validateOnly) {
          this.validateOnly = validateOnly;
          return this;
        }

        @Override
        public Create set(String parameterName, Object value) {
          return (Create) super.set(parameterName, value);
        }
      }
      /**
       * Deletes an existing group.
       *
       * Create a request for the method "groups.delete".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
       *
       * @param name Required. The group to delete. The format is: projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
       * @return the request
       */
      public Delete delete(java.lang.String name) throws java.io.IOException {
        Delete result = new Delete(name);
        initialize(result);
        return result;
      }

      public class Delete extends MonitoringRequest<com.google.api.services.monitoring.v3.model.Empty> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/groups/[^/]+$");

        /**
         * Deletes an existing group.
         *
         * Create a request for the method "groups.delete".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
         * <p> {@link
         * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The group to delete. The format is: projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
         * @since 1.13
         */
        protected Delete(java.lang.String name) {
          super(Monitoring.this, "DELETE", REST_PATH, null, com.google.api.services.monitoring.v3.model.Empty.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/groups/[^/]+$");
          }
        }

        @Override
        public Delete set$Xgafv(java.lang.String $Xgafv) {
          return (Delete) super.set$Xgafv($Xgafv);
        }

        @Override
        public Delete setAccessToken(java.lang.String accessToken) {
          return (Delete) super.setAccessToken(accessToken);
        }

        @Override
        public Delete setAlt(java.lang.String alt) {
          return (Delete) super.setAlt(alt);
        }

        @Override
        public Delete setCallback(java.lang.String callback) {
          return (Delete) super.setCallback(callback);
        }

        @Override
        public Delete setFields(java.lang.String fields) {
          return (Delete) super.setFields(fields);
        }

        @Override
        public Delete setKey(java.lang.String key) {
          return (Delete) super.setKey(key);
        }

        @Override
        public Delete setOauthToken(java.lang.String oauthToken) {
          return (Delete) super.setOauthToken(oauthToken);
        }

        @Override
        public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Delete) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Delete setQuotaUser(java.lang.String quotaUser) {
          return (Delete) super.setQuotaUser(quotaUser);
        }

        @Override
        public Delete setUploadType(java.lang.String uploadType) {
          return (Delete) super.setUploadType(uploadType);
        }

        @Override
        public Delete setUploadProtocol(java.lang.String uploadProtocol) {
          return (Delete) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The group to delete. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The group to delete. The format is: projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The group to delete. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
         */
        public Delete setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/groups/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /**
         * If this field is true, then the request means to delete a group with all its descendants.
         * Otherwise, the request means to delete a group only when it has no descendants. The
         * default value is false.
         */
        @com.google.api.client.util.Key
        private java.lang.Boolean recursive;

        /** If this field is true, then the request means to delete a group with all its descendants.
       Otherwise, the request means to delete a group only when it has no descendants. The default value
       is false.
         */
        public java.lang.Boolean getRecursive() {
          return recursive;
        }

        /**
         * If this field is true, then the request means to delete a group with all its descendants.
         * Otherwise, the request means to delete a group only when it has no descendants. The
         * default value is false.
         */
        public Delete setRecursive(java.lang.Boolean recursive) {
          this.recursive = recursive;
          return this;
        }

        @Override
        public Delete set(String parameterName, Object value) {
          return (Delete) super.set(parameterName, value);
        }
      }
      /**
       * Gets a single group.
       *
       * Create a request for the method "groups.get".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Get#execute()} method to invoke the remote operation.
       *
       * @param name Required. The group to retrieve. The format is: projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
       * @return the request
       */
      public Get get(java.lang.String name) throws java.io.IOException {
        Get result = new Get(name);
        initialize(result);
        return result;
      }

      public class Get extends MonitoringRequest<com.google.api.services.monitoring.v3.model.Group> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/groups/[^/]+$");

        /**
         * Gets a single group.
         *
         * Create a request for the method "groups.get".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
         * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The group to retrieve. The format is: projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
         * @since 1.13
         */
        protected Get(java.lang.String name) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.Group.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/groups/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public Get set$Xgafv(java.lang.String $Xgafv) {
          return (Get) super.set$Xgafv($Xgafv);
        }

        @Override
        public Get setAccessToken(java.lang.String accessToken) {
          return (Get) super.setAccessToken(accessToken);
        }

        @Override
        public Get setAlt(java.lang.String alt) {
          return (Get) super.setAlt(alt);
        }

        @Override
        public Get setCallback(java.lang.String callback) {
          return (Get) super.setCallback(callback);
        }

        @Override
        public Get setFields(java.lang.String fields) {
          return (Get) super.setFields(fields);
        }

        @Override
        public Get setKey(java.lang.String key) {
          return (Get) super.setKey(key);
        }

        @Override
        public Get setOauthToken(java.lang.String oauthToken) {
          return (Get) super.setOauthToken(oauthToken);
        }

        @Override
        public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Get) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Get setQuotaUser(java.lang.String quotaUser) {
          return (Get) super.setQuotaUser(quotaUser);
        }

        @Override
        public Get setUploadType(java.lang.String uploadType) {
          return (Get) super.setUploadType(uploadType);
        }

        @Override
        public Get setUploadProtocol(java.lang.String uploadProtocol) {
          return (Get) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The group to retrieve. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The group to retrieve. The format is: projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The group to retrieve. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
         */
        public Get setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/groups/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Get set(String parameterName, Object value) {
          return (Get) super.set(parameterName, value);
        }
      }
      /**
       * Lists the existing groups.
       *
       * Create a request for the method "groups.list".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link List#execute()} method to invoke the remote operation.
       *
       * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose groups are to
       *        be listed. The format is: projects/[PROJECT_ID_OR_NUMBER]
       * @return the request
       */
      public List list(java.lang.String name) throws java.io.IOException {
        List result = new List(name);
        initialize(result);
        return result;
      }

      public class List extends MonitoringRequest<com.google.api.services.monitoring.v3.model.ListGroupsResponse> {

        private static final String REST_PATH = "v3/{+name}/groups";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Lists the existing groups.
         *
         * Create a request for the method "groups.list".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
         * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose groups are to
       *        be listed. The format is: projects/[PROJECT_ID_OR_NUMBER]
         * @since 1.13
         */
        protected List(java.lang.String name) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.ListGroupsResponse.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public List set$Xgafv(java.lang.String $Xgafv) {
          return (List) super.set$Xgafv($Xgafv);
        }

        @Override
        public List setAccessToken(java.lang.String accessToken) {
          return (List) super.setAccessToken(accessToken);
        }

        @Override
        public List setAlt(java.lang.String alt) {
          return (List) super.setAlt(alt);
        }

        @Override
        public List setCallback(java.lang.String callback) {
          return (List) super.setCallback(callback);
        }

        @Override
        public List setFields(java.lang.String fields) {
          return (List) super.setFields(fields);
        }

        @Override
        public List setKey(java.lang.String key) {
          return (List) super.setKey(key);
        }

        @Override
        public List setOauthToken(java.lang.String oauthToken) {
          return (List) super.setOauthToken(oauthToken);
        }

        @Override
        public List setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (List) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public List setQuotaUser(java.lang.String quotaUser) {
          return (List) super.setQuotaUser(quotaUser);
        }

        @Override
        public List setUploadType(java.lang.String uploadType) {
          return (List) super.setUploadType(uploadType);
        }

        @Override
        public List setUploadProtocol(java.lang.String uploadProtocol) {
          return (List) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose
         * groups are to be listed. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose groups are to
       be listed. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose
         * groups are to be listed. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public List setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /**
         * A group name. The format is: projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID] Returns
         * groups that are ancestors of the specified group. The groups are returned in order,
         * starting with the immediate parent and ending with the most distant ancestor. If the
         * specified group has no immediate parent, the results are empty.
         */
        @com.google.api.client.util.Key
        private java.lang.String ancestorsOfGroup;

        /** A group name. The format is: projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID] Returns groups that
       are ancestors of the specified group. The groups are returned in order, starting with the immediate
       parent and ending with the most distant ancestor. If the specified group has no immediate parent,
       the results are empty.
         */
        public java.lang.String getAncestorsOfGroup() {
          return ancestorsOfGroup;
        }

        /**
         * A group name. The format is: projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID] Returns
         * groups that are ancestors of the specified group. The groups are returned in order,
         * starting with the immediate parent and ending with the most distant ancestor. If the
         * specified group has no immediate parent, the results are empty.
         */
        public List setAncestorsOfGroup(java.lang.String ancestorsOfGroup) {
          this.ancestorsOfGroup = ancestorsOfGroup;
          return this;
        }

        /**
         * A group name. The format is: projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID] Returns
         * groups whose parent_name field contains the group name. If no groups have this parent,
         * the results are empty.
         */
        @com.google.api.client.util.Key
        private java.lang.String childrenOfGroup;

        /** A group name. The format is: projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID] Returns groups whose
       parent_name field contains the group name. If no groups have this parent, the results are empty.
         */
        public java.lang.String getChildrenOfGroup() {
          return childrenOfGroup;
        }

        /**
         * A group name. The format is: projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID] Returns
         * groups whose parent_name field contains the group name. If no groups have this parent,
         * the results are empty.
         */
        public List setChildrenOfGroup(java.lang.String childrenOfGroup) {
          this.childrenOfGroup = childrenOfGroup;
          return this;
        }

        /**
         * A group name. The format is: projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID] Returns
         * the descendants of the specified group. This is a superset of the results returned by the
         * children_of_group filter, and includes children-of-children, and so forth.
         */
        @com.google.api.client.util.Key
        private java.lang.String descendantsOfGroup;

        /** A group name. The format is: projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID] Returns the
       descendants of the specified group. This is a superset of the results returned by the
       children_of_group filter, and includes children-of-children, and so forth.
         */
        public java.lang.String getDescendantsOfGroup() {
          return descendantsOfGroup;
        }

        /**
         * A group name. The format is: projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID] Returns
         * the descendants of the specified group. This is a superset of the results returned by the
         * children_of_group filter, and includes children-of-children, and so forth.
         */
        public List setDescendantsOfGroup(java.lang.String descendantsOfGroup) {
          this.descendantsOfGroup = descendantsOfGroup;
          return this;
        }

        /** A positive number that is the maximum number of results to return. */
        @com.google.api.client.util.Key
        private java.lang.Integer pageSize;

        /** A positive number that is the maximum number of results to return.
         */
        public java.lang.Integer getPageSize() {
          return pageSize;
        }

        /** A positive number that is the maximum number of results to return. */
        public List setPageSize(java.lang.Integer pageSize) {
          this.pageSize = pageSize;
          return this;
        }

        /**
         * If this field is not empty then it must contain the next_page_token value returned by a
         * previous call to this method. Using this field causes the method to return additional
         * results from the previous method call.
         */
        @com.google.api.client.util.Key
        private java.lang.String pageToken;

        /** If this field is not empty then it must contain the next_page_token value returned by a previous
       call to this method. Using this field causes the method to return additional results from the
       previous method call.
         */
        public java.lang.String getPageToken() {
          return pageToken;
        }

        /**
         * If this field is not empty then it must contain the next_page_token value returned by a
         * previous call to this method. Using this field causes the method to return additional
         * results from the previous method call.
         */
        public List setPageToken(java.lang.String pageToken) {
          this.pageToken = pageToken;
          return this;
        }

        @Override
        public List set(String parameterName, Object value) {
          return (List) super.set(parameterName, value);
        }
      }
      /**
       * Updates an existing group. You can change any group attributes except name.
       *
       * Create a request for the method "groups.update".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Update#execute()} method to invoke the remote operation.
       *
       * @param name Output only. The name of this group. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID] When creating a group, this field is
       *        ignored and a new name is created consisting of the project specified in the call to
       *        CreateGroup and a unique [GROUP_ID] that is generated automatically.
       * @param content the {@link com.google.api.services.monitoring.v3.model.Group}
       * @return the request
       */
      public Update update(java.lang.String name, com.google.api.services.monitoring.v3.model.Group content) throws java.io.IOException {
        Update result = new Update(name, content);
        initialize(result);
        return result;
      }

      public class Update extends MonitoringRequest<com.google.api.services.monitoring.v3.model.Group> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/groups/[^/]+$");

        /**
         * Updates an existing group. You can change any group attributes except name.
         *
         * Create a request for the method "groups.update".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Update#execute()} method to invoke the remote operation.
         * <p> {@link
         * Update#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Output only. The name of this group. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID] When creating a group, this field is
       *        ignored and a new name is created consisting of the project specified in the call to
       *        CreateGroup and a unique [GROUP_ID] that is generated automatically.
         * @param content the {@link com.google.api.services.monitoring.v3.model.Group}
         * @since 1.13
         */
        protected Update(java.lang.String name, com.google.api.services.monitoring.v3.model.Group content) {
          super(Monitoring.this, "PUT", REST_PATH, content, com.google.api.services.monitoring.v3.model.Group.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/groups/[^/]+$");
          }
        }

        @Override
        public Update set$Xgafv(java.lang.String $Xgafv) {
          return (Update) super.set$Xgafv($Xgafv);
        }

        @Override
        public Update setAccessToken(java.lang.String accessToken) {
          return (Update) super.setAccessToken(accessToken);
        }

        @Override
        public Update setAlt(java.lang.String alt) {
          return (Update) super.setAlt(alt);
        }

        @Override
        public Update setCallback(java.lang.String callback) {
          return (Update) super.setCallback(callback);
        }

        @Override
        public Update setFields(java.lang.String fields) {
          return (Update) super.setFields(fields);
        }

        @Override
        public Update setKey(java.lang.String key) {
          return (Update) super.setKey(key);
        }

        @Override
        public Update setOauthToken(java.lang.String oauthToken) {
          return (Update) super.setOauthToken(oauthToken);
        }

        @Override
        public Update setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Update) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Update setQuotaUser(java.lang.String quotaUser) {
          return (Update) super.setQuotaUser(quotaUser);
        }

        @Override
        public Update setUploadType(java.lang.String uploadType) {
          return (Update) super.setUploadType(uploadType);
        }

        @Override
        public Update setUploadProtocol(java.lang.String uploadProtocol) {
          return (Update) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Output only. The name of this group. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID] When creating a group, this field is
         * ignored and a new name is created consisting of the project specified in the call to
         * CreateGroup and a unique [GROUP_ID] that is generated automatically.
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Output only. The name of this group. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID] When creating a group, this field is ignored and
       a new name is created consisting of the project specified in the call to CreateGroup and a unique
       [GROUP_ID] that is generated automatically.
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Output only. The name of this group. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID] When creating a group, this field is
         * ignored and a new name is created consisting of the project specified in the call to
         * CreateGroup and a unique [GROUP_ID] that is generated automatically.
         */
        public Update setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/groups/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /** If true, validate this request but do not update the existing group. */
        @com.google.api.client.util.Key
        private java.lang.Boolean validateOnly;

        /** If true, validate this request but do not update the existing group.
         */
        public java.lang.Boolean getValidateOnly() {
          return validateOnly;
        }

        /** If true, validate this request but do not update the existing group. */
        public Update setValidateOnly(java.lang.Boolean validateOnly) {
          this.validateOnly = validateOnly;
          return this;
        }

        @Override
        public Update set(String parameterName, Object value) {
          return (Update) super.set(parameterName, value);
        }
      }

      /**
       * An accessor for creating requests from the Members collection.
       *
       * <p>The typical use is:</p>
       * <pre>
       *   {@code Monitoring monitoring = new Monitoring(...);}
       *   {@code Monitoring.Members.List request = monitoring.members().list(parameters ...)}
       * </pre>
       *
       * @return the resource collection
       */
      public Members members() {
        return new Members();
      }

      /**
       * The "members" collection of methods.
       */
      public class Members {

        /**
         * Lists the monitored resources that are members of a group.
         *
         * Create a request for the method "members.list".
         *
         * This request holds the parameters needed by the monitoring server.  After setting any optional
         * parameters, call the {@link List#execute()} method to invoke the remote operation.
         *
         * @param name Required. The group whose members are listed. The format is:
         *        projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
         * @return the request
         */
        public List list(java.lang.String name) throws java.io.IOException {
          List result = new List(name);
          initialize(result);
          return result;
        }

        public class List extends MonitoringRequest<com.google.api.services.monitoring.v3.model.ListGroupMembersResponse> {

          private static final String REST_PATH = "v3/{+name}/members";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/groups/[^/]+$");

          /**
           * Lists the monitored resources that are members of a group.
           *
           * Create a request for the method "members.list".
           *
           * This request holds the parameters needed by the the monitoring server.  After setting any
           * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
           * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
           * must be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name Required. The group whose members are listed. The format is:
         *        projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
           * @since 1.13
           */
          protected List(java.lang.String name) {
            super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.ListGroupMembersResponse.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/groups/[^/]+$");
            }
          }

          @Override
          public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
            return super.executeUsingHead();
          }

          @Override
          public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
            return super.buildHttpRequestUsingHead();
          }

          @Override
          public List set$Xgafv(java.lang.String $Xgafv) {
            return (List) super.set$Xgafv($Xgafv);
          }

          @Override
          public List setAccessToken(java.lang.String accessToken) {
            return (List) super.setAccessToken(accessToken);
          }

          @Override
          public List setAlt(java.lang.String alt) {
            return (List) super.setAlt(alt);
          }

          @Override
          public List setCallback(java.lang.String callback) {
            return (List) super.setCallback(callback);
          }

          @Override
          public List setFields(java.lang.String fields) {
            return (List) super.setFields(fields);
          }

          @Override
          public List setKey(java.lang.String key) {
            return (List) super.setKey(key);
          }

          @Override
          public List setOauthToken(java.lang.String oauthToken) {
            return (List) super.setOauthToken(oauthToken);
          }

          @Override
          public List setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (List) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public List setQuotaUser(java.lang.String quotaUser) {
            return (List) super.setQuotaUser(quotaUser);
          }

          @Override
          public List setUploadType(java.lang.String uploadType) {
            return (List) super.setUploadType(uploadType);
          }

          @Override
          public List setUploadProtocol(java.lang.String uploadProtocol) {
            return (List) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Required. The group whose members are listed. The format is:
           * projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
           */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** Required. The group whose members are listed. The format is:
         projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
           */
          public java.lang.String getName() {
            return name;
          }

          /**
           * Required. The group whose members are listed. The format is:
           * projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
           */
          public List setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/groups/[^/]+$");
            }
            this.name = name;
            return this;
          }

          /**
           * An optional list filter (https://cloud.google.com/monitoring/api/learn_more#filtering)
           * describing the members to be returned. The filter may reference the type, labels, and
           * metadata of monitored resources that comprise the group. For example, to return only
           * resources representing Compute Engine VM instances, use this filter: `resource.type =
           * "gce_instance"`
           */
          @com.google.api.client.util.Key
          private java.lang.String filter;

          /** An optional list filter (https://cloud.google.com/monitoring/api/learn_more#filtering) describing
         the members to be returned. The filter may reference the type, labels, and metadata of monitored
         resources that comprise the group. For example, to return only resources representing Compute
         Engine VM instances, use this filter: `resource.type = "gce_instance"`
           */
          public java.lang.String getFilter() {
            return filter;
          }

          /**
           * An optional list filter (https://cloud.google.com/monitoring/api/learn_more#filtering)
           * describing the members to be returned. The filter may reference the type, labels, and
           * metadata of monitored resources that comprise the group. For example, to return only
           * resources representing Compute Engine VM instances, use this filter: `resource.type =
           * "gce_instance"`
           */
          public List setFilter(java.lang.String filter) {
            this.filter = filter;
            return this;
          }

          /** Required. The end of the time interval. */
          @com.google.api.client.util.Key("interval.endTime")
          private String intervalEndTime;

          /** Required. The end of the time interval.
           */
          public String getIntervalEndTime() {
            return intervalEndTime;
          }

          /** Required. The end of the time interval. */
          public List setIntervalEndTime(String intervalEndTime) {
            this.intervalEndTime = intervalEndTime;
            return this;
          }

          /**
           * Optional. The beginning of the time interval. The default value for the start time is
           * the end time. The start time must not be later than the end time.
           */
          @com.google.api.client.util.Key("interval.startTime")
          private String intervalStartTime;

          /** Optional. The beginning of the time interval. The default value for the start time is the end time.
         The start time must not be later than the end time.
           */
          public String getIntervalStartTime() {
            return intervalStartTime;
          }

          /**
           * Optional. The beginning of the time interval. The default value for the start time is
           * the end time. The start time must not be later than the end time.
           */
          public List setIntervalStartTime(String intervalStartTime) {
            this.intervalStartTime = intervalStartTime;
            return this;
          }

          /** A positive number that is the maximum number of results to return. */
          @com.google.api.client.util.Key
          private java.lang.Integer pageSize;

          /** A positive number that is the maximum number of results to return.
           */
          public java.lang.Integer getPageSize() {
            return pageSize;
          }

          /** A positive number that is the maximum number of results to return. */
          public List setPageSize(java.lang.Integer pageSize) {
            this.pageSize = pageSize;
            return this;
          }

          /**
           * If this field is not empty then it must contain the next_page_token value returned by a
           * previous call to this method. Using this field causes the method to return additional
           * results from the previous method call.
           */
          @com.google.api.client.util.Key
          private java.lang.String pageToken;

          /** If this field is not empty then it must contain the next_page_token value returned by a previous
         call to this method. Using this field causes the method to return additional results from the
         previous method call.
           */
          public java.lang.String getPageToken() {
            return pageToken;
          }

          /**
           * If this field is not empty then it must contain the next_page_token value returned by a
           * previous call to this method. Using this field causes the method to return additional
           * results from the previous method call.
           */
          public List setPageToken(java.lang.String pageToken) {
            this.pageToken = pageToken;
            return this;
          }

          @Override
          public List set(String parameterName, Object value) {
            return (List) super.set(parameterName, value);
          }
        }

      }
    }
    /**
     * An accessor for creating requests from the MetricDescriptors collection.
     *
     * <p>The typical use is:</p>
     * <pre>
     *   {@code Monitoring monitoring = new Monitoring(...);}
     *   {@code Monitoring.MetricDescriptors.List request = monitoring.metricDescriptors().list(parameters ...)}
     * </pre>
     *
     * @return the resource collection
     */
    public MetricDescriptors metricDescriptors() {
      return new MetricDescriptors();
    }

    /**
     * The "metricDescriptors" collection of methods.
     */
    public class MetricDescriptors {

      /**
       * Creates a new metric descriptor. The creation is executed asynchronously. User-created metric
       * descriptors define custom metrics (https://cloud.google.com/monitoring/custom-metrics). The
       * metric descriptor is updated if it already exists, except that metric labels are never removed.
       *
       * Create a request for the method "metricDescriptors.create".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Create#execute()} method to invoke the remote operation.
       *
       * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       *        the request. The format is: 4 projects/PROJECT_ID_OR_NUMBER
       * @param content the {@link com.google.api.services.monitoring.v3.model.MetricDescriptor}
       * @return the request
       */
      public Create create(java.lang.String name, com.google.api.services.monitoring.v3.model.MetricDescriptor content) throws java.io.IOException {
        Create result = new Create(name, content);
        initialize(result);
        return result;
      }

      public class Create extends MonitoringRequest<com.google.api.services.monitoring.v3.model.MetricDescriptor> {

        private static final String REST_PATH = "v3/{+name}/metricDescriptors";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Creates a new metric descriptor. The creation is executed asynchronously. User-created metric
         * descriptors define custom metrics (https://cloud.google.com/monitoring/custom-metrics). The
         * metric descriptor is updated if it already exists, except that metric labels are never removed.
         *
         * Create a request for the method "metricDescriptors.create".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
         * <p> {@link
         * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       *        the request. The format is: 4 projects/PROJECT_ID_OR_NUMBER
         * @param content the {@link com.google.api.services.monitoring.v3.model.MetricDescriptor}
         * @since 1.13
         */
        protected Create(java.lang.String name, com.google.api.services.monitoring.v3.model.MetricDescriptor content) {
          super(Monitoring.this, "POST", REST_PATH, content, com.google.api.services.monitoring.v3.model.MetricDescriptor.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public Create set$Xgafv(java.lang.String $Xgafv) {
          return (Create) super.set$Xgafv($Xgafv);
        }

        @Override
        public Create setAccessToken(java.lang.String accessToken) {
          return (Create) super.setAccessToken(accessToken);
        }

        @Override
        public Create setAlt(java.lang.String alt) {
          return (Create) super.setAlt(alt);
        }

        @Override
        public Create setCallback(java.lang.String callback) {
          return (Create) super.setCallback(callback);
        }

        @Override
        public Create setFields(java.lang.String fields) {
          return (Create) super.setFields(fields);
        }

        @Override
        public Create setKey(java.lang.String key) {
          return (Create) super.setKey(key);
        }

        @Override
        public Create setOauthToken(java.lang.String oauthToken) {
          return (Create) super.setOauthToken(oauthToken);
        }

        @Override
        public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Create) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Create setQuotaUser(java.lang.String quotaUser) {
          return (Create) super.setQuotaUser(quotaUser);
        }

        @Override
        public Create setUploadType(java.lang.String uploadType) {
          return (Create) super.setUploadType(uploadType);
        }

        @Override
        public Create setUploadProtocol(java.lang.String uploadProtocol) {
          return (Create) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which
         * to execute the request. The format is: 4 projects/PROJECT_ID_OR_NUMBER
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       the request. The format is: 4 projects/PROJECT_ID_OR_NUMBER
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which
         * to execute the request. The format is: 4 projects/PROJECT_ID_OR_NUMBER
         */
        public Create setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Create set(String parameterName, Object value) {
          return (Create) super.set(parameterName, value);
        }
      }
      /**
       * Deletes a metric descriptor. Only user-created custom metrics
       * (https://cloud.google.com/monitoring/custom-metrics) can be deleted.
       *
       * Create a request for the method "metricDescriptors.delete".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
       *
       * @param name Required. The metric descriptor on which to execute the request. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID] An example of [METRIC_ID]
       *        is: "custom.googleapis.com/my_test_metric".
       * @return the request
       */
      public Delete delete(java.lang.String name) throws java.io.IOException {
        Delete result = new Delete(name);
        initialize(result);
        return result;
      }

      public class Delete extends MonitoringRequest<com.google.api.services.monitoring.v3.model.Empty> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/metricDescriptors/.*$");

        /**
         * Deletes a metric descriptor. Only user-created custom metrics
         * (https://cloud.google.com/monitoring/custom-metrics) can be deleted.
         *
         * Create a request for the method "metricDescriptors.delete".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
         * <p> {@link
         * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The metric descriptor on which to execute the request. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID] An example of [METRIC_ID]
       *        is: "custom.googleapis.com/my_test_metric".
         * @since 1.13
         */
        protected Delete(java.lang.String name) {
          super(Monitoring.this, "DELETE", REST_PATH, null, com.google.api.services.monitoring.v3.model.Empty.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/metricDescriptors/.*$");
          }
        }

        @Override
        public Delete set$Xgafv(java.lang.String $Xgafv) {
          return (Delete) super.set$Xgafv($Xgafv);
        }

        @Override
        public Delete setAccessToken(java.lang.String accessToken) {
          return (Delete) super.setAccessToken(accessToken);
        }

        @Override
        public Delete setAlt(java.lang.String alt) {
          return (Delete) super.setAlt(alt);
        }

        @Override
        public Delete setCallback(java.lang.String callback) {
          return (Delete) super.setCallback(callback);
        }

        @Override
        public Delete setFields(java.lang.String fields) {
          return (Delete) super.setFields(fields);
        }

        @Override
        public Delete setKey(java.lang.String key) {
          return (Delete) super.setKey(key);
        }

        @Override
        public Delete setOauthToken(java.lang.String oauthToken) {
          return (Delete) super.setOauthToken(oauthToken);
        }

        @Override
        public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Delete) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Delete setQuotaUser(java.lang.String quotaUser) {
          return (Delete) super.setQuotaUser(quotaUser);
        }

        @Override
        public Delete setUploadType(java.lang.String uploadType) {
          return (Delete) super.setUploadType(uploadType);
        }

        @Override
        public Delete setUploadProtocol(java.lang.String uploadProtocol) {
          return (Delete) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The metric descriptor on which to execute the request. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID] An example of [METRIC_ID]
         * is: "custom.googleapis.com/my_test_metric".
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The metric descriptor on which to execute the request. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID] An example of [METRIC_ID] is:
       "custom.googleapis.com/my_test_metric".
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The metric descriptor on which to execute the request. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID] An example of [METRIC_ID]
         * is: "custom.googleapis.com/my_test_metric".
         */
        public Delete setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/metricDescriptors/.*$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Delete set(String parameterName, Object value) {
          return (Delete) super.set(parameterName, value);
        }
      }
      /**
       * Gets a single metric descriptor.
       *
       * Create a request for the method "metricDescriptors.get".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Get#execute()} method to invoke the remote operation.
       *
       * @param name Required. The metric descriptor on which to execute the request. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID] An example value of
       *        [METRIC_ID] is "compute.googleapis.com/instance/disk/read_bytes_count".
       * @return the request
       */
      public Get get(java.lang.String name) throws java.io.IOException {
        Get result = new Get(name);
        initialize(result);
        return result;
      }

      public class Get extends MonitoringRequest<com.google.api.services.monitoring.v3.model.MetricDescriptor> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/metricDescriptors/.*$");

        /**
         * Gets a single metric descriptor.
         *
         * Create a request for the method "metricDescriptors.get".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
         * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The metric descriptor on which to execute the request. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID] An example value of
       *        [METRIC_ID] is "compute.googleapis.com/instance/disk/read_bytes_count".
         * @since 1.13
         */
        protected Get(java.lang.String name) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.MetricDescriptor.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/metricDescriptors/.*$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public Get set$Xgafv(java.lang.String $Xgafv) {
          return (Get) super.set$Xgafv($Xgafv);
        }

        @Override
        public Get setAccessToken(java.lang.String accessToken) {
          return (Get) super.setAccessToken(accessToken);
        }

        @Override
        public Get setAlt(java.lang.String alt) {
          return (Get) super.setAlt(alt);
        }

        @Override
        public Get setCallback(java.lang.String callback) {
          return (Get) super.setCallback(callback);
        }

        @Override
        public Get setFields(java.lang.String fields) {
          return (Get) super.setFields(fields);
        }

        @Override
        public Get setKey(java.lang.String key) {
          return (Get) super.setKey(key);
        }

        @Override
        public Get setOauthToken(java.lang.String oauthToken) {
          return (Get) super.setOauthToken(oauthToken);
        }

        @Override
        public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Get) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Get setQuotaUser(java.lang.String quotaUser) {
          return (Get) super.setQuotaUser(quotaUser);
        }

        @Override
        public Get setUploadType(java.lang.String uploadType) {
          return (Get) super.setUploadType(uploadType);
        }

        @Override
        public Get setUploadProtocol(java.lang.String uploadProtocol) {
          return (Get) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The metric descriptor on which to execute the request. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID] An example value of
         * [METRIC_ID] is "compute.googleapis.com/instance/disk/read_bytes_count".
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The metric descriptor on which to execute the request. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID] An example value of [METRIC_ID] is
       "compute.googleapis.com/instance/disk/read_bytes_count".
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The metric descriptor on which to execute the request. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID] An example value of
         * [METRIC_ID] is "compute.googleapis.com/instance/disk/read_bytes_count".
         */
        public Get setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/metricDescriptors/.*$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Get set(String parameterName, Object value) {
          return (Get) super.set(parameterName, value);
        }
      }
      /**
       * Lists metric descriptors that match a filter.
       *
       * Create a request for the method "metricDescriptors.list".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link List#execute()} method to invoke the remote operation.
       *
       * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       *        the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
       * @return the request
       */
      public List list(java.lang.String name) throws java.io.IOException {
        List result = new List(name);
        initialize(result);
        return result;
      }

      public class List extends MonitoringRequest<com.google.api.services.monitoring.v3.model.ListMetricDescriptorsResponse> {

        private static final String REST_PATH = "v3/{+name}/metricDescriptors";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Lists metric descriptors that match a filter.
         *
         * Create a request for the method "metricDescriptors.list".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
         * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       *        the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         * @since 1.13
         */
        protected List(java.lang.String name) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.ListMetricDescriptorsResponse.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public List set$Xgafv(java.lang.String $Xgafv) {
          return (List) super.set$Xgafv($Xgafv);
        }

        @Override
        public List setAccessToken(java.lang.String accessToken) {
          return (List) super.setAccessToken(accessToken);
        }

        @Override
        public List setAlt(java.lang.String alt) {
          return (List) super.setAlt(alt);
        }

        @Override
        public List setCallback(java.lang.String callback) {
          return (List) super.setCallback(callback);
        }

        @Override
        public List setFields(java.lang.String fields) {
          return (List) super.setFields(fields);
        }

        @Override
        public List setKey(java.lang.String key) {
          return (List) super.setKey(key);
        }

        @Override
        public List setOauthToken(java.lang.String oauthToken) {
          return (List) super.setOauthToken(oauthToken);
        }

        @Override
        public List setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (List) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public List setQuotaUser(java.lang.String quotaUser) {
          return (List) super.setQuotaUser(quotaUser);
        }

        @Override
        public List setUploadType(java.lang.String uploadType) {
          return (List) super.setUploadType(uploadType);
        }

        @Override
        public List setUploadProtocol(java.lang.String uploadProtocol) {
          return (List) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which
         * to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which
         * to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public List setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /**
         * If this field is empty, all custom and system-defined metric descriptors are returned.
         * Otherwise, the filter (https://cloud.google.com/monitoring/api/v3/filters) specifies
         * which metric descriptors are to be returned. For example, the following filter matches
         * all custom metrics (https://cloud.google.com/monitoring/custom-metrics): metric.type =
         * starts_with("custom.googleapis.com/")
         */
        @com.google.api.client.util.Key
        private java.lang.String filter;

        /** If this field is empty, all custom and system-defined metric descriptors are returned. Otherwise,
       the filter (https://cloud.google.com/monitoring/api/v3/filters) specifies which metric descriptors
       are to be returned. For example, the following filter matches all custom metrics
       (https://cloud.google.com/monitoring/custom-metrics): metric.type =
       starts_with("custom.googleapis.com/")
         */
        public java.lang.String getFilter() {
          return filter;
        }

        /**
         * If this field is empty, all custom and system-defined metric descriptors are returned.
         * Otherwise, the filter (https://cloud.google.com/monitoring/api/v3/filters) specifies
         * which metric descriptors are to be returned. For example, the following filter matches
         * all custom metrics (https://cloud.google.com/monitoring/custom-metrics): metric.type =
         * starts_with("custom.googleapis.com/")
         */
        public List setFilter(java.lang.String filter) {
          this.filter = filter;
          return this;
        }

        /**
         * A positive number that is the maximum number of results to return. The default and
         * maximum value is 10,000. If a page_size <= 0 or > 10,000 is submitted, will instead
         * return a maximum of 10,000 results.
         */
        @com.google.api.client.util.Key
        private java.lang.Integer pageSize;

        /** A positive number that is the maximum number of results to return. The default and maximum value is
       10,000. If a page_size <= 0 or > 10,000 is submitted, will instead return a maximum of 10,000
       results.
         */
        public java.lang.Integer getPageSize() {
          return pageSize;
        }

        /**
         * A positive number that is the maximum number of results to return. The default and
         * maximum value is 10,000. If a page_size <= 0 or > 10,000 is submitted, will instead
         * return a maximum of 10,000 results.
         */
        public List setPageSize(java.lang.Integer pageSize) {
          this.pageSize = pageSize;
          return this;
        }

        /**
         * If this field is not empty then it must contain the nextPageToken value returned by a
         * previous call to this method. Using this field causes the method to return additional
         * results from the previous method call.
         */
        @com.google.api.client.util.Key
        private java.lang.String pageToken;

        /** If this field is not empty then it must contain the nextPageToken value returned by a previous call
       to this method. Using this field causes the method to return additional results from the previous
       method call.
         */
        public java.lang.String getPageToken() {
          return pageToken;
        }

        /**
         * If this field is not empty then it must contain the nextPageToken value returned by a
         * previous call to this method. Using this field causes the method to return additional
         * results from the previous method call.
         */
        public List setPageToken(java.lang.String pageToken) {
          this.pageToken = pageToken;
          return this;
        }

        @Override
        public List set(String parameterName, Object value) {
          return (List) super.set(parameterName, value);
        }
      }

    }
    /**
     * An accessor for creating requests from the MonitoredResourceDescriptors collection.
     *
     * <p>The typical use is:</p>
     * <pre>
     *   {@code Monitoring monitoring = new Monitoring(...);}
     *   {@code Monitoring.MonitoredResourceDescriptors.List request = monitoring.monitoredResourceDescriptors().list(parameters ...)}
     * </pre>
     *
     * @return the resource collection
     */
    public MonitoredResourceDescriptors monitoredResourceDescriptors() {
      return new MonitoredResourceDescriptors();
    }

    /**
     * The "monitoredResourceDescriptors" collection of methods.
     */
    public class MonitoredResourceDescriptors {

      /**
       * Gets a single monitored resource descriptor.
       *
       * Create a request for the method "monitoredResourceDescriptors.get".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Get#execute()} method to invoke the remote operation.
       *
       * @param name Required. The monitored resource descriptor to get. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/monitoredResourceDescriptors/[RESOURCE_TYPE] The
       *        [RESOURCE_TYPE] is a predefined type, such as cloudsql_database.
       * @return the request
       */
      public Get get(java.lang.String name) throws java.io.IOException {
        Get result = new Get(name);
        initialize(result);
        return result;
      }

      public class Get extends MonitoringRequest<com.google.api.services.monitoring.v3.model.MonitoredResourceDescriptor> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/monitoredResourceDescriptors/.*$");

        /**
         * Gets a single monitored resource descriptor.
         *
         * Create a request for the method "monitoredResourceDescriptors.get".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
         * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The monitored resource descriptor to get. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/monitoredResourceDescriptors/[RESOURCE_TYPE] The
       *        [RESOURCE_TYPE] is a predefined type, such as cloudsql_database.
         * @since 1.13
         */
        protected Get(java.lang.String name) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.MonitoredResourceDescriptor.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/monitoredResourceDescriptors/.*$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public Get set$Xgafv(java.lang.String $Xgafv) {
          return (Get) super.set$Xgafv($Xgafv);
        }

        @Override
        public Get setAccessToken(java.lang.String accessToken) {
          return (Get) super.setAccessToken(accessToken);
        }

        @Override
        public Get setAlt(java.lang.String alt) {
          return (Get) super.setAlt(alt);
        }

        @Override
        public Get setCallback(java.lang.String callback) {
          return (Get) super.setCallback(callback);
        }

        @Override
        public Get setFields(java.lang.String fields) {
          return (Get) super.setFields(fields);
        }

        @Override
        public Get setKey(java.lang.String key) {
          return (Get) super.setKey(key);
        }

        @Override
        public Get setOauthToken(java.lang.String oauthToken) {
          return (Get) super.setOauthToken(oauthToken);
        }

        @Override
        public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Get) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Get setQuotaUser(java.lang.String quotaUser) {
          return (Get) super.setQuotaUser(quotaUser);
        }

        @Override
        public Get setUploadType(java.lang.String uploadType) {
          return (Get) super.setUploadType(uploadType);
        }

        @Override
        public Get setUploadProtocol(java.lang.String uploadProtocol) {
          return (Get) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The monitored resource descriptor to get. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/monitoredResourceDescriptors/[RESOURCE_TYPE] The
         * [RESOURCE_TYPE] is a predefined type, such as cloudsql_database.
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The monitored resource descriptor to get. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/monitoredResourceDescriptors/[RESOURCE_TYPE] The [RESOURCE_TYPE] is
       a predefined type, such as cloudsql_database.
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The monitored resource descriptor to get. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/monitoredResourceDescriptors/[RESOURCE_TYPE] The
         * [RESOURCE_TYPE] is a predefined type, such as cloudsql_database.
         */
        public Get setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/monitoredResourceDescriptors/.*$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Get set(String parameterName, Object value) {
          return (Get) super.set(parameterName, value);
        }
      }
      /**
       * Lists monitored resource descriptors that match a filter.
       *
       * Create a request for the method "monitoredResourceDescriptors.list".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link List#execute()} method to invoke the remote operation.
       *
       * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       *        the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
       * @return the request
       */
      public List list(java.lang.String name) throws java.io.IOException {
        List result = new List(name);
        initialize(result);
        return result;
      }

      public class List extends MonitoringRequest<com.google.api.services.monitoring.v3.model.ListMonitoredResourceDescriptorsResponse> {

        private static final String REST_PATH = "v3/{+name}/monitoredResourceDescriptors";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Lists monitored resource descriptors that match a filter.
         *
         * Create a request for the method "monitoredResourceDescriptors.list".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
         * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       *        the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         * @since 1.13
         */
        protected List(java.lang.String name) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.ListMonitoredResourceDescriptorsResponse.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public List set$Xgafv(java.lang.String $Xgafv) {
          return (List) super.set$Xgafv($Xgafv);
        }

        @Override
        public List setAccessToken(java.lang.String accessToken) {
          return (List) super.setAccessToken(accessToken);
        }

        @Override
        public List setAlt(java.lang.String alt) {
          return (List) super.setAlt(alt);
        }

        @Override
        public List setCallback(java.lang.String callback) {
          return (List) super.setCallback(callback);
        }

        @Override
        public List setFields(java.lang.String fields) {
          return (List) super.setFields(fields);
        }

        @Override
        public List setKey(java.lang.String key) {
          return (List) super.setKey(key);
        }

        @Override
        public List setOauthToken(java.lang.String oauthToken) {
          return (List) super.setOauthToken(oauthToken);
        }

        @Override
        public List setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (List) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public List setQuotaUser(java.lang.String quotaUser) {
          return (List) super.setQuotaUser(quotaUser);
        }

        @Override
        public List setUploadType(java.lang.String uploadType) {
          return (List) super.setUploadType(uploadType);
        }

        @Override
        public List setUploadProtocol(java.lang.String uploadProtocol) {
          return (List) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which
         * to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which
         * to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public List setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /**
         * An optional filter (https://cloud.google.com/monitoring/api/v3/filters) describing the
         * descriptors to be returned. The filter can reference the descriptor's type and labels.
         * For example, the following filter returns only Google Compute Engine descriptors that
         * have an id label: resource.type = starts_with("gce_") AND resource.label:id
         */
        @com.google.api.client.util.Key
        private java.lang.String filter;

        /** An optional filter (https://cloud.google.com/monitoring/api/v3/filters) describing the descriptors
       to be returned. The filter can reference the descriptor's type and labels. For example, the
       following filter returns only Google Compute Engine descriptors that have an id label:
       resource.type = starts_with("gce_") AND resource.label:id
         */
        public java.lang.String getFilter() {
          return filter;
        }

        /**
         * An optional filter (https://cloud.google.com/monitoring/api/v3/filters) describing the
         * descriptors to be returned. The filter can reference the descriptor's type and labels.
         * For example, the following filter returns only Google Compute Engine descriptors that
         * have an id label: resource.type = starts_with("gce_") AND resource.label:id
         */
        public List setFilter(java.lang.String filter) {
          this.filter = filter;
          return this;
        }

        /** A positive number that is the maximum number of results to return. */
        @com.google.api.client.util.Key
        private java.lang.Integer pageSize;

        /** A positive number that is the maximum number of results to return.
         */
        public java.lang.Integer getPageSize() {
          return pageSize;
        }

        /** A positive number that is the maximum number of results to return. */
        public List setPageSize(java.lang.Integer pageSize) {
          this.pageSize = pageSize;
          return this;
        }

        /**
         * If this field is not empty then it must contain the nextPageToken value returned by a
         * previous call to this method. Using this field causes the method to return additional
         * results from the previous method call.
         */
        @com.google.api.client.util.Key
        private java.lang.String pageToken;

        /** If this field is not empty then it must contain the nextPageToken value returned by a previous call
       to this method. Using this field causes the method to return additional results from the previous
       method call.
         */
        public java.lang.String getPageToken() {
          return pageToken;
        }

        /**
         * If this field is not empty then it must contain the nextPageToken value returned by a
         * previous call to this method. Using this field causes the method to return additional
         * results from the previous method call.
         */
        public List setPageToken(java.lang.String pageToken) {
          this.pageToken = pageToken;
          return this;
        }

        @Override
        public List set(String parameterName, Object value) {
          return (List) super.set(parameterName, value);
        }
      }

    }
    /**
     * An accessor for creating requests from the NotificationChannelDescriptors collection.
     *
     * <p>The typical use is:</p>
     * <pre>
     *   {@code Monitoring monitoring = new Monitoring(...);}
     *   {@code Monitoring.NotificationChannelDescriptors.List request = monitoring.notificationChannelDescriptors().list(parameters ...)}
     * </pre>
     *
     * @return the resource collection
     */
    public NotificationChannelDescriptors notificationChannelDescriptors() {
      return new NotificationChannelDescriptors();
    }

    /**
     * The "notificationChannelDescriptors" collection of methods.
     */
    public class NotificationChannelDescriptors {

      /**
       * Gets a single channel descriptor. The descriptor indicates which fields are expected / permitted
       * for a notification channel of the given type.
       *
       * Create a request for the method "notificationChannelDescriptors.get".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Get#execute()} method to invoke the remote operation.
       *
       * @param name Required. The channel type for which to execute the request. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/notificationChannelDescriptors/[CHANNEL_TYPE]
       * @return the request
       */
      public Get get(java.lang.String name) throws java.io.IOException {
        Get result = new Get(name);
        initialize(result);
        return result;
      }

      public class Get extends MonitoringRequest<com.google.api.services.monitoring.v3.model.NotificationChannelDescriptor> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/notificationChannelDescriptors/[^/]+$");

        /**
         * Gets a single channel descriptor. The descriptor indicates which fields are expected /
         * permitted for a notification channel of the given type.
         *
         * Create a request for the method "notificationChannelDescriptors.get".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
         * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The channel type for which to execute the request. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/notificationChannelDescriptors/[CHANNEL_TYPE]
         * @since 1.13
         */
        protected Get(java.lang.String name) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.NotificationChannelDescriptor.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/notificationChannelDescriptors/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public Get set$Xgafv(java.lang.String $Xgafv) {
          return (Get) super.set$Xgafv($Xgafv);
        }

        @Override
        public Get setAccessToken(java.lang.String accessToken) {
          return (Get) super.setAccessToken(accessToken);
        }

        @Override
        public Get setAlt(java.lang.String alt) {
          return (Get) super.setAlt(alt);
        }

        @Override
        public Get setCallback(java.lang.String callback) {
          return (Get) super.setCallback(callback);
        }

        @Override
        public Get setFields(java.lang.String fields) {
          return (Get) super.setFields(fields);
        }

        @Override
        public Get setKey(java.lang.String key) {
          return (Get) super.setKey(key);
        }

        @Override
        public Get setOauthToken(java.lang.String oauthToken) {
          return (Get) super.setOauthToken(oauthToken);
        }

        @Override
        public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Get) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Get setQuotaUser(java.lang.String quotaUser) {
          return (Get) super.setQuotaUser(quotaUser);
        }

        @Override
        public Get setUploadType(java.lang.String uploadType) {
          return (Get) super.setUploadType(uploadType);
        }

        @Override
        public Get setUploadProtocol(java.lang.String uploadProtocol) {
          return (Get) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The channel type for which to execute the request. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/notificationChannelDescriptors/[CHANNEL_TYPE]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The channel type for which to execute the request. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/notificationChannelDescriptors/[CHANNEL_TYPE]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The channel type for which to execute the request. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/notificationChannelDescriptors/[CHANNEL_TYPE]
         */
        public Get setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/notificationChannelDescriptors/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Get set(String parameterName, Object value) {
          return (Get) super.set(parameterName, value);
        }
      }
      /**
       * Lists the descriptors for supported channel types. The use of descriptors makes it possible for
       * new channel types to be dynamically added.
       *
       * Create a request for the method "notificationChannelDescriptors.list".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link List#execute()} method to invoke the remote operation.
       *
       * @param name Required. The REST resource name of the parent from which to retrieve the notification channel
       *        descriptors. The expected syntax is: projects/[PROJECT_ID_OR_NUMBER] Note that this names
       *        (https://cloud.google.com/monitoring/api/v3#project_name) the parent container in which to
       *        look for the descriptors; to retrieve a single descriptor by name, use the
       *        GetNotificationChannelDescriptor operation, instead.
       * @return the request
       */
      public List list(java.lang.String name) throws java.io.IOException {
        List result = new List(name);
        initialize(result);
        return result;
      }

      public class List extends MonitoringRequest<com.google.api.services.monitoring.v3.model.ListNotificationChannelDescriptorsResponse> {

        private static final String REST_PATH = "v3/{+name}/notificationChannelDescriptors";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Lists the descriptors for supported channel types. The use of descriptors makes it possible for
         * new channel types to be dynamically added.
         *
         * Create a request for the method "notificationChannelDescriptors.list".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
         * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The REST resource name of the parent from which to retrieve the notification channel
       *        descriptors. The expected syntax is: projects/[PROJECT_ID_OR_NUMBER] Note that this names
       *        (https://cloud.google.com/monitoring/api/v3#project_name) the parent container in which to
       *        look for the descriptors; to retrieve a single descriptor by name, use the
       *        GetNotificationChannelDescriptor operation, instead.
         * @since 1.13
         */
        protected List(java.lang.String name) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.ListNotificationChannelDescriptorsResponse.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public List set$Xgafv(java.lang.String $Xgafv) {
          return (List) super.set$Xgafv($Xgafv);
        }

        @Override
        public List setAccessToken(java.lang.String accessToken) {
          return (List) super.setAccessToken(accessToken);
        }

        @Override
        public List setAlt(java.lang.String alt) {
          return (List) super.setAlt(alt);
        }

        @Override
        public List setCallback(java.lang.String callback) {
          return (List) super.setCallback(callback);
        }

        @Override
        public List setFields(java.lang.String fields) {
          return (List) super.setFields(fields);
        }

        @Override
        public List setKey(java.lang.String key) {
          return (List) super.setKey(key);
        }

        @Override
        public List setOauthToken(java.lang.String oauthToken) {
          return (List) super.setOauthToken(oauthToken);
        }

        @Override
        public List setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (List) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public List setQuotaUser(java.lang.String quotaUser) {
          return (List) super.setQuotaUser(quotaUser);
        }

        @Override
        public List setUploadType(java.lang.String uploadType) {
          return (List) super.setUploadType(uploadType);
        }

        @Override
        public List setUploadProtocol(java.lang.String uploadProtocol) {
          return (List) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The REST resource name of the parent from which to retrieve the notification
         * channel descriptors. The expected syntax is: projects/[PROJECT_ID_OR_NUMBER] Note that
         * this names (https://cloud.google.com/monitoring/api/v3#project_name) the parent container
         * in which to look for the descriptors; to retrieve a single descriptor by name, use the
         * GetNotificationChannelDescriptor operation, instead.
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The REST resource name of the parent from which to retrieve the notification channel
       descriptors. The expected syntax is: projects/[PROJECT_ID_OR_NUMBER] Note that this names
       (https://cloud.google.com/monitoring/api/v3#project_name) the parent container in which to look for
       the descriptors; to retrieve a single descriptor by name, use the GetNotificationChannelDescriptor
       operation, instead.
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The REST resource name of the parent from which to retrieve the notification
         * channel descriptors. The expected syntax is: projects/[PROJECT_ID_OR_NUMBER] Note that
         * this names (https://cloud.google.com/monitoring/api/v3#project_name) the parent container
         * in which to look for the descriptors; to retrieve a single descriptor by name, use the
         * GetNotificationChannelDescriptor operation, instead.
         */
        public List setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /**
         * The maximum number of results to return in a single response. If not set to a positive
         * number, a reasonable value will be chosen by the service.
         */
        @com.google.api.client.util.Key
        private java.lang.Integer pageSize;

        /** The maximum number of results to return in a single response. If not set to a positive number, a
       reasonable value will be chosen by the service.
         */
        public java.lang.Integer getPageSize() {
          return pageSize;
        }

        /**
         * The maximum number of results to return in a single response. If not set to a positive
         * number, a reasonable value will be chosen by the service.
         */
        public List setPageSize(java.lang.Integer pageSize) {
          this.pageSize = pageSize;
          return this;
        }

        /**
         * If non-empty, page_token must contain a value returned as the next_page_token in a
         * previous response to request the next set of results.
         */
        @com.google.api.client.util.Key
        private java.lang.String pageToken;

        /** If non-empty, page_token must contain a value returned as the next_page_token in a previous
       response to request the next set of results.
         */
        public java.lang.String getPageToken() {
          return pageToken;
        }

        /**
         * If non-empty, page_token must contain a value returned as the next_page_token in a
         * previous response to request the next set of results.
         */
        public List setPageToken(java.lang.String pageToken) {
          this.pageToken = pageToken;
          return this;
        }

        @Override
        public List set(String parameterName, Object value) {
          return (List) super.set(parameterName, value);
        }
      }

    }
    /**
     * An accessor for creating requests from the NotificationChannels collection.
     *
     * <p>The typical use is:</p>
     * <pre>
     *   {@code Monitoring monitoring = new Monitoring(...);}
     *   {@code Monitoring.NotificationChannels.List request = monitoring.notificationChannels().list(parameters ...)}
     * </pre>
     *
     * @return the resource collection
     */
    public NotificationChannels notificationChannels() {
      return new NotificationChannels();
    }

    /**
     * The "notificationChannels" collection of methods.
     */
    public class NotificationChannels {

      /**
       * Creates a new notification channel, representing a single notification endpoint such as an email
       * address, SMS number, or PagerDuty service.Design your application to single-thread API calls that
       * modify the state of notification channels in a single project. This includes calls to
       * CreateNotificationChannel, DeleteNotificationChannel and UpdateNotificationChannel.
       *
       * Create a request for the method "notificationChannels.create".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Create#execute()} method to invoke the remote operation.
       *
       * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       *        the request. The format is: projects/[PROJECT_ID_OR_NUMBER] This names the container into
       *        which the channel will be written, this does not name the newly created channel. The
       *        resulting channel's name will have a normalized version of this field as a prefix, but
       *        will add /notificationChannels/[CHANNEL_ID] to identify the channel.
       * @param content the {@link com.google.api.services.monitoring.v3.model.NotificationChannel}
       * @return the request
       */
      public Create create(java.lang.String name, com.google.api.services.monitoring.v3.model.NotificationChannel content) throws java.io.IOException {
        Create result = new Create(name, content);
        initialize(result);
        return result;
      }

      public class Create extends MonitoringRequest<com.google.api.services.monitoring.v3.model.NotificationChannel> {

        private static final String REST_PATH = "v3/{+name}/notificationChannels";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Creates a new notification channel, representing a single notification endpoint such as an
         * email address, SMS number, or PagerDuty service.Design your application to single-thread API
         * calls that modify the state of notification channels in a single project. This includes calls
         * to CreateNotificationChannel, DeleteNotificationChannel and UpdateNotificationChannel.
         *
         * Create a request for the method "notificationChannels.create".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
         * <p> {@link
         * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       *        the request. The format is: projects/[PROJECT_ID_OR_NUMBER] This names the container into
       *        which the channel will be written, this does not name the newly created channel. The
       *        resulting channel's name will have a normalized version of this field as a prefix, but
       *        will add /notificationChannels/[CHANNEL_ID] to identify the channel.
         * @param content the {@link com.google.api.services.monitoring.v3.model.NotificationChannel}
         * @since 1.13
         */
        protected Create(java.lang.String name, com.google.api.services.monitoring.v3.model.NotificationChannel content) {
          super(Monitoring.this, "POST", REST_PATH, content, com.google.api.services.monitoring.v3.model.NotificationChannel.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public Create set$Xgafv(java.lang.String $Xgafv) {
          return (Create) super.set$Xgafv($Xgafv);
        }

        @Override
        public Create setAccessToken(java.lang.String accessToken) {
          return (Create) super.setAccessToken(accessToken);
        }

        @Override
        public Create setAlt(java.lang.String alt) {
          return (Create) super.setAlt(alt);
        }

        @Override
        public Create setCallback(java.lang.String callback) {
          return (Create) super.setCallback(callback);
        }

        @Override
        public Create setFields(java.lang.String fields) {
          return (Create) super.setFields(fields);
        }

        @Override
        public Create setKey(java.lang.String key) {
          return (Create) super.setKey(key);
        }

        @Override
        public Create setOauthToken(java.lang.String oauthToken) {
          return (Create) super.setOauthToken(oauthToken);
        }

        @Override
        public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Create) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Create setQuotaUser(java.lang.String quotaUser) {
          return (Create) super.setQuotaUser(quotaUser);
        }

        @Override
        public Create setUploadType(java.lang.String uploadType) {
          return (Create) super.setUploadType(uploadType);
        }

        @Override
        public Create setUploadProtocol(java.lang.String uploadProtocol) {
          return (Create) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which
         * to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER] This names the
         * container into which the channel will be written, this does not name the newly created
         * channel. The resulting channel's name will have a normalized version of this field as a
         * prefix, but will add /notificationChannels/[CHANNEL_ID] to identify the channel.
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       the request. The format is: projects/[PROJECT_ID_OR_NUMBER] This names the container into which the
       channel will be written, this does not name the newly created channel. The resulting channel's name
       will have a normalized version of this field as a prefix, but will add
       /notificationChannels/[CHANNEL_ID] to identify the channel.
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which
         * to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER] This names the
         * container into which the channel will be written, this does not name the newly created
         * channel. The resulting channel's name will have a normalized version of this field as a
         * prefix, but will add /notificationChannels/[CHANNEL_ID] to identify the channel.
         */
        public Create setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Create set(String parameterName, Object value) {
          return (Create) super.set(parameterName, value);
        }
      }
      /**
       * Deletes a notification channel.Design your application to single-thread API calls that modify the
       * state of notification channels in a single project. This includes calls to
       * CreateNotificationChannel, DeleteNotificationChannel and UpdateNotificationChannel.
       *
       * Create a request for the method "notificationChannels.delete".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
       *
       * @param name Required. The channel for which to execute the request. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
       * @return the request
       */
      public Delete delete(java.lang.String name) throws java.io.IOException {
        Delete result = new Delete(name);
        initialize(result);
        return result;
      }

      public class Delete extends MonitoringRequest<com.google.api.services.monitoring.v3.model.Empty> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/notificationChannels/[^/]+$");

        /**
         * Deletes a notification channel.Design your application to single-thread API calls that modify
         * the state of notification channels in a single project. This includes calls to
         * CreateNotificationChannel, DeleteNotificationChannel and UpdateNotificationChannel.
         *
         * Create a request for the method "notificationChannels.delete".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
         * <p> {@link
         * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The channel for which to execute the request. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
         * @since 1.13
         */
        protected Delete(java.lang.String name) {
          super(Monitoring.this, "DELETE", REST_PATH, null, com.google.api.services.monitoring.v3.model.Empty.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/notificationChannels/[^/]+$");
          }
        }

        @Override
        public Delete set$Xgafv(java.lang.String $Xgafv) {
          return (Delete) super.set$Xgafv($Xgafv);
        }

        @Override
        public Delete setAccessToken(java.lang.String accessToken) {
          return (Delete) super.setAccessToken(accessToken);
        }

        @Override
        public Delete setAlt(java.lang.String alt) {
          return (Delete) super.setAlt(alt);
        }

        @Override
        public Delete setCallback(java.lang.String callback) {
          return (Delete) super.setCallback(callback);
        }

        @Override
        public Delete setFields(java.lang.String fields) {
          return (Delete) super.setFields(fields);
        }

        @Override
        public Delete setKey(java.lang.String key) {
          return (Delete) super.setKey(key);
        }

        @Override
        public Delete setOauthToken(java.lang.String oauthToken) {
          return (Delete) super.setOauthToken(oauthToken);
        }

        @Override
        public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Delete) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Delete setQuotaUser(java.lang.String quotaUser) {
          return (Delete) super.setQuotaUser(quotaUser);
        }

        @Override
        public Delete setUploadType(java.lang.String uploadType) {
          return (Delete) super.setUploadType(uploadType);
        }

        @Override
        public Delete setUploadProtocol(java.lang.String uploadProtocol) {
          return (Delete) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The channel for which to execute the request. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The channel for which to execute the request. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The channel for which to execute the request. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
         */
        public Delete setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/notificationChannels/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /**
         * If true, the notification channel will be deleted regardless of its use in alert policies
         * (the policies will be updated to remove the channel). If false, channels that are still
         * referenced by an existing alerting policy will fail to be deleted in a delete operation.
         */
        @com.google.api.client.util.Key
        private java.lang.Boolean force;

        /** If true, the notification channel will be deleted regardless of its use in alert policies (the
       policies will be updated to remove the channel). If false, channels that are still referenced by an
       existing alerting policy will fail to be deleted in a delete operation.
         */
        public java.lang.Boolean getForce() {
          return force;
        }

        /**
         * If true, the notification channel will be deleted regardless of its use in alert policies
         * (the policies will be updated to remove the channel). If false, channels that are still
         * referenced by an existing alerting policy will fail to be deleted in a delete operation.
         */
        public Delete setForce(java.lang.Boolean force) {
          this.force = force;
          return this;
        }

        @Override
        public Delete set(String parameterName, Object value) {
          return (Delete) super.set(parameterName, value);
        }
      }
      /**
       * Gets a single notification channel. The channel includes the relevant configuration details with
       * which the channel was created. However, the response may truncate or omit passwords, API keys, or
       * other private key matter and thus the response may not be 100% identical to the information that
       * was supplied in the call to the create method.
       *
       * Create a request for the method "notificationChannels.get".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Get#execute()} method to invoke the remote operation.
       *
       * @param name Required. The channel for which to execute the request. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
       * @return the request
       */
      public Get get(java.lang.String name) throws java.io.IOException {
        Get result = new Get(name);
        initialize(result);
        return result;
      }

      public class Get extends MonitoringRequest<com.google.api.services.monitoring.v3.model.NotificationChannel> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/notificationChannels/[^/]+$");

        /**
         * Gets a single notification channel. The channel includes the relevant configuration details
         * with which the channel was created. However, the response may truncate or omit passwords, API
         * keys, or other private key matter and thus the response may not be 100% identical to the
         * information that was supplied in the call to the create method.
         *
         * Create a request for the method "notificationChannels.get".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
         * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The channel for which to execute the request. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
         * @since 1.13
         */
        protected Get(java.lang.String name) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.NotificationChannel.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/notificationChannels/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public Get set$Xgafv(java.lang.String $Xgafv) {
          return (Get) super.set$Xgafv($Xgafv);
        }

        @Override
        public Get setAccessToken(java.lang.String accessToken) {
          return (Get) super.setAccessToken(accessToken);
        }

        @Override
        public Get setAlt(java.lang.String alt) {
          return (Get) super.setAlt(alt);
        }

        @Override
        public Get setCallback(java.lang.String callback) {
          return (Get) super.setCallback(callback);
        }

        @Override
        public Get setFields(java.lang.String fields) {
          return (Get) super.setFields(fields);
        }

        @Override
        public Get setKey(java.lang.String key) {
          return (Get) super.setKey(key);
        }

        @Override
        public Get setOauthToken(java.lang.String oauthToken) {
          return (Get) super.setOauthToken(oauthToken);
        }

        @Override
        public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Get) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Get setQuotaUser(java.lang.String quotaUser) {
          return (Get) super.setQuotaUser(quotaUser);
        }

        @Override
        public Get setUploadType(java.lang.String uploadType) {
          return (Get) super.setUploadType(uploadType);
        }

        @Override
        public Get setUploadProtocol(java.lang.String uploadProtocol) {
          return (Get) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The channel for which to execute the request. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The channel for which to execute the request. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The channel for which to execute the request. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
         */
        public Get setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/notificationChannels/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Get set(String parameterName, Object value) {
          return (Get) super.set(parameterName, value);
        }
      }
      /**
       * Requests a verification code for an already verified channel that can then be used in a call to
       * VerifyNotificationChannel() on a different channel with an equivalent identity in the same or in
       * a different project. This makes it possible to copy a channel between projects without requiring
       * manual reverification of the channel. If the channel is not in the verified state, this method
       * will fail (in other words, this may only be used if the SendNotificationChannelVerificationCode
       * and VerifyNotificationChannel paths have already been used to put the given channel into the
       * verified state).There is no guarantee that the verification codes returned by this method will be
       * of a similar structure or form as the ones that are delivered to the channel via
       * SendNotificationChannelVerificationCode; while VerifyNotificationChannel() will recognize both
       * the codes delivered via SendNotificationChannelVerificationCode() and returned from
       * GetNotificationChannelVerificationCode(), it is typically the case that the verification codes
       * delivered via SendNotificationChannelVerificationCode() will be shorter and also have a shorter
       * expiration (e.g. codes such as "G-123456") whereas GetVerificationCode() will typically return a
       * much longer, websafe base 64 encoded string that has a longer expiration time.
       *
       * Create a request for the method "notificationChannels.getVerificationCode".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link GetVerificationCode#execute()} method to invoke the remote operation.
       *
       * @param name Required. The notification channel for which a verification code is to be generated and retrieved.
       *        This must name a channel that is already verified; if the specified channel is not
       *        verified, the request will fail.
       * @param content the {@link com.google.api.services.monitoring.v3.model.GetNotificationChannelVerificationCodeRequest}
       * @return the request
       */
      public GetVerificationCode getVerificationCode(java.lang.String name, com.google.api.services.monitoring.v3.model.GetNotificationChannelVerificationCodeRequest content) throws java.io.IOException {
        GetVerificationCode result = new GetVerificationCode(name, content);
        initialize(result);
        return result;
      }

      public class GetVerificationCode extends MonitoringRequest<com.google.api.services.monitoring.v3.model.GetNotificationChannelVerificationCodeResponse> {

        private static final String REST_PATH = "v3/{+name}:getVerificationCode";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/notificationChannels/[^/]+$");

        /**
         * Requests a verification code for an already verified channel that can then be used in a call to
         * VerifyNotificationChannel() on a different channel with an equivalent identity in the same or
         * in a different project. This makes it possible to copy a channel between projects without
         * requiring manual reverification of the channel. If the channel is not in the verified state,
         * this method will fail (in other words, this may only be used if the
         * SendNotificationChannelVerificationCode and VerifyNotificationChannel paths have already been
         * used to put the given channel into the verified state).There is no guarantee that the
         * verification codes returned by this method will be of a similar structure or form as the ones
         * that are delivered to the channel via SendNotificationChannelVerificationCode; while
         * VerifyNotificationChannel() will recognize both the codes delivered via
         * SendNotificationChannelVerificationCode() and returned from
         * GetNotificationChannelVerificationCode(), it is typically the case that the verification codes
         * delivered via SendNotificationChannelVerificationCode() will be shorter and also have a shorter
         * expiration (e.g. codes such as "G-123456") whereas GetVerificationCode() will typically return
         * a much longer, websafe base 64 encoded string that has a longer expiration time.
         *
         * Create a request for the method "notificationChannels.getVerificationCode".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link GetVerificationCode#execute()} method to invoke the remote
         * operation. <p> {@link GetVerificationCode#initialize(com.google.api.client.googleapis.services.
         * AbstractGoogleClientRequest)} must be called to initialize this instance immediately after
         * invoking the constructor. </p>
         *
         * @param name Required. The notification channel for which a verification code is to be generated and retrieved.
       *        This must name a channel that is already verified; if the specified channel is not
       *        verified, the request will fail.
         * @param content the {@link com.google.api.services.monitoring.v3.model.GetNotificationChannelVerificationCodeRequest}
         * @since 1.13
         */
        protected GetVerificationCode(java.lang.String name, com.google.api.services.monitoring.v3.model.GetNotificationChannelVerificationCodeRequest content) {
          super(Monitoring.this, "POST", REST_PATH, content, com.google.api.services.monitoring.v3.model.GetNotificationChannelVerificationCodeResponse.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/notificationChannels/[^/]+$");
          }
        }

        @Override
        public GetVerificationCode set$Xgafv(java.lang.String $Xgafv) {
          return (GetVerificationCode) super.set$Xgafv($Xgafv);
        }

        @Override
        public GetVerificationCode setAccessToken(java.lang.String accessToken) {
          return (GetVerificationCode) super.setAccessToken(accessToken);
        }

        @Override
        public GetVerificationCode setAlt(java.lang.String alt) {
          return (GetVerificationCode) super.setAlt(alt);
        }

        @Override
        public GetVerificationCode setCallback(java.lang.String callback) {
          return (GetVerificationCode) super.setCallback(callback);
        }

        @Override
        public GetVerificationCode setFields(java.lang.String fields) {
          return (GetVerificationCode) super.setFields(fields);
        }

        @Override
        public GetVerificationCode setKey(java.lang.String key) {
          return (GetVerificationCode) super.setKey(key);
        }

        @Override
        public GetVerificationCode setOauthToken(java.lang.String oauthToken) {
          return (GetVerificationCode) super.setOauthToken(oauthToken);
        }

        @Override
        public GetVerificationCode setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (GetVerificationCode) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public GetVerificationCode setQuotaUser(java.lang.String quotaUser) {
          return (GetVerificationCode) super.setQuotaUser(quotaUser);
        }

        @Override
        public GetVerificationCode setUploadType(java.lang.String uploadType) {
          return (GetVerificationCode) super.setUploadType(uploadType);
        }

        @Override
        public GetVerificationCode setUploadProtocol(java.lang.String uploadProtocol) {
          return (GetVerificationCode) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The notification channel for which a verification code is to be generated and
         * retrieved. This must name a channel that is already verified; if the specified channel is
         * not verified, the request will fail.
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The notification channel for which a verification code is to be generated and retrieved.
       This must name a channel that is already verified; if the specified channel is not verified, the
       request will fail.
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The notification channel for which a verification code is to be generated and
         * retrieved. This must name a channel that is already verified; if the specified channel is
         * not verified, the request will fail.
         */
        public GetVerificationCode setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/notificationChannels/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public GetVerificationCode set(String parameterName, Object value) {
          return (GetVerificationCode) super.set(parameterName, value);
        }
      }
      /**
       * Lists the notification channels that have been created for the project. To list the types of
       * notification channels that are supported, use the ListNotificationChannelDescriptors method.
       *
       * Create a request for the method "notificationChannels.list".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link List#execute()} method to invoke the remote operation.
       *
       * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       *        the request. The format is: projects/[PROJECT_ID_OR_NUMBER] This names the container in
       *        which to look for the notification channels; it does not name a specific channel. To query
       *        a specific channel by REST resource name, use the GetNotificationChannel operation.
       * @return the request
       */
      public List list(java.lang.String name) throws java.io.IOException {
        List result = new List(name);
        initialize(result);
        return result;
      }

      public class List extends MonitoringRequest<com.google.api.services.monitoring.v3.model.ListNotificationChannelsResponse> {

        private static final String REST_PATH = "v3/{+name}/notificationChannels";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Lists the notification channels that have been created for the project. To list the types of
         * notification channels that are supported, use the ListNotificationChannelDescriptors method.
         *
         * Create a request for the method "notificationChannels.list".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
         * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       *        the request. The format is: projects/[PROJECT_ID_OR_NUMBER] This names the container in
       *        which to look for the notification channels; it does not name a specific channel. To query
       *        a specific channel by REST resource name, use the GetNotificationChannel operation.
         * @since 1.13
         */
        protected List(java.lang.String name) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.ListNotificationChannelsResponse.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public List set$Xgafv(java.lang.String $Xgafv) {
          return (List) super.set$Xgafv($Xgafv);
        }

        @Override
        public List setAccessToken(java.lang.String accessToken) {
          return (List) super.setAccessToken(accessToken);
        }

        @Override
        public List setAlt(java.lang.String alt) {
          return (List) super.setAlt(alt);
        }

        @Override
        public List setCallback(java.lang.String callback) {
          return (List) super.setCallback(callback);
        }

        @Override
        public List setFields(java.lang.String fields) {
          return (List) super.setFields(fields);
        }

        @Override
        public List setKey(java.lang.String key) {
          return (List) super.setKey(key);
        }

        @Override
        public List setOauthToken(java.lang.String oauthToken) {
          return (List) super.setOauthToken(oauthToken);
        }

        @Override
        public List setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (List) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public List setQuotaUser(java.lang.String quotaUser) {
          return (List) super.setQuotaUser(quotaUser);
        }

        @Override
        public List setUploadType(java.lang.String uploadType) {
          return (List) super.setUploadType(uploadType);
        }

        @Override
        public List setUploadProtocol(java.lang.String uploadProtocol) {
          return (List) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which
         * to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER] This names the
         * container in which to look for the notification channels; it does not name a specific
         * channel. To query a specific channel by REST resource name, use the
         * GetNotificationChannel operation.
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       the request. The format is: projects/[PROJECT_ID_OR_NUMBER] This names the container in which to
       look for the notification channels; it does not name a specific channel. To query a specific
       channel by REST resource name, use the GetNotificationChannel operation.
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which
         * to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER] This names the
         * container in which to look for the notification channels; it does not name a specific
         * channel. To query a specific channel by REST resource name, use the
         * GetNotificationChannel operation.
         */
        public List setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /**
         * If provided, this field specifies the criteria that must be met by notification channels
         * to be included in the response.For more details, see sorting and filtering
         * (https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
         */
        @com.google.api.client.util.Key
        private java.lang.String filter;

        /** If provided, this field specifies the criteria that must be met by notification channels to be
       included in the response.For more details, see sorting and filtering
       (https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
         */
        public java.lang.String getFilter() {
          return filter;
        }

        /**
         * If provided, this field specifies the criteria that must be met by notification channels
         * to be included in the response.For more details, see sorting and filtering
         * (https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
         */
        public List setFilter(java.lang.String filter) {
          this.filter = filter;
          return this;
        }

        /**
         * A comma-separated list of fields by which to sort the result. Supports the same set of
         * fields as in filter. Entries can be prefixed with a minus sign to sort in descending
         * rather than ascending order.For more details, see sorting and filtering
         * (https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
         */
        @com.google.api.client.util.Key
        private java.lang.String orderBy;

        /** A comma-separated list of fields by which to sort the result. Supports the same set of fields as in
       filter. Entries can be prefixed with a minus sign to sort in descending rather than ascending
       order.For more details, see sorting and filtering (https://cloud.google.com/monitoring/api/v3
       /sorting-and-filtering).
         */
        public java.lang.String getOrderBy() {
          return orderBy;
        }

        /**
         * A comma-separated list of fields by which to sort the result. Supports the same set of
         * fields as in filter. Entries can be prefixed with a minus sign to sort in descending
         * rather than ascending order.For more details, see sorting and filtering
         * (https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
         */
        public List setOrderBy(java.lang.String orderBy) {
          this.orderBy = orderBy;
          return this;
        }

        /**
         * The maximum number of results to return in a single response. If not set to a positive
         * number, a reasonable value will be chosen by the service.
         */
        @com.google.api.client.util.Key
        private java.lang.Integer pageSize;

        /** The maximum number of results to return in a single response. If not set to a positive number, a
       reasonable value will be chosen by the service.
         */
        public java.lang.Integer getPageSize() {
          return pageSize;
        }

        /**
         * The maximum number of results to return in a single response. If not set to a positive
         * number, a reasonable value will be chosen by the service.
         */
        public List setPageSize(java.lang.Integer pageSize) {
          this.pageSize = pageSize;
          return this;
        }

        /**
         * If non-empty, page_token must contain a value returned as the next_page_token in a
         * previous response to request the next set of results.
         */
        @com.google.api.client.util.Key
        private java.lang.String pageToken;

        /** If non-empty, page_token must contain a value returned as the next_page_token in a previous
       response to request the next set of results.
         */
        public java.lang.String getPageToken() {
          return pageToken;
        }

        /**
         * If non-empty, page_token must contain a value returned as the next_page_token in a
         * previous response to request the next set of results.
         */
        public List setPageToken(java.lang.String pageToken) {
          this.pageToken = pageToken;
          return this;
        }

        @Override
        public List set(String parameterName, Object value) {
          return (List) super.set(parameterName, value);
        }
      }
      /**
       * Updates a notification channel. Fields not specified in the field mask remain unchanged.Design
       * your application to single-thread API calls that modify the state of notification channels in a
       * single project. This includes calls to CreateNotificationChannel, DeleteNotificationChannel and
       * UpdateNotificationChannel.
       *
       * Create a request for the method "notificationChannels.patch".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Patch#execute()} method to invoke the remote operation.
       *
       * @param name The full REST resource name for this channel. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID] The [CHANNEL_ID] is
       *        automatically assigned by the server on creation.
       * @param content the {@link com.google.api.services.monitoring.v3.model.NotificationChannel}
       * @return the request
       */
      public Patch patch(java.lang.String name, com.google.api.services.monitoring.v3.model.NotificationChannel content) throws java.io.IOException {
        Patch result = new Patch(name, content);
        initialize(result);
        return result;
      }

      public class Patch extends MonitoringRequest<com.google.api.services.monitoring.v3.model.NotificationChannel> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/notificationChannels/[^/]+$");

        /**
         * Updates a notification channel. Fields not specified in the field mask remain unchanged.Design
         * your application to single-thread API calls that modify the state of notification channels in a
         * single project. This includes calls to CreateNotificationChannel, DeleteNotificationChannel and
         * UpdateNotificationChannel.
         *
         * Create a request for the method "notificationChannels.patch".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Patch#execute()} method to invoke the remote operation.
         * <p> {@link
         * Patch#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name The full REST resource name for this channel. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID] The [CHANNEL_ID] is
       *        automatically assigned by the server on creation.
         * @param content the {@link com.google.api.services.monitoring.v3.model.NotificationChannel}
         * @since 1.13
         */
        protected Patch(java.lang.String name, com.google.api.services.monitoring.v3.model.NotificationChannel content) {
          super(Monitoring.this, "PATCH", REST_PATH, content, com.google.api.services.monitoring.v3.model.NotificationChannel.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/notificationChannels/[^/]+$");
          }
        }

        @Override
        public Patch set$Xgafv(java.lang.String $Xgafv) {
          return (Patch) super.set$Xgafv($Xgafv);
        }

        @Override
        public Patch setAccessToken(java.lang.String accessToken) {
          return (Patch) super.setAccessToken(accessToken);
        }

        @Override
        public Patch setAlt(java.lang.String alt) {
          return (Patch) super.setAlt(alt);
        }

        @Override
        public Patch setCallback(java.lang.String callback) {
          return (Patch) super.setCallback(callback);
        }

        @Override
        public Patch setFields(java.lang.String fields) {
          return (Patch) super.setFields(fields);
        }

        @Override
        public Patch setKey(java.lang.String key) {
          return (Patch) super.setKey(key);
        }

        @Override
        public Patch setOauthToken(java.lang.String oauthToken) {
          return (Patch) super.setOauthToken(oauthToken);
        }

        @Override
        public Patch setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Patch) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Patch setQuotaUser(java.lang.String quotaUser) {
          return (Patch) super.setQuotaUser(quotaUser);
        }

        @Override
        public Patch setUploadType(java.lang.String uploadType) {
          return (Patch) super.setUploadType(uploadType);
        }

        @Override
        public Patch setUploadProtocol(java.lang.String uploadProtocol) {
          return (Patch) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * The full REST resource name for this channel. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID] The [CHANNEL_ID] is
         * automatically assigned by the server on creation.
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** The full REST resource name for this channel. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID] The [CHANNEL_ID] is automatically
       assigned by the server on creation.
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * The full REST resource name for this channel. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID] The [CHANNEL_ID] is
         * automatically assigned by the server on creation.
         */
        public Patch setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/notificationChannels/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /** The fields to update. */
        @com.google.api.client.util.Key
        private String updateMask;

        /** The fields to update.
         */
        public String getUpdateMask() {
          return updateMask;
        }

        /** The fields to update. */
        public Patch setUpdateMask(String updateMask) {
          this.updateMask = updateMask;
          return this;
        }

        @Override
        public Patch set(String parameterName, Object value) {
          return (Patch) super.set(parameterName, value);
        }
      }
      /**
       * Causes a verification code to be delivered to the channel. The code can then be supplied in
       * VerifyNotificationChannel to verify the channel.
       *
       * Create a request for the method "notificationChannels.sendVerificationCode".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link SendVerificationCode#execute()} method to invoke the remote
       * operation.
       *
       * @param name Required. The notification channel to which to send a verification code.
       * @param content the {@link com.google.api.services.monitoring.v3.model.SendNotificationChannelVerificationCodeRequest}
       * @return the request
       */
      public SendVerificationCode sendVerificationCode(java.lang.String name, com.google.api.services.monitoring.v3.model.SendNotificationChannelVerificationCodeRequest content) throws java.io.IOException {
        SendVerificationCode result = new SendVerificationCode(name, content);
        initialize(result);
        return result;
      }

      public class SendVerificationCode extends MonitoringRequest<com.google.api.services.monitoring.v3.model.Empty> {

        private static final String REST_PATH = "v3/{+name}:sendVerificationCode";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/notificationChannels/[^/]+$");

        /**
         * Causes a verification code to be delivered to the channel. The code can then be supplied in
         * VerifyNotificationChannel to verify the channel.
         *
         * Create a request for the method "notificationChannels.sendVerificationCode".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link SendVerificationCode#execute()} method to invoke the
         * remote operation. <p> {@link SendVerificationCode#initialize(com.google.api.client.googleapis.s
         * ervices.AbstractGoogleClientRequest)} must be called to initialize this instance immediately
         * after invoking the constructor. </p>
         *
         * @param name Required. The notification channel to which to send a verification code.
         * @param content the {@link com.google.api.services.monitoring.v3.model.SendNotificationChannelVerificationCodeRequest}
         * @since 1.13
         */
        protected SendVerificationCode(java.lang.String name, com.google.api.services.monitoring.v3.model.SendNotificationChannelVerificationCodeRequest content) {
          super(Monitoring.this, "POST", REST_PATH, content, com.google.api.services.monitoring.v3.model.Empty.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/notificationChannels/[^/]+$");
          }
        }

        @Override
        public SendVerificationCode set$Xgafv(java.lang.String $Xgafv) {
          return (SendVerificationCode) super.set$Xgafv($Xgafv);
        }

        @Override
        public SendVerificationCode setAccessToken(java.lang.String accessToken) {
          return (SendVerificationCode) super.setAccessToken(accessToken);
        }

        @Override
        public SendVerificationCode setAlt(java.lang.String alt) {
          return (SendVerificationCode) super.setAlt(alt);
        }

        @Override
        public SendVerificationCode setCallback(java.lang.String callback) {
          return (SendVerificationCode) super.setCallback(callback);
        }

        @Override
        public SendVerificationCode setFields(java.lang.String fields) {
          return (SendVerificationCode) super.setFields(fields);
        }

        @Override
        public SendVerificationCode setKey(java.lang.String key) {
          return (SendVerificationCode) super.setKey(key);
        }

        @Override
        public SendVerificationCode setOauthToken(java.lang.String oauthToken) {
          return (SendVerificationCode) super.setOauthToken(oauthToken);
        }

        @Override
        public SendVerificationCode setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (SendVerificationCode) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public SendVerificationCode setQuotaUser(java.lang.String quotaUser) {
          return (SendVerificationCode) super.setQuotaUser(quotaUser);
        }

        @Override
        public SendVerificationCode setUploadType(java.lang.String uploadType) {
          return (SendVerificationCode) super.setUploadType(uploadType);
        }

        @Override
        public SendVerificationCode setUploadProtocol(java.lang.String uploadProtocol) {
          return (SendVerificationCode) super.setUploadProtocol(uploadProtocol);
        }

        /** Required. The notification channel to which to send a verification code. */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The notification channel to which to send a verification code.
         */
        public java.lang.String getName() {
          return name;
        }

        /** Required. The notification channel to which to send a verification code. */
        public SendVerificationCode setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/notificationChannels/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public SendVerificationCode set(String parameterName, Object value) {
          return (SendVerificationCode) super.set(parameterName, value);
        }
      }
      /**
       * Verifies a NotificationChannel by proving receipt of the code delivered to the channel as a
       * result of calling SendNotificationChannelVerificationCode.
       *
       * Create a request for the method "notificationChannels.verify".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Verify#execute()} method to invoke the remote operation.
       *
       * @param name Required. The notification channel to verify.
       * @param content the {@link com.google.api.services.monitoring.v3.model.VerifyNotificationChannelRequest}
       * @return the request
       */
      public Verify verify(java.lang.String name, com.google.api.services.monitoring.v3.model.VerifyNotificationChannelRequest content) throws java.io.IOException {
        Verify result = new Verify(name, content);
        initialize(result);
        return result;
      }

      public class Verify extends MonitoringRequest<com.google.api.services.monitoring.v3.model.NotificationChannel> {

        private static final String REST_PATH = "v3/{+name}:verify";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/notificationChannels/[^/]+$");

        /**
         * Verifies a NotificationChannel by proving receipt of the code delivered to the channel as a
         * result of calling SendNotificationChannelVerificationCode.
         *
         * Create a request for the method "notificationChannels.verify".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Verify#execute()} method to invoke the remote operation.
         * <p> {@link
         * Verify#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The notification channel to verify.
         * @param content the {@link com.google.api.services.monitoring.v3.model.VerifyNotificationChannelRequest}
         * @since 1.13
         */
        protected Verify(java.lang.String name, com.google.api.services.monitoring.v3.model.VerifyNotificationChannelRequest content) {
          super(Monitoring.this, "POST", REST_PATH, content, com.google.api.services.monitoring.v3.model.NotificationChannel.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/notificationChannels/[^/]+$");
          }
        }

        @Override
        public Verify set$Xgafv(java.lang.String $Xgafv) {
          return (Verify) super.set$Xgafv($Xgafv);
        }

        @Override
        public Verify setAccessToken(java.lang.String accessToken) {
          return (Verify) super.setAccessToken(accessToken);
        }

        @Override
        public Verify setAlt(java.lang.String alt) {
          return (Verify) super.setAlt(alt);
        }

        @Override
        public Verify setCallback(java.lang.String callback) {
          return (Verify) super.setCallback(callback);
        }

        @Override
        public Verify setFields(java.lang.String fields) {
          return (Verify) super.setFields(fields);
        }

        @Override
        public Verify setKey(java.lang.String key) {
          return (Verify) super.setKey(key);
        }

        @Override
        public Verify setOauthToken(java.lang.String oauthToken) {
          return (Verify) super.setOauthToken(oauthToken);
        }

        @Override
        public Verify setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Verify) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Verify setQuotaUser(java.lang.String quotaUser) {
          return (Verify) super.setQuotaUser(quotaUser);
        }

        @Override
        public Verify setUploadType(java.lang.String uploadType) {
          return (Verify) super.setUploadType(uploadType);
        }

        @Override
        public Verify setUploadProtocol(java.lang.String uploadProtocol) {
          return (Verify) super.setUploadProtocol(uploadProtocol);
        }

        /** Required. The notification channel to verify. */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The notification channel to verify.
         */
        public java.lang.String getName() {
          return name;
        }

        /** Required. The notification channel to verify. */
        public Verify setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/notificationChannels/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Verify set(String parameterName, Object value) {
          return (Verify) super.set(parameterName, value);
        }
      }

    }
    /**
     * An accessor for creating requests from the Snoozes collection.
     *
     * <p>The typical use is:</p>
     * <pre>
     *   {@code Monitoring monitoring = new Monitoring(...);}
     *   {@code Monitoring.Snoozes.List request = monitoring.snoozes().list(parameters ...)}
     * </pre>
     *
     * @return the resource collection
     */
    public Snoozes snoozes() {
      return new Snoozes();
    }

    /**
     * The "snoozes" collection of methods.
     */
    public class Snoozes {

      /**
       * Creates a Snooze that will prevent alerts, which match the provided criteria, from being opened.
       * The Snooze applies for a specific time interval.
       *
       * Create a request for the method "snoozes.create".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Create#execute()} method to invoke the remote operation.
       *
       * @param parent Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which a Snooze
       *        should be created. The format is: projects/[PROJECT_ID_OR_NUMBER]
       * @param content the {@link com.google.api.services.monitoring.v3.model.Snooze}
       * @return the request
       */
      public Create create(java.lang.String parent, com.google.api.services.monitoring.v3.model.Snooze content) throws java.io.IOException {
        Create result = new Create(parent, content);
        initialize(result);
        return result;
      }

      public class Create extends MonitoringRequest<com.google.api.services.monitoring.v3.model.Snooze> {

        private static final String REST_PATH = "v3/{+parent}/snoozes";

        private final java.util.regex.Pattern PARENT_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Creates a Snooze that will prevent alerts, which match the provided criteria, from being
         * opened. The Snooze applies for a specific time interval.
         *
         * Create a request for the method "snoozes.create".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
         * <p> {@link
         * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param parent Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which a Snooze
       *        should be created. The format is: projects/[PROJECT_ID_OR_NUMBER]
         * @param content the {@link com.google.api.services.monitoring.v3.model.Snooze}
         * @since 1.13
         */
        protected Create(java.lang.String parent, com.google.api.services.monitoring.v3.model.Snooze content) {
          super(Monitoring.this, "POST", REST_PATH, content, com.google.api.services.monitoring.v3.model.Snooze.class);
          this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                "Parameter parent must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public Create set$Xgafv(java.lang.String $Xgafv) {
          return (Create) super.set$Xgafv($Xgafv);
        }

        @Override
        public Create setAccessToken(java.lang.String accessToken) {
          return (Create) super.setAccessToken(accessToken);
        }

        @Override
        public Create setAlt(java.lang.String alt) {
          return (Create) super.setAlt(alt);
        }

        @Override
        public Create setCallback(java.lang.String callback) {
          return (Create) super.setCallback(callback);
        }

        @Override
        public Create setFields(java.lang.String fields) {
          return (Create) super.setFields(fields);
        }

        @Override
        public Create setKey(java.lang.String key) {
          return (Create) super.setKey(key);
        }

        @Override
        public Create setOauthToken(java.lang.String oauthToken) {
          return (Create) super.setOauthToken(oauthToken);
        }

        @Override
        public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Create) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Create setQuotaUser(java.lang.String quotaUser) {
          return (Create) super.setQuotaUser(quotaUser);
        }

        @Override
        public Create setUploadType(java.lang.String uploadType) {
          return (Create) super.setUploadType(uploadType);
        }

        @Override
        public Create setUploadProtocol(java.lang.String uploadProtocol) {
          return (Create) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which
         * a Snooze should be created. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        @com.google.api.client.util.Key
        private java.lang.String parent;

        /** Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which a Snooze
       should be created. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public java.lang.String getParent() {
          return parent;
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which
         * a Snooze should be created. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public Create setParent(java.lang.String parent) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                "Parameter parent must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.parent = parent;
          return this;
        }

        @Override
        public Create set(String parameterName, Object value) {
          return (Create) super.set(parameterName, value);
        }
      }
      /**
       * Retrieves a Snooze by name.
       *
       * Create a request for the method "snoozes.get".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Get#execute()} method to invoke the remote operation.
       *
       * @param name Required. The ID of the Snooze to retrieve. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/snoozes/[SNOOZE_ID]
       * @return the request
       */
      public Get get(java.lang.String name) throws java.io.IOException {
        Get result = new Get(name);
        initialize(result);
        return result;
      }

      public class Get extends MonitoringRequest<com.google.api.services.monitoring.v3.model.Snooze> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/snoozes/[^/]+$");

        /**
         * Retrieves a Snooze by name.
         *
         * Create a request for the method "snoozes.get".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
         * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The ID of the Snooze to retrieve. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/snoozes/[SNOOZE_ID]
         * @since 1.13
         */
        protected Get(java.lang.String name) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.Snooze.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/snoozes/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public Get set$Xgafv(java.lang.String $Xgafv) {
          return (Get) super.set$Xgafv($Xgafv);
        }

        @Override
        public Get setAccessToken(java.lang.String accessToken) {
          return (Get) super.setAccessToken(accessToken);
        }

        @Override
        public Get setAlt(java.lang.String alt) {
          return (Get) super.setAlt(alt);
        }

        @Override
        public Get setCallback(java.lang.String callback) {
          return (Get) super.setCallback(callback);
        }

        @Override
        public Get setFields(java.lang.String fields) {
          return (Get) super.setFields(fields);
        }

        @Override
        public Get setKey(java.lang.String key) {
          return (Get) super.setKey(key);
        }

        @Override
        public Get setOauthToken(java.lang.String oauthToken) {
          return (Get) super.setOauthToken(oauthToken);
        }

        @Override
        public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Get) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Get setQuotaUser(java.lang.String quotaUser) {
          return (Get) super.setQuotaUser(quotaUser);
        }

        @Override
        public Get setUploadType(java.lang.String uploadType) {
          return (Get) super.setUploadType(uploadType);
        }

        @Override
        public Get setUploadProtocol(java.lang.String uploadProtocol) {
          return (Get) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The ID of the Snooze to retrieve. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/snoozes/[SNOOZE_ID]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The ID of the Snooze to retrieve. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/snoozes/[SNOOZE_ID]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The ID of the Snooze to retrieve. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/snoozes/[SNOOZE_ID]
         */
        public Get setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/snoozes/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Get set(String parameterName, Object value) {
          return (Get) super.set(parameterName, value);
        }
      }
      /**
       * Lists the Snoozes associated with a project. Can optionally pass in filter, which specifies
       * predicates to match Snoozes.
       *
       * Create a request for the method "snoozes.list".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link List#execute()} method to invoke the remote operation.
       *
       * @param parent Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose Snoozes should
       *        be listed. The format is: projects/[PROJECT_ID_OR_NUMBER]
       * @return the request
       */
      public List list(java.lang.String parent) throws java.io.IOException {
        List result = new List(parent);
        initialize(result);
        return result;
      }

      public class List extends MonitoringRequest<com.google.api.services.monitoring.v3.model.ListSnoozesResponse> {

        private static final String REST_PATH = "v3/{+parent}/snoozes";

        private final java.util.regex.Pattern PARENT_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Lists the Snoozes associated with a project. Can optionally pass in filter, which specifies
         * predicates to match Snoozes.
         *
         * Create a request for the method "snoozes.list".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
         * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param parent Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose Snoozes should
       *        be listed. The format is: projects/[PROJECT_ID_OR_NUMBER]
         * @since 1.13
         */
        protected List(java.lang.String parent) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.ListSnoozesResponse.class);
          this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                "Parameter parent must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public List set$Xgafv(java.lang.String $Xgafv) {
          return (List) super.set$Xgafv($Xgafv);
        }

        @Override
        public List setAccessToken(java.lang.String accessToken) {
          return (List) super.setAccessToken(accessToken);
        }

        @Override
        public List setAlt(java.lang.String alt) {
          return (List) super.setAlt(alt);
        }

        @Override
        public List setCallback(java.lang.String callback) {
          return (List) super.setCallback(callback);
        }

        @Override
        public List setFields(java.lang.String fields) {
          return (List) super.setFields(fields);
        }

        @Override
        public List setKey(java.lang.String key) {
          return (List) super.setKey(key);
        }

        @Override
        public List setOauthToken(java.lang.String oauthToken) {
          return (List) super.setOauthToken(oauthToken);
        }

        @Override
        public List setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (List) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public List setQuotaUser(java.lang.String quotaUser) {
          return (List) super.setQuotaUser(quotaUser);
        }

        @Override
        public List setUploadType(java.lang.String uploadType) {
          return (List) super.setUploadType(uploadType);
        }

        @Override
        public List setUploadProtocol(java.lang.String uploadProtocol) {
          return (List) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose
         * Snoozes should be listed. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        @com.google.api.client.util.Key
        private java.lang.String parent;

        /** Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose Snoozes
       should be listed. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public java.lang.String getParent() {
          return parent;
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose
         * Snoozes should be listed. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public List setParent(java.lang.String parent) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                "Parameter parent must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.parent = parent;
          return this;
        }

        /**
         * Optional. Optional filter to restrict results to the given criteria. The following fields
         * are supported. interval.start_time interval.end_timeFor example: ``` interval.start_time
         * > "2022-03-11T00:00:00-08:00" AND interval.end_time < "2022-03-12T00:00:00-08:00" ```
         */
        @com.google.api.client.util.Key
        private java.lang.String filter;

        /** Optional. Optional filter to restrict results to the given criteria. The following fields are
       supported. interval.start_time interval.end_timeFor example: ``` interval.start_time >
       "2022-03-11T00:00:00-08:00" AND interval.end_time < "2022-03-12T00:00:00-08:00" ```
         */
        public java.lang.String getFilter() {
          return filter;
        }

        /**
         * Optional. Optional filter to restrict results to the given criteria. The following fields
         * are supported. interval.start_time interval.end_timeFor example: ``` interval.start_time
         * > "2022-03-11T00:00:00-08:00" AND interval.end_time < "2022-03-12T00:00:00-08:00" ```
         */
        public List setFilter(java.lang.String filter) {
          this.filter = filter;
          return this;
        }

        /**
         * Optional. The maximum number of results to return for a single query. The server may
         * further constrain the maximum number of results returned in a single page. The value
         * should be in the range 1, 1000. If the value given is outside this range, the server will
         * decide the number of results to be returned.
         */
        @com.google.api.client.util.Key
        private java.lang.Integer pageSize;

        /** Optional. The maximum number of results to return for a single query. The server may further
       constrain the maximum number of results returned in a single page. The value should be in the range
       1, 1000. If the value given is outside this range, the server will decide the number of results to
       be returned.
         */
        public java.lang.Integer getPageSize() {
          return pageSize;
        }

        /**
         * Optional. The maximum number of results to return for a single query. The server may
         * further constrain the maximum number of results returned in a single page. The value
         * should be in the range 1, 1000. If the value given is outside this range, the server will
         * decide the number of results to be returned.
         */
        public List setPageSize(java.lang.Integer pageSize) {
          this.pageSize = pageSize;
          return this;
        }

        /**
         * Optional. The next_page_token from a previous call to ListSnoozesRequest to get the next
         * page of results.
         */
        @com.google.api.client.util.Key
        private java.lang.String pageToken;

        /** Optional. The next_page_token from a previous call to ListSnoozesRequest to get the next page of
       results.
         */
        public java.lang.String getPageToken() {
          return pageToken;
        }

        /**
         * Optional. The next_page_token from a previous call to ListSnoozesRequest to get the next
         * page of results.
         */
        public List setPageToken(java.lang.String pageToken) {
          this.pageToken = pageToken;
          return this;
        }

        @Override
        public List set(String parameterName, Object value) {
          return (List) super.set(parameterName, value);
        }
      }
      /**
       * Updates a Snooze, identified by its name, with the parameters in the given Snooze object.
       *
       * Create a request for the method "snoozes.patch".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Patch#execute()} method to invoke the remote operation.
       *
       * @param name Required. The name of the Snooze. The format is: projects/[PROJECT_ID_OR_NUMBER]/snoozes/[SNOOZE_ID]
       *        The ID of the Snooze will be generated by the system.
       * @param content the {@link com.google.api.services.monitoring.v3.model.Snooze}
       * @return the request
       */
      public Patch patch(java.lang.String name, com.google.api.services.monitoring.v3.model.Snooze content) throws java.io.IOException {
        Patch result = new Patch(name, content);
        initialize(result);
        return result;
      }

      public class Patch extends MonitoringRequest<com.google.api.services.monitoring.v3.model.Snooze> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/snoozes/[^/]+$");

        /**
         * Updates a Snooze, identified by its name, with the parameters in the given Snooze object.
         *
         * Create a request for the method "snoozes.patch".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Patch#execute()} method to invoke the remote operation.
         * <p> {@link
         * Patch#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The name of the Snooze. The format is: projects/[PROJECT_ID_OR_NUMBER]/snoozes/[SNOOZE_ID]
       *        The ID of the Snooze will be generated by the system.
         * @param content the {@link com.google.api.services.monitoring.v3.model.Snooze}
         * @since 1.13
         */
        protected Patch(java.lang.String name, com.google.api.services.monitoring.v3.model.Snooze content) {
          super(Monitoring.this, "PATCH", REST_PATH, content, com.google.api.services.monitoring.v3.model.Snooze.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/snoozes/[^/]+$");
          }
        }

        @Override
        public Patch set$Xgafv(java.lang.String $Xgafv) {
          return (Patch) super.set$Xgafv($Xgafv);
        }

        @Override
        public Patch setAccessToken(java.lang.String accessToken) {
          return (Patch) super.setAccessToken(accessToken);
        }

        @Override
        public Patch setAlt(java.lang.String alt) {
          return (Patch) super.setAlt(alt);
        }

        @Override
        public Patch setCallback(java.lang.String callback) {
          return (Patch) super.setCallback(callback);
        }

        @Override
        public Patch setFields(java.lang.String fields) {
          return (Patch) super.setFields(fields);
        }

        @Override
        public Patch setKey(java.lang.String key) {
          return (Patch) super.setKey(key);
        }

        @Override
        public Patch setOauthToken(java.lang.String oauthToken) {
          return (Patch) super.setOauthToken(oauthToken);
        }

        @Override
        public Patch setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Patch) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Patch setQuotaUser(java.lang.String quotaUser) {
          return (Patch) super.setQuotaUser(quotaUser);
        }

        @Override
        public Patch setUploadType(java.lang.String uploadType) {
          return (Patch) super.setUploadType(uploadType);
        }

        @Override
        public Patch setUploadProtocol(java.lang.String uploadProtocol) {
          return (Patch) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The name of the Snooze. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/snoozes/[SNOOZE_ID] The ID of the Snooze will be
         * generated by the system.
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The name of the Snooze. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/snoozes/[SNOOZE_ID] The ID of the Snooze will be generated by the
       system.
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The name of the Snooze. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/snoozes/[SNOOZE_ID] The ID of the Snooze will be
         * generated by the system.
         */
        public Patch setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/snoozes/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /**
         * Required. The fields to update.For each field listed in update_mask: If the Snooze object
         * supplied in the UpdateSnoozeRequest has a value for that field, the value of the field in
         * the existing Snooze will be set to the value of the field in the supplied Snooze. If the
         * field does not have a value in the supplied Snooze, the field in the existing Snooze is
         * set to its default value.Fields not listed retain their existing value.The following are
         * the field names that are accepted in update_mask: display_name interval.start_time
         * interval.end_timeThat said, the start time and end time of the Snooze determines which
         * fields can legally be updated. Before attempting an update, users should consult the
         * documentation for UpdateSnoozeRequest, which talks about which fields can be updated.
         */
        @com.google.api.client.util.Key
        private String updateMask;

        /** Required. The fields to update.For each field listed in update_mask: If the Snooze object supplied
       in the UpdateSnoozeRequest has a value for that field, the value of the field in the existing
       Snooze will be set to the value of the field in the supplied Snooze. If the field does not have a
       value in the supplied Snooze, the field in the existing Snooze is set to its default value.Fields
       not listed retain their existing value.The following are the field names that are accepted in
       update_mask: display_name interval.start_time interval.end_timeThat said, the start time and end
       time of the Snooze determines which fields can legally be updated. Before attempting an update,
       users should consult the documentation for UpdateSnoozeRequest, which talks about which fields can
       be updated.
         */
        public String getUpdateMask() {
          return updateMask;
        }

        /**
         * Required. The fields to update.For each field listed in update_mask: If the Snooze object
         * supplied in the UpdateSnoozeRequest has a value for that field, the value of the field in
         * the existing Snooze will be set to the value of the field in the supplied Snooze. If the
         * field does not have a value in the supplied Snooze, the field in the existing Snooze is
         * set to its default value.Fields not listed retain their existing value.The following are
         * the field names that are accepted in update_mask: display_name interval.start_time
         * interval.end_timeThat said, the start time and end time of the Snooze determines which
         * fields can legally be updated. Before attempting an update, users should consult the
         * documentation for UpdateSnoozeRequest, which talks about which fields can be updated.
         */
        public Patch setUpdateMask(String updateMask) {
          this.updateMask = updateMask;
          return this;
        }

        @Override
        public Patch set(String parameterName, Object value) {
          return (Patch) super.set(parameterName, value);
        }
      }

    }
    /**
     * An accessor for creating requests from the TimeSeries collection.
     *
     * <p>The typical use is:</p>
     * <pre>
     *   {@code Monitoring monitoring = new Monitoring(...);}
     *   {@code Monitoring.TimeSeries.List request = monitoring.timeSeries().list(parameters ...)}
     * </pre>
     *
     * @return the resource collection
     */
    public TimeSeries timeSeries() {
      return new TimeSeries();
    }

    /**
     * The "timeSeries" collection of methods.
     */
    public class TimeSeries {

      /**
       * Creates or adds data to one or more time series. The response is empty if all time series in the
       * request were written. If any time series could not be written, a corresponding failure message is
       * included in the error response. This method does not support resource locations constraint of an
       * organization policy (https://cloud.google.com/resource-manager/docs/organization-policy/defining-
       * locations#setting_the_organization_policy).
       *
       * Create a request for the method "timeSeries.create".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Create#execute()} method to invoke the remote operation.
       *
       * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       *        the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
       * @param content the {@link com.google.api.services.monitoring.v3.model.CreateTimeSeriesRequest}
       * @return the request
       */
      public Create create(java.lang.String name, com.google.api.services.monitoring.v3.model.CreateTimeSeriesRequest content) throws java.io.IOException {
        Create result = new Create(name, content);
        initialize(result);
        return result;
      }

      public class Create extends MonitoringRequest<com.google.api.services.monitoring.v3.model.Empty> {

        private static final String REST_PATH = "v3/{+name}/timeSeries";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Creates or adds data to one or more time series. The response is empty if all time series in
         * the request were written. If any time series could not be written, a corresponding failure
         * message is included in the error response. This method does not support resource locations
         * constraint of an organization policy (https://cloud.google.com/resource-manager/docs
         * /organization-policy/defining-locations#setting_the_organization_policy).
         *
         * Create a request for the method "timeSeries.create".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
         * <p> {@link
         * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       *        the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         * @param content the {@link com.google.api.services.monitoring.v3.model.CreateTimeSeriesRequest}
         * @since 1.13
         */
        protected Create(java.lang.String name, com.google.api.services.monitoring.v3.model.CreateTimeSeriesRequest content) {
          super(Monitoring.this, "POST", REST_PATH, content, com.google.api.services.monitoring.v3.model.Empty.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public Create set$Xgafv(java.lang.String $Xgafv) {
          return (Create) super.set$Xgafv($Xgafv);
        }

        @Override
        public Create setAccessToken(java.lang.String accessToken) {
          return (Create) super.setAccessToken(accessToken);
        }

        @Override
        public Create setAlt(java.lang.String alt) {
          return (Create) super.setAlt(alt);
        }

        @Override
        public Create setCallback(java.lang.String callback) {
          return (Create) super.setCallback(callback);
        }

        @Override
        public Create setFields(java.lang.String fields) {
          return (Create) super.setFields(fields);
        }

        @Override
        public Create setKey(java.lang.String key) {
          return (Create) super.setKey(key);
        }

        @Override
        public Create setOauthToken(java.lang.String oauthToken) {
          return (Create) super.setOauthToken(oauthToken);
        }

        @Override
        public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Create) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Create setQuotaUser(java.lang.String quotaUser) {
          return (Create) super.setQuotaUser(quotaUser);
        }

        @Override
        public Create setUploadType(java.lang.String uploadType) {
          return (Create) super.setUploadType(uploadType);
        }

        @Override
        public Create setUploadProtocol(java.lang.String uploadProtocol) {
          return (Create) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which
         * to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which
         * to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public Create setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Create set(String parameterName, Object value) {
          return (Create) super.set(parameterName, value);
        }
      }
      /**
       * Creates or adds data to one or more service time series. A service time series is a time series
       * for a metric from a Google Cloud service. The response is empty if all time series in the request
       * were written. If any time series could not be written, a corresponding failure message is
       * included in the error response. This endpoint rejects writes to user-defined metrics. This method
       * is only for use by Google Cloud services. Use projects.timeSeries.create instead.
       *
       * Create a request for the method "timeSeries.createService".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link CreateService#execute()} method to invoke the remote operation.
       *
       * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       *        the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
       * @param content the {@link com.google.api.services.monitoring.v3.model.CreateTimeSeriesRequest}
       * @return the request
       */
      public CreateService createService(java.lang.String name, com.google.api.services.monitoring.v3.model.CreateTimeSeriesRequest content) throws java.io.IOException {
        CreateService result = new CreateService(name, content);
        initialize(result);
        return result;
      }

      public class CreateService extends MonitoringRequest<com.google.api.services.monitoring.v3.model.Empty> {

        private static final String REST_PATH = "v3/{+name}/timeSeries:createService";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Creates or adds data to one or more service time series. A service time series is a time series
         * for a metric from a Google Cloud service. The response is empty if all time series in the
         * request were written. If any time series could not be written, a corresponding failure message
         * is included in the error response. This endpoint rejects writes to user-defined metrics. This
         * method is only for use by Google Cloud services. Use projects.timeSeries.create instead.
         *
         * Create a request for the method "timeSeries.createService".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link CreateService#execute()} method to invoke the remote
         * operation. <p> {@link CreateService#initialize(com.google.api.client.googleapis.services.Abstra
         * ctGoogleClientRequest)} must be called to initialize this instance immediately after invoking
         * the constructor. </p>
         *
         * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       *        the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         * @param content the {@link com.google.api.services.monitoring.v3.model.CreateTimeSeriesRequest}
         * @since 1.13
         */
        protected CreateService(java.lang.String name, com.google.api.services.monitoring.v3.model.CreateTimeSeriesRequest content) {
          super(Monitoring.this, "POST", REST_PATH, content, com.google.api.services.monitoring.v3.model.Empty.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public CreateService set$Xgafv(java.lang.String $Xgafv) {
          return (CreateService) super.set$Xgafv($Xgafv);
        }

        @Override
        public CreateService setAccessToken(java.lang.String accessToken) {
          return (CreateService) super.setAccessToken(accessToken);
        }

        @Override
        public CreateService setAlt(java.lang.String alt) {
          return (CreateService) super.setAlt(alt);
        }

        @Override
        public CreateService setCallback(java.lang.String callback) {
          return (CreateService) super.setCallback(callback);
        }

        @Override
        public CreateService setFields(java.lang.String fields) {
          return (CreateService) super.setFields(fields);
        }

        @Override
        public CreateService setKey(java.lang.String key) {
          return (CreateService) super.setKey(key);
        }

        @Override
        public CreateService setOauthToken(java.lang.String oauthToken) {
          return (CreateService) super.setOauthToken(oauthToken);
        }

        @Override
        public CreateService setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (CreateService) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public CreateService setQuotaUser(java.lang.String quotaUser) {
          return (CreateService) super.setQuotaUser(quotaUser);
        }

        @Override
        public CreateService setUploadType(java.lang.String uploadType) {
          return (CreateService) super.setUploadType(uploadType);
        }

        @Override
        public CreateService setUploadProtocol(java.lang.String uploadProtocol) {
          return (CreateService) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which
         * to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which
         * to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public CreateService setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public CreateService set(String parameterName, Object value) {
          return (CreateService) super.set(parameterName, value);
        }
      }
      /**
       * Lists time series that match a filter.
       *
       * Create a request for the method "timeSeries.list".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link List#execute()} method to invoke the remote operation.
       *
       * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name), organization or
       *        folder on which to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
       *        organizations/[ORGANIZATION_ID] folders/[FOLDER_ID]
       * @return the request
       */
      public List list(java.lang.String name) throws java.io.IOException {
        List result = new List(name);
        initialize(result);
        return result;
      }

      public class List extends MonitoringRequest<com.google.api.services.monitoring.v3.model.ListTimeSeriesResponse> {

        private static final String REST_PATH = "v3/{+name}/timeSeries";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Lists time series that match a filter.
         *
         * Create a request for the method "timeSeries.list".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
         * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name), organization or
       *        folder on which to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
       *        organizations/[ORGANIZATION_ID] folders/[FOLDER_ID]
         * @since 1.13
         */
        protected List(java.lang.String name) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.ListTimeSeriesResponse.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public List set$Xgafv(java.lang.String $Xgafv) {
          return (List) super.set$Xgafv($Xgafv);
        }

        @Override
        public List setAccessToken(java.lang.String accessToken) {
          return (List) super.setAccessToken(accessToken);
        }

        @Override
        public List setAlt(java.lang.String alt) {
          return (List) super.setAlt(alt);
        }

        @Override
        public List setCallback(java.lang.String callback) {
          return (List) super.setCallback(callback);
        }

        @Override
        public List setFields(java.lang.String fields) {
          return (List) super.setFields(fields);
        }

        @Override
        public List setKey(java.lang.String key) {
          return (List) super.setKey(key);
        }

        @Override
        public List setOauthToken(java.lang.String oauthToken) {
          return (List) super.setOauthToken(oauthToken);
        }

        @Override
        public List setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (List) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public List setQuotaUser(java.lang.String quotaUser) {
          return (List) super.setQuotaUser(quotaUser);
        }

        @Override
        public List setUploadType(java.lang.String uploadType) {
          return (List) super.setUploadType(uploadType);
        }

        @Override
        public List setUploadProtocol(java.lang.String uploadProtocol) {
          return (List) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name),
         * organization or folder on which to execute the request. The format is:
         * projects/[PROJECT_ID_OR_NUMBER] organizations/[ORGANIZATION_ID] folders/[FOLDER_ID]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The project (https://cloud.google.com/monitoring/api/v3#project_name), organization or
       folder on which to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
       organizations/[ORGANIZATION_ID] folders/[FOLDER_ID]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name),
         * organization or folder on which to execute the request. The format is:
         * projects/[PROJECT_ID_OR_NUMBER] organizations/[ORGANIZATION_ID] folders/[FOLDER_ID]
         */
        public List setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /**
         * The alignment_period specifies a time interval, in seconds, that is used to divide the
         * data in all the time series into consistent blocks of time. This will be done before the
         * per-series aligner can be applied to the data.The value must be at least 60 seconds. If a
         * per-series aligner other than ALIGN_NONE is specified, this field is required or an error
         * is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is
         * specified, then this field is ignored.The maximum value of the alignment_period is 104
         * weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
         */
        @com.google.api.client.util.Key("aggregation.alignmentPeriod")
        private String aggregationAlignmentPeriod;

        /** The alignment_period specifies a time interval, in seconds, that is used to divide the data in all
       the time series into consistent blocks of time. This will be done before the per-series aligner can
       be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than
       ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner
       is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value
       of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for
       alerting policies.
         */
        public String getAggregationAlignmentPeriod() {
          return aggregationAlignmentPeriod;
        }

        /**
         * The alignment_period specifies a time interval, in seconds, that is used to divide the
         * data in all the time series into consistent blocks of time. This will be done before the
         * per-series aligner can be applied to the data.The value must be at least 60 seconds. If a
         * per-series aligner other than ALIGN_NONE is specified, this field is required or an error
         * is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is
         * specified, then this field is ignored.The maximum value of the alignment_period is 104
         * weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
         */
        public List setAggregationAlignmentPeriod(String aggregationAlignmentPeriod) {
          this.aggregationAlignmentPeriod = aggregationAlignmentPeriod;
          return this;
        }

        /**
         * The reduction operation to be used to combine time series into a single time series,
         * where the value of each data point in the resulting series is a function of all the
         * already aligned values in the input time series.Not all reducer operations can be applied
         * to all time series. The valid choices depend on the metric_kind and the value_type of the
         * original time series. Reduction can yield a time series with a different metric_kind or
         * value_type than the input time series.Time series data must first be aligned (see
         * per_series_aligner) in order to perform cross-time series reduction. If
         * cross_series_reducer is specified, then per_series_aligner must be specified, and must
         * not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is
         * returned.
         */
        @com.google.api.client.util.Key("aggregation.crossSeriesReducer")
        private java.lang.String aggregationCrossSeriesReducer;

        /** The reduction operation to be used to combine time series into a single time series, where the
       value of each data point in the resulting series is a function of all the already aligned values in
       the input time series.Not all reducer operations can be applied to all time series. The valid
       choices depend on the metric_kind and the value_type of the original time series. Reduction can
       yield a time series with a different metric_kind or value_type than the input time series.Time
       series data must first be aligned (see per_series_aligner) in order to perform cross-time series
       reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and
       must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is
       returned.
         */
        public java.lang.String getAggregationCrossSeriesReducer() {
          return aggregationCrossSeriesReducer;
        }

        /**
         * The reduction operation to be used to combine time series into a single time series,
         * where the value of each data point in the resulting series is a function of all the
         * already aligned values in the input time series.Not all reducer operations can be applied
         * to all time series. The valid choices depend on the metric_kind and the value_type of the
         * original time series. Reduction can yield a time series with a different metric_kind or
         * value_type than the input time series.Time series data must first be aligned (see
         * per_series_aligner) in order to perform cross-time series reduction. If
         * cross_series_reducer is specified, then per_series_aligner must be specified, and must
         * not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is
         * returned.
         */
        public List setAggregationCrossSeriesReducer(java.lang.String aggregationCrossSeriesReducer) {
          this.aggregationCrossSeriesReducer = aggregationCrossSeriesReducer;
          return this;
        }

        /**
         * The set of fields to preserve when cross_series_reducer is specified. The group_by_fields
         * determine how the time series are partitioned into subsets prior to applying the
         * aggregation operation. Each subset contains time series that have the same value for each
         * of the grouping fields. Each individual time series is a member of exactly one subset.
         * The cross_series_reducer is applied to each subset of time series. It is not possible to
         * reduce across different resource types, so this field implicitly contains resource.type.
         * Fields not specified in group_by_fields are aggregated away. If group_by_fields is not
         * specified and all the time series have the same resource type, then the time series are
         * aggregated into a single output time series. If cross_series_reducer is not defined, this
         * field is ignored.
         */
        @com.google.api.client.util.Key("aggregation.groupByFields")
        private java.util.List<java.lang.String> aggregationGroupByFields;

        /** The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine
       how the time series are partitioned into subsets prior to applying the aggregation operation. Each
       subset contains time series that have the same value for each of the grouping fields. Each
       individual time series is a member of exactly one subset. The cross_series_reducer is applied to
       each subset of time series. It is not possible to reduce across different resource types, so this
       field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated
       away. If group_by_fields is not specified and all the time series have the same resource type, then
       the time series are aggregated into a single output time series. If cross_series_reducer is not
       defined, this field is ignored.
         */
        public java.util.List<java.lang.String> getAggregationGroupByFields() {
          return aggregationGroupByFields;
        }

        /**
         * The set of fields to preserve when cross_series_reducer is specified. The group_by_fields
         * determine how the time series are partitioned into subsets prior to applying the
         * aggregation operation. Each subset contains time series that have the same value for each
         * of the grouping fields. Each individual time series is a member of exactly one subset.
         * The cross_series_reducer is applied to each subset of time series. It is not possible to
         * reduce across different resource types, so this field implicitly contains resource.type.
         * Fields not specified in group_by_fields are aggregated away. If group_by_fields is not
         * specified and all the time series have the same resource type, then the time series are
         * aggregated into a single output time series. If cross_series_reducer is not defined, this
         * field is ignored.
         */
        public List setAggregationGroupByFields(java.util.List<java.lang.String> aggregationGroupByFields) {
          this.aggregationGroupByFields = aggregationGroupByFields;
          return this;
        }

        /**
         * An Aligner describes how to bring the data points in a single time series into temporal
         * alignment. Except for ALIGN_NONE, all alignments cause all the data points in an
         * alignment_period to be mathematically grouped together, resulting in a single data point
         * for each alignment_period with end timestamp at the end of the period.Not all alignment
         * operations may be applied to all time series. The valid choices depend on the metric_kind
         * and value_type of the original time series. Alignment can change the metric_kind or the
         * value_type of the time series.Time series data must be aligned in order to perform cross-
         * time series reduction. If cross_series_reducer is specified, then per_series_aligner must
         * be specified and not equal to ALIGN_NONE and alignment_period must be specified;
         * otherwise, an error is returned.
         */
        @com.google.api.client.util.Key("aggregation.perSeriesAligner")
        private java.lang.String aggregationPerSeriesAligner;

        /** An Aligner describes how to bring the data points in a single time series into temporal alignment.
       Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be
       mathematically grouped together, resulting in a single data point for each alignment_period with
       end timestamp at the end of the period.Not all alignment operations may be applied to all time
       series. The valid choices depend on the metric_kind and value_type of the original time series.
       Alignment can change the metric_kind or the value_type of the time series.Time series data must be
       aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then
       per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be
       specified; otherwise, an error is returned.
         */
        public java.lang.String getAggregationPerSeriesAligner() {
          return aggregationPerSeriesAligner;
        }

        /**
         * An Aligner describes how to bring the data points in a single time series into temporal
         * alignment. Except for ALIGN_NONE, all alignments cause all the data points in an
         * alignment_period to be mathematically grouped together, resulting in a single data point
         * for each alignment_period with end timestamp at the end of the period.Not all alignment
         * operations may be applied to all time series. The valid choices depend on the metric_kind
         * and value_type of the original time series. Alignment can change the metric_kind or the
         * value_type of the time series.Time series data must be aligned in order to perform cross-
         * time series reduction. If cross_series_reducer is specified, then per_series_aligner must
         * be specified and not equal to ALIGN_NONE and alignment_period must be specified;
         * otherwise, an error is returned.
         */
        public List setAggregationPerSeriesAligner(java.lang.String aggregationPerSeriesAligner) {
          this.aggregationPerSeriesAligner = aggregationPerSeriesAligner;
          return this;
        }

        /**
         * Required. A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that
         * specifies which time series should be returned. The filter must specify a single metric
         * type, and can additionally specify metric labels and other information. For example:
         * metric.type = "compute.googleapis.com/instance/cpu/usage_time" AND
         * metric.labels.instance_name = "my-instance-name"
         */
        @com.google.api.client.util.Key
        private java.lang.String filter;

        /** Required. A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that specifies
       which time series should be returned. The filter must specify a single metric type, and can
       additionally specify metric labels and other information. For example: metric.type =
       "compute.googleapis.com/instance/cpu/usage_time" AND metric.labels.instance_name = "my-instance-
       name"
         */
        public java.lang.String getFilter() {
          return filter;
        }

        /**
         * Required. A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that
         * specifies which time series should be returned. The filter must specify a single metric
         * type, and can additionally specify metric labels and other information. For example:
         * metric.type = "compute.googleapis.com/instance/cpu/usage_time" AND
         * metric.labels.instance_name = "my-instance-name"
         */
        public List setFilter(java.lang.String filter) {
          this.filter = filter;
          return this;
        }

        /** Required. The end of the time interval. */
        @com.google.api.client.util.Key("interval.endTime")
        private String intervalEndTime;

        /** Required. The end of the time interval.
         */
        public String getIntervalEndTime() {
          return intervalEndTime;
        }

        /** Required. The end of the time interval. */
        public List setIntervalEndTime(String intervalEndTime) {
          this.intervalEndTime = intervalEndTime;
          return this;
        }

        /**
         * Optional. The beginning of the time interval. The default value for the start time is the
         * end time. The start time must not be later than the end time.
         */
        @com.google.api.client.util.Key("interval.startTime")
        private String intervalStartTime;

        /** Optional. The beginning of the time interval. The default value for the start time is the end time.
       The start time must not be later than the end time.
         */
        public String getIntervalStartTime() {
          return intervalStartTime;
        }

        /**
         * Optional. The beginning of the time interval. The default value for the start time is the
         * end time. The start time must not be later than the end time.
         */
        public List setIntervalStartTime(String intervalStartTime) {
          this.intervalStartTime = intervalStartTime;
          return this;
        }

        /**
         * Unsupported: must be left blank. The points in each time series are currently returned in
         * reverse time order (most recent to oldest).
         */
        @com.google.api.client.util.Key
        private java.lang.String orderBy;

        /** Unsupported: must be left blank. The points in each time series are currently returned in reverse
       time order (most recent to oldest).
         */
        public java.lang.String getOrderBy() {
          return orderBy;
        }

        /**
         * Unsupported: must be left blank. The points in each time series are currently returned in
         * reverse time order (most recent to oldest).
         */
        public List setOrderBy(java.lang.String orderBy) {
          this.orderBy = orderBy;
          return this;
        }

        /**
         * A positive number that is the maximum number of results to return. If page_size is empty
         * or more than 100,000 results, the effective page_size is 100,000 results. If view is set
         * to FULL, this is the maximum number of Points returned. If view is set to HEADERS, this
         * is the maximum number of TimeSeries returned.
         */
        @com.google.api.client.util.Key
        private java.lang.Integer pageSize;

        /** A positive number that is the maximum number of results to return. If page_size is empty or more
       than 100,000 results, the effective page_size is 100,000 results. If view is set to FULL, this is
       the maximum number of Points returned. If view is set to HEADERS, this is the maximum number of
       TimeSeries returned.
         */
        public java.lang.Integer getPageSize() {
          return pageSize;
        }

        /**
         * A positive number that is the maximum number of results to return. If page_size is empty
         * or more than 100,000 results, the effective page_size is 100,000 results. If view is set
         * to FULL, this is the maximum number of Points returned. If view is set to HEADERS, this
         * is the maximum number of TimeSeries returned.
         */
        public List setPageSize(java.lang.Integer pageSize) {
          this.pageSize = pageSize;
          return this;
        }

        /**
         * If this field is not empty then it must contain the nextPageToken value returned by a
         * previous call to this method. Using this field causes the method to return additional
         * results from the previous method call.
         */
        @com.google.api.client.util.Key
        private java.lang.String pageToken;

        /** If this field is not empty then it must contain the nextPageToken value returned by a previous call
       to this method. Using this field causes the method to return additional results from the previous
       method call.
         */
        public java.lang.String getPageToken() {
          return pageToken;
        }

        /**
         * If this field is not empty then it must contain the nextPageToken value returned by a
         * previous call to this method. Using this field causes the method to return additional
         * results from the previous method call.
         */
        public List setPageToken(java.lang.String pageToken) {
          this.pageToken = pageToken;
          return this;
        }

        /**
         * The alignment_period specifies a time interval, in seconds, that is used to divide the
         * data in all the time series into consistent blocks of time. This will be done before the
         * per-series aligner can be applied to the data.The value must be at least 60 seconds. If a
         * per-series aligner other than ALIGN_NONE is specified, this field is required or an error
         * is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is
         * specified, then this field is ignored.The maximum value of the alignment_period is 104
         * weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
         */
        @com.google.api.client.util.Key("secondaryAggregation.alignmentPeriod")
        private String secondaryAggregationAlignmentPeriod;

        /** The alignment_period specifies a time interval, in seconds, that is used to divide the data in all
       the time series into consistent blocks of time. This will be done before the per-series aligner can
       be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than
       ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner
       is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value
       of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for
       alerting policies.
         */
        public String getSecondaryAggregationAlignmentPeriod() {
          return secondaryAggregationAlignmentPeriod;
        }

        /**
         * The alignment_period specifies a time interval, in seconds, that is used to divide the
         * data in all the time series into consistent blocks of time. This will be done before the
         * per-series aligner can be applied to the data.The value must be at least 60 seconds. If a
         * per-series aligner other than ALIGN_NONE is specified, this field is required or an error
         * is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is
         * specified, then this field is ignored.The maximum value of the alignment_period is 104
         * weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
         */
        public List setSecondaryAggregationAlignmentPeriod(String secondaryAggregationAlignmentPeriod) {
          this.secondaryAggregationAlignmentPeriod = secondaryAggregationAlignmentPeriod;
          return this;
        }

        /**
         * The reduction operation to be used to combine time series into a single time series,
         * where the value of each data point in the resulting series is a function of all the
         * already aligned values in the input time series.Not all reducer operations can be applied
         * to all time series. The valid choices depend on the metric_kind and the value_type of the
         * original time series. Reduction can yield a time series with a different metric_kind or
         * value_type than the input time series.Time series data must first be aligned (see
         * per_series_aligner) in order to perform cross-time series reduction. If
         * cross_series_reducer is specified, then per_series_aligner must be specified, and must
         * not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is
         * returned.
         */
        @com.google.api.client.util.Key("secondaryAggregation.crossSeriesReducer")
        private java.lang.String secondaryAggregationCrossSeriesReducer;

        /** The reduction operation to be used to combine time series into a single time series, where the
       value of each data point in the resulting series is a function of all the already aligned values in
       the input time series.Not all reducer operations can be applied to all time series. The valid
       choices depend on the metric_kind and the value_type of the original time series. Reduction can
       yield a time series with a different metric_kind or value_type than the input time series.Time
       series data must first be aligned (see per_series_aligner) in order to perform cross-time series
       reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and
       must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is
       returned.
         */
        public java.lang.String getSecondaryAggregationCrossSeriesReducer() {
          return secondaryAggregationCrossSeriesReducer;
        }

        /**
         * The reduction operation to be used to combine time series into a single time series,
         * where the value of each data point in the resulting series is a function of all the
         * already aligned values in the input time series.Not all reducer operations can be applied
         * to all time series. The valid choices depend on the metric_kind and the value_type of the
         * original time series. Reduction can yield a time series with a different metric_kind or
         * value_type than the input time series.Time series data must first be aligned (see
         * per_series_aligner) in order to perform cross-time series reduction. If
         * cross_series_reducer is specified, then per_series_aligner must be specified, and must
         * not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is
         * returned.
         */
        public List setSecondaryAggregationCrossSeriesReducer(java.lang.String secondaryAggregationCrossSeriesReducer) {
          this.secondaryAggregationCrossSeriesReducer = secondaryAggregationCrossSeriesReducer;
          return this;
        }

        /**
         * The set of fields to preserve when cross_series_reducer is specified. The group_by_fields
         * determine how the time series are partitioned into subsets prior to applying the
         * aggregation operation. Each subset contains time series that have the same value for each
         * of the grouping fields. Each individual time series is a member of exactly one subset.
         * The cross_series_reducer is applied to each subset of time series. It is not possible to
         * reduce across different resource types, so this field implicitly contains resource.type.
         * Fields not specified in group_by_fields are aggregated away. If group_by_fields is not
         * specified and all the time series have the same resource type, then the time series are
         * aggregated into a single output time series. If cross_series_reducer is not defined, this
         * field is ignored.
         */
        @com.google.api.client.util.Key("secondaryAggregation.groupByFields")
        private java.util.List<java.lang.String> secondaryAggregationGroupByFields;

        /** The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine
       how the time series are partitioned into subsets prior to applying the aggregation operation. Each
       subset contains time series that have the same value for each of the grouping fields. Each
       individual time series is a member of exactly one subset. The cross_series_reducer is applied to
       each subset of time series. It is not possible to reduce across different resource types, so this
       field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated
       away. If group_by_fields is not specified and all the time series have the same resource type, then
       the time series are aggregated into a single output time series. If cross_series_reducer is not
       defined, this field is ignored.
         */
        public java.util.List<java.lang.String> getSecondaryAggregationGroupByFields() {
          return secondaryAggregationGroupByFields;
        }

        /**
         * The set of fields to preserve when cross_series_reducer is specified. The group_by_fields
         * determine how the time series are partitioned into subsets prior to applying the
         * aggregation operation. Each subset contains time series that have the same value for each
         * of the grouping fields. Each individual time series is a member of exactly one subset.
         * The cross_series_reducer is applied to each subset of time series. It is not possible to
         * reduce across different resource types, so this field implicitly contains resource.type.
         * Fields not specified in group_by_fields are aggregated away. If group_by_fields is not
         * specified and all the time series have the same resource type, then the time series are
         * aggregated into a single output time series. If cross_series_reducer is not defined, this
         * field is ignored.
         */
        public List setSecondaryAggregationGroupByFields(java.util.List<java.lang.String> secondaryAggregationGroupByFields) {
          this.secondaryAggregationGroupByFields = secondaryAggregationGroupByFields;
          return this;
        }

        /**
         * An Aligner describes how to bring the data points in a single time series into temporal
         * alignment. Except for ALIGN_NONE, all alignments cause all the data points in an
         * alignment_period to be mathematically grouped together, resulting in a single data point
         * for each alignment_period with end timestamp at the end of the period.Not all alignment
         * operations may be applied to all time series. The valid choices depend on the metric_kind
         * and value_type of the original time series. Alignment can change the metric_kind or the
         * value_type of the time series.Time series data must be aligned in order to perform cross-
         * time series reduction. If cross_series_reducer is specified, then per_series_aligner must
         * be specified and not equal to ALIGN_NONE and alignment_period must be specified;
         * otherwise, an error is returned.
         */
        @com.google.api.client.util.Key("secondaryAggregation.perSeriesAligner")
        private java.lang.String secondaryAggregationPerSeriesAligner;

        /** An Aligner describes how to bring the data points in a single time series into temporal alignment.
       Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be
       mathematically grouped together, resulting in a single data point for each alignment_period with
       end timestamp at the end of the period.Not all alignment operations may be applied to all time
       series. The valid choices depend on the metric_kind and value_type of the original time series.
       Alignment can change the metric_kind or the value_type of the time series.Time series data must be
       aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then
       per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be
       specified; otherwise, an error is returned.
         */
        public java.lang.String getSecondaryAggregationPerSeriesAligner() {
          return secondaryAggregationPerSeriesAligner;
        }

        /**
         * An Aligner describes how to bring the data points in a single time series into temporal
         * alignment. Except for ALIGN_NONE, all alignments cause all the data points in an
         * alignment_period to be mathematically grouped together, resulting in a single data point
         * for each alignment_period with end timestamp at the end of the period.Not all alignment
         * operations may be applied to all time series. The valid choices depend on the metric_kind
         * and value_type of the original time series. Alignment can change the metric_kind or the
         * value_type of the time series.Time series data must be aligned in order to perform cross-
         * time series reduction. If cross_series_reducer is specified, then per_series_aligner must
         * be specified and not equal to ALIGN_NONE and alignment_period must be specified;
         * otherwise, an error is returned.
         */
        public List setSecondaryAggregationPerSeriesAligner(java.lang.String secondaryAggregationPerSeriesAligner) {
          this.secondaryAggregationPerSeriesAligner = secondaryAggregationPerSeriesAligner;
          return this;
        }

        /** Required. Specifies which information is returned about the time series. */
        @com.google.api.client.util.Key
        private java.lang.String view;

        /** Required. Specifies which information is returned about the time series.
         */
        public java.lang.String getView() {
          return view;
        }

        /** Required. Specifies which information is returned about the time series. */
        public List setView(java.lang.String view) {
          this.view = view;
          return this;
        }

        @Override
        public List set(String parameterName, Object value) {
          return (List) super.set(parameterName, value);
        }
      }
      /**
       * Queries time series using Monitoring Query Language.
       *
       * Create a request for the method "timeSeries.query".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Query#execute()} method to invoke the remote operation.
       *
       * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       *        the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
       * @param content the {@link com.google.api.services.monitoring.v3.model.QueryTimeSeriesRequest}
       * @return the request
       */
      public Query query(java.lang.String name, com.google.api.services.monitoring.v3.model.QueryTimeSeriesRequest content) throws java.io.IOException {
        Query result = new Query(name, content);
        initialize(result);
        return result;
      }

      public class Query extends MonitoringRequest<com.google.api.services.monitoring.v3.model.QueryTimeSeriesResponse> {

        private static final String REST_PATH = "v3/{+name}/timeSeries:query";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Queries time series using Monitoring Query Language.
         *
         * Create a request for the method "timeSeries.query".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Query#execute()} method to invoke the remote operation.
         * <p> {@link
         * Query#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       *        the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         * @param content the {@link com.google.api.services.monitoring.v3.model.QueryTimeSeriesRequest}
         * @since 1.13
         */
        protected Query(java.lang.String name, com.google.api.services.monitoring.v3.model.QueryTimeSeriesRequest content) {
          super(Monitoring.this, "POST", REST_PATH, content, com.google.api.services.monitoring.v3.model.QueryTimeSeriesResponse.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public Query set$Xgafv(java.lang.String $Xgafv) {
          return (Query) super.set$Xgafv($Xgafv);
        }

        @Override
        public Query setAccessToken(java.lang.String accessToken) {
          return (Query) super.setAccessToken(accessToken);
        }

        @Override
        public Query setAlt(java.lang.String alt) {
          return (Query) super.setAlt(alt);
        }

        @Override
        public Query setCallback(java.lang.String callback) {
          return (Query) super.setCallback(callback);
        }

        @Override
        public Query setFields(java.lang.String fields) {
          return (Query) super.setFields(fields);
        }

        @Override
        public Query setKey(java.lang.String key) {
          return (Query) super.setKey(key);
        }

        @Override
        public Query setOauthToken(java.lang.String oauthToken) {
          return (Query) super.setOauthToken(oauthToken);
        }

        @Override
        public Query setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Query) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Query setQuotaUser(java.lang.String quotaUser) {
          return (Query) super.setQuotaUser(quotaUser);
        }

        @Override
        public Query setUploadType(java.lang.String uploadType) {
          return (Query) super.setUploadType(uploadType);
        }

        @Override
        public Query setUploadProtocol(java.lang.String uploadProtocol) {
          return (Query) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which
         * to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which to execute
       the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) on which
         * to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public Query setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Query set(String parameterName, Object value) {
          return (Query) super.set(parameterName, value);
        }
      }

    }
    /**
     * An accessor for creating requests from the UptimeCheckConfigs collection.
     *
     * <p>The typical use is:</p>
     * <pre>
     *   {@code Monitoring monitoring = new Monitoring(...);}
     *   {@code Monitoring.UptimeCheckConfigs.List request = monitoring.uptimeCheckConfigs().list(parameters ...)}
     * </pre>
     *
     * @return the resource collection
     */
    public UptimeCheckConfigs uptimeCheckConfigs() {
      return new UptimeCheckConfigs();
    }

    /**
     * The "uptimeCheckConfigs" collection of methods.
     */
    public class UptimeCheckConfigs {

      /**
       * Creates a new Uptime check configuration.
       *
       * Create a request for the method "uptimeCheckConfigs.create".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Create#execute()} method to invoke the remote operation.
       *
       * @param parent Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which to create
       *        the Uptime check. The format is: projects/[PROJECT_ID_OR_NUMBER]
       * @param content the {@link com.google.api.services.monitoring.v3.model.UptimeCheckConfig}
       * @return the request
       */
      public Create create(java.lang.String parent, com.google.api.services.monitoring.v3.model.UptimeCheckConfig content) throws java.io.IOException {
        Create result = new Create(parent, content);
        initialize(result);
        return result;
      }

      public class Create extends MonitoringRequest<com.google.api.services.monitoring.v3.model.UptimeCheckConfig> {

        private static final String REST_PATH = "v3/{+parent}/uptimeCheckConfigs";

        private final java.util.regex.Pattern PARENT_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Creates a new Uptime check configuration.
         *
         * Create a request for the method "uptimeCheckConfigs.create".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
         * <p> {@link
         * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param parent Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which to create
       *        the Uptime check. The format is: projects/[PROJECT_ID_OR_NUMBER]
         * @param content the {@link com.google.api.services.monitoring.v3.model.UptimeCheckConfig}
         * @since 1.13
         */
        protected Create(java.lang.String parent, com.google.api.services.monitoring.v3.model.UptimeCheckConfig content) {
          super(Monitoring.this, "POST", REST_PATH, content, com.google.api.services.monitoring.v3.model.UptimeCheckConfig.class);
          this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                "Parameter parent must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public Create set$Xgafv(java.lang.String $Xgafv) {
          return (Create) super.set$Xgafv($Xgafv);
        }

        @Override
        public Create setAccessToken(java.lang.String accessToken) {
          return (Create) super.setAccessToken(accessToken);
        }

        @Override
        public Create setAlt(java.lang.String alt) {
          return (Create) super.setAlt(alt);
        }

        @Override
        public Create setCallback(java.lang.String callback) {
          return (Create) super.setCallback(callback);
        }

        @Override
        public Create setFields(java.lang.String fields) {
          return (Create) super.setFields(fields);
        }

        @Override
        public Create setKey(java.lang.String key) {
          return (Create) super.setKey(key);
        }

        @Override
        public Create setOauthToken(java.lang.String oauthToken) {
          return (Create) super.setOauthToken(oauthToken);
        }

        @Override
        public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Create) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Create setQuotaUser(java.lang.String quotaUser) {
          return (Create) super.setQuotaUser(quotaUser);
        }

        @Override
        public Create setUploadType(java.lang.String uploadType) {
          return (Create) super.setUploadType(uploadType);
        }

        @Override
        public Create setUploadProtocol(java.lang.String uploadProtocol) {
          return (Create) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which
         * to create the Uptime check. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        @com.google.api.client.util.Key
        private java.lang.String parent;

        /** Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which to create
       the Uptime check. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public java.lang.String getParent() {
          return parent;
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) in which
         * to create the Uptime check. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public Create setParent(java.lang.String parent) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                "Parameter parent must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.parent = parent;
          return this;
        }

        @Override
        public Create set(String parameterName, Object value) {
          return (Create) super.set(parameterName, value);
        }
      }
      /**
       * Deletes an Uptime check configuration. Note that this method will fail if the Uptime check
       * configuration is referenced by an alert policy or other dependent configs that would be rendered
       * invalid by the deletion.
       *
       * Create a request for the method "uptimeCheckConfigs.delete".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
       *
       * @param name Required. The Uptime check configuration to delete. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
       * @return the request
       */
      public Delete delete(java.lang.String name) throws java.io.IOException {
        Delete result = new Delete(name);
        initialize(result);
        return result;
      }

      public class Delete extends MonitoringRequest<com.google.api.services.monitoring.v3.model.Empty> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/uptimeCheckConfigs/[^/]+$");

        /**
         * Deletes an Uptime check configuration. Note that this method will fail if the Uptime check
         * configuration is referenced by an alert policy or other dependent configs that would be
         * rendered invalid by the deletion.
         *
         * Create a request for the method "uptimeCheckConfigs.delete".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
         * <p> {@link
         * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The Uptime check configuration to delete. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
         * @since 1.13
         */
        protected Delete(java.lang.String name) {
          super(Monitoring.this, "DELETE", REST_PATH, null, com.google.api.services.monitoring.v3.model.Empty.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/uptimeCheckConfigs/[^/]+$");
          }
        }

        @Override
        public Delete set$Xgafv(java.lang.String $Xgafv) {
          return (Delete) super.set$Xgafv($Xgafv);
        }

        @Override
        public Delete setAccessToken(java.lang.String accessToken) {
          return (Delete) super.setAccessToken(accessToken);
        }

        @Override
        public Delete setAlt(java.lang.String alt) {
          return (Delete) super.setAlt(alt);
        }

        @Override
        public Delete setCallback(java.lang.String callback) {
          return (Delete) super.setCallback(callback);
        }

        @Override
        public Delete setFields(java.lang.String fields) {
          return (Delete) super.setFields(fields);
        }

        @Override
        public Delete setKey(java.lang.String key) {
          return (Delete) super.setKey(key);
        }

        @Override
        public Delete setOauthToken(java.lang.String oauthToken) {
          return (Delete) super.setOauthToken(oauthToken);
        }

        @Override
        public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Delete) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Delete setQuotaUser(java.lang.String quotaUser) {
          return (Delete) super.setQuotaUser(quotaUser);
        }

        @Override
        public Delete setUploadType(java.lang.String uploadType) {
          return (Delete) super.setUploadType(uploadType);
        }

        @Override
        public Delete setUploadProtocol(java.lang.String uploadProtocol) {
          return (Delete) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The Uptime check configuration to delete. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The Uptime check configuration to delete. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The Uptime check configuration to delete. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
         */
        public Delete setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/uptimeCheckConfigs/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Delete set(String parameterName, Object value) {
          return (Delete) super.set(parameterName, value);
        }
      }
      /**
       * Gets a single Uptime check configuration.
       *
       * Create a request for the method "uptimeCheckConfigs.get".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Get#execute()} method to invoke the remote operation.
       *
       * @param name Required. The Uptime check configuration to retrieve. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
       * @return the request
       */
      public Get get(java.lang.String name) throws java.io.IOException {
        Get result = new Get(name);
        initialize(result);
        return result;
      }

      public class Get extends MonitoringRequest<com.google.api.services.monitoring.v3.model.UptimeCheckConfig> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/uptimeCheckConfigs/[^/]+$");

        /**
         * Gets a single Uptime check configuration.
         *
         * Create a request for the method "uptimeCheckConfigs.get".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
         * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. The Uptime check configuration to retrieve. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
         * @since 1.13
         */
        protected Get(java.lang.String name) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.UptimeCheckConfig.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/uptimeCheckConfigs/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public Get set$Xgafv(java.lang.String $Xgafv) {
          return (Get) super.set$Xgafv($Xgafv);
        }

        @Override
        public Get setAccessToken(java.lang.String accessToken) {
          return (Get) super.setAccessToken(accessToken);
        }

        @Override
        public Get setAlt(java.lang.String alt) {
          return (Get) super.setAlt(alt);
        }

        @Override
        public Get setCallback(java.lang.String callback) {
          return (Get) super.setCallback(callback);
        }

        @Override
        public Get setFields(java.lang.String fields) {
          return (Get) super.setFields(fields);
        }

        @Override
        public Get setKey(java.lang.String key) {
          return (Get) super.setKey(key);
        }

        @Override
        public Get setOauthToken(java.lang.String oauthToken) {
          return (Get) super.setOauthToken(oauthToken);
        }

        @Override
        public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Get) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Get setQuotaUser(java.lang.String quotaUser) {
          return (Get) super.setQuotaUser(quotaUser);
        }

        @Override
        public Get setUploadType(java.lang.String uploadType) {
          return (Get) super.setUploadType(uploadType);
        }

        @Override
        public Get setUploadProtocol(java.lang.String uploadProtocol) {
          return (Get) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The Uptime check configuration to retrieve. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. The Uptime check configuration to retrieve. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. The Uptime check configuration to retrieve. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
         */
        public Get setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/uptimeCheckConfigs/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Get set(String parameterName, Object value) {
          return (Get) super.set(parameterName, value);
        }
      }
      /**
       * Lists the existing valid Uptime check configurations for the project (leaving out any invalid
       * configurations).
       *
       * Create a request for the method "uptimeCheckConfigs.list".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link List#execute()} method to invoke the remote operation.
       *
       * @param parent Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose Uptime check
       *        configurations are listed. The format is: projects/[PROJECT_ID_OR_NUMBER]
       * @return the request
       */
      public List list(java.lang.String parent) throws java.io.IOException {
        List result = new List(parent);
        initialize(result);
        return result;
      }

      public class List extends MonitoringRequest<com.google.api.services.monitoring.v3.model.ListUptimeCheckConfigsResponse> {

        private static final String REST_PATH = "v3/{+parent}/uptimeCheckConfigs";

        private final java.util.regex.Pattern PARENT_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Lists the existing valid Uptime check configurations for the project (leaving out any invalid
         * configurations).
         *
         * Create a request for the method "uptimeCheckConfigs.list".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
         * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param parent Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose Uptime check
       *        configurations are listed. The format is: projects/[PROJECT_ID_OR_NUMBER]
         * @since 1.13
         */
        protected List(java.lang.String parent) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.ListUptimeCheckConfigsResponse.class);
          this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                "Parameter parent must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public List set$Xgafv(java.lang.String $Xgafv) {
          return (List) super.set$Xgafv($Xgafv);
        }

        @Override
        public List setAccessToken(java.lang.String accessToken) {
          return (List) super.setAccessToken(accessToken);
        }

        @Override
        public List setAlt(java.lang.String alt) {
          return (List) super.setAlt(alt);
        }

        @Override
        public List setCallback(java.lang.String callback) {
          return (List) super.setCallback(callback);
        }

        @Override
        public List setFields(java.lang.String fields) {
          return (List) super.setFields(fields);
        }

        @Override
        public List setKey(java.lang.String key) {
          return (List) super.setKey(key);
        }

        @Override
        public List setOauthToken(java.lang.String oauthToken) {
          return (List) super.setOauthToken(oauthToken);
        }

        @Override
        public List setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (List) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public List setQuotaUser(java.lang.String quotaUser) {
          return (List) super.setQuotaUser(quotaUser);
        }

        @Override
        public List setUploadType(java.lang.String uploadType) {
          return (List) super.setUploadType(uploadType);
        }

        @Override
        public List setUploadProtocol(java.lang.String uploadProtocol) {
          return (List) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose
         * Uptime check configurations are listed. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        @com.google.api.client.util.Key
        private java.lang.String parent;

        /** Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose Uptime check
       configurations are listed. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public java.lang.String getParent() {
          return parent;
        }

        /**
         * Required. The project (https://cloud.google.com/monitoring/api/v3#project_name) whose
         * Uptime check configurations are listed. The format is: projects/[PROJECT_ID_OR_NUMBER]
         */
        public List setParent(java.lang.String parent) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                "Parameter parent must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.parent = parent;
          return this;
        }

        /**
         * If provided, this field specifies the criteria that must be met by uptime checks to be
         * included in the response.For more details, see Filtering syntax
         * (https://cloud.google.com/monitoring/api/v3/sorting-and-filtering#filter_syntax).
         */
        @com.google.api.client.util.Key
        private java.lang.String filter;

        /** If provided, this field specifies the criteria that must be met by uptime checks to be included in
       the response.For more details, see Filtering syntax (https://cloud.google.com/monitoring/api/v3
       /sorting-and-filtering#filter_syntax).
         */
        public java.lang.String getFilter() {
          return filter;
        }

        /**
         * If provided, this field specifies the criteria that must be met by uptime checks to be
         * included in the response.For more details, see Filtering syntax
         * (https://cloud.google.com/monitoring/api/v3/sorting-and-filtering#filter_syntax).
         */
        public List setFilter(java.lang.String filter) {
          this.filter = filter;
          return this;
        }

        /**
         * The maximum number of results to return in a single response. The server may further
         * constrain the maximum number of results returned in a single page. If the page_size is
         * <=0, the server will decide the number of results to be returned.
         */
        @com.google.api.client.util.Key
        private java.lang.Integer pageSize;

        /** The maximum number of results to return in a single response. The server may further constrain the
       maximum number of results returned in a single page. If the page_size is <=0, the server will
       decide the number of results to be returned.
         */
        public java.lang.Integer getPageSize() {
          return pageSize;
        }

        /**
         * The maximum number of results to return in a single response. The server may further
         * constrain the maximum number of results returned in a single page. If the page_size is
         * <=0, the server will decide the number of results to be returned.
         */
        public List setPageSize(java.lang.Integer pageSize) {
          this.pageSize = pageSize;
          return this;
        }

        /**
         * If this field is not empty then it must contain the nextPageToken value returned by a
         * previous call to this method. Using this field causes the method to return more results
         * from the previous method call.
         */
        @com.google.api.client.util.Key
        private java.lang.String pageToken;

        /** If this field is not empty then it must contain the nextPageToken value returned by a previous call
       to this method. Using this field causes the method to return more results from the previous method
       call.
         */
        public java.lang.String getPageToken() {
          return pageToken;
        }

        /**
         * If this field is not empty then it must contain the nextPageToken value returned by a
         * previous call to this method. Using this field causes the method to return more results
         * from the previous method call.
         */
        public List setPageToken(java.lang.String pageToken) {
          this.pageToken = pageToken;
          return this;
        }

        @Override
        public List set(String parameterName, Object value) {
          return (List) super.set(parameterName, value);
        }
      }
      /**
       * Updates an Uptime check configuration. You can either replace the entire configuration with a new
       * one or replace only certain fields in the current configuration by specifying the fields to be
       * updated via updateMask. Returns the updated configuration.
       *
       * Create a request for the method "uptimeCheckConfigs.patch".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Patch#execute()} method to invoke the remote operation.
       *
       * @param name Identifier. A unique resource name for this Uptime check configuration. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
       *        [PROJECT_ID_OR_NUMBER] is the Workspace host project associated with the Uptime check.This
       *        field should be omitted when creating the Uptime check configuration; on create, the
       *        resource name is assigned by the server and included in the response.
       * @param content the {@link com.google.api.services.monitoring.v3.model.UptimeCheckConfig}
       * @return the request
       */
      public Patch patch(java.lang.String name, com.google.api.services.monitoring.v3.model.UptimeCheckConfig content) throws java.io.IOException {
        Patch result = new Patch(name, content);
        initialize(result);
        return result;
      }

      public class Patch extends MonitoringRequest<com.google.api.services.monitoring.v3.model.UptimeCheckConfig> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/uptimeCheckConfigs/[^/]+$");

        /**
         * Updates an Uptime check configuration. You can either replace the entire configuration with a
         * new one or replace only certain fields in the current configuration by specifying the fields to
         * be updated via updateMask. Returns the updated configuration.
         *
         * Create a request for the method "uptimeCheckConfigs.patch".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Patch#execute()} method to invoke the remote operation.
         * <p> {@link
         * Patch#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Identifier. A unique resource name for this Uptime check configuration. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
       *        [PROJECT_ID_OR_NUMBER] is the Workspace host project associated with the Uptime check.This
       *        field should be omitted when creating the Uptime check configuration; on create, the
       *        resource name is assigned by the server and included in the response.
         * @param content the {@link com.google.api.services.monitoring.v3.model.UptimeCheckConfig}
         * @since 1.13
         */
        protected Patch(java.lang.String name, com.google.api.services.monitoring.v3.model.UptimeCheckConfig content) {
          super(Monitoring.this, "PATCH", REST_PATH, content, com.google.api.services.monitoring.v3.model.UptimeCheckConfig.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/uptimeCheckConfigs/[^/]+$");
          }
        }

        @Override
        public Patch set$Xgafv(java.lang.String $Xgafv) {
          return (Patch) super.set$Xgafv($Xgafv);
        }

        @Override
        public Patch setAccessToken(java.lang.String accessToken) {
          return (Patch) super.setAccessToken(accessToken);
        }

        @Override
        public Patch setAlt(java.lang.String alt) {
          return (Patch) super.setAlt(alt);
        }

        @Override
        public Patch setCallback(java.lang.String callback) {
          return (Patch) super.setCallback(callback);
        }

        @Override
        public Patch setFields(java.lang.String fields) {
          return (Patch) super.setFields(fields);
        }

        @Override
        public Patch setKey(java.lang.String key) {
          return (Patch) super.setKey(key);
        }

        @Override
        public Patch setOauthToken(java.lang.String oauthToken) {
          return (Patch) super.setOauthToken(oauthToken);
        }

        @Override
        public Patch setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Patch) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Patch setQuotaUser(java.lang.String quotaUser) {
          return (Patch) super.setQuotaUser(quotaUser);
        }

        @Override
        public Patch setUploadType(java.lang.String uploadType) {
          return (Patch) super.setUploadType(uploadType);
        }

        @Override
        public Patch setUploadProtocol(java.lang.String uploadProtocol) {
          return (Patch) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Identifier. A unique resource name for this Uptime check configuration. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
         * [PROJECT_ID_OR_NUMBER] is the Workspace host project associated with the Uptime
         * check.This field should be omitted when creating the Uptime check configuration; on
         * create, the resource name is assigned by the server and included in the response.
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Identifier. A unique resource name for this Uptime check configuration. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID] [PROJECT_ID_OR_NUMBER] is the
       Workspace host project associated with the Uptime check.This field should be omitted when creating
       the Uptime check configuration; on create, the resource name is assigned by the server and included
       in the response.
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Identifier. A unique resource name for this Uptime check configuration. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
         * [PROJECT_ID_OR_NUMBER] is the Workspace host project associated with the Uptime
         * check.This field should be omitted when creating the Uptime check configuration; on
         * create, the resource name is assigned by the server and included in the response.
         */
        public Patch setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/uptimeCheckConfigs/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /**
         * Optional. If present, only the listed fields in the current Uptime check configuration
         * are updated with values from the new configuration. If this field is empty, then the
         * current configuration is completely replaced with the new configuration.
         */
        @com.google.api.client.util.Key
        private String updateMask;

        /** Optional. If present, only the listed fields in the current Uptime check configuration are updated
       with values from the new configuration. If this field is empty, then the current configuration is
       completely replaced with the new configuration.
         */
        public String getUpdateMask() {
          return updateMask;
        }

        /**
         * Optional. If present, only the listed fields in the current Uptime check configuration
         * are updated with values from the new configuration. If this field is empty, then the
         * current configuration is completely replaced with the new configuration.
         */
        public Patch setUpdateMask(String updateMask) {
          this.updateMask = updateMask;
          return this;
        }

        @Override
        public Patch set(String parameterName, Object value) {
          return (Patch) super.set(parameterName, value);
        }
      }

    }
  }

  /**
   * An accessor for creating requests from the Services collection.
   *
   * <p>The typical use is:</p>
   * <pre>
   *   {@code Monitoring monitoring = new Monitoring(...);}
   *   {@code Monitoring.Services.List request = monitoring.services().list(parameters ...)}
   * </pre>
   *
   * @return the resource collection
   */
  public Services services() {
    return new Services();
  }

  /**
   * The "services" collection of methods.
   */
  public class Services {

    /**
     * Create a Service.
     *
     * Create a request for the method "services.create".
     *
     * This request holds the parameters needed by the monitoring server.  After setting any optional
     * parameters, call the {@link Create#execute()} method to invoke the remote operation.
     *
     * @param parent Required. Resource name (https://cloud.google.com/monitoring/api/v3#project_name) of the parent
     *        Metrics Scope. The format is: projects/[PROJECT_ID_OR_NUMBER]
     * @param content the {@link com.google.api.services.monitoring.v3.model.Service}
     * @return the request
     */
    public Create create(java.lang.String parent, com.google.api.services.monitoring.v3.model.Service content) throws java.io.IOException {
      Create result = new Create(parent, content);
      initialize(result);
      return result;
    }

    public class Create extends MonitoringRequest<com.google.api.services.monitoring.v3.model.Service> {

      private static final String REST_PATH = "v3/{+parent}/services";

      private final java.util.regex.Pattern PARENT_PATTERN =
          java.util.regex.Pattern.compile("^[^/]+/[^/]+$");

      /**
       * Create a Service.
       *
       * Create a request for the method "services.create".
       *
       * This request holds the parameters needed by the the monitoring server.  After setting any
       * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
       * <p> {@link
       * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
       * be called to initialize this instance immediately after invoking the constructor. </p>
       *
       * @param parent Required. Resource name (https://cloud.google.com/monitoring/api/v3#project_name) of the parent
     *        Metrics Scope. The format is: projects/[PROJECT_ID_OR_NUMBER]
       * @param content the {@link com.google.api.services.monitoring.v3.model.Service}
       * @since 1.13
       */
      protected Create(java.lang.String parent, com.google.api.services.monitoring.v3.model.Service content) {
        super(Monitoring.this, "POST", REST_PATH, content, com.google.api.services.monitoring.v3.model.Service.class);
        this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
              "Parameter parent must conform to the pattern " +
              "^[^/]+/[^/]+$");
        }
      }

      @Override
      public Create set$Xgafv(java.lang.String $Xgafv) {
        return (Create) super.set$Xgafv($Xgafv);
      }

      @Override
      public Create setAccessToken(java.lang.String accessToken) {
        return (Create) super.setAccessToken(accessToken);
      }

      @Override
      public Create setAlt(java.lang.String alt) {
        return (Create) super.setAlt(alt);
      }

      @Override
      public Create setCallback(java.lang.String callback) {
        return (Create) super.setCallback(callback);
      }

      @Override
      public Create setFields(java.lang.String fields) {
        return (Create) super.setFields(fields);
      }

      @Override
      public Create setKey(java.lang.String key) {
        return (Create) super.setKey(key);
      }

      @Override
      public Create setOauthToken(java.lang.String oauthToken) {
        return (Create) super.setOauthToken(oauthToken);
      }

      @Override
      public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
        return (Create) super.setPrettyPrint(prettyPrint);
      }

      @Override
      public Create setQuotaUser(java.lang.String quotaUser) {
        return (Create) super.setQuotaUser(quotaUser);
      }

      @Override
      public Create setUploadType(java.lang.String uploadType) {
        return (Create) super.setUploadType(uploadType);
      }

      @Override
      public Create setUploadProtocol(java.lang.String uploadProtocol) {
        return (Create) super.setUploadProtocol(uploadProtocol);
      }

      /**
       * Required. Resource name (https://cloud.google.com/monitoring/api/v3#project_name) of the
       * parent Metrics Scope. The format is: projects/[PROJECT_ID_OR_NUMBER]
       */
      @com.google.api.client.util.Key
      private java.lang.String parent;

      /** Required. Resource name (https://cloud.google.com/monitoring/api/v3#project_name) of the parent
     Metrics Scope. The format is: projects/[PROJECT_ID_OR_NUMBER]
       */
      public java.lang.String getParent() {
        return parent;
      }

      /**
       * Required. Resource name (https://cloud.google.com/monitoring/api/v3#project_name) of the
       * parent Metrics Scope. The format is: projects/[PROJECT_ID_OR_NUMBER]
       */
      public Create setParent(java.lang.String parent) {
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
              "Parameter parent must conform to the pattern " +
              "^[^/]+/[^/]+$");
        }
        this.parent = parent;
        return this;
      }

      /**
       * Optional. The Service id to use for this Service. If omitted, an id will be generated
       * instead. Must match the pattern [a-z0-9\-]+
       */
      @com.google.api.client.util.Key
      private java.lang.String serviceId;

      /** Optional. The Service id to use for this Service. If omitted, an id will be generated instead. Must
     match the pattern [a-z0-9\-]+
       */
      public java.lang.String getServiceId() {
        return serviceId;
      }

      /**
       * Optional. The Service id to use for this Service. If omitted, an id will be generated
       * instead. Must match the pattern [a-z0-9\-]+
       */
      public Create setServiceId(java.lang.String serviceId) {
        this.serviceId = serviceId;
        return this;
      }

      @Override
      public Create set(String parameterName, Object value) {
        return (Create) super.set(parameterName, value);
      }
    }
    /**
     * Soft delete this Service.
     *
     * Create a request for the method "services.delete".
     *
     * This request holds the parameters needed by the monitoring server.  After setting any optional
     * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
     *
     * @param name Required. Resource name of the Service to delete. The format is:
     *        projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
     * @return the request
     */
    public Delete delete(java.lang.String name) throws java.io.IOException {
      Delete result = new Delete(name);
      initialize(result);
      return result;
    }

    public class Delete extends MonitoringRequest<com.google.api.services.monitoring.v3.model.Empty> {

      private static final String REST_PATH = "v3/{+name}";

      private final java.util.regex.Pattern NAME_PATTERN =
          java.util.regex.Pattern.compile("^[^/]+/[^/]+/services/[^/]+$");

      /**
       * Soft delete this Service.
       *
       * Create a request for the method "services.delete".
       *
       * This request holds the parameters needed by the the monitoring server.  After setting any
       * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
       * <p> {@link
       * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
       * be called to initialize this instance immediately after invoking the constructor. </p>
       *
       * @param name Required. Resource name of the Service to delete. The format is:
     *        projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
       * @since 1.13
       */
      protected Delete(java.lang.String name) {
        super(Monitoring.this, "DELETE", REST_PATH, null, com.google.api.services.monitoring.v3.model.Empty.class);
        this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
              "Parameter name must conform to the pattern " +
              "^[^/]+/[^/]+/services/[^/]+$");
        }
      }

      @Override
      public Delete set$Xgafv(java.lang.String $Xgafv) {
        return (Delete) super.set$Xgafv($Xgafv);
      }

      @Override
      public Delete setAccessToken(java.lang.String accessToken) {
        return (Delete) super.setAccessToken(accessToken);
      }

      @Override
      public Delete setAlt(java.lang.String alt) {
        return (Delete) super.setAlt(alt);
      }

      @Override
      public Delete setCallback(java.lang.String callback) {
        return (Delete) super.setCallback(callback);
      }

      @Override
      public Delete setFields(java.lang.String fields) {
        return (Delete) super.setFields(fields);
      }

      @Override
      public Delete setKey(java.lang.String key) {
        return (Delete) super.setKey(key);
      }

      @Override
      public Delete setOauthToken(java.lang.String oauthToken) {
        return (Delete) super.setOauthToken(oauthToken);
      }

      @Override
      public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
        return (Delete) super.setPrettyPrint(prettyPrint);
      }

      @Override
      public Delete setQuotaUser(java.lang.String quotaUser) {
        return (Delete) super.setQuotaUser(quotaUser);
      }

      @Override
      public Delete setUploadType(java.lang.String uploadType) {
        return (Delete) super.setUploadType(uploadType);
      }

      @Override
      public Delete setUploadProtocol(java.lang.String uploadProtocol) {
        return (Delete) super.setUploadProtocol(uploadProtocol);
      }

      /**
       * Required. Resource name of the Service to delete. The format is:
       * projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
       */
      @com.google.api.client.util.Key
      private java.lang.String name;

      /** Required. Resource name of the Service to delete. The format is:
     projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
       */
      public java.lang.String getName() {
        return name;
      }

      /**
       * Required. Resource name of the Service to delete. The format is:
       * projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
       */
      public Delete setName(java.lang.String name) {
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
              "Parameter name must conform to the pattern " +
              "^[^/]+/[^/]+/services/[^/]+$");
        }
        this.name = name;
        return this;
      }

      @Override
      public Delete set(String parameterName, Object value) {
        return (Delete) super.set(parameterName, value);
      }
    }
    /**
     * Get the named Service.
     *
     * Create a request for the method "services.get".
     *
     * This request holds the parameters needed by the monitoring server.  After setting any optional
     * parameters, call the {@link Get#execute()} method to invoke the remote operation.
     *
     * @param name Required. Resource name of the Service. The format is:
     *        projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
     * @return the request
     */
    public Get get(java.lang.String name) throws java.io.IOException {
      Get result = new Get(name);
      initialize(result);
      return result;
    }

    public class Get extends MonitoringRequest<com.google.api.services.monitoring.v3.model.Service> {

      private static final String REST_PATH = "v3/{+name}";

      private final java.util.regex.Pattern NAME_PATTERN =
          java.util.regex.Pattern.compile("^[^/]+/[^/]+/services/[^/]+$");

      /**
       * Get the named Service.
       *
       * Create a request for the method "services.get".
       *
       * This request holds the parameters needed by the the monitoring server.  After setting any
       * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
       * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
       * must be called to initialize this instance immediately after invoking the constructor. </p>
       *
       * @param name Required. Resource name of the Service. The format is:
     *        projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
       * @since 1.13
       */
      protected Get(java.lang.String name) {
        super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.Service.class);
        this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
              "Parameter name must conform to the pattern " +
              "^[^/]+/[^/]+/services/[^/]+$");
        }
      }

      @Override
      public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
        return super.executeUsingHead();
      }

      @Override
      public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
        return super.buildHttpRequestUsingHead();
      }

      @Override
      public Get set$Xgafv(java.lang.String $Xgafv) {
        return (Get) super.set$Xgafv($Xgafv);
      }

      @Override
      public Get setAccessToken(java.lang.String accessToken) {
        return (Get) super.setAccessToken(accessToken);
      }

      @Override
      public Get setAlt(java.lang.String alt) {
        return (Get) super.setAlt(alt);
      }

      @Override
      public Get setCallback(java.lang.String callback) {
        return (Get) super.setCallback(callback);
      }

      @Override
      public Get setFields(java.lang.String fields) {
        return (Get) super.setFields(fields);
      }

      @Override
      public Get setKey(java.lang.String key) {
        return (Get) super.setKey(key);
      }

      @Override
      public Get setOauthToken(java.lang.String oauthToken) {
        return (Get) super.setOauthToken(oauthToken);
      }

      @Override
      public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
        return (Get) super.setPrettyPrint(prettyPrint);
      }

      @Override
      public Get setQuotaUser(java.lang.String quotaUser) {
        return (Get) super.setQuotaUser(quotaUser);
      }

      @Override
      public Get setUploadType(java.lang.String uploadType) {
        return (Get) super.setUploadType(uploadType);
      }

      @Override
      public Get setUploadProtocol(java.lang.String uploadProtocol) {
        return (Get) super.setUploadProtocol(uploadProtocol);
      }

      /**
       * Required. Resource name of the Service. The format is:
       * projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
       */
      @com.google.api.client.util.Key
      private java.lang.String name;

      /** Required. Resource name of the Service. The format is:
     projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
       */
      public java.lang.String getName() {
        return name;
      }

      /**
       * Required. Resource name of the Service. The format is:
       * projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
       */
      public Get setName(java.lang.String name) {
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
              "Parameter name must conform to the pattern " +
              "^[^/]+/[^/]+/services/[^/]+$");
        }
        this.name = name;
        return this;
      }

      @Override
      public Get set(String parameterName, Object value) {
        return (Get) super.set(parameterName, value);
      }
    }
    /**
     * List Services for this Metrics Scope.
     *
     * Create a request for the method "services.list".
     *
     * This request holds the parameters needed by the monitoring server.  After setting any optional
     * parameters, call the {@link List#execute()} method to invoke the remote operation.
     *
     * @param parent Required. Resource name of the parent containing the listed services, either a project
     *        (https://cloud.google.com/monitoring/api/v3#project_name) or a Monitoring Metrics Scope.
     *        The formats are: projects/[PROJECT_ID_OR_NUMBER] workspaces/[HOST_PROJECT_ID_OR_NUMBER]
     * @return the request
     */
    public List list(java.lang.String parent) throws java.io.IOException {
      List result = new List(parent);
      initialize(result);
      return result;
    }

    public class List extends MonitoringRequest<com.google.api.services.monitoring.v3.model.ListServicesResponse> {

      private static final String REST_PATH = "v3/{+parent}/services";

      private final java.util.regex.Pattern PARENT_PATTERN =
          java.util.regex.Pattern.compile("^[^/]+/[^/]+$");

      /**
       * List Services for this Metrics Scope.
       *
       * Create a request for the method "services.list".
       *
       * This request holds the parameters needed by the the monitoring server.  After setting any
       * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
       * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
       * must be called to initialize this instance immediately after invoking the constructor. </p>
       *
       * @param parent Required. Resource name of the parent containing the listed services, either a project
     *        (https://cloud.google.com/monitoring/api/v3#project_name) or a Monitoring Metrics Scope.
     *        The formats are: projects/[PROJECT_ID_OR_NUMBER] workspaces/[HOST_PROJECT_ID_OR_NUMBER]
       * @since 1.13
       */
      protected List(java.lang.String parent) {
        super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.ListServicesResponse.class);
        this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
              "Parameter parent must conform to the pattern " +
              "^[^/]+/[^/]+$");
        }
      }

      @Override
      public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
        return super.executeUsingHead();
      }

      @Override
      public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
        return super.buildHttpRequestUsingHead();
      }

      @Override
      public List set$Xgafv(java.lang.String $Xgafv) {
        return (List) super.set$Xgafv($Xgafv);
      }

      @Override
      public List setAccessToken(java.lang.String accessToken) {
        return (List) super.setAccessToken(accessToken);
      }

      @Override
      public List setAlt(java.lang.String alt) {
        return (List) super.setAlt(alt);
      }

      @Override
      public List setCallback(java.lang.String callback) {
        return (List) super.setCallback(callback);
      }

      @Override
      public List setFields(java.lang.String fields) {
        return (List) super.setFields(fields);
      }

      @Override
      public List setKey(java.lang.String key) {
        return (List) super.setKey(key);
      }

      @Override
      public List setOauthToken(java.lang.String oauthToken) {
        return (List) super.setOauthToken(oauthToken);
      }

      @Override
      public List setPrettyPrint(java.lang.Boolean prettyPrint) {
        return (List) super.setPrettyPrint(prettyPrint);
      }

      @Override
      public List setQuotaUser(java.lang.String quotaUser) {
        return (List) super.setQuotaUser(quotaUser);
      }

      @Override
      public List setUploadType(java.lang.String uploadType) {
        return (List) super.setUploadType(uploadType);
      }

      @Override
      public List setUploadProtocol(java.lang.String uploadProtocol) {
        return (List) super.setUploadProtocol(uploadProtocol);
      }

      /**
       * Required. Resource name of the parent containing the listed services, either a project
       * (https://cloud.google.com/monitoring/api/v3#project_name) or a Monitoring Metrics Scope.
       * The formats are: projects/[PROJECT_ID_OR_NUMBER] workspaces/[HOST_PROJECT_ID_OR_NUMBER]
       */
      @com.google.api.client.util.Key
      private java.lang.String parent;

      /** Required. Resource name of the parent containing the listed services, either a project
     (https://cloud.google.com/monitoring/api/v3#project_name) or a Monitoring Metrics Scope. The
     formats are: projects/[PROJECT_ID_OR_NUMBER] workspaces/[HOST_PROJECT_ID_OR_NUMBER]
       */
      public java.lang.String getParent() {
        return parent;
      }

      /**
       * Required. Resource name of the parent containing the listed services, either a project
       * (https://cloud.google.com/monitoring/api/v3#project_name) or a Monitoring Metrics Scope.
       * The formats are: projects/[PROJECT_ID_OR_NUMBER] workspaces/[HOST_PROJECT_ID_OR_NUMBER]
       */
      public List setParent(java.lang.String parent) {
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
              "Parameter parent must conform to the pattern " +
              "^[^/]+/[^/]+$");
        }
        this.parent = parent;
        return this;
      }

      /**
       * A filter specifying what Services to return. The filter supports filtering on a particular
       * service-identifier type or one of its attributes.To filter on a particular service-
       * identifier type, the identifier_case refers to which option in the identifier field is
       * populated. For example, the filter identifier_case = "CUSTOM" would match all services with
       * a value for the custom field. Valid options include "CUSTOM", "APP_ENGINE", "MESH_ISTIO",
       * and the other options listed at
       * https://cloud.google.com/monitoring/api/ref_v3/rest/v3/services#ServiceTo filter on an
       * attribute of a service-identifier type, apply the filter name by using the snake case of
       * the service-identifier type and the attribute of that service-identifier type, and join the
       * two with a period. For example, to filter by the meshUid field of the MeshIstio service-
       * identifier type, you must filter on mesh_istio.mesh_uid = "123" to match all services with
       * mesh UID "123". Service-identifier types and their attributes are described at
       * https://cloud.google.com/monitoring/api/ref_v3/rest/v3/services#Service
       */
      @com.google.api.client.util.Key
      private java.lang.String filter;

      /** A filter specifying what Services to return. The filter supports filtering on a particular service-
     identifier type or one of its attributes.To filter on a particular service-identifier type, the
     identifier_case refers to which option in the identifier field is populated. For example, the
     filter identifier_case = "CUSTOM" would match all services with a value for the custom field. Valid
     options include "CUSTOM", "APP_ENGINE", "MESH_ISTIO", and the other options listed at
     https://cloud.google.com/monitoring/api/ref_v3/rest/v3/services#ServiceTo filter on an attribute of
     a service-identifier type, apply the filter name by using the snake case of the service-identifier
     type and the attribute of that service-identifier type, and join the two with a period. For
     example, to filter by the meshUid field of the MeshIstio service-identifier type, you must filter
     on mesh_istio.mesh_uid = "123" to match all services with mesh UID "123". Service-identifier types
     and their attributes are described at
     https://cloud.google.com/monitoring/api/ref_v3/rest/v3/services#Service
       */
      public java.lang.String getFilter() {
        return filter;
      }

      /**
       * A filter specifying what Services to return. The filter supports filtering on a particular
       * service-identifier type or one of its attributes.To filter on a particular service-
       * identifier type, the identifier_case refers to which option in the identifier field is
       * populated. For example, the filter identifier_case = "CUSTOM" would match all services with
       * a value for the custom field. Valid options include "CUSTOM", "APP_ENGINE", "MESH_ISTIO",
       * and the other options listed at
       * https://cloud.google.com/monitoring/api/ref_v3/rest/v3/services#ServiceTo filter on an
       * attribute of a service-identifier type, apply the filter name by using the snake case of
       * the service-identifier type and the attribute of that service-identifier type, and join the
       * two with a period. For example, to filter by the meshUid field of the MeshIstio service-
       * identifier type, you must filter on mesh_istio.mesh_uid = "123" to match all services with
       * mesh UID "123". Service-identifier types and their attributes are described at
       * https://cloud.google.com/monitoring/api/ref_v3/rest/v3/services#Service
       */
      public List setFilter(java.lang.String filter) {
        this.filter = filter;
        return this;
      }

      /**
       * A non-negative number that is the maximum number of results to return. When 0, use default
       * page size.
       */
      @com.google.api.client.util.Key
      private java.lang.Integer pageSize;

      /** A non-negative number that is the maximum number of results to return. When 0, use default page
     size.
       */
      public java.lang.Integer getPageSize() {
        return pageSize;
      }

      /**
       * A non-negative number that is the maximum number of results to return. When 0, use default
       * page size.
       */
      public List setPageSize(java.lang.Integer pageSize) {
        this.pageSize = pageSize;
        return this;
      }

      /**
       * If this field is not empty then it must contain the nextPageToken value returned by a
       * previous call to this method. Using this field causes the method to return additional
       * results from the previous method call.
       */
      @com.google.api.client.util.Key
      private java.lang.String pageToken;

      /** If this field is not empty then it must contain the nextPageToken value returned by a previous call
     to this method. Using this field causes the method to return additional results from the previous
     method call.
       */
      public java.lang.String getPageToken() {
        return pageToken;
      }

      /**
       * If this field is not empty then it must contain the nextPageToken value returned by a
       * previous call to this method. Using this field causes the method to return additional
       * results from the previous method call.
       */
      public List setPageToken(java.lang.String pageToken) {
        this.pageToken = pageToken;
        return this;
      }

      @Override
      public List set(String parameterName, Object value) {
        return (List) super.set(parameterName, value);
      }
    }
    /**
     * Update this Service.
     *
     * Create a request for the method "services.patch".
     *
     * This request holds the parameters needed by the monitoring server.  After setting any optional
     * parameters, call the {@link Patch#execute()} method to invoke the remote operation.
     *
     * @param name Identifier. Resource name for this Service. The format is:
     *        projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
     * @param content the {@link com.google.api.services.monitoring.v3.model.Service}
     * @return the request
     */
    public Patch patch(java.lang.String name, com.google.api.services.monitoring.v3.model.Service content) throws java.io.IOException {
      Patch result = new Patch(name, content);
      initialize(result);
      return result;
    }

    public class Patch extends MonitoringRequest<com.google.api.services.monitoring.v3.model.Service> {

      private static final String REST_PATH = "v3/{+name}";

      private final java.util.regex.Pattern NAME_PATTERN =
          java.util.regex.Pattern.compile("^[^/]+/[^/]+/services/[^/]+$");

      /**
       * Update this Service.
       *
       * Create a request for the method "services.patch".
       *
       * This request holds the parameters needed by the the monitoring server.  After setting any
       * optional parameters, call the {@link Patch#execute()} method to invoke the remote operation.
       * <p> {@link
       * Patch#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
       * be called to initialize this instance immediately after invoking the constructor. </p>
       *
       * @param name Identifier. Resource name for this Service. The format is:
     *        projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
       * @param content the {@link com.google.api.services.monitoring.v3.model.Service}
       * @since 1.13
       */
      protected Patch(java.lang.String name, com.google.api.services.monitoring.v3.model.Service content) {
        super(Monitoring.this, "PATCH", REST_PATH, content, com.google.api.services.monitoring.v3.model.Service.class);
        this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
              "Parameter name must conform to the pattern " +
              "^[^/]+/[^/]+/services/[^/]+$");
        }
      }

      @Override
      public Patch set$Xgafv(java.lang.String $Xgafv) {
        return (Patch) super.set$Xgafv($Xgafv);
      }

      @Override
      public Patch setAccessToken(java.lang.String accessToken) {
        return (Patch) super.setAccessToken(accessToken);
      }

      @Override
      public Patch setAlt(java.lang.String alt) {
        return (Patch) super.setAlt(alt);
      }

      @Override
      public Patch setCallback(java.lang.String callback) {
        return (Patch) super.setCallback(callback);
      }

      @Override
      public Patch setFields(java.lang.String fields) {
        return (Patch) super.setFields(fields);
      }

      @Override
      public Patch setKey(java.lang.String key) {
        return (Patch) super.setKey(key);
      }

      @Override
      public Patch setOauthToken(java.lang.String oauthToken) {
        return (Patch) super.setOauthToken(oauthToken);
      }

      @Override
      public Patch setPrettyPrint(java.lang.Boolean prettyPrint) {
        return (Patch) super.setPrettyPrint(prettyPrint);
      }

      @Override
      public Patch setQuotaUser(java.lang.String quotaUser) {
        return (Patch) super.setQuotaUser(quotaUser);
      }

      @Override
      public Patch setUploadType(java.lang.String uploadType) {
        return (Patch) super.setUploadType(uploadType);
      }

      @Override
      public Patch setUploadProtocol(java.lang.String uploadProtocol) {
        return (Patch) super.setUploadProtocol(uploadProtocol);
      }

      /**
       * Identifier. Resource name for this Service. The format is:
       * projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
       */
      @com.google.api.client.util.Key
      private java.lang.String name;

      /** Identifier. Resource name for this Service. The format is:
     projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
       */
      public java.lang.String getName() {
        return name;
      }

      /**
       * Identifier. Resource name for this Service. The format is:
       * projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
       */
      public Patch setName(java.lang.String name) {
        if (!getSuppressPatternChecks()) {
          com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
              "Parameter name must conform to the pattern " +
              "^[^/]+/[^/]+/services/[^/]+$");
        }
        this.name = name;
        return this;
      }

      /** A set of field paths defining which fields to use for the update. */
      @com.google.api.client.util.Key
      private String updateMask;

      /** A set of field paths defining which fields to use for the update.
       */
      public String getUpdateMask() {
        return updateMask;
      }

      /** A set of field paths defining which fields to use for the update. */
      public Patch setUpdateMask(String updateMask) {
        this.updateMask = updateMask;
        return this;
      }

      @Override
      public Patch set(String parameterName, Object value) {
        return (Patch) super.set(parameterName, value);
      }
    }

    /**
     * An accessor for creating requests from the ServiceLevelObjectives collection.
     *
     * <p>The typical use is:</p>
     * <pre>
     *   {@code Monitoring monitoring = new Monitoring(...);}
     *   {@code Monitoring.ServiceLevelObjectives.List request = monitoring.serviceLevelObjectives().list(parameters ...)}
     * </pre>
     *
     * @return the resource collection
     */
    public ServiceLevelObjectives serviceLevelObjectives() {
      return new ServiceLevelObjectives();
    }

    /**
     * The "serviceLevelObjectives" collection of methods.
     */
    public class ServiceLevelObjectives {

      /**
       * Create a ServiceLevelObjective for the given Service.
       *
       * Create a request for the method "serviceLevelObjectives.create".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Create#execute()} method to invoke the remote operation.
       *
       * @param parent Required. Resource name of the parent Service. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
       * @param content the {@link com.google.api.services.monitoring.v3.model.ServiceLevelObjective}
       * @return the request
       */
      public Create create(java.lang.String parent, com.google.api.services.monitoring.v3.model.ServiceLevelObjective content) throws java.io.IOException {
        Create result = new Create(parent, content);
        initialize(result);
        return result;
      }

      public class Create extends MonitoringRequest<com.google.api.services.monitoring.v3.model.ServiceLevelObjective> {

        private static final String REST_PATH = "v3/{+parent}/serviceLevelObjectives";

        private final java.util.regex.Pattern PARENT_PATTERN =
            java.util.regex.Pattern.compile("^[^/]+/[^/]+/services/[^/]+$");

        /**
         * Create a ServiceLevelObjective for the given Service.
         *
         * Create a request for the method "serviceLevelObjectives.create".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
         * <p> {@link
         * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param parent Required. Resource name of the parent Service. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
         * @param content the {@link com.google.api.services.monitoring.v3.model.ServiceLevelObjective}
         * @since 1.13
         */
        protected Create(java.lang.String parent, com.google.api.services.monitoring.v3.model.ServiceLevelObjective content) {
          super(Monitoring.this, "POST", REST_PATH, content, com.google.api.services.monitoring.v3.model.ServiceLevelObjective.class);
          this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                "Parameter parent must conform to the pattern " +
                "^[^/]+/[^/]+/services/[^/]+$");
          }
        }

        @Override
        public Create set$Xgafv(java.lang.String $Xgafv) {
          return (Create) super.set$Xgafv($Xgafv);
        }

        @Override
        public Create setAccessToken(java.lang.String accessToken) {
          return (Create) super.setAccessToken(accessToken);
        }

        @Override
        public Create setAlt(java.lang.String alt) {
          return (Create) super.setAlt(alt);
        }

        @Override
        public Create setCallback(java.lang.String callback) {
          return (Create) super.setCallback(callback);
        }

        @Override
        public Create setFields(java.lang.String fields) {
          return (Create) super.setFields(fields);
        }

        @Override
        public Create setKey(java.lang.String key) {
          return (Create) super.setKey(key);
        }

        @Override
        public Create setOauthToken(java.lang.String oauthToken) {
          return (Create) super.setOauthToken(oauthToken);
        }

        @Override
        public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Create) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Create setQuotaUser(java.lang.String quotaUser) {
          return (Create) super.setQuotaUser(quotaUser);
        }

        @Override
        public Create setUploadType(java.lang.String uploadType) {
          return (Create) super.setUploadType(uploadType);
        }

        @Override
        public Create setUploadProtocol(java.lang.String uploadProtocol) {
          return (Create) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. Resource name of the parent Service. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
         */
        @com.google.api.client.util.Key
        private java.lang.String parent;

        /** Required. Resource name of the parent Service. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
         */
        public java.lang.String getParent() {
          return parent;
        }

        /**
         * Required. Resource name of the parent Service. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
         */
        public Create setParent(java.lang.String parent) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                "Parameter parent must conform to the pattern " +
                "^[^/]+/[^/]+/services/[^/]+$");
          }
          this.parent = parent;
          return this;
        }

        /**
         * Optional. The ServiceLevelObjective id to use for this ServiceLevelObjective. If omitted,
         * an id will be generated instead. Must match the pattern ^[a-zA-Z0-9-_:.]+$
         */
        @com.google.api.client.util.Key
        private java.lang.String serviceLevelObjectiveId;

        /** Optional. The ServiceLevelObjective id to use for this ServiceLevelObjective. If omitted, an id
       will be generated instead. Must match the pattern ^[a-zA-Z0-9-_:.]+$
         */
        public java.lang.String getServiceLevelObjectiveId() {
          return serviceLevelObjectiveId;
        }

        /**
         * Optional. The ServiceLevelObjective id to use for this ServiceLevelObjective. If omitted,
         * an id will be generated instead. Must match the pattern ^[a-zA-Z0-9-_:.]+$
         */
        public Create setServiceLevelObjectiveId(java.lang.String serviceLevelObjectiveId) {
          this.serviceLevelObjectiveId = serviceLevelObjectiveId;
          return this;
        }

        @Override
        public Create set(String parameterName, Object value) {
          return (Create) super.set(parameterName, value);
        }
      }
      /**
       * Delete the given ServiceLevelObjective.
       *
       * Create a request for the method "serviceLevelObjectives.delete".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
       *
       * @param name Required. Resource name of the ServiceLevelObjective to delete. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
       * @return the request
       */
      public Delete delete(java.lang.String name) throws java.io.IOException {
        Delete result = new Delete(name);
        initialize(result);
        return result;
      }

      public class Delete extends MonitoringRequest<com.google.api.services.monitoring.v3.model.Empty> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^[^/]+/[^/]+/services/[^/]+/serviceLevelObjectives/[^/]+$");

        /**
         * Delete the given ServiceLevelObjective.
         *
         * Create a request for the method "serviceLevelObjectives.delete".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
         * <p> {@link
         * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. Resource name of the ServiceLevelObjective to delete. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
         * @since 1.13
         */
        protected Delete(java.lang.String name) {
          super(Monitoring.this, "DELETE", REST_PATH, null, com.google.api.services.monitoring.v3.model.Empty.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^[^/]+/[^/]+/services/[^/]+/serviceLevelObjectives/[^/]+$");
          }
        }

        @Override
        public Delete set$Xgafv(java.lang.String $Xgafv) {
          return (Delete) super.set$Xgafv($Xgafv);
        }

        @Override
        public Delete setAccessToken(java.lang.String accessToken) {
          return (Delete) super.setAccessToken(accessToken);
        }

        @Override
        public Delete setAlt(java.lang.String alt) {
          return (Delete) super.setAlt(alt);
        }

        @Override
        public Delete setCallback(java.lang.String callback) {
          return (Delete) super.setCallback(callback);
        }

        @Override
        public Delete setFields(java.lang.String fields) {
          return (Delete) super.setFields(fields);
        }

        @Override
        public Delete setKey(java.lang.String key) {
          return (Delete) super.setKey(key);
        }

        @Override
        public Delete setOauthToken(java.lang.String oauthToken) {
          return (Delete) super.setOauthToken(oauthToken);
        }

        @Override
        public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Delete) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Delete setQuotaUser(java.lang.String quotaUser) {
          return (Delete) super.setQuotaUser(quotaUser);
        }

        @Override
        public Delete setUploadType(java.lang.String uploadType) {
          return (Delete) super.setUploadType(uploadType);
        }

        @Override
        public Delete setUploadProtocol(java.lang.String uploadProtocol) {
          return (Delete) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. Resource name of the ServiceLevelObjective to delete. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. Resource name of the ServiceLevelObjective to delete. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. Resource name of the ServiceLevelObjective to delete. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
         */
        public Delete setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^[^/]+/[^/]+/services/[^/]+/serviceLevelObjectives/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Delete set(String parameterName, Object value) {
          return (Delete) super.set(parameterName, value);
        }
      }
      /**
       * Get a ServiceLevelObjective by name.
       *
       * Create a request for the method "serviceLevelObjectives.get".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Get#execute()} method to invoke the remote operation.
       *
       * @param name Required. Resource name of the ServiceLevelObjective to get. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
       * @return the request
       */
      public Get get(java.lang.String name) throws java.io.IOException {
        Get result = new Get(name);
        initialize(result);
        return result;
      }

      public class Get extends MonitoringRequest<com.google.api.services.monitoring.v3.model.ServiceLevelObjective> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^[^/]+/[^/]+/services/[^/]+/serviceLevelObjectives/[^/]+$");

        /**
         * Get a ServiceLevelObjective by name.
         *
         * Create a request for the method "serviceLevelObjectives.get".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
         * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Required. Resource name of the ServiceLevelObjective to get. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
         * @since 1.13
         */
        protected Get(java.lang.String name) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.ServiceLevelObjective.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^[^/]+/[^/]+/services/[^/]+/serviceLevelObjectives/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public Get set$Xgafv(java.lang.String $Xgafv) {
          return (Get) super.set$Xgafv($Xgafv);
        }

        @Override
        public Get setAccessToken(java.lang.String accessToken) {
          return (Get) super.setAccessToken(accessToken);
        }

        @Override
        public Get setAlt(java.lang.String alt) {
          return (Get) super.setAlt(alt);
        }

        @Override
        public Get setCallback(java.lang.String callback) {
          return (Get) super.setCallback(callback);
        }

        @Override
        public Get setFields(java.lang.String fields) {
          return (Get) super.setFields(fields);
        }

        @Override
        public Get setKey(java.lang.String key) {
          return (Get) super.setKey(key);
        }

        @Override
        public Get setOauthToken(java.lang.String oauthToken) {
          return (Get) super.setOauthToken(oauthToken);
        }

        @Override
        public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Get) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Get setQuotaUser(java.lang.String quotaUser) {
          return (Get) super.setQuotaUser(quotaUser);
        }

        @Override
        public Get setUploadType(java.lang.String uploadType) {
          return (Get) super.setUploadType(uploadType);
        }

        @Override
        public Get setUploadProtocol(java.lang.String uploadProtocol) {
          return (Get) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. Resource name of the ServiceLevelObjective to get. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Required. Resource name of the ServiceLevelObjective to get. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Required. Resource name of the ServiceLevelObjective to get. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
         */
        public Get setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^[^/]+/[^/]+/services/[^/]+/serviceLevelObjectives/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /**
         * View of the ServiceLevelObjective to return. If DEFAULT, return the ServiceLevelObjective
         * as originally defined. If EXPLICIT and the ServiceLevelObjective is defined in terms of a
         * BasicSli, replace the BasicSli with a RequestBasedSli spelling out how the SLI is
         * computed.
         */
        @com.google.api.client.util.Key
        private java.lang.String view;

        /** View of the ServiceLevelObjective to return. If DEFAULT, return the ServiceLevelObjective as
       originally defined. If EXPLICIT and the ServiceLevelObjective is defined in terms of a BasicSli,
       replace the BasicSli with a RequestBasedSli spelling out how the SLI is computed.
         */
        public java.lang.String getView() {
          return view;
        }

        /**
         * View of the ServiceLevelObjective to return. If DEFAULT, return the ServiceLevelObjective
         * as originally defined. If EXPLICIT and the ServiceLevelObjective is defined in terms of a
         * BasicSli, replace the BasicSli with a RequestBasedSli spelling out how the SLI is
         * computed.
         */
        public Get setView(java.lang.String view) {
          this.view = view;
          return this;
        }

        @Override
        public Get set(String parameterName, Object value) {
          return (Get) super.set(parameterName, value);
        }
      }
      /**
       * List the ServiceLevelObjectives for the given Service.
       *
       * Create a request for the method "serviceLevelObjectives.list".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link List#execute()} method to invoke the remote operation.
       *
       * @param parent Required. Resource name of the parent containing the listed SLOs, either a project or a Monitoring
       *        Metrics Scope. The formats are: projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
       *        workspaces/[HOST_PROJECT_ID_OR_NUMBER]/services/-
       * @return the request
       */
      public List list(java.lang.String parent) throws java.io.IOException {
        List result = new List(parent);
        initialize(result);
        return result;
      }

      public class List extends MonitoringRequest<com.google.api.services.monitoring.v3.model.ListServiceLevelObjectivesResponse> {

        private static final String REST_PATH = "v3/{+parent}/serviceLevelObjectives";

        private final java.util.regex.Pattern PARENT_PATTERN =
            java.util.regex.Pattern.compile("^[^/]+/[^/]+/services/[^/]+$");

        /**
         * List the ServiceLevelObjectives for the given Service.
         *
         * Create a request for the method "serviceLevelObjectives.list".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
         * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param parent Required. Resource name of the parent containing the listed SLOs, either a project or a Monitoring
       *        Metrics Scope. The formats are: projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
       *        workspaces/[HOST_PROJECT_ID_OR_NUMBER]/services/-
         * @since 1.13
         */
        protected List(java.lang.String parent) {
          super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.ListServiceLevelObjectivesResponse.class);
          this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                "Parameter parent must conform to the pattern " +
                "^[^/]+/[^/]+/services/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public List set$Xgafv(java.lang.String $Xgafv) {
          return (List) super.set$Xgafv($Xgafv);
        }

        @Override
        public List setAccessToken(java.lang.String accessToken) {
          return (List) super.setAccessToken(accessToken);
        }

        @Override
        public List setAlt(java.lang.String alt) {
          return (List) super.setAlt(alt);
        }

        @Override
        public List setCallback(java.lang.String callback) {
          return (List) super.setCallback(callback);
        }

        @Override
        public List setFields(java.lang.String fields) {
          return (List) super.setFields(fields);
        }

        @Override
        public List setKey(java.lang.String key) {
          return (List) super.setKey(key);
        }

        @Override
        public List setOauthToken(java.lang.String oauthToken) {
          return (List) super.setOauthToken(oauthToken);
        }

        @Override
        public List setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (List) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public List setQuotaUser(java.lang.String quotaUser) {
          return (List) super.setQuotaUser(quotaUser);
        }

        @Override
        public List setUploadType(java.lang.String uploadType) {
          return (List) super.setUploadType(uploadType);
        }

        @Override
        public List setUploadProtocol(java.lang.String uploadProtocol) {
          return (List) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Required. Resource name of the parent containing the listed SLOs, either a project or a
         * Monitoring Metrics Scope. The formats are:
         * projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
         * workspaces/[HOST_PROJECT_ID_OR_NUMBER]/services/-
         */
        @com.google.api.client.util.Key
        private java.lang.String parent;

        /** Required. Resource name of the parent containing the listed SLOs, either a project or a Monitoring
       Metrics Scope. The formats are: projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
       workspaces/[HOST_PROJECT_ID_OR_NUMBER]/services/-
         */
        public java.lang.String getParent() {
          return parent;
        }

        /**
         * Required. Resource name of the parent containing the listed SLOs, either a project or a
         * Monitoring Metrics Scope. The formats are:
         * projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
         * workspaces/[HOST_PROJECT_ID_OR_NUMBER]/services/-
         */
        public List setParent(java.lang.String parent) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                "Parameter parent must conform to the pattern " +
                "^[^/]+/[^/]+/services/[^/]+$");
          }
          this.parent = parent;
          return this;
        }

        /** A filter specifying what ServiceLevelObjectives to return. */
        @com.google.api.client.util.Key
        private java.lang.String filter;

        /** A filter specifying what ServiceLevelObjectives to return.
         */
        public java.lang.String getFilter() {
          return filter;
        }

        /** A filter specifying what ServiceLevelObjectives to return. */
        public List setFilter(java.lang.String filter) {
          this.filter = filter;
          return this;
        }

        /**
         * A non-negative number that is the maximum number of results to return. When 0, use
         * default page size.
         */
        @com.google.api.client.util.Key
        private java.lang.Integer pageSize;

        /** A non-negative number that is the maximum number of results to return. When 0, use default page
       size.
         */
        public java.lang.Integer getPageSize() {
          return pageSize;
        }

        /**
         * A non-negative number that is the maximum number of results to return. When 0, use
         * default page size.
         */
        public List setPageSize(java.lang.Integer pageSize) {
          this.pageSize = pageSize;
          return this;
        }

        /**
         * If this field is not empty then it must contain the nextPageToken value returned by a
         * previous call to this method. Using this field causes the method to return additional
         * results from the previous method call.
         */
        @com.google.api.client.util.Key
        private java.lang.String pageToken;

        /** If this field is not empty then it must contain the nextPageToken value returned by a previous call
       to this method. Using this field causes the method to return additional results from the previous
       method call.
         */
        public java.lang.String getPageToken() {
          return pageToken;
        }

        /**
         * If this field is not empty then it must contain the nextPageToken value returned by a
         * previous call to this method. Using this field causes the method to return additional
         * results from the previous method call.
         */
        public List setPageToken(java.lang.String pageToken) {
          this.pageToken = pageToken;
          return this;
        }

        /**
         * View of the ServiceLevelObjectives to return. If DEFAULT, return each
         * ServiceLevelObjective as originally defined. If EXPLICIT and the ServiceLevelObjective is
         * defined in terms of a BasicSli, replace the BasicSli with a RequestBasedSli spelling out
         * how the SLI is computed.
         */
        @com.google.api.client.util.Key
        private java.lang.String view;

        /** View of the ServiceLevelObjectives to return. If DEFAULT, return each ServiceLevelObjective as
       originally defined. If EXPLICIT and the ServiceLevelObjective is defined in terms of a BasicSli,
       replace the BasicSli with a RequestBasedSli spelling out how the SLI is computed.
         */
        public java.lang.String getView() {
          return view;
        }

        /**
         * View of the ServiceLevelObjectives to return. If DEFAULT, return each
         * ServiceLevelObjective as originally defined. If EXPLICIT and the ServiceLevelObjective is
         * defined in terms of a BasicSli, replace the BasicSli with a RequestBasedSli spelling out
         * how the SLI is computed.
         */
        public List setView(java.lang.String view) {
          this.view = view;
          return this;
        }

        @Override
        public List set(String parameterName, Object value) {
          return (List) super.set(parameterName, value);
        }
      }
      /**
       * Update the given ServiceLevelObjective.
       *
       * Create a request for the method "serviceLevelObjectives.patch".
       *
       * This request holds the parameters needed by the monitoring server.  After setting any optional
       * parameters, call the {@link Patch#execute()} method to invoke the remote operation.
       *
       * @param name Identifier. Resource name for this ServiceLevelObjective. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
       * @param content the {@link com.google.api.services.monitoring.v3.model.ServiceLevelObjective}
       * @return the request
       */
      public Patch patch(java.lang.String name, com.google.api.services.monitoring.v3.model.ServiceLevelObjective content) throws java.io.IOException {
        Patch result = new Patch(name, content);
        initialize(result);
        return result;
      }

      public class Patch extends MonitoringRequest<com.google.api.services.monitoring.v3.model.ServiceLevelObjective> {

        private static final String REST_PATH = "v3/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^[^/]+/[^/]+/services/[^/]+/serviceLevelObjectives/[^/]+$");

        /**
         * Update the given ServiceLevelObjective.
         *
         * Create a request for the method "serviceLevelObjectives.patch".
         *
         * This request holds the parameters needed by the the monitoring server.  After setting any
         * optional parameters, call the {@link Patch#execute()} method to invoke the remote operation.
         * <p> {@link
         * Patch#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
         * be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Identifier. Resource name for this ServiceLevelObjective. The format is:
       *        projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
         * @param content the {@link com.google.api.services.monitoring.v3.model.ServiceLevelObjective}
         * @since 1.13
         */
        protected Patch(java.lang.String name, com.google.api.services.monitoring.v3.model.ServiceLevelObjective content) {
          super(Monitoring.this, "PATCH", REST_PATH, content, com.google.api.services.monitoring.v3.model.ServiceLevelObjective.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^[^/]+/[^/]+/services/[^/]+/serviceLevelObjectives/[^/]+$");
          }
        }

        @Override
        public Patch set$Xgafv(java.lang.String $Xgafv) {
          return (Patch) super.set$Xgafv($Xgafv);
        }

        @Override
        public Patch setAccessToken(java.lang.String accessToken) {
          return (Patch) super.setAccessToken(accessToken);
        }

        @Override
        public Patch setAlt(java.lang.String alt) {
          return (Patch) super.setAlt(alt);
        }

        @Override
        public Patch setCallback(java.lang.String callback) {
          return (Patch) super.setCallback(callback);
        }

        @Override
        public Patch setFields(java.lang.String fields) {
          return (Patch) super.setFields(fields);
        }

        @Override
        public Patch setKey(java.lang.String key) {
          return (Patch) super.setKey(key);
        }

        @Override
        public Patch setOauthToken(java.lang.String oauthToken) {
          return (Patch) super.setOauthToken(oauthToken);
        }

        @Override
        public Patch setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Patch) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Patch setQuotaUser(java.lang.String quotaUser) {
          return (Patch) super.setQuotaUser(quotaUser);
        }

        @Override
        public Patch setUploadType(java.lang.String uploadType) {
          return (Patch) super.setUploadType(uploadType);
        }

        @Override
        public Patch setUploadProtocol(java.lang.String uploadProtocol) {
          return (Patch) super.setUploadProtocol(uploadProtocol);
        }

        /**
         * Identifier. Resource name for this ServiceLevelObjective. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
         */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Identifier. Resource name for this ServiceLevelObjective. The format is:
       projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
         */
        public java.lang.String getName() {
          return name;
        }

        /**
         * Identifier. Resource name for this ServiceLevelObjective. The format is:
         * projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
         */
        public Patch setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^[^/]+/[^/]+/services/[^/]+/serviceLevelObjectives/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /** A set of field paths defining which fields to use for the update. */
        @com.google.api.client.util.Key
        private String updateMask;

        /** A set of field paths defining which fields to use for the update.
         */
        public String getUpdateMask() {
          return updateMask;
        }

        /** A set of field paths defining which fields to use for the update. */
        public Patch setUpdateMask(String updateMask) {
          this.updateMask = updateMask;
          return this;
        }

        @Override
        public Patch set(String parameterName, Object value) {
          return (Patch) super.set(parameterName, value);
        }
      }

    }
  }

  /**
   * An accessor for creating requests from the UptimeCheckIps collection.
   *
   * <p>The typical use is:</p>
   * <pre>
   *   {@code Monitoring monitoring = new Monitoring(...);}
   *   {@code Monitoring.UptimeCheckIps.List request = monitoring.uptimeCheckIps().list(parameters ...)}
   * </pre>
   *
   * @return the resource collection
   */
  public UptimeCheckIps uptimeCheckIps() {
    return new UptimeCheckIps();
  }

  /**
   * The "uptimeCheckIps" collection of methods.
   */
  public class UptimeCheckIps {

    /**
     * Returns the list of IP addresses that checkers run from
     *
     * Create a request for the method "uptimeCheckIps.list".
     *
     * This request holds the parameters needed by the monitoring server.  After setting any optional
     * parameters, call the {@link List#execute()} method to invoke the remote operation.
     *
     * @return the request
     */
    public List list() throws java.io.IOException {
      List result = new List();
      initialize(result);
      return result;
    }

    public class List extends MonitoringRequest<com.google.api.services.monitoring.v3.model.ListUptimeCheckIpsResponse> {

      private static final String REST_PATH = "v3/uptimeCheckIps";

      /**
       * Returns the list of IP addresses that checkers run from
       *
       * Create a request for the method "uptimeCheckIps.list".
       *
       * This request holds the parameters needed by the the monitoring server.  After setting any
       * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
       * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
       * must be called to initialize this instance immediately after invoking the constructor. </p>
       *
       * @since 1.13
       */
      protected List() {
        super(Monitoring.this, "GET", REST_PATH, null, com.google.api.services.monitoring.v3.model.ListUptimeCheckIpsResponse.class);
      }

      @Override
      public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
        return super.executeUsingHead();
      }

      @Override
      public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
        return super.buildHttpRequestUsingHead();
      }

      @Override
      public List set$Xgafv(java.lang.String $Xgafv) {
        return (List) super.set$Xgafv($Xgafv);
      }

      @Override
      public List setAccessToken(java.lang.String accessToken) {
        return (List) super.setAccessToken(accessToken);
      }

      @Override
      public List setAlt(java.lang.String alt) {
        return (List) super.setAlt(alt);
      }

      @Override
      public List setCallback(java.lang.String callback) {
        return (List) super.setCallback(callback);
      }

      @Override
      public List setFields(java.lang.String fields) {
        return (List) super.setFields(fields);
      }

      @Override
      public List setKey(java.lang.String key) {
        return (List) super.setKey(key);
      }

      @Override
      public List setOauthToken(java.lang.String oauthToken) {
        return (List) super.setOauthToken(oauthToken);
      }

      @Override
      public List setPrettyPrint(java.lang.Boolean prettyPrint) {
        return (List) super.setPrettyPrint(prettyPrint);
      }

      @Override
      public List setQuotaUser(java.lang.String quotaUser) {
        return (List) super.setQuotaUser(quotaUser);
      }

      @Override
      public List setUploadType(java.lang.String uploadType) {
        return (List) super.setUploadType(uploadType);
      }

      @Override
      public List setUploadProtocol(java.lang.String uploadProtocol) {
        return (List) super.setUploadProtocol(uploadProtocol);
      }

      /**
       * The maximum number of results to return in a single response. The server may further
       * constrain the maximum number of results returned in a single page. If the page_size is <=0,
       * the server will decide the number of results to be returned. NOTE: this field is not yet
       * implemented
       */
      @com.google.api.client.util.Key
      private java.lang.Integer pageSize;

      /** The maximum number of results to return in a single response. The server may further constrain the
     maximum number of results returned in a single page. If the page_size is <=0, the server will
     decide the number of results to be returned. NOTE: this field is not yet implemented
       */
      public java.lang.Integer getPageSize() {
        return pageSize;
      }

      /**
       * The maximum number of results to return in a single response. The server may further
       * constrain the maximum number of results returned in a single page. If the page_size is <=0,
       * the server will decide the number of results to be returned. NOTE: this field is not yet
       * implemented
       */
      public List setPageSize(java.lang.Integer pageSize) {
        this.pageSize = pageSize;
        return this;
      }

      /**
       * If this field is not empty then it must contain the nextPageToken value returned by a
       * previous call to this method. Using this field causes the method to return more results
       * from the previous method call. NOTE: this field is not yet implemented
       */
      @com.google.api.client.util.Key
      private java.lang.String pageToken;

      /** If this field is not empty then it must contain the nextPageToken value returned by a previous call
     to this method. Using this field causes the method to return more results from the previous method
     call. NOTE: this field is not yet implemented
       */
      public java.lang.String getPageToken() {
        return pageToken;
      }

      /**
       * If this field is not empty then it must contain the nextPageToken value returned by a
       * previous call to this method. Using this field causes the method to return more results
       * from the previous method call. NOTE: this field is not yet implemented
       */
      public List setPageToken(java.lang.String pageToken) {
        this.pageToken = pageToken;
        return this;
      }

      @Override
      public List set(String parameterName, Object value) {
        return (List) super.set(parameterName, value);
      }
    }

  }

  /**
   * Builder for {@link Monitoring}.
   *
   * <p>
   * Implementation is not thread-safe.
   * </p>
   *
   * @since 1.3.0
   */
  public static final class Builder extends com.google.api.client.googleapis.services.json.AbstractGoogleJsonClient.Builder {

    private static String chooseEndpoint(com.google.api.client.http.HttpTransport transport) {
      // If the GOOGLE_API_USE_MTLS_ENDPOINT environment variable value is "always", use mTLS endpoint.
      // If the env variable is "auto", use mTLS endpoint if and only if the transport is mTLS.
      // Use the regular endpoint for all other cases.
      String useMtlsEndpoint = System.getenv("GOOGLE_API_USE_MTLS_ENDPOINT");
      useMtlsEndpoint = useMtlsEndpoint == null ? "auto" : useMtlsEndpoint;
      if ("always".equals(useMtlsEndpoint) || ("auto".equals(useMtlsEndpoint) && transport != null && transport.isMtls())) {
        return DEFAULT_MTLS_ROOT_URL;
      }
      return DEFAULT_ROOT_URL;
    }

    /**
     * Returns an instance of a new builder.
     *
     * @param transport HTTP transport, which should normally be:
     *        <ul>
     *        <li>Google App Engine:
     *        {@code com.google.api.client.extensions.appengine.http.UrlFetchTransport}</li>
     *        <li>Android: {@code newCompatibleTransport} from
     *        {@code com.google.api.client.extensions.android.http.AndroidHttp}</li>
     *        <li>Java: {@link com.google.api.client.googleapis.javanet.GoogleNetHttpTransport#newTrustedTransport()}
     *        </li>
     *        </ul>
     * @param jsonFactory JSON factory, which may be:
     *        <ul>
     *        <li>Jackson: {@code com.google.api.client.json.jackson2.JacksonFactory}</li>
     *        <li>Google GSON: {@code com.google.api.client.json.gson.GsonFactory}</li>
     *        <li>Android Honeycomb or higher:
     *        {@code com.google.api.client.extensions.android.json.AndroidJsonFactory}</li>
     *        </ul>
     * @param httpRequestInitializer HTTP request initializer or {@code null} for none
     * @since 1.7
     */
    public Builder(com.google.api.client.http.HttpTransport transport, com.google.api.client.json.JsonFactory jsonFactory,
        com.google.api.client.http.HttpRequestInitializer httpRequestInitializer) {
      super(
          transport,
          jsonFactory,
          Builder.chooseEndpoint(transport),
          DEFAULT_SERVICE_PATH,
          httpRequestInitializer,
          false);
      setBatchPath(DEFAULT_BATCH_PATH);
    }

    /** Builds a new instance of {@link Monitoring}. */
    @Override
    public Monitoring build() {
      return new Monitoring(this);
    }

    @Override
    public Builder setRootUrl(String rootUrl) {
      return (Builder) super.setRootUrl(rootUrl);
    }

    @Override
    public Builder setServicePath(String servicePath) {
      return (Builder) super.setServicePath(servicePath);
    }

    @Override
    public Builder setBatchPath(String batchPath) {
      return (Builder) super.setBatchPath(batchPath);
    }

    @Override
    public Builder setHttpRequestInitializer(com.google.api.client.http.HttpRequestInitializer httpRequestInitializer) {
      return (Builder) super.setHttpRequestInitializer(httpRequestInitializer);
    }

    @Override
    public Builder setApplicationName(String applicationName) {
      return (Builder) super.setApplicationName(applicationName);
    }

    @Override
    public Builder setSuppressPatternChecks(boolean suppressPatternChecks) {
      return (Builder) super.setSuppressPatternChecks(suppressPatternChecks);
    }

    @Override
    public Builder setSuppressRequiredParameterChecks(boolean suppressRequiredParameterChecks) {
      return (Builder) super.setSuppressRequiredParameterChecks(suppressRequiredParameterChecks);
    }

    @Override
    public Builder setSuppressAllChecks(boolean suppressAllChecks) {
      return (Builder) super.setSuppressAllChecks(suppressAllChecks);
    }

    /**
     * Set the {@link MonitoringRequestInitializer}.
     *
     * @since 1.12
     */
    public Builder setMonitoringRequestInitializer(
        MonitoringRequestInitializer monitoringRequestInitializer) {
      return (Builder) super.setGoogleClientRequestInitializer(monitoringRequestInitializer);
    }

    @Override
    public Builder setGoogleClientRequestInitializer(
        com.google.api.client.googleapis.services.GoogleClientRequestInitializer googleClientRequestInitializer) {
      return (Builder) super.setGoogleClientRequestInitializer(googleClientRequestInitializer);
    }

    @Override
    public Builder setUniverseDomain(String universeDomain) {
      return (Builder) super.setUniverseDomain(universeDomain);
    }
  }
}
