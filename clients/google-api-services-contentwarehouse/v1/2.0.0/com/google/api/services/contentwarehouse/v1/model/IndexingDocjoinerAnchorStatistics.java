/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.contentwarehouse.v1.model;

/**
 * Statistics of the anchors in a docjoin. Next available tag ID: 63.
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the Document AI Warehouse API. For a detailed explanation
 * see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class IndexingDocjoinerAnchorStatistics extends com.google.api.client.json.GenericJson {

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer anchorCount;

  /**
   * The number of unique anchor phrases. Capped by the constant kMaxAnchorPhraseCountInStats
   * (=5000) defined in indexing/docjoiner/anchors/anchor-manager.cc.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer anchorPhraseCount;

  /**
   * This structure contains signals and penalties of AnchorSpamPenalizer. It replaces
   * phrase_anchor_spam_info above, that is deprecated.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private IndexingDocjoinerAnchorSpamInfo anchorSpamInfo;

  /**
   * The number of anchors for which some ImprovAnchors phrases have been removed due to duplication
   * within source org.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer anchorsWithDedupedImprovanchors;

  /**
   * Whether this doc is penalized by BadBackLinks, in which case we should not use improvanchor
   * score in mustang ascorer.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean badbacklinksPenalized;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer baseAnchorCount;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer baseOffdomainAnchorCount;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer droppedHomepageAnchorCount;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer droppedLocalAnchorCount;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer droppedNonLocalAnchorCount;

  /**
   * Sum of anchors_dropped in the repeated group RedundantAnchorInfo, but can go higher if the
   * latter reaches the cap of kMaxRecordsToKeep. (indexing/docjoiner/anchors/anchor-loader.cc),
   * currently 10,000
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer droppedRedundantAnchorCount;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer fakeAnchorCount;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer forwardedAnchorCount;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer forwardedOffdomainAnchorCount;

  /**
   * Metric of number of changed global anchors computed as, size(union(previous, new) -
   * intersection(previous, new)).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer globalAnchorDelta;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer linkBeforeSitechangeTaggedAnchors;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer localAnchorCount;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer lowCorpusAnchorCount;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer lowCorpusOffdomainAnchorCount;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer mediumCorpusAnchorCount;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer mediumCorpusOffdomainAnchorCount;

  /**
   * Minimum local outdegree of all anchor sources that are domain home pages as well as on the same
   * domain as the current target URL.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer minDomainHomePageLocalOutdegree;

  /**
   * Minimum local outdegree of all anchor sources that are host home pages as well as on the same
   * host as the current target URL.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer minHostHomePageLocalOutdegree;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer nonLocalAnchorCount;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer offdomainAnchorCount;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer ondomainAnchorCount;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer onsiteAnchorCount;

  /**
   * Set in SignalPenalizer::FillInAnchorStatistics.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer pageFromExpiredTaggedAnchors;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer pageMismatchTaggedAnchors;

  /**
   * Doc is protected by goodness of early anchors.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean penguinEarlyAnchorProtected;

  /**
   * BEGIN: Penguin related fields. Timestamp when penguin scores were last updated. Measured in
   * days since Jan. 1st 1995.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer penguinLastUpdate;

  /**
   * Page-level penguin penalty (0 = good, 1 = bad).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Float penguinPenalty;

  /**
   * Doc not scored because it has too many anchor sources. END: Penguin related fields.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean penguinTooManySources;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<IndexingDocjoinerAnchorStatisticsPerDupStats> perdupstats;

  /**
   * Following signals identify spike of spammy anchor phrases. Anchors created during the spike are
   * tagged with LINK_SPAM_PHRASE_SPIKE.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private IndexingDocjoinerAnchorPhraseSpamInfo phraseAnchorSpamInfo;

  /**
   * Total anchor dropped due to exceed per domain phrase cap. Equals to sum of anchors_dropped in
   * the repeated group RedundantAnchorInfoForPhraseCap, but can go higher if the latter reaches the
   * cap of kMaxDomainsToKeepForPhraseCap (indexing/docjoiner/anchors/anchor-loader.h), currently
   * 1000.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer redundantAnchorForPhraseCapCount;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<IndexingDocjoinerAnchorStatisticsRedundantAnchorInfo> redundantanchorinfo;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<IndexingDocjoinerAnchorStatisticsRedundantAnchorInfoForPhraseCap> redundantanchorinfoforphrasecap;

  /**
   * The total number of anchors being scanned from storage.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer scannedAnchorCount;

  /**
   * A count of the number of times anchor accumulation has been skipped for this document. Note:
   * Only used when canonical.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer skippedAccumulate;

  /**
   * Reason to skip accumulate, when skipped, or Reason for reprocessing when not skipped.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String skippedOrReusedReason;

  /**
   * The log base 10 odds that this set of anchors exhibits spammy behavior. Computed in the
   * AnchorLocalizer.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Float spamLog10Odds;

  /**
   * Walltime of when anchors were accumulated last.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer timestamp;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer topPrOffdomainAnchorCount;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer topPrOndomainAnchorCount;

  /**
   * According to anchor quality bucket, anchor with pagrank > 51000 is the best anchor. anchors
   * with pagerank < 47000 are all same.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer topPrOnsiteAnchorCount;

  /**
   * The following should be equal to the size of the following repeated group, except that it can
   * go higher than 10,000.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer totalDomainPhrasePairsAboveLimit;

  /**
   * Number of domain/phrase pairs in total -- i.e. how many anchors we would have if the
   * domain/phrase cutoff was set to 1 instead of 200. This is "approx" for large anchor clusters
   * because there can be double counting when the LRU cache forgets about rare domain/phrase pairs.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer totalDomainPhrasePairsSeenApprox;

  /**
   * Number of domains above per domain phrase cap. We see too many phrases in the domains.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer totalDomainsAbovePhraseCap;

  /**
   * Number of domains seen in total.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer totalDomainsSeen;

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getAnchorCount() {
    return anchorCount;
  }

  /**
   * @param anchorCount anchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setAnchorCount(java.lang.Integer anchorCount) {
    this.anchorCount = anchorCount;
    return this;
  }

  /**
   * The number of unique anchor phrases. Capped by the constant kMaxAnchorPhraseCountInStats
   * (=5000) defined in indexing/docjoiner/anchors/anchor-manager.cc.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getAnchorPhraseCount() {
    return anchorPhraseCount;
  }

  /**
   * The number of unique anchor phrases. Capped by the constant kMaxAnchorPhraseCountInStats
   * (=5000) defined in indexing/docjoiner/anchors/anchor-manager.cc.
   * @param anchorPhraseCount anchorPhraseCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setAnchorPhraseCount(java.lang.Integer anchorPhraseCount) {
    this.anchorPhraseCount = anchorPhraseCount;
    return this;
  }

  /**
   * This structure contains signals and penalties of AnchorSpamPenalizer. It replaces
   * phrase_anchor_spam_info above, that is deprecated.
   * @return value or {@code null} for none
   */
  public IndexingDocjoinerAnchorSpamInfo getAnchorSpamInfo() {
    return anchorSpamInfo;
  }

  /**
   * This structure contains signals and penalties of AnchorSpamPenalizer. It replaces
   * phrase_anchor_spam_info above, that is deprecated.
   * @param anchorSpamInfo anchorSpamInfo or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setAnchorSpamInfo(IndexingDocjoinerAnchorSpamInfo anchorSpamInfo) {
    this.anchorSpamInfo = anchorSpamInfo;
    return this;
  }

  /**
   * The number of anchors for which some ImprovAnchors phrases have been removed due to duplication
   * within source org.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getAnchorsWithDedupedImprovanchors() {
    return anchorsWithDedupedImprovanchors;
  }

  /**
   * The number of anchors for which some ImprovAnchors phrases have been removed due to duplication
   * within source org.
   * @param anchorsWithDedupedImprovanchors anchorsWithDedupedImprovanchors or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setAnchorsWithDedupedImprovanchors(java.lang.Integer anchorsWithDedupedImprovanchors) {
    this.anchorsWithDedupedImprovanchors = anchorsWithDedupedImprovanchors;
    return this;
  }

  /**
   * Whether this doc is penalized by BadBackLinks, in which case we should not use improvanchor
   * score in mustang ascorer.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getBadbacklinksPenalized() {
    return badbacklinksPenalized;
  }

  /**
   * Whether this doc is penalized by BadBackLinks, in which case we should not use improvanchor
   * score in mustang ascorer.
   * @param badbacklinksPenalized badbacklinksPenalized or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setBadbacklinksPenalized(java.lang.Boolean badbacklinksPenalized) {
    this.badbacklinksPenalized = badbacklinksPenalized;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getBaseAnchorCount() {
    return baseAnchorCount;
  }

  /**
   * @param baseAnchorCount baseAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setBaseAnchorCount(java.lang.Integer baseAnchorCount) {
    this.baseAnchorCount = baseAnchorCount;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getBaseOffdomainAnchorCount() {
    return baseOffdomainAnchorCount;
  }

  /**
   * @param baseOffdomainAnchorCount baseOffdomainAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setBaseOffdomainAnchorCount(java.lang.Integer baseOffdomainAnchorCount) {
    this.baseOffdomainAnchorCount = baseOffdomainAnchorCount;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getDroppedHomepageAnchorCount() {
    return droppedHomepageAnchorCount;
  }

  /**
   * @param droppedHomepageAnchorCount droppedHomepageAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setDroppedHomepageAnchorCount(java.lang.Integer droppedHomepageAnchorCount) {
    this.droppedHomepageAnchorCount = droppedHomepageAnchorCount;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getDroppedLocalAnchorCount() {
    return droppedLocalAnchorCount;
  }

  /**
   * @param droppedLocalAnchorCount droppedLocalAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setDroppedLocalAnchorCount(java.lang.Integer droppedLocalAnchorCount) {
    this.droppedLocalAnchorCount = droppedLocalAnchorCount;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getDroppedNonLocalAnchorCount() {
    return droppedNonLocalAnchorCount;
  }

  /**
   * @param droppedNonLocalAnchorCount droppedNonLocalAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setDroppedNonLocalAnchorCount(java.lang.Integer droppedNonLocalAnchorCount) {
    this.droppedNonLocalAnchorCount = droppedNonLocalAnchorCount;
    return this;
  }

  /**
   * Sum of anchors_dropped in the repeated group RedundantAnchorInfo, but can go higher if the
   * latter reaches the cap of kMaxRecordsToKeep. (indexing/docjoiner/anchors/anchor-loader.cc),
   * currently 10,000
   * @return value or {@code null} for none
   */
  public java.lang.Integer getDroppedRedundantAnchorCount() {
    return droppedRedundantAnchorCount;
  }

  /**
   * Sum of anchors_dropped in the repeated group RedundantAnchorInfo, but can go higher if the
   * latter reaches the cap of kMaxRecordsToKeep. (indexing/docjoiner/anchors/anchor-loader.cc),
   * currently 10,000
   * @param droppedRedundantAnchorCount droppedRedundantAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setDroppedRedundantAnchorCount(java.lang.Integer droppedRedundantAnchorCount) {
    this.droppedRedundantAnchorCount = droppedRedundantAnchorCount;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getFakeAnchorCount() {
    return fakeAnchorCount;
  }

  /**
   * @param fakeAnchorCount fakeAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setFakeAnchorCount(java.lang.Integer fakeAnchorCount) {
    this.fakeAnchorCount = fakeAnchorCount;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getForwardedAnchorCount() {
    return forwardedAnchorCount;
  }

  /**
   * @param forwardedAnchorCount forwardedAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setForwardedAnchorCount(java.lang.Integer forwardedAnchorCount) {
    this.forwardedAnchorCount = forwardedAnchorCount;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getForwardedOffdomainAnchorCount() {
    return forwardedOffdomainAnchorCount;
  }

  /**
   * @param forwardedOffdomainAnchorCount forwardedOffdomainAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setForwardedOffdomainAnchorCount(java.lang.Integer forwardedOffdomainAnchorCount) {
    this.forwardedOffdomainAnchorCount = forwardedOffdomainAnchorCount;
    return this;
  }

  /**
   * Metric of number of changed global anchors computed as, size(union(previous, new) -
   * intersection(previous, new)).
   * @return value or {@code null} for none
   */
  public java.lang.Integer getGlobalAnchorDelta() {
    return globalAnchorDelta;
  }

  /**
   * Metric of number of changed global anchors computed as, size(union(previous, new) -
   * intersection(previous, new)).
   * @param globalAnchorDelta globalAnchorDelta or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setGlobalAnchorDelta(java.lang.Integer globalAnchorDelta) {
    this.globalAnchorDelta = globalAnchorDelta;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getLinkBeforeSitechangeTaggedAnchors() {
    return linkBeforeSitechangeTaggedAnchors;
  }

  /**
   * @param linkBeforeSitechangeTaggedAnchors linkBeforeSitechangeTaggedAnchors or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setLinkBeforeSitechangeTaggedAnchors(java.lang.Integer linkBeforeSitechangeTaggedAnchors) {
    this.linkBeforeSitechangeTaggedAnchors = linkBeforeSitechangeTaggedAnchors;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getLocalAnchorCount() {
    return localAnchorCount;
  }

  /**
   * @param localAnchorCount localAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setLocalAnchorCount(java.lang.Integer localAnchorCount) {
    this.localAnchorCount = localAnchorCount;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getLowCorpusAnchorCount() {
    return lowCorpusAnchorCount;
  }

  /**
   * @param lowCorpusAnchorCount lowCorpusAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setLowCorpusAnchorCount(java.lang.Integer lowCorpusAnchorCount) {
    this.lowCorpusAnchorCount = lowCorpusAnchorCount;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getLowCorpusOffdomainAnchorCount() {
    return lowCorpusOffdomainAnchorCount;
  }

  /**
   * @param lowCorpusOffdomainAnchorCount lowCorpusOffdomainAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setLowCorpusOffdomainAnchorCount(java.lang.Integer lowCorpusOffdomainAnchorCount) {
    this.lowCorpusOffdomainAnchorCount = lowCorpusOffdomainAnchorCount;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getMediumCorpusAnchorCount() {
    return mediumCorpusAnchorCount;
  }

  /**
   * @param mediumCorpusAnchorCount mediumCorpusAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setMediumCorpusAnchorCount(java.lang.Integer mediumCorpusAnchorCount) {
    this.mediumCorpusAnchorCount = mediumCorpusAnchorCount;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getMediumCorpusOffdomainAnchorCount() {
    return mediumCorpusOffdomainAnchorCount;
  }

  /**
   * @param mediumCorpusOffdomainAnchorCount mediumCorpusOffdomainAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setMediumCorpusOffdomainAnchorCount(java.lang.Integer mediumCorpusOffdomainAnchorCount) {
    this.mediumCorpusOffdomainAnchorCount = mediumCorpusOffdomainAnchorCount;
    return this;
  }

  /**
   * Minimum local outdegree of all anchor sources that are domain home pages as well as on the same
   * domain as the current target URL.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getMinDomainHomePageLocalOutdegree() {
    return minDomainHomePageLocalOutdegree;
  }

  /**
   * Minimum local outdegree of all anchor sources that are domain home pages as well as on the same
   * domain as the current target URL.
   * @param minDomainHomePageLocalOutdegree minDomainHomePageLocalOutdegree or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setMinDomainHomePageLocalOutdegree(java.lang.Integer minDomainHomePageLocalOutdegree) {
    this.minDomainHomePageLocalOutdegree = minDomainHomePageLocalOutdegree;
    return this;
  }

  /**
   * Minimum local outdegree of all anchor sources that are host home pages as well as on the same
   * host as the current target URL.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getMinHostHomePageLocalOutdegree() {
    return minHostHomePageLocalOutdegree;
  }

  /**
   * Minimum local outdegree of all anchor sources that are host home pages as well as on the same
   * host as the current target URL.
   * @param minHostHomePageLocalOutdegree minHostHomePageLocalOutdegree or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setMinHostHomePageLocalOutdegree(java.lang.Integer minHostHomePageLocalOutdegree) {
    this.minHostHomePageLocalOutdegree = minHostHomePageLocalOutdegree;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getNonLocalAnchorCount() {
    return nonLocalAnchorCount;
  }

  /**
   * @param nonLocalAnchorCount nonLocalAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setNonLocalAnchorCount(java.lang.Integer nonLocalAnchorCount) {
    this.nonLocalAnchorCount = nonLocalAnchorCount;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getOffdomainAnchorCount() {
    return offdomainAnchorCount;
  }

  /**
   * @param offdomainAnchorCount offdomainAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setOffdomainAnchorCount(java.lang.Integer offdomainAnchorCount) {
    this.offdomainAnchorCount = offdomainAnchorCount;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getOndomainAnchorCount() {
    return ondomainAnchorCount;
  }

  /**
   * @param ondomainAnchorCount ondomainAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setOndomainAnchorCount(java.lang.Integer ondomainAnchorCount) {
    this.ondomainAnchorCount = ondomainAnchorCount;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getOnsiteAnchorCount() {
    return onsiteAnchorCount;
  }

  /**
   * @param onsiteAnchorCount onsiteAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setOnsiteAnchorCount(java.lang.Integer onsiteAnchorCount) {
    this.onsiteAnchorCount = onsiteAnchorCount;
    return this;
  }

  /**
   * Set in SignalPenalizer::FillInAnchorStatistics.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getPageFromExpiredTaggedAnchors() {
    return pageFromExpiredTaggedAnchors;
  }

  /**
   * Set in SignalPenalizer::FillInAnchorStatistics.
   * @param pageFromExpiredTaggedAnchors pageFromExpiredTaggedAnchors or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setPageFromExpiredTaggedAnchors(java.lang.Integer pageFromExpiredTaggedAnchors) {
    this.pageFromExpiredTaggedAnchors = pageFromExpiredTaggedAnchors;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getPageMismatchTaggedAnchors() {
    return pageMismatchTaggedAnchors;
  }

  /**
   * @param pageMismatchTaggedAnchors pageMismatchTaggedAnchors or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setPageMismatchTaggedAnchors(java.lang.Integer pageMismatchTaggedAnchors) {
    this.pageMismatchTaggedAnchors = pageMismatchTaggedAnchors;
    return this;
  }

  /**
   * Doc is protected by goodness of early anchors.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getPenguinEarlyAnchorProtected() {
    return penguinEarlyAnchorProtected;
  }

  /**
   * Doc is protected by goodness of early anchors.
   * @param penguinEarlyAnchorProtected penguinEarlyAnchorProtected or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setPenguinEarlyAnchorProtected(java.lang.Boolean penguinEarlyAnchorProtected) {
    this.penguinEarlyAnchorProtected = penguinEarlyAnchorProtected;
    return this;
  }

  /**
   * BEGIN: Penguin related fields. Timestamp when penguin scores were last updated. Measured in
   * days since Jan. 1st 1995.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getPenguinLastUpdate() {
    return penguinLastUpdate;
  }

  /**
   * BEGIN: Penguin related fields. Timestamp when penguin scores were last updated. Measured in
   * days since Jan. 1st 1995.
   * @param penguinLastUpdate penguinLastUpdate or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setPenguinLastUpdate(java.lang.Integer penguinLastUpdate) {
    this.penguinLastUpdate = penguinLastUpdate;
    return this;
  }

  /**
   * Page-level penguin penalty (0 = good, 1 = bad).
   * @return value or {@code null} for none
   */
  public java.lang.Float getPenguinPenalty() {
    return penguinPenalty;
  }

  /**
   * Page-level penguin penalty (0 = good, 1 = bad).
   * @param penguinPenalty penguinPenalty or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setPenguinPenalty(java.lang.Float penguinPenalty) {
    this.penguinPenalty = penguinPenalty;
    return this;
  }

  /**
   * Doc not scored because it has too many anchor sources. END: Penguin related fields.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getPenguinTooManySources() {
    return penguinTooManySources;
  }

  /**
   * Doc not scored because it has too many anchor sources. END: Penguin related fields.
   * @param penguinTooManySources penguinTooManySources or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setPenguinTooManySources(java.lang.Boolean penguinTooManySources) {
    this.penguinTooManySources = penguinTooManySources;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.util.List<IndexingDocjoinerAnchorStatisticsPerDupStats> getPerdupstats() {
    return perdupstats;
  }

  /**
   * @param perdupstats perdupstats or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setPerdupstats(java.util.List<IndexingDocjoinerAnchorStatisticsPerDupStats> perdupstats) {
    this.perdupstats = perdupstats;
    return this;
  }

  /**
   * Following signals identify spike of spammy anchor phrases. Anchors created during the spike are
   * tagged with LINK_SPAM_PHRASE_SPIKE.
   * @return value or {@code null} for none
   */
  public IndexingDocjoinerAnchorPhraseSpamInfo getPhraseAnchorSpamInfo() {
    return phraseAnchorSpamInfo;
  }

  /**
   * Following signals identify spike of spammy anchor phrases. Anchors created during the spike are
   * tagged with LINK_SPAM_PHRASE_SPIKE.
   * @param phraseAnchorSpamInfo phraseAnchorSpamInfo or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setPhraseAnchorSpamInfo(IndexingDocjoinerAnchorPhraseSpamInfo phraseAnchorSpamInfo) {
    this.phraseAnchorSpamInfo = phraseAnchorSpamInfo;
    return this;
  }

  /**
   * Total anchor dropped due to exceed per domain phrase cap. Equals to sum of anchors_dropped in
   * the repeated group RedundantAnchorInfoForPhraseCap, but can go higher if the latter reaches the
   * cap of kMaxDomainsToKeepForPhraseCap (indexing/docjoiner/anchors/anchor-loader.h), currently
   * 1000.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getRedundantAnchorForPhraseCapCount() {
    return redundantAnchorForPhraseCapCount;
  }

  /**
   * Total anchor dropped due to exceed per domain phrase cap. Equals to sum of anchors_dropped in
   * the repeated group RedundantAnchorInfoForPhraseCap, but can go higher if the latter reaches the
   * cap of kMaxDomainsToKeepForPhraseCap (indexing/docjoiner/anchors/anchor-loader.h), currently
   * 1000.
   * @param redundantAnchorForPhraseCapCount redundantAnchorForPhraseCapCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setRedundantAnchorForPhraseCapCount(java.lang.Integer redundantAnchorForPhraseCapCount) {
    this.redundantAnchorForPhraseCapCount = redundantAnchorForPhraseCapCount;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.util.List<IndexingDocjoinerAnchorStatisticsRedundantAnchorInfo> getRedundantanchorinfo() {
    return redundantanchorinfo;
  }

  /**
   * @param redundantanchorinfo redundantanchorinfo or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setRedundantanchorinfo(java.util.List<IndexingDocjoinerAnchorStatisticsRedundantAnchorInfo> redundantanchorinfo) {
    this.redundantanchorinfo = redundantanchorinfo;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.util.List<IndexingDocjoinerAnchorStatisticsRedundantAnchorInfoForPhraseCap> getRedundantanchorinfoforphrasecap() {
    return redundantanchorinfoforphrasecap;
  }

  /**
   * @param redundantanchorinfoforphrasecap redundantanchorinfoforphrasecap or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setRedundantanchorinfoforphrasecap(java.util.List<IndexingDocjoinerAnchorStatisticsRedundantAnchorInfoForPhraseCap> redundantanchorinfoforphrasecap) {
    this.redundantanchorinfoforphrasecap = redundantanchorinfoforphrasecap;
    return this;
  }

  /**
   * The total number of anchors being scanned from storage.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getScannedAnchorCount() {
    return scannedAnchorCount;
  }

  /**
   * The total number of anchors being scanned from storage.
   * @param scannedAnchorCount scannedAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setScannedAnchorCount(java.lang.Integer scannedAnchorCount) {
    this.scannedAnchorCount = scannedAnchorCount;
    return this;
  }

  /**
   * A count of the number of times anchor accumulation has been skipped for this document. Note:
   * Only used when canonical.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getSkippedAccumulate() {
    return skippedAccumulate;
  }

  /**
   * A count of the number of times anchor accumulation has been skipped for this document. Note:
   * Only used when canonical.
   * @param skippedAccumulate skippedAccumulate or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setSkippedAccumulate(java.lang.Integer skippedAccumulate) {
    this.skippedAccumulate = skippedAccumulate;
    return this;
  }

  /**
   * Reason to skip accumulate, when skipped, or Reason for reprocessing when not skipped.
   * @return value or {@code null} for none
   */
  public java.lang.String getSkippedOrReusedReason() {
    return skippedOrReusedReason;
  }

  /**
   * Reason to skip accumulate, when skipped, or Reason for reprocessing when not skipped.
   * @param skippedOrReusedReason skippedOrReusedReason or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setSkippedOrReusedReason(java.lang.String skippedOrReusedReason) {
    this.skippedOrReusedReason = skippedOrReusedReason;
    return this;
  }

  /**
   * The log base 10 odds that this set of anchors exhibits spammy behavior. Computed in the
   * AnchorLocalizer.
   * @return value or {@code null} for none
   */
  public java.lang.Float getSpamLog10Odds() {
    return spamLog10Odds;
  }

  /**
   * The log base 10 odds that this set of anchors exhibits spammy behavior. Computed in the
   * AnchorLocalizer.
   * @param spamLog10Odds spamLog10Odds or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setSpamLog10Odds(java.lang.Float spamLog10Odds) {
    this.spamLog10Odds = spamLog10Odds;
    return this;
  }

  /**
   * Walltime of when anchors were accumulated last.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getTimestamp() {
    return timestamp;
  }

  /**
   * Walltime of when anchors were accumulated last.
   * @param timestamp timestamp or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setTimestamp(java.lang.Integer timestamp) {
    this.timestamp = timestamp;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getTopPrOffdomainAnchorCount() {
    return topPrOffdomainAnchorCount;
  }

  /**
   * @param topPrOffdomainAnchorCount topPrOffdomainAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setTopPrOffdomainAnchorCount(java.lang.Integer topPrOffdomainAnchorCount) {
    this.topPrOffdomainAnchorCount = topPrOffdomainAnchorCount;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getTopPrOndomainAnchorCount() {
    return topPrOndomainAnchorCount;
  }

  /**
   * @param topPrOndomainAnchorCount topPrOndomainAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setTopPrOndomainAnchorCount(java.lang.Integer topPrOndomainAnchorCount) {
    this.topPrOndomainAnchorCount = topPrOndomainAnchorCount;
    return this;
  }

  /**
   * According to anchor quality bucket, anchor with pagrank > 51000 is the best anchor. anchors
   * with pagerank < 47000 are all same.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getTopPrOnsiteAnchorCount() {
    return topPrOnsiteAnchorCount;
  }

  /**
   * According to anchor quality bucket, anchor with pagrank > 51000 is the best anchor. anchors
   * with pagerank < 47000 are all same.
   * @param topPrOnsiteAnchorCount topPrOnsiteAnchorCount or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setTopPrOnsiteAnchorCount(java.lang.Integer topPrOnsiteAnchorCount) {
    this.topPrOnsiteAnchorCount = topPrOnsiteAnchorCount;
    return this;
  }

  /**
   * The following should be equal to the size of the following repeated group, except that it can
   * go higher than 10,000.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getTotalDomainPhrasePairsAboveLimit() {
    return totalDomainPhrasePairsAboveLimit;
  }

  /**
   * The following should be equal to the size of the following repeated group, except that it can
   * go higher than 10,000.
   * @param totalDomainPhrasePairsAboveLimit totalDomainPhrasePairsAboveLimit or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setTotalDomainPhrasePairsAboveLimit(java.lang.Integer totalDomainPhrasePairsAboveLimit) {
    this.totalDomainPhrasePairsAboveLimit = totalDomainPhrasePairsAboveLimit;
    return this;
  }

  /**
   * Number of domain/phrase pairs in total -- i.e. how many anchors we would have if the
   * domain/phrase cutoff was set to 1 instead of 200. This is "approx" for large anchor clusters
   * because there can be double counting when the LRU cache forgets about rare domain/phrase pairs.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getTotalDomainPhrasePairsSeenApprox() {
    return totalDomainPhrasePairsSeenApprox;
  }

  /**
   * Number of domain/phrase pairs in total -- i.e. how many anchors we would have if the
   * domain/phrase cutoff was set to 1 instead of 200. This is "approx" for large anchor clusters
   * because there can be double counting when the LRU cache forgets about rare domain/phrase pairs.
   * @param totalDomainPhrasePairsSeenApprox totalDomainPhrasePairsSeenApprox or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setTotalDomainPhrasePairsSeenApprox(java.lang.Integer totalDomainPhrasePairsSeenApprox) {
    this.totalDomainPhrasePairsSeenApprox = totalDomainPhrasePairsSeenApprox;
    return this;
  }

  /**
   * Number of domains above per domain phrase cap. We see too many phrases in the domains.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getTotalDomainsAbovePhraseCap() {
    return totalDomainsAbovePhraseCap;
  }

  /**
   * Number of domains above per domain phrase cap. We see too many phrases in the domains.
   * @param totalDomainsAbovePhraseCap totalDomainsAbovePhraseCap or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setTotalDomainsAbovePhraseCap(java.lang.Integer totalDomainsAbovePhraseCap) {
    this.totalDomainsAbovePhraseCap = totalDomainsAbovePhraseCap;
    return this;
  }

  /**
   * Number of domains seen in total.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getTotalDomainsSeen() {
    return totalDomainsSeen;
  }

  /**
   * Number of domains seen in total.
   * @param totalDomainsSeen totalDomainsSeen or {@code null} for none
   */
  public IndexingDocjoinerAnchorStatistics setTotalDomainsSeen(java.lang.Integer totalDomainsSeen) {
    this.totalDomainsSeen = totalDomainsSeen;
    return this;
  }

  @Override
  public IndexingDocjoinerAnchorStatistics set(String fieldName, Object value) {
    return (IndexingDocjoinerAnchorStatistics) super.set(fieldName, value);
  }

  @Override
  public IndexingDocjoinerAnchorStatistics clone() {
    return (IndexingDocjoinerAnchorStatistics) super.clone();
  }

}
