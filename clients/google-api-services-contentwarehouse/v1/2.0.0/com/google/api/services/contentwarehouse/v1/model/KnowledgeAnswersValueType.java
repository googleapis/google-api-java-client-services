/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.contentwarehouse.v1.model;

/**
 * Specifies the allowed type(s) that a value can have, e.g. for a Slot. For example, having both
 * entity_type and string_type present in a ValueType field of a Slot means that the Slot can take
 * _either_ an an EntityType _or_ StringType as a value, and nothing else. It may be helpful to
 * think of this proto as being called something like AllAllowedValueTypes. To enforce a component-
 * specific contract (go/contract-based-conformance) for allowed type(s), we add a repeated field
 * view_specific_${x} for the type ${x}. For example, if we want a slot that can hold any type by
 * default, but can only hold an integer when checking against the P2_LWA contract, then the
 * following should be added to MeaningCatalog: slot { name: "integer_only_slot" type { // The
 * default view has no sub_type or other options. number_type {} // The P2_LWA view specifies
 * INTEGER sub_type. view_specific_number_types { sub_type: INTEGER component_specific_contracts:
 * P2_LWA } } } See go/view-based-options-for-valuetype for more information. Next tag id: 26
 * LINT.IfChange
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the Document AI Warehouse API. For a detailed explanation
 * see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class KnowledgeAnswersValueType extends com.google.api.client.json.GenericJson {

  /**
   * This type is meant to accept "any" type and allow any and all composition. As such, it should
   * not be used for any composition algorithms, e.g. in Loose Parser. See more detailed discussion
   * at go/any-type-in-mrf. This type may appear on an answer_type, implying that the output of that
   * Meaning Schema is allowed to nest in any other slot. However, support for this is NOT
   * implemented in Loose Parser due to risk of overcomposition, but the MRF Conformance checker
   * allows for this. If you are thinking of using this, please contact mrf-team@.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersAnyType anyType;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersAttributeType attributeType;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersBooleanType booleanType;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersCollectionType collectionType;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersCompoundType compoundType;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersDateType dateType;

  /**
   * Used for configuring dynamic types to allow for type transparency. See: go/type-dependencies
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersDependencyType dependencyType;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersDurationType durationType;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersEntityType entityType;

  /**
   * When specified on a slot's type, restricts composition based on the enum value. This does not
   * mean anything when the value type is to be interpreted as an output_type.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String inputCompositionConfig;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersMeasurementType measurementType;

  /**
   * Note that normalized_string_type is NOT supported in the loose parser. A slot with this type
   * will cause the intent to not be parsed.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersNormalizedStringType normalizedStringType;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersNumberType numberType;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersOpaqueType opaqueType;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersPlexityRequirement plexityRequirement;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersPolarQuestionType polarQuestionType;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersSemanticType semanticType;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersStateOfAffairsType stateOfAffairsType;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersStringType stringType;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersTimeZoneType timezoneType;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private KnowledgeAnswersTrackingNumberType trackingNumberType;

  /**
   * LINT.IfChange Contract-specific typing (go/view-based-options-for-valuetype). NOTE: To
   * facilitate writing macros for view-specific filtering, all view-specific fields should be named
   * with the format "view_specific_${singular_field}s" -- e.g., for the singular field
   * |number_type|, the view-specific repeated field is |view_specific_number_types|.
   * LINT.ThenChange(
   * //depot/google3/nlp/meaning/remodel/meaning_remodeling_utils.cc:ViewSpecificTypes, //depot/goog
   * le3/nlp/meaning/analyzer/checks/component_specific_contracts_checks.cc:ViewSpecificTypes)
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<KnowledgeAnswersNumberType> viewSpecificNumberTypes;

  static {
    // hack to force ProGuard to consider KnowledgeAnswersNumberType used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(KnowledgeAnswersNumberType.class);
  }

  /**
   * This type is meant to accept "any" type and allow any and all composition. As such, it should
   * not be used for any composition algorithms, e.g. in Loose Parser. See more detailed discussion
   * at go/any-type-in-mrf. This type may appear on an answer_type, implying that the output of that
   * Meaning Schema is allowed to nest in any other slot. However, support for this is NOT
   * implemented in Loose Parser due to risk of overcomposition, but the MRF Conformance checker
   * allows for this. If you are thinking of using this, please contact mrf-team@.
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersAnyType getAnyType() {
    return anyType;
  }

  /**
   * This type is meant to accept "any" type and allow any and all composition. As such, it should
   * not be used for any composition algorithms, e.g. in Loose Parser. See more detailed discussion
   * at go/any-type-in-mrf. This type may appear on an answer_type, implying that the output of that
   * Meaning Schema is allowed to nest in any other slot. However, support for this is NOT
   * implemented in Loose Parser due to risk of overcomposition, but the MRF Conformance checker
   * allows for this. If you are thinking of using this, please contact mrf-team@.
   * @param anyType anyType or {@code null} for none
   */
  public KnowledgeAnswersValueType setAnyType(KnowledgeAnswersAnyType anyType) {
    this.anyType = anyType;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersAttributeType getAttributeType() {
    return attributeType;
  }

  /**
   * @param attributeType attributeType or {@code null} for none
   */
  public KnowledgeAnswersValueType setAttributeType(KnowledgeAnswersAttributeType attributeType) {
    this.attributeType = attributeType;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersBooleanType getBooleanType() {
    return booleanType;
  }

  /**
   * @param booleanType booleanType or {@code null} for none
   */
  public KnowledgeAnswersValueType setBooleanType(KnowledgeAnswersBooleanType booleanType) {
    this.booleanType = booleanType;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersCollectionType getCollectionType() {
    return collectionType;
  }

  /**
   * @param collectionType collectionType or {@code null} for none
   */
  public KnowledgeAnswersValueType setCollectionType(KnowledgeAnswersCollectionType collectionType) {
    this.collectionType = collectionType;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersCompoundType getCompoundType() {
    return compoundType;
  }

  /**
   * @param compoundType compoundType or {@code null} for none
   */
  public KnowledgeAnswersValueType setCompoundType(KnowledgeAnswersCompoundType compoundType) {
    this.compoundType = compoundType;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersDateType getDateType() {
    return dateType;
  }

  /**
   * @param dateType dateType or {@code null} for none
   */
  public KnowledgeAnswersValueType setDateType(KnowledgeAnswersDateType dateType) {
    this.dateType = dateType;
    return this;
  }

  /**
   * Used for configuring dynamic types to allow for type transparency. See: go/type-dependencies
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersDependencyType getDependencyType() {
    return dependencyType;
  }

  /**
   * Used for configuring dynamic types to allow for type transparency. See: go/type-dependencies
   * @param dependencyType dependencyType or {@code null} for none
   */
  public KnowledgeAnswersValueType setDependencyType(KnowledgeAnswersDependencyType dependencyType) {
    this.dependencyType = dependencyType;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersDurationType getDurationType() {
    return durationType;
  }

  /**
   * @param durationType durationType or {@code null} for none
   */
  public KnowledgeAnswersValueType setDurationType(KnowledgeAnswersDurationType durationType) {
    this.durationType = durationType;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersEntityType getEntityType() {
    return entityType;
  }

  /**
   * @param entityType entityType or {@code null} for none
   */
  public KnowledgeAnswersValueType setEntityType(KnowledgeAnswersEntityType entityType) {
    this.entityType = entityType;
    return this;
  }

  /**
   * When specified on a slot's type, restricts composition based on the enum value. This does not
   * mean anything when the value type is to be interpreted as an output_type.
   * @return value or {@code null} for none
   */
  public java.lang.String getInputCompositionConfig() {
    return inputCompositionConfig;
  }

  /**
   * When specified on a slot's type, restricts composition based on the enum value. This does not
   * mean anything when the value type is to be interpreted as an output_type.
   * @param inputCompositionConfig inputCompositionConfig or {@code null} for none
   */
  public KnowledgeAnswersValueType setInputCompositionConfig(java.lang.String inputCompositionConfig) {
    this.inputCompositionConfig = inputCompositionConfig;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersMeasurementType getMeasurementType() {
    return measurementType;
  }

  /**
   * @param measurementType measurementType or {@code null} for none
   */
  public KnowledgeAnswersValueType setMeasurementType(KnowledgeAnswersMeasurementType measurementType) {
    this.measurementType = measurementType;
    return this;
  }

  /**
   * Note that normalized_string_type is NOT supported in the loose parser. A slot with this type
   * will cause the intent to not be parsed.
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersNormalizedStringType getNormalizedStringType() {
    return normalizedStringType;
  }

  /**
   * Note that normalized_string_type is NOT supported in the loose parser. A slot with this type
   * will cause the intent to not be parsed.
   * @param normalizedStringType normalizedStringType or {@code null} for none
   */
  public KnowledgeAnswersValueType setNormalizedStringType(KnowledgeAnswersNormalizedStringType normalizedStringType) {
    this.normalizedStringType = normalizedStringType;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersNumberType getNumberType() {
    return numberType;
  }

  /**
   * @param numberType numberType or {@code null} for none
   */
  public KnowledgeAnswersValueType setNumberType(KnowledgeAnswersNumberType numberType) {
    this.numberType = numberType;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersOpaqueType getOpaqueType() {
    return opaqueType;
  }

  /**
   * @param opaqueType opaqueType or {@code null} for none
   */
  public KnowledgeAnswersValueType setOpaqueType(KnowledgeAnswersOpaqueType opaqueType) {
    this.opaqueType = opaqueType;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersPlexityRequirement getPlexityRequirement() {
    return plexityRequirement;
  }

  /**
   * @param plexityRequirement plexityRequirement or {@code null} for none
   */
  public KnowledgeAnswersValueType setPlexityRequirement(KnowledgeAnswersPlexityRequirement plexityRequirement) {
    this.plexityRequirement = plexityRequirement;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersPolarQuestionType getPolarQuestionType() {
    return polarQuestionType;
  }

  /**
   * @param polarQuestionType polarQuestionType or {@code null} for none
   */
  public KnowledgeAnswersValueType setPolarQuestionType(KnowledgeAnswersPolarQuestionType polarQuestionType) {
    this.polarQuestionType = polarQuestionType;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersSemanticType getSemanticType() {
    return semanticType;
  }

  /**
   * @param semanticType semanticType or {@code null} for none
   */
  public KnowledgeAnswersValueType setSemanticType(KnowledgeAnswersSemanticType semanticType) {
    this.semanticType = semanticType;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersStateOfAffairsType getStateOfAffairsType() {
    return stateOfAffairsType;
  }

  /**
   * @param stateOfAffairsType stateOfAffairsType or {@code null} for none
   */
  public KnowledgeAnswersValueType setStateOfAffairsType(KnowledgeAnswersStateOfAffairsType stateOfAffairsType) {
    this.stateOfAffairsType = stateOfAffairsType;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersStringType getStringType() {
    return stringType;
  }

  /**
   * @param stringType stringType or {@code null} for none
   */
  public KnowledgeAnswersValueType setStringType(KnowledgeAnswersStringType stringType) {
    this.stringType = stringType;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersTimeZoneType getTimezoneType() {
    return timezoneType;
  }

  /**
   * @param timezoneType timezoneType or {@code null} for none
   */
  public KnowledgeAnswersValueType setTimezoneType(KnowledgeAnswersTimeZoneType timezoneType) {
    this.timezoneType = timezoneType;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public KnowledgeAnswersTrackingNumberType getTrackingNumberType() {
    return trackingNumberType;
  }

  /**
   * @param trackingNumberType trackingNumberType or {@code null} for none
   */
  public KnowledgeAnswersValueType setTrackingNumberType(KnowledgeAnswersTrackingNumberType trackingNumberType) {
    this.trackingNumberType = trackingNumberType;
    return this;
  }

  /**
   * LINT.IfChange Contract-specific typing (go/view-based-options-for-valuetype). NOTE: To
   * facilitate writing macros for view-specific filtering, all view-specific fields should be named
   * with the format "view_specific_${singular_field}s" -- e.g., for the singular field
   * |number_type|, the view-specific repeated field is |view_specific_number_types|.
   * LINT.ThenChange(
   * //depot/google3/nlp/meaning/remodel/meaning_remodeling_utils.cc:ViewSpecificTypes, //depot/goog
   * le3/nlp/meaning/analyzer/checks/component_specific_contracts_checks.cc:ViewSpecificTypes)
   * @return value or {@code null} for none
   */
  public java.util.List<KnowledgeAnswersNumberType> getViewSpecificNumberTypes() {
    return viewSpecificNumberTypes;
  }

  /**
   * LINT.IfChange Contract-specific typing (go/view-based-options-for-valuetype). NOTE: To
   * facilitate writing macros for view-specific filtering, all view-specific fields should be named
   * with the format "view_specific_${singular_field}s" -- e.g., for the singular field
   * |number_type|, the view-specific repeated field is |view_specific_number_types|.
   * LINT.ThenChange(
   * //depot/google3/nlp/meaning/remodel/meaning_remodeling_utils.cc:ViewSpecificTypes, //depot/goog
   * le3/nlp/meaning/analyzer/checks/component_specific_contracts_checks.cc:ViewSpecificTypes)
   * @param viewSpecificNumberTypes viewSpecificNumberTypes or {@code null} for none
   */
  public KnowledgeAnswersValueType setViewSpecificNumberTypes(java.util.List<KnowledgeAnswersNumberType> viewSpecificNumberTypes) {
    this.viewSpecificNumberTypes = viewSpecificNumberTypes;
    return this;
  }

  @Override
  public KnowledgeAnswersValueType set(String fieldName, Object value) {
    return (KnowledgeAnswersValueType) super.set(fieldName, value);
  }

  @Override
  public KnowledgeAnswersValueType clone() {
    return (KnowledgeAnswersValueType) super.clone();
  }

}
