/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.contentwarehouse.v1.model;

/**
 * A restriction is an expression that limits when an action can be taken. Each restriction has a
 * set of conditions. If all of the conditions are true, then the restriction applies and the action
 * cannot be taken. For example, the restriction "no turns 3-5pm except buses" would have two
 * conditions: "time is 3-5pm" and "vehicle is not a bus". If both of these conditions apply, the
 * restriction is true, and the turn is prohibited. Multiple restrictions may apply to the same
 * action. Clients handle this by always declaring RestrictionProto as a "repeated" element. The
 * semantics of having multiple restrictions are that if any restriction applies, then the action
 * cannot be taken. In other words, restrictions are OR-ed together. Putting all of this together, a
 * set of RestrictionProtos can be interpreted as an bool expression in disjunctive normal form: (A
 * and B) or (D and E and F) or (G and H) The action is prohibited if this expression is true. Note
 * that a restriction with no conditions is always true, i.e. its action is always prohibited.
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the contentwarehouse API. For a detailed explanation see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class GeostoreRestrictionProto extends com.google.api.client.json.GenericJson {

  /**
   * The restriction only applies in these specific autonomous driving product scenarios. NOTE: This
   * should only be set on restrictions with TRAVEL_AUTONOMOUS_VEHICLE travel mode.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.String> autonomousDrivingProducts;

  /**
   * Actually *required* if style=STYLE_IN_OUT, otherwise forbidden. Typically the intersection
   * group type is artifact, but either artifact or logical groups can be used for STYLE_IN_OUT
   * restrictions.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFeatureIdProto intersectionGroup;

  /**
   * Field-level metadata for this restriction.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFieldMetadataProto metadata;

  /**
   * Restriction group this restriction belongs to.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFeatureIdProto restrictionGroup;

  /**
   * When specified, restriction applies only at particular times (operating hours or times of the
   * year: reversing lanes, seasonal roads, no left turns from 3-5pm Mon-Fri except holidays).
   * Otherwise, restriction is in effect at all times.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreTimeScheduleProto schedule;

  /**
   * The scope that the restriction applies to. - SCOPE_DIRECTION means the segment/sibling pair is
   * restricted in the direction of the segment that contains this RestrictionProto. For
   * segment/sibling pairs with pedestrian facilities (and thus side-of-road routing) the
   * RestrictionProto restricts both facilities in the direction of the segment (assuming that the
   * restriction applies to travel mode TRAVEL_PEDESTRIAN). - SCOPE_SIDE means the RestrictionProto
   * applies only to the side of road that the containing segment represents. That sibling's
   * pedestrian facility is restricted in both directions. Schema constraints: - SCOPE_SIDE must be
   * set if and only if travel_mode == [TRAVEL_PEDESTRIAN] and the segment containing the
   * restriction has PEDESTRIAN_FACILITY_PRESENT. Such restrictions must have no subpath. - All
   * other restrictions must have this field set to SCOPE_DIRECTION (whether explicitly or
   * implicitly). This distinction is necessary for cases such as pedestrian facility on one-way
   * segment/sibling roads.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String scope;

  /**
   * Restriction Style defines the semantics of the subpath field, as defined above in the
   * documentation of subpath.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String style;

  /**
   * "subpath" specifies the GeoStore segments that this restriction applies to, according to the
   * restriction_style field below. Segments that are referenced by this subpath field also refer to
   * this feature back via the same subpath field. For all styles of restriction, all segments in
   * the subpath must have identical copies of the restriction. In other words, restrictions are
   * duplicated along every segment in the subpath. Note that subpaths of length 1 do not have any
   * purpose and are disallowed. Note that it is possible to represent restrictions either using
   * STYLE_CONTIGUOUS, or depending on the length of the subpath, one of the more specific
   * STYLE_SINGLE, STYLE_TURN, or STYLE_IN_OUT. New code should use the more specific alternatives
   * if possible, as they support instant updates. For restriction_style == STYLE_CONTIGUOUS (the
   * default): "subpath" can either be empty, for a single-segment restriction, or it specifies
   * exactly the sequence of segments which this restriction applies to. The subpath may be used to
   * specify a turn restriction (a subpath of length 2) or to prohibit more complex maneuvers. For
   * example, when merging onto a road from the right-hand side it may not be possible to make an
   * immediate left turn due to insufficient time to cross the intervening lanes or the presence of
   * a physical barrier. This would be indicated by a subpath restriction of length 3 or more. For
   * restriction_style == STYLE_SINGLE: The subpath field of the Restriction must be empty. The
   * restriction applies only to the segment it is attached to. There must not be an intersection
   * group specified. For restriction_style == STYLE_TURN: The subpath field of the Restriction must
   * contain exactly two segments. The first is called the "in_segment", the second is the
   * "out_segment". They must be contiguous, i.e. the end intersection of the in_segment is the
   * start intersection of the out_segment. The restriction applies only to a direct maneuver from
   * the in_segment to the out_segment. Other paths from the in_segment to the out_segment are not
   * restricted. There must not be an intersection group specified. For restriction_style ==
   * STYLE_IN_OUT: The subpath field of the Restriction must contain exactly two segments. The first
   * is called the "in_segment", the second is the "out_segment". Note that the two segments define
   * paths, but may not actually be one. The end intersection of the in_segment must be in an
   * intersection group which also contains the start intersection of the out_segment. The in- and
   * out-segments are not required to be adjacent, but may be. Either way, the restriction applies
   * to any path from the in_segment to the out_segment through the intersection group, not just
   * direct turns. The intersection_group must be specified. Note that clients which read
   * restrictions and need to know which paths are restricted by a given IN_OUT restriction must
   * expand the IN_OUT restriction by finding all paths through the intersection group from the
   * in_segment to the out_segment.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreFeatureIdProto> subpath;

  static {
    // hack to force ProGuard to consider GeostoreFeatureIdProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreFeatureIdProto.class);
  }

  /**
   * A place for clients to attach arbitrary data to a restriction. Never set in MapFacts.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private Proto2BridgeMessageSet temporaryData;

  /**
   * Restriction applies only to the given travel modes. This field should always be set, but may be
   * missing in old data. WARNING: Restrictions with no travel modes are DEPRECATED. Historically,
   * no travel modes has meant "all travel modes", except they didn't really even mean that, because
   * Pathfinder would use a complex set of heuristics to interpret the "correct" travel modes.
   * Pathfinder currently (last updated August 2013) has heuristics to cope with incomplete data
   * that reduce or extend application of the specified restrictions to pedestrians or bicycles. We
   * are actively working to remove these heuristics and replace them with explicit, correct travel
   * modes in the data. See b/8746491.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.String> travelMode;

  /**
   * clang-format on The type of restriction. This is not a condition, but rather tells you what
   * kind of restriction it is. This field should always be set.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String type;

  /**
   * The restriction only applies to vehicles that meet all of the attributes defined here. If this
   * is empty, it does not affect the scope of the restriction.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreVehicleAttributeFilterProto vehicleAttributeFilter;

  /**
   * The restriction only applies in these specific autonomous driving product scenarios. NOTE: This
   * should only be set on restrictions with TRAVEL_AUTONOMOUS_VEHICLE travel mode.
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.String> getAutonomousDrivingProducts() {
    return autonomousDrivingProducts;
  }

  /**
   * The restriction only applies in these specific autonomous driving product scenarios. NOTE: This
   * should only be set on restrictions with TRAVEL_AUTONOMOUS_VEHICLE travel mode.
   * @param autonomousDrivingProducts autonomousDrivingProducts or {@code null} for none
   */
  public GeostoreRestrictionProto setAutonomousDrivingProducts(java.util.List<java.lang.String> autonomousDrivingProducts) {
    this.autonomousDrivingProducts = autonomousDrivingProducts;
    return this;
  }

  /**
   * Actually *required* if style=STYLE_IN_OUT, otherwise forbidden. Typically the intersection
   * group type is artifact, but either artifact or logical groups can be used for STYLE_IN_OUT
   * restrictions.
   * @return value or {@code null} for none
   */
  public GeostoreFeatureIdProto getIntersectionGroup() {
    return intersectionGroup;
  }

  /**
   * Actually *required* if style=STYLE_IN_OUT, otherwise forbidden. Typically the intersection
   * group type is artifact, but either artifact or logical groups can be used for STYLE_IN_OUT
   * restrictions.
   * @param intersectionGroup intersectionGroup or {@code null} for none
   */
  public GeostoreRestrictionProto setIntersectionGroup(GeostoreFeatureIdProto intersectionGroup) {
    this.intersectionGroup = intersectionGroup;
    return this;
  }

  /**
   * Field-level metadata for this restriction.
   * @return value or {@code null} for none
   */
  public GeostoreFieldMetadataProto getMetadata() {
    return metadata;
  }

  /**
   * Field-level metadata for this restriction.
   * @param metadata metadata or {@code null} for none
   */
  public GeostoreRestrictionProto setMetadata(GeostoreFieldMetadataProto metadata) {
    this.metadata = metadata;
    return this;
  }

  /**
   * Restriction group this restriction belongs to.
   * @return value or {@code null} for none
   */
  public GeostoreFeatureIdProto getRestrictionGroup() {
    return restrictionGroup;
  }

  /**
   * Restriction group this restriction belongs to.
   * @param restrictionGroup restrictionGroup or {@code null} for none
   */
  public GeostoreRestrictionProto setRestrictionGroup(GeostoreFeatureIdProto restrictionGroup) {
    this.restrictionGroup = restrictionGroup;
    return this;
  }

  /**
   * When specified, restriction applies only at particular times (operating hours or times of the
   * year: reversing lanes, seasonal roads, no left turns from 3-5pm Mon-Fri except holidays).
   * Otherwise, restriction is in effect at all times.
   * @return value or {@code null} for none
   */
  public GeostoreTimeScheduleProto getSchedule() {
    return schedule;
  }

  /**
   * When specified, restriction applies only at particular times (operating hours or times of the
   * year: reversing lanes, seasonal roads, no left turns from 3-5pm Mon-Fri except holidays).
   * Otherwise, restriction is in effect at all times.
   * @param schedule schedule or {@code null} for none
   */
  public GeostoreRestrictionProto setSchedule(GeostoreTimeScheduleProto schedule) {
    this.schedule = schedule;
    return this;
  }

  /**
   * The scope that the restriction applies to. - SCOPE_DIRECTION means the segment/sibling pair is
   * restricted in the direction of the segment that contains this RestrictionProto. For
   * segment/sibling pairs with pedestrian facilities (and thus side-of-road routing) the
   * RestrictionProto restricts both facilities in the direction of the segment (assuming that the
   * restriction applies to travel mode TRAVEL_PEDESTRIAN). - SCOPE_SIDE means the RestrictionProto
   * applies only to the side of road that the containing segment represents. That sibling's
   * pedestrian facility is restricted in both directions. Schema constraints: - SCOPE_SIDE must be
   * set if and only if travel_mode == [TRAVEL_PEDESTRIAN] and the segment containing the
   * restriction has PEDESTRIAN_FACILITY_PRESENT. Such restrictions must have no subpath. - All
   * other restrictions must have this field set to SCOPE_DIRECTION (whether explicitly or
   * implicitly). This distinction is necessary for cases such as pedestrian facility on one-way
   * segment/sibling roads.
   * @return value or {@code null} for none
   */
  public java.lang.String getScope() {
    return scope;
  }

  /**
   * The scope that the restriction applies to. - SCOPE_DIRECTION means the segment/sibling pair is
   * restricted in the direction of the segment that contains this RestrictionProto. For
   * segment/sibling pairs with pedestrian facilities (and thus side-of-road routing) the
   * RestrictionProto restricts both facilities in the direction of the segment (assuming that the
   * restriction applies to travel mode TRAVEL_PEDESTRIAN). - SCOPE_SIDE means the RestrictionProto
   * applies only to the side of road that the containing segment represents. That sibling's
   * pedestrian facility is restricted in both directions. Schema constraints: - SCOPE_SIDE must be
   * set if and only if travel_mode == [TRAVEL_PEDESTRIAN] and the segment containing the
   * restriction has PEDESTRIAN_FACILITY_PRESENT. Such restrictions must have no subpath. - All
   * other restrictions must have this field set to SCOPE_DIRECTION (whether explicitly or
   * implicitly). This distinction is necessary for cases such as pedestrian facility on one-way
   * segment/sibling roads.
   * @param scope scope or {@code null} for none
   */
  public GeostoreRestrictionProto setScope(java.lang.String scope) {
    this.scope = scope;
    return this;
  }

  /**
   * Restriction Style defines the semantics of the subpath field, as defined above in the
   * documentation of subpath.
   * @return value or {@code null} for none
   */
  public java.lang.String getStyle() {
    return style;
  }

  /**
   * Restriction Style defines the semantics of the subpath field, as defined above in the
   * documentation of subpath.
   * @param style style or {@code null} for none
   */
  public GeostoreRestrictionProto setStyle(java.lang.String style) {
    this.style = style;
    return this;
  }

  /**
   * "subpath" specifies the GeoStore segments that this restriction applies to, according to the
   * restriction_style field below. Segments that are referenced by this subpath field also refer to
   * this feature back via the same subpath field. For all styles of restriction, all segments in
   * the subpath must have identical copies of the restriction. In other words, restrictions are
   * duplicated along every segment in the subpath. Note that subpaths of length 1 do not have any
   * purpose and are disallowed. Note that it is possible to represent restrictions either using
   * STYLE_CONTIGUOUS, or depending on the length of the subpath, one of the more specific
   * STYLE_SINGLE, STYLE_TURN, or STYLE_IN_OUT. New code should use the more specific alternatives
   * if possible, as they support instant updates. For restriction_style == STYLE_CONTIGUOUS (the
   * default): "subpath" can either be empty, for a single-segment restriction, or it specifies
   * exactly the sequence of segments which this restriction applies to. The subpath may be used to
   * specify a turn restriction (a subpath of length 2) or to prohibit more complex maneuvers. For
   * example, when merging onto a road from the right-hand side it may not be possible to make an
   * immediate left turn due to insufficient time to cross the intervening lanes or the presence of
   * a physical barrier. This would be indicated by a subpath restriction of length 3 or more. For
   * restriction_style == STYLE_SINGLE: The subpath field of the Restriction must be empty. The
   * restriction applies only to the segment it is attached to. There must not be an intersection
   * group specified. For restriction_style == STYLE_TURN: The subpath field of the Restriction must
   * contain exactly two segments. The first is called the "in_segment", the second is the
   * "out_segment". They must be contiguous, i.e. the end intersection of the in_segment is the
   * start intersection of the out_segment. The restriction applies only to a direct maneuver from
   * the in_segment to the out_segment. Other paths from the in_segment to the out_segment are not
   * restricted. There must not be an intersection group specified. For restriction_style ==
   * STYLE_IN_OUT: The subpath field of the Restriction must contain exactly two segments. The first
   * is called the "in_segment", the second is the "out_segment". Note that the two segments define
   * paths, but may not actually be one. The end intersection of the in_segment must be in an
   * intersection group which also contains the start intersection of the out_segment. The in- and
   * out-segments are not required to be adjacent, but may be. Either way, the restriction applies
   * to any path from the in_segment to the out_segment through the intersection group, not just
   * direct turns. The intersection_group must be specified. Note that clients which read
   * restrictions and need to know which paths are restricted by a given IN_OUT restriction must
   * expand the IN_OUT restriction by finding all paths through the intersection group from the
   * in_segment to the out_segment.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreFeatureIdProto> getSubpath() {
    return subpath;
  }

  /**
   * "subpath" specifies the GeoStore segments that this restriction applies to, according to the
   * restriction_style field below. Segments that are referenced by this subpath field also refer to
   * this feature back via the same subpath field. For all styles of restriction, all segments in
   * the subpath must have identical copies of the restriction. In other words, restrictions are
   * duplicated along every segment in the subpath. Note that subpaths of length 1 do not have any
   * purpose and are disallowed. Note that it is possible to represent restrictions either using
   * STYLE_CONTIGUOUS, or depending on the length of the subpath, one of the more specific
   * STYLE_SINGLE, STYLE_TURN, or STYLE_IN_OUT. New code should use the more specific alternatives
   * if possible, as they support instant updates. For restriction_style == STYLE_CONTIGUOUS (the
   * default): "subpath" can either be empty, for a single-segment restriction, or it specifies
   * exactly the sequence of segments which this restriction applies to. The subpath may be used to
   * specify a turn restriction (a subpath of length 2) or to prohibit more complex maneuvers. For
   * example, when merging onto a road from the right-hand side it may not be possible to make an
   * immediate left turn due to insufficient time to cross the intervening lanes or the presence of
   * a physical barrier. This would be indicated by a subpath restriction of length 3 or more. For
   * restriction_style == STYLE_SINGLE: The subpath field of the Restriction must be empty. The
   * restriction applies only to the segment it is attached to. There must not be an intersection
   * group specified. For restriction_style == STYLE_TURN: The subpath field of the Restriction must
   * contain exactly two segments. The first is called the "in_segment", the second is the
   * "out_segment". They must be contiguous, i.e. the end intersection of the in_segment is the
   * start intersection of the out_segment. The restriction applies only to a direct maneuver from
   * the in_segment to the out_segment. Other paths from the in_segment to the out_segment are not
   * restricted. There must not be an intersection group specified. For restriction_style ==
   * STYLE_IN_OUT: The subpath field of the Restriction must contain exactly two segments. The first
   * is called the "in_segment", the second is the "out_segment". Note that the two segments define
   * paths, but may not actually be one. The end intersection of the in_segment must be in an
   * intersection group which also contains the start intersection of the out_segment. The in- and
   * out-segments are not required to be adjacent, but may be. Either way, the restriction applies
   * to any path from the in_segment to the out_segment through the intersection group, not just
   * direct turns. The intersection_group must be specified. Note that clients which read
   * restrictions and need to know which paths are restricted by a given IN_OUT restriction must
   * expand the IN_OUT restriction by finding all paths through the intersection group from the
   * in_segment to the out_segment.
   * @param subpath subpath or {@code null} for none
   */
  public GeostoreRestrictionProto setSubpath(java.util.List<GeostoreFeatureIdProto> subpath) {
    this.subpath = subpath;
    return this;
  }

  /**
   * A place for clients to attach arbitrary data to a restriction. Never set in MapFacts.
   * @return value or {@code null} for none
   */
  public Proto2BridgeMessageSet getTemporaryData() {
    return temporaryData;
  }

  /**
   * A place for clients to attach arbitrary data to a restriction. Never set in MapFacts.
   * @param temporaryData temporaryData or {@code null} for none
   */
  public GeostoreRestrictionProto setTemporaryData(Proto2BridgeMessageSet temporaryData) {
    this.temporaryData = temporaryData;
    return this;
  }

  /**
   * Restriction applies only to the given travel modes. This field should always be set, but may be
   * missing in old data. WARNING: Restrictions with no travel modes are DEPRECATED. Historically,
   * no travel modes has meant "all travel modes", except they didn't really even mean that, because
   * Pathfinder would use a complex set of heuristics to interpret the "correct" travel modes.
   * Pathfinder currently (last updated August 2013) has heuristics to cope with incomplete data
   * that reduce or extend application of the specified restrictions to pedestrians or bicycles. We
   * are actively working to remove these heuristics and replace them with explicit, correct travel
   * modes in the data. See b/8746491.
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.String> getTravelMode() {
    return travelMode;
  }

  /**
   * Restriction applies only to the given travel modes. This field should always be set, but may be
   * missing in old data. WARNING: Restrictions with no travel modes are DEPRECATED. Historically,
   * no travel modes has meant "all travel modes", except they didn't really even mean that, because
   * Pathfinder would use a complex set of heuristics to interpret the "correct" travel modes.
   * Pathfinder currently (last updated August 2013) has heuristics to cope with incomplete data
   * that reduce or extend application of the specified restrictions to pedestrians or bicycles. We
   * are actively working to remove these heuristics and replace them with explicit, correct travel
   * modes in the data. See b/8746491.
   * @param travelMode travelMode or {@code null} for none
   */
  public GeostoreRestrictionProto setTravelMode(java.util.List<java.lang.String> travelMode) {
    this.travelMode = travelMode;
    return this;
  }

  /**
   * clang-format on The type of restriction. This is not a condition, but rather tells you what
   * kind of restriction it is. This field should always be set.
   * @return value or {@code null} for none
   */
  public java.lang.String getType() {
    return type;
  }

  /**
   * clang-format on The type of restriction. This is not a condition, but rather tells you what
   * kind of restriction it is. This field should always be set.
   * @param type type or {@code null} for none
   */
  public GeostoreRestrictionProto setType(java.lang.String type) {
    this.type = type;
    return this;
  }

  /**
   * The restriction only applies to vehicles that meet all of the attributes defined here. If this
   * is empty, it does not affect the scope of the restriction.
   * @return value or {@code null} for none
   */
  public GeostoreVehicleAttributeFilterProto getVehicleAttributeFilter() {
    return vehicleAttributeFilter;
  }

  /**
   * The restriction only applies to vehicles that meet all of the attributes defined here. If this
   * is empty, it does not affect the scope of the restriction.
   * @param vehicleAttributeFilter vehicleAttributeFilter or {@code null} for none
   */
  public GeostoreRestrictionProto setVehicleAttributeFilter(GeostoreVehicleAttributeFilterProto vehicleAttributeFilter) {
    this.vehicleAttributeFilter = vehicleAttributeFilter;
    return this;
  }

  @Override
  public GeostoreRestrictionProto set(String fieldName, Object value) {
    return (GeostoreRestrictionProto) super.set(fieldName, value);
  }

  @Override
  public GeostoreRestrictionProto clone() {
    return (GeostoreRestrictionProto) super.clone();
  }

}
