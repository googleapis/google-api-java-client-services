/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.contentwarehouse.v1.model;

/**
 * Describes an individual road lane. Not only driving lanes, but also parking and biking lanes are
 * covered by this. Note that we may eventually add curbs and walking to this schema.
 * MOTIVATION/DESIGN DISCUSSION The intent of this schema is to model a schematic representation of
 * the road for a bunch of use cases within GMM, navigation, map tiles. For rendering, we do not
 * want to represent the geometry of each lane exactly, but do want to model types/width/gaps/lane
 * markings so that a schematic rendering can be made. For navigation, we model lane connectivity
 * and restrictions per lane, so that Pathfinder can potentially pick routes based on lanes, and
 * definitely use the lanes to better describe the path to the driver. This schema is driven by the
 * GT team, which is likely to be the only provider of this data. It is based on compromises that we
 * are working out with other teams, based on what our operators can reasonably collect and what is
 * useful. See docs here: https://docs.google.com/a/google.com/document/d/11XJ1WvqS5Sm7MxWXzzc3tnsk4
 * 9VhrR3BYFjiRMAzYm0/edit?hl=en_US https://docs.google.com/a/google.com/document/d
 * /1nzdupynTUKE8xY8JcfvQbU-KWtCJ6IwHiTaCxuq40EM/edit?hl=en_US Note: Some lane information (width,
 * surface type, etc) may duplicate or contradict information stored at the segment level.
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the Document AI Warehouse API. For a detailed explanation
 * see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class GeostoreLaneProto extends com.google.api.client.json.GenericJson {

  /**
   * References to any gcid:physical_lane_marker features that bound this lane.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreBoundingMarkerProto> boundingMarker;

  static {
    // hack to force ProGuard to consider GeostoreBoundingMarkerProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreBoundingMarkerProto.class);
  }

  /**
   * If the current lane is part of a merge/split area, indicates the type (split or merge) and
   * whether the current lane is on the left or right or in the middle of the merge/split area, as
   * seen in the direction of traffic. See go/lane-split-merge-schema
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String conjoinedCategory;

  /**
   * Gap between this lane and the next in meters. This is relevant when the divider is physical, or
   * a wide painted area. For regular painted single or double lines, there is no gap. This distance
   * is duplicated between the innermost lanes for each side. Note that this is not used to describe
   * smallish islands - this is only for long-running gaps. In particular, this models the median
   * width, the gap between HOV lanes/regular lanes on freeways, and the road verge between a curb
   * and sidewalk. Note on split roads: We can model any split road with a median as a single
   * sibling pair with this distance set to the width of the median, or as two one-way sibling
   * pairs.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Float distanceToNextLane;

  /**
   * The most logical path for the center of an object to travel along within the lane. Typically,
   * this is the lane's center line, but doesn't have to be.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFlowLineProto flow;

  /**
   * Connections to lanes of other segments at the end of this segment. These connections model the
   * connectivity where you don't have to do a lane change maneuver. If any lane connection is
   * present, assume that all others are forbidden. Also note that segment level restrictions do
   * apply if present, and can disallow some turn even if the lanes are connected. For instance,
   * this can happen with timed or vehicle type based restrictions on the segment. If lane
   * connectivity implies a segment-level restriction (can't transition to some target segment),
   * that restriction will also exist as a segment level restriction. In effect - PathFinder does
   * not have to look at lane connectivity to figure out segment connectivity. Example: Typically,
   * lanes are just connected to one other lane. Example: A splitting lane is connected to the two
   * resulting lanes. Example: At an intersection, a lane is connected to crossing lanes according
   * to how lanes are painted across the intersection. In the common case, the target segment will
   * be connected to the same intersection as this segment. That will however NOT be true for
   * complex intersections where there is an intersection group. The connections will be across the
   * whole group, connecting to one of the outgoing segments from the group. This is analogous to
   * how we do turn restrictions around intersection groups.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreLaneProtoLaneConnection> laneConnection;

  /**
   * clang-format on Whether the divider to the inside of this lane can be crossed. Note that we
   * assume this is symmetric, and that this also describes whether someone in the next inside lane
   * can cross to this one. The "inside" lane is the one with a lower lane_number. Note on lane
   * markers: We do not model the painting, but only the resulting legality. There are many painted
   * marker styles and colors that lead to the same legality. We expect Paint or Driveabout to
   * render lanes stylized, with solid meaning "can't cross", and dashed meaning "can cross". Note
   * on varying legality along segment: ALLOWED takes precedence - even if some small portion has a
   * restriction (such as right before an intersection) , the lane change will be ALLOWED.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String laneDividerCrossing;

  /**
   * These indicate for what portion of the segment the lane's flowline exactly follows the segment,
   * and the lane is of constant width. This will be set to not include the whole segment where
   * there is a split/turn/merge at either end of the lane. The painting of the lane should
   * completely synthesize the lane geometry outside of this portion, connecting it to neighboring
   * lanes to make graphical nice.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Float laneFollowsSegmentBeginFraction;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Float laneFollowsSegmentEndFraction;

  /**
   * Lanes are numbered from inside of the road outward, i.e. the lane next to the center line is
   * lane 0. The lanes then stack outwards, towards the side that one drives on this segment (right
   * or left). NOTE: do NOT use the lane_number as index for lookup. Lane_number is not guaranteed
   * to match the segment.lane repeated field index.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer laneNumber;

  /**
   * A token that can be used to identify the version of the data about this lane.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String laneToken;

  /**
   * Field-level metadata for this lane.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFieldMetadataProto metadata;

  /**
   * Restrictions that apply to this lane only. Examples include HOV lanes. If a lane restriction
   * implies a segment-level restriction (can't route on the segment at all), that restriction will
   * also exist as a segment level restriction. In effect - PathFinder does not have to look at lane
   * restrictions to figure out segment restrictions.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreRestrictionProto> restriction;

  /**
   * True if this lane is usable in both directions (left-turn lane, reversing lane, one-lane road,
   * etc). To get the total number of lanes for a road, add up the lanes in each direction counting
   * 0.5 for each shared lane.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean shared;

  /**
   * References to any gcid:physical_lane_marker features that intersect this lane, with the
   * implication that a moving vehicle should stop there.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreFeatureIdProto> stopLine;

  static {
    // hack to force ProGuard to consider GeostoreFeatureIdProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreFeatureIdProto.class);
  }

  /**
   * clang-format on LINT.ThenChange(//depot/google3/geostore/base/proto/segment.proto) Unlike the
   * surface in SegmentProto, this field does not have a default value. This is because the lane-
   * level surface overrides the segment-level surface. The lane's surface should be unset unless
   * explicitly overriding the segment's surface.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String surface;

  /**
   * clang-format on
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String type;

  /**
   * Width of this lane in meters. In many cases, we will collect this data by dividing the total
   * road width by the number of lanes. On accuracy: This is a rough average width along this
   * segment. If and when we wanted to be more accurate, we'd extend this schema to have full
   * polygons for segments/lanes rather than just this average width.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Float width;

  /**
   * References to any gcid:physical_lane_marker features that bound this lane.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreBoundingMarkerProto> getBoundingMarker() {
    return boundingMarker;
  }

  /**
   * References to any gcid:physical_lane_marker features that bound this lane.
   * @param boundingMarker boundingMarker or {@code null} for none
   */
  public GeostoreLaneProto setBoundingMarker(java.util.List<GeostoreBoundingMarkerProto> boundingMarker) {
    this.boundingMarker = boundingMarker;
    return this;
  }

  /**
   * If the current lane is part of a merge/split area, indicates the type (split or merge) and
   * whether the current lane is on the left or right or in the middle of the merge/split area, as
   * seen in the direction of traffic. See go/lane-split-merge-schema
   * @return value or {@code null} for none
   */
  public java.lang.String getConjoinedCategory() {
    return conjoinedCategory;
  }

  /**
   * If the current lane is part of a merge/split area, indicates the type (split or merge) and
   * whether the current lane is on the left or right or in the middle of the merge/split area, as
   * seen in the direction of traffic. See go/lane-split-merge-schema
   * @param conjoinedCategory conjoinedCategory or {@code null} for none
   */
  public GeostoreLaneProto setConjoinedCategory(java.lang.String conjoinedCategory) {
    this.conjoinedCategory = conjoinedCategory;
    return this;
  }

  /**
   * Gap between this lane and the next in meters. This is relevant when the divider is physical, or
   * a wide painted area. For regular painted single or double lines, there is no gap. This distance
   * is duplicated between the innermost lanes for each side. Note that this is not used to describe
   * smallish islands - this is only for long-running gaps. In particular, this models the median
   * width, the gap between HOV lanes/regular lanes on freeways, and the road verge between a curb
   * and sidewalk. Note on split roads: We can model any split road with a median as a single
   * sibling pair with this distance set to the width of the median, or as two one-way sibling
   * pairs.
   * @return value or {@code null} for none
   */
  public java.lang.Float getDistanceToNextLane() {
    return distanceToNextLane;
  }

  /**
   * Gap between this lane and the next in meters. This is relevant when the divider is physical, or
   * a wide painted area. For regular painted single or double lines, there is no gap. This distance
   * is duplicated between the innermost lanes for each side. Note that this is not used to describe
   * smallish islands - this is only for long-running gaps. In particular, this models the median
   * width, the gap between HOV lanes/regular lanes on freeways, and the road verge between a curb
   * and sidewalk. Note on split roads: We can model any split road with a median as a single
   * sibling pair with this distance set to the width of the median, or as two one-way sibling
   * pairs.
   * @param distanceToNextLane distanceToNextLane or {@code null} for none
   */
  public GeostoreLaneProto setDistanceToNextLane(java.lang.Float distanceToNextLane) {
    this.distanceToNextLane = distanceToNextLane;
    return this;
  }

  /**
   * The most logical path for the center of an object to travel along within the lane. Typically,
   * this is the lane's center line, but doesn't have to be.
   * @return value or {@code null} for none
   */
  public GeostoreFlowLineProto getFlow() {
    return flow;
  }

  /**
   * The most logical path for the center of an object to travel along within the lane. Typically,
   * this is the lane's center line, but doesn't have to be.
   * @param flow flow or {@code null} for none
   */
  public GeostoreLaneProto setFlow(GeostoreFlowLineProto flow) {
    this.flow = flow;
    return this;
  }

  /**
   * Connections to lanes of other segments at the end of this segment. These connections model the
   * connectivity where you don't have to do a lane change maneuver. If any lane connection is
   * present, assume that all others are forbidden. Also note that segment level restrictions do
   * apply if present, and can disallow some turn even if the lanes are connected. For instance,
   * this can happen with timed or vehicle type based restrictions on the segment. If lane
   * connectivity implies a segment-level restriction (can't transition to some target segment),
   * that restriction will also exist as a segment level restriction. In effect - PathFinder does
   * not have to look at lane connectivity to figure out segment connectivity. Example: Typically,
   * lanes are just connected to one other lane. Example: A splitting lane is connected to the two
   * resulting lanes. Example: At an intersection, a lane is connected to crossing lanes according
   * to how lanes are painted across the intersection. In the common case, the target segment will
   * be connected to the same intersection as this segment. That will however NOT be true for
   * complex intersections where there is an intersection group. The connections will be across the
   * whole group, connecting to one of the outgoing segments from the group. This is analogous to
   * how we do turn restrictions around intersection groups.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreLaneProtoLaneConnection> getLaneConnection() {
    return laneConnection;
  }

  /**
   * Connections to lanes of other segments at the end of this segment. These connections model the
   * connectivity where you don't have to do a lane change maneuver. If any lane connection is
   * present, assume that all others are forbidden. Also note that segment level restrictions do
   * apply if present, and can disallow some turn even if the lanes are connected. For instance,
   * this can happen with timed or vehicle type based restrictions on the segment. If lane
   * connectivity implies a segment-level restriction (can't transition to some target segment),
   * that restriction will also exist as a segment level restriction. In effect - PathFinder does
   * not have to look at lane connectivity to figure out segment connectivity. Example: Typically,
   * lanes are just connected to one other lane. Example: A splitting lane is connected to the two
   * resulting lanes. Example: At an intersection, a lane is connected to crossing lanes according
   * to how lanes are painted across the intersection. In the common case, the target segment will
   * be connected to the same intersection as this segment. That will however NOT be true for
   * complex intersections where there is an intersection group. The connections will be across the
   * whole group, connecting to one of the outgoing segments from the group. This is analogous to
   * how we do turn restrictions around intersection groups.
   * @param laneConnection laneConnection or {@code null} for none
   */
  public GeostoreLaneProto setLaneConnection(java.util.List<GeostoreLaneProtoLaneConnection> laneConnection) {
    this.laneConnection = laneConnection;
    return this;
  }

  /**
   * clang-format on Whether the divider to the inside of this lane can be crossed. Note that we
   * assume this is symmetric, and that this also describes whether someone in the next inside lane
   * can cross to this one. The "inside" lane is the one with a lower lane_number. Note on lane
   * markers: We do not model the painting, but only the resulting legality. There are many painted
   * marker styles and colors that lead to the same legality. We expect Paint or Driveabout to
   * render lanes stylized, with solid meaning "can't cross", and dashed meaning "can cross". Note
   * on varying legality along segment: ALLOWED takes precedence - even if some small portion has a
   * restriction (such as right before an intersection) , the lane change will be ALLOWED.
   * @return value or {@code null} for none
   */
  public java.lang.String getLaneDividerCrossing() {
    return laneDividerCrossing;
  }

  /**
   * clang-format on Whether the divider to the inside of this lane can be crossed. Note that we
   * assume this is symmetric, and that this also describes whether someone in the next inside lane
   * can cross to this one. The "inside" lane is the one with a lower lane_number. Note on lane
   * markers: We do not model the painting, but only the resulting legality. There are many painted
   * marker styles and colors that lead to the same legality. We expect Paint or Driveabout to
   * render lanes stylized, with solid meaning "can't cross", and dashed meaning "can cross". Note
   * on varying legality along segment: ALLOWED takes precedence - even if some small portion has a
   * restriction (such as right before an intersection) , the lane change will be ALLOWED.
   * @param laneDividerCrossing laneDividerCrossing or {@code null} for none
   */
  public GeostoreLaneProto setLaneDividerCrossing(java.lang.String laneDividerCrossing) {
    this.laneDividerCrossing = laneDividerCrossing;
    return this;
  }

  /**
   * These indicate for what portion of the segment the lane's flowline exactly follows the segment,
   * and the lane is of constant width. This will be set to not include the whole segment where
   * there is a split/turn/merge at either end of the lane. The painting of the lane should
   * completely synthesize the lane geometry outside of this portion, connecting it to neighboring
   * lanes to make graphical nice.
   * @return value or {@code null} for none
   */
  public java.lang.Float getLaneFollowsSegmentBeginFraction() {
    return laneFollowsSegmentBeginFraction;
  }

  /**
   * These indicate for what portion of the segment the lane's flowline exactly follows the segment,
   * and the lane is of constant width. This will be set to not include the whole segment where
   * there is a split/turn/merge at either end of the lane. The painting of the lane should
   * completely synthesize the lane geometry outside of this portion, connecting it to neighboring
   * lanes to make graphical nice.
   * @param laneFollowsSegmentBeginFraction laneFollowsSegmentBeginFraction or {@code null} for none
   */
  public GeostoreLaneProto setLaneFollowsSegmentBeginFraction(java.lang.Float laneFollowsSegmentBeginFraction) {
    this.laneFollowsSegmentBeginFraction = laneFollowsSegmentBeginFraction;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Float getLaneFollowsSegmentEndFraction() {
    return laneFollowsSegmentEndFraction;
  }

  /**
   * @param laneFollowsSegmentEndFraction laneFollowsSegmentEndFraction or {@code null} for none
   */
  public GeostoreLaneProto setLaneFollowsSegmentEndFraction(java.lang.Float laneFollowsSegmentEndFraction) {
    this.laneFollowsSegmentEndFraction = laneFollowsSegmentEndFraction;
    return this;
  }

  /**
   * Lanes are numbered from inside of the road outward, i.e. the lane next to the center line is
   * lane 0. The lanes then stack outwards, towards the side that one drives on this segment (right
   * or left). NOTE: do NOT use the lane_number as index for lookup. Lane_number is not guaranteed
   * to match the segment.lane repeated field index.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getLaneNumber() {
    return laneNumber;
  }

  /**
   * Lanes are numbered from inside of the road outward, i.e. the lane next to the center line is
   * lane 0. The lanes then stack outwards, towards the side that one drives on this segment (right
   * or left). NOTE: do NOT use the lane_number as index for lookup. Lane_number is not guaranteed
   * to match the segment.lane repeated field index.
   * @param laneNumber laneNumber or {@code null} for none
   */
  public GeostoreLaneProto setLaneNumber(java.lang.Integer laneNumber) {
    this.laneNumber = laneNumber;
    return this;
  }

  /**
   * A token that can be used to identify the version of the data about this lane.
   * @return value or {@code null} for none
   */
  public java.lang.String getLaneToken() {
    return laneToken;
  }

  /**
   * A token that can be used to identify the version of the data about this lane.
   * @param laneToken laneToken or {@code null} for none
   */
  public GeostoreLaneProto setLaneToken(java.lang.String laneToken) {
    this.laneToken = laneToken;
    return this;
  }

  /**
   * Field-level metadata for this lane.
   * @return value or {@code null} for none
   */
  public GeostoreFieldMetadataProto getMetadata() {
    return metadata;
  }

  /**
   * Field-level metadata for this lane.
   * @param metadata metadata or {@code null} for none
   */
  public GeostoreLaneProto setMetadata(GeostoreFieldMetadataProto metadata) {
    this.metadata = metadata;
    return this;
  }

  /**
   * Restrictions that apply to this lane only. Examples include HOV lanes. If a lane restriction
   * implies a segment-level restriction (can't route on the segment at all), that restriction will
   * also exist as a segment level restriction. In effect - PathFinder does not have to look at lane
   * restrictions to figure out segment restrictions.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreRestrictionProto> getRestriction() {
    return restriction;
  }

  /**
   * Restrictions that apply to this lane only. Examples include HOV lanes. If a lane restriction
   * implies a segment-level restriction (can't route on the segment at all), that restriction will
   * also exist as a segment level restriction. In effect - PathFinder does not have to look at lane
   * restrictions to figure out segment restrictions.
   * @param restriction restriction or {@code null} for none
   */
  public GeostoreLaneProto setRestriction(java.util.List<GeostoreRestrictionProto> restriction) {
    this.restriction = restriction;
    return this;
  }

  /**
   * True if this lane is usable in both directions (left-turn lane, reversing lane, one-lane road,
   * etc). To get the total number of lanes for a road, add up the lanes in each direction counting
   * 0.5 for each shared lane.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getShared() {
    return shared;
  }

  /**
   * True if this lane is usable in both directions (left-turn lane, reversing lane, one-lane road,
   * etc). To get the total number of lanes for a road, add up the lanes in each direction counting
   * 0.5 for each shared lane.
   * @param shared shared or {@code null} for none
   */
  public GeostoreLaneProto setShared(java.lang.Boolean shared) {
    this.shared = shared;
    return this;
  }

  /**
   * References to any gcid:physical_lane_marker features that intersect this lane, with the
   * implication that a moving vehicle should stop there.
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreFeatureIdProto> getStopLine() {
    return stopLine;
  }

  /**
   * References to any gcid:physical_lane_marker features that intersect this lane, with the
   * implication that a moving vehicle should stop there.
   * @param stopLine stopLine or {@code null} for none
   */
  public GeostoreLaneProto setStopLine(java.util.List<GeostoreFeatureIdProto> stopLine) {
    this.stopLine = stopLine;
    return this;
  }

  /**
   * clang-format on LINT.ThenChange(//depot/google3/geostore/base/proto/segment.proto) Unlike the
   * surface in SegmentProto, this field does not have a default value. This is because the lane-
   * level surface overrides the segment-level surface. The lane's surface should be unset unless
   * explicitly overriding the segment's surface.
   * @return value or {@code null} for none
   */
  public java.lang.String getSurface() {
    return surface;
  }

  /**
   * clang-format on LINT.ThenChange(//depot/google3/geostore/base/proto/segment.proto) Unlike the
   * surface in SegmentProto, this field does not have a default value. This is because the lane-
   * level surface overrides the segment-level surface. The lane's surface should be unset unless
   * explicitly overriding the segment's surface.
   * @param surface surface or {@code null} for none
   */
  public GeostoreLaneProto setSurface(java.lang.String surface) {
    this.surface = surface;
    return this;
  }

  /**
   * clang-format on
   * @return value or {@code null} for none
   */
  public java.lang.String getType() {
    return type;
  }

  /**
   * clang-format on
   * @param type type or {@code null} for none
   */
  public GeostoreLaneProto setType(java.lang.String type) {
    this.type = type;
    return this;
  }

  /**
   * Width of this lane in meters. In many cases, we will collect this data by dividing the total
   * road width by the number of lanes. On accuracy: This is a rough average width along this
   * segment. If and when we wanted to be more accurate, we'd extend this schema to have full
   * polygons for segments/lanes rather than just this average width.
   * @return value or {@code null} for none
   */
  public java.lang.Float getWidth() {
    return width;
  }

  /**
   * Width of this lane in meters. In many cases, we will collect this data by dividing the total
   * road width by the number of lanes. On accuracy: This is a rough average width along this
   * segment. If and when we wanted to be more accurate, we'd extend this schema to have full
   * polygons for segments/lanes rather than just this average width.
   * @param width width or {@code null} for none
   */
  public GeostoreLaneProto setWidth(java.lang.Float width) {
    this.width = width;
    return this;
  }

  @Override
  public GeostoreLaneProto set(String fieldName, Object value) {
    return (GeostoreLaneProto) super.set(fieldName, value);
  }

  @Override
  public GeostoreLaneProto clone() {
    return (GeostoreLaneProto) super.clone();
  }

}
