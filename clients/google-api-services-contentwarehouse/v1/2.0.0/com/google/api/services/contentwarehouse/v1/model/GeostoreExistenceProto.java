/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.contentwarehouse.v1.model;

/**
 * Model definition for GeostoreExistenceProto.
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the contentwarehouse API. For a detailed explanation see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class GeostoreExistenceProto extends com.google.api.client.json.GenericJson {

  /**
   * Structured reason for the permanent closure (if any).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String closeReason;

  /**
   * Indicates whether the place is closed (permanently or temporarily), i.e., not operational in
   * the present, but was at in the past and/or will be in the future. WARNING: New code should use
   * Geo Schema's libraries instead, specifically the OpeningStatus APIs, available in: * C++
   * (cs/f:google3/geostore/base/public/feature.h%20function:ExistenceState) * Java
   * (cs/f:google3/java/com/google/geostore/base/Existence.java%20function:OpeningStatus) * Python
   * (cs/f:google3/geostore/base/public/python/feature.clif%20existence_state)
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean closed;

  /**
   * RESERVED
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreDateTimeProto endAsOfDate;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreDateTimeProto endDate;

  /**
   * ** DEPRECATED ** This field is now deprecated (see b/22878252). Please use the Geo Schema
   * GetFeatureBirthTimestamp() API to extract the birth timestamp of a feature. The timestamp in
   * seconds since the UNIX epoch (January 1, 1970) when this feature becomes live in the Geo
   * repository. Different from start_date in that this is the birth date of Google's representation
   * of the place whereas start_date is the birth date of the place in the physical world.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long featureBirthTimestampSeconds;

  /**
   * Indicates whether the feature is marked as removed in the Geo repository. Removed features are
   * still present in the Geo repository but are considered to be in an inactive state (not valid
   * for lint purposes, not retrievable except explicitly by feature ID, etc.). NOTE: If you have
   * access to a complete FeatureProto, do NOT read this bit directly to find out whether a feature
   * is removed. Instead, rely on the IsFeatureRemoved() API, available in C++
   * (geostore/base/public/feature.h) and Java (geostore/base/Feature.java).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean removed;

  /**
   * Structured reason why the feature is marked as removed. Relevant only when removed == true.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String removedReason;

  /**
   * (Initial) opening and (permanent) closing dates of the establishment, such that start_date is
   * the first day open and end_date is the first day closed. The only allowed precisions are
   * PRECISION_DAY, PRECISION_MONTH, PRECISION_YEAR. DateTimeProto.seconds should have the lowest
   * legal value for the desired date/time and precision. E.g. for PRECISION_MONTH, 2019-02-15
   * 21:10:30 is not valid, it should be 2019-02-01 00:00:00 instead. NOTE: The start_date and
   * end_date are stored in UTC but should be interpreted as being in the local timezone. So clients
   * should convert the DateTimeProto to local (civil) time using UTC+0, and then treat the result
   * as local to the feature.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreDateTimeProto startDate;

  /**
   * Structured reason for the permanent closure (if any).
   * @return value or {@code null} for none
   */
  public java.lang.String getCloseReason() {
    return closeReason;
  }

  /**
   * Structured reason for the permanent closure (if any).
   * @param closeReason closeReason or {@code null} for none
   */
  public GeostoreExistenceProto setCloseReason(java.lang.String closeReason) {
    this.closeReason = closeReason;
    return this;
  }

  /**
   * Indicates whether the place is closed (permanently or temporarily), i.e., not operational in
   * the present, but was at in the past and/or will be in the future. WARNING: New code should use
   * Geo Schema's libraries instead, specifically the OpeningStatus APIs, available in: * C++
   * (cs/f:google3/geostore/base/public/feature.h%20function:ExistenceState) * Java
   * (cs/f:google3/java/com/google/geostore/base/Existence.java%20function:OpeningStatus) * Python
   * (cs/f:google3/geostore/base/public/python/feature.clif%20existence_state)
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getClosed() {
    return closed;
  }

  /**
   * Indicates whether the place is closed (permanently or temporarily), i.e., not operational in
   * the present, but was at in the past and/or will be in the future. WARNING: New code should use
   * Geo Schema's libraries instead, specifically the OpeningStatus APIs, available in: * C++
   * (cs/f:google3/geostore/base/public/feature.h%20function:ExistenceState) * Java
   * (cs/f:google3/java/com/google/geostore/base/Existence.java%20function:OpeningStatus) * Python
   * (cs/f:google3/geostore/base/public/python/feature.clif%20existence_state)
   * @param closed closed or {@code null} for none
   */
  public GeostoreExistenceProto setClosed(java.lang.Boolean closed) {
    this.closed = closed;
    return this;
  }

  /**
   * RESERVED
   * @return value or {@code null} for none
   */
  public GeostoreDateTimeProto getEndAsOfDate() {
    return endAsOfDate;
  }

  /**
   * RESERVED
   * @param endAsOfDate endAsOfDate or {@code null} for none
   */
  public GeostoreExistenceProto setEndAsOfDate(GeostoreDateTimeProto endAsOfDate) {
    this.endAsOfDate = endAsOfDate;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public GeostoreDateTimeProto getEndDate() {
    return endDate;
  }

  /**
   * @param endDate endDate or {@code null} for none
   */
  public GeostoreExistenceProto setEndDate(GeostoreDateTimeProto endDate) {
    this.endDate = endDate;
    return this;
  }

  /**
   * ** DEPRECATED ** This field is now deprecated (see b/22878252). Please use the Geo Schema
   * GetFeatureBirthTimestamp() API to extract the birth timestamp of a feature. The timestamp in
   * seconds since the UNIX epoch (January 1, 1970) when this feature becomes live in the Geo
   * repository. Different from start_date in that this is the birth date of Google's representation
   * of the place whereas start_date is the birth date of the place in the physical world.
   * @return value or {@code null} for none
   */
  public java.lang.Long getFeatureBirthTimestampSeconds() {
    return featureBirthTimestampSeconds;
  }

  /**
   * ** DEPRECATED ** This field is now deprecated (see b/22878252). Please use the Geo Schema
   * GetFeatureBirthTimestamp() API to extract the birth timestamp of a feature. The timestamp in
   * seconds since the UNIX epoch (January 1, 1970) when this feature becomes live in the Geo
   * repository. Different from start_date in that this is the birth date of Google's representation
   * of the place whereas start_date is the birth date of the place in the physical world.
   * @param featureBirthTimestampSeconds featureBirthTimestampSeconds or {@code null} for none
   */
  public GeostoreExistenceProto setFeatureBirthTimestampSeconds(java.lang.Long featureBirthTimestampSeconds) {
    this.featureBirthTimestampSeconds = featureBirthTimestampSeconds;
    return this;
  }

  /**
   * Indicates whether the feature is marked as removed in the Geo repository. Removed features are
   * still present in the Geo repository but are considered to be in an inactive state (not valid
   * for lint purposes, not retrievable except explicitly by feature ID, etc.). NOTE: If you have
   * access to a complete FeatureProto, do NOT read this bit directly to find out whether a feature
   * is removed. Instead, rely on the IsFeatureRemoved() API, available in C++
   * (geostore/base/public/feature.h) and Java (geostore/base/Feature.java).
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getRemoved() {
    return removed;
  }

  /**
   * Indicates whether the feature is marked as removed in the Geo repository. Removed features are
   * still present in the Geo repository but are considered to be in an inactive state (not valid
   * for lint purposes, not retrievable except explicitly by feature ID, etc.). NOTE: If you have
   * access to a complete FeatureProto, do NOT read this bit directly to find out whether a feature
   * is removed. Instead, rely on the IsFeatureRemoved() API, available in C++
   * (geostore/base/public/feature.h) and Java (geostore/base/Feature.java).
   * @param removed removed or {@code null} for none
   */
  public GeostoreExistenceProto setRemoved(java.lang.Boolean removed) {
    this.removed = removed;
    return this;
  }

  /**
   * Structured reason why the feature is marked as removed. Relevant only when removed == true.
   * @return value or {@code null} for none
   */
  public java.lang.String getRemovedReason() {
    return removedReason;
  }

  /**
   * Structured reason why the feature is marked as removed. Relevant only when removed == true.
   * @param removedReason removedReason or {@code null} for none
   */
  public GeostoreExistenceProto setRemovedReason(java.lang.String removedReason) {
    this.removedReason = removedReason;
    return this;
  }

  /**
   * (Initial) opening and (permanent) closing dates of the establishment, such that start_date is
   * the first day open and end_date is the first day closed. The only allowed precisions are
   * PRECISION_DAY, PRECISION_MONTH, PRECISION_YEAR. DateTimeProto.seconds should have the lowest
   * legal value for the desired date/time and precision. E.g. for PRECISION_MONTH, 2019-02-15
   * 21:10:30 is not valid, it should be 2019-02-01 00:00:00 instead. NOTE: The start_date and
   * end_date are stored in UTC but should be interpreted as being in the local timezone. So clients
   * should convert the DateTimeProto to local (civil) time using UTC+0, and then treat the result
   * as local to the feature.
   * @return value or {@code null} for none
   */
  public GeostoreDateTimeProto getStartDate() {
    return startDate;
  }

  /**
   * (Initial) opening and (permanent) closing dates of the establishment, such that start_date is
   * the first day open and end_date is the first day closed. The only allowed precisions are
   * PRECISION_DAY, PRECISION_MONTH, PRECISION_YEAR. DateTimeProto.seconds should have the lowest
   * legal value for the desired date/time and precision. E.g. for PRECISION_MONTH, 2019-02-15
   * 21:10:30 is not valid, it should be 2019-02-01 00:00:00 instead. NOTE: The start_date and
   * end_date are stored in UTC but should be interpreted as being in the local timezone. So clients
   * should convert the DateTimeProto to local (civil) time using UTC+0, and then treat the result
   * as local to the feature.
   * @param startDate startDate or {@code null} for none
   */
  public GeostoreExistenceProto setStartDate(GeostoreDateTimeProto startDate) {
    this.startDate = startDate;
    return this;
  }

  @Override
  public GeostoreExistenceProto set(String fieldName, Object value) {
    return (GeostoreExistenceProto) super.set(fieldName, value);
  }

  @Override
  public GeostoreExistenceProto clone() {
    return (GeostoreExistenceProto) super.clone();
  }

}
