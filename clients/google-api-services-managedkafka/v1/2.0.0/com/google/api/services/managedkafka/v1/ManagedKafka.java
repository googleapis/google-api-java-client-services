/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.managedkafka.v1;

/**
 * Service definition for ManagedKafka (v1).
 *
 * <p>
 * Manage Apache Kafka clusters and resources. 
 * </p>
 *
 * <p>
 * For more information about this service, see the
 * <a href="https://cloud.google.com/managed-service-for-apache-kafka/docs" target="_blank">API Documentation</a>
 * </p>
 *
 * <p>
 * This service uses {@link ManagedKafkaRequestInitializer} to initialize global parameters via its
 * {@link Builder}.
 * </p>
 *
 * @since 1.3
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public class ManagedKafka extends com.google.api.client.googleapis.services.json.AbstractGoogleJsonClient {

  // Note: Leave this static initializer at the top of the file.
  static {
    com.google.api.client.util.Preconditions.checkState(
        (com.google.api.client.googleapis.GoogleUtils.MAJOR_VERSION == 1 &&
        (com.google.api.client.googleapis.GoogleUtils.MINOR_VERSION >= 32 ||
        (com.google.api.client.googleapis.GoogleUtils.MINOR_VERSION == 31 &&
        com.google.api.client.googleapis.GoogleUtils.BUGFIX_VERSION >= 1))) ||
        com.google.api.client.googleapis.GoogleUtils.MAJOR_VERSION >= 2,
        "You are currently running with version %s of google-api-client. " +
        "You need at least version 1.31.1 of google-api-client to run version " +
        "2.0.0 of the Managed Service for Apache Kafka API library.", com.google.api.client.googleapis.GoogleUtils.VERSION);
  }

  /**
   * The default encoded root URL of the service. This is determined when the library is generated
   * and normally should not be changed.
   *
   * @since 1.7
   */
  public static final String DEFAULT_ROOT_URL = "https://managedkafka.googleapis.com/";

  /**
   * The default encoded mTLS root URL of the service. This is determined when the library is generated
   * and normally should not be changed.
   *
   * @since 1.31
   */
  public static final String DEFAULT_MTLS_ROOT_URL = "https://managedkafka.mtls.googleapis.com/";

  /**
   * The default encoded service path of the service. This is determined when the library is
   * generated and normally should not be changed.
   *
   * @since 1.7
   */
  public static final String DEFAULT_SERVICE_PATH = "";

  /**
   * The default encoded batch path of the service. This is determined when the library is
   * generated and normally should not be changed.
   *
   * @since 1.23
   */
  public static final String DEFAULT_BATCH_PATH = "batch";

  /**
   * The default encoded base URL of the service. This is determined when the library is generated
   * and normally should not be changed.
   */
  public static final String DEFAULT_BASE_URL = DEFAULT_ROOT_URL + DEFAULT_SERVICE_PATH;

  /**
   * Constructor.
   *
   * <p>
   * Use {@link Builder} if you need to specify any of the optional parameters.
   * </p>
   *
   * @param transport HTTP transport, which should normally be:
   *        <ul>
   *        <li>Google App Engine:
   *        {@code com.google.api.client.extensions.appengine.http.UrlFetchTransport}</li>
   *        <li>Android: {@code newCompatibleTransport} from
   *        {@code com.google.api.client.extensions.android.http.AndroidHttp}</li>
   *        <li>Java: {@link com.google.api.client.googleapis.javanet.GoogleNetHttpTransport#newTrustedTransport()}
   *        </li>
   *        </ul>
   * @param jsonFactory JSON factory, which may be:
   *        <ul>
   *        <li>Jackson: {@code com.google.api.client.json.jackson2.JacksonFactory}</li>
   *        <li>Google GSON: {@code com.google.api.client.json.gson.GsonFactory}</li>
   *        <li>Android Honeycomb or higher:
   *        {@code com.google.api.client.extensions.android.json.AndroidJsonFactory}</li>
   *        </ul>
   * @param httpRequestInitializer HTTP request initializer or {@code null} for none
   * @since 1.7
   */
  public ManagedKafka(com.google.api.client.http.HttpTransport transport, com.google.api.client.json.JsonFactory jsonFactory,
      com.google.api.client.http.HttpRequestInitializer httpRequestInitializer) {
    this(new Builder(transport, jsonFactory, httpRequestInitializer));
  }

  /**
   * @param builder builder
   */
  ManagedKafka(Builder builder) {
    super(builder);
  }

  @Override
  protected void initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest<?> httpClientRequest) throws java.io.IOException {
    super.initialize(httpClientRequest);
  }

  /**
   * An accessor for creating requests from the Projects collection.
   *
   * <p>The typical use is:</p>
   * <pre>
   *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
   *   {@code ManagedKafka.Projects.List request = managedkafka.projects().list(parameters ...)}
   * </pre>
   *
   * @return the resource collection
   */
  public Projects projects() {
    return new Projects();
  }

  /**
   * The "projects" collection of methods.
   */
  public class Projects {

    /**
     * An accessor for creating requests from the Locations collection.
     *
     * <p>The typical use is:</p>
     * <pre>
     *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
     *   {@code ManagedKafka.Locations.List request = managedkafka.locations().list(parameters ...)}
     * </pre>
     *
     * @return the resource collection
     */
    public Locations locations() {
      return new Locations();
    }

    /**
     * The "locations" collection of methods.
     */
    public class Locations {

      /**
       * Gets information about a location.
       *
       * Create a request for the method "locations.get".
       *
       * This request holds the parameters needed by the managedkafka server.  After setting any optional
       * parameters, call the {@link Get#execute()} method to invoke the remote operation.
       *
       * @param name Resource name for the location.
       * @return the request
       */
      public Get get(java.lang.String name) throws java.io.IOException {
        Get result = new Get(name);
        initialize(result);
        return result;
      }

      public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Location> {

        private static final String REST_PATH = "v1/{+name}";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+$");

        /**
         * Gets information about a location.
         *
         * Create a request for the method "locations.get".
         *
         * This request holds the parameters needed by the the managedkafka server.  After setting any
         * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
         * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name Resource name for the location.
         * @since 1.13
         */
        protected Get(java.lang.String name) {
          super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Location.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/locations/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public Get set$Xgafv(java.lang.String $Xgafv) {
          return (Get) super.set$Xgafv($Xgafv);
        }

        @Override
        public Get setAccessToken(java.lang.String accessToken) {
          return (Get) super.setAccessToken(accessToken);
        }

        @Override
        public Get setAlt(java.lang.String alt) {
          return (Get) super.setAlt(alt);
        }

        @Override
        public Get setCallback(java.lang.String callback) {
          return (Get) super.setCallback(callback);
        }

        @Override
        public Get setFields(java.lang.String fields) {
          return (Get) super.setFields(fields);
        }

        @Override
        public Get setKey(java.lang.String key) {
          return (Get) super.setKey(key);
        }

        @Override
        public Get setOauthToken(java.lang.String oauthToken) {
          return (Get) super.setOauthToken(oauthToken);
        }

        @Override
        public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (Get) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public Get setQuotaUser(java.lang.String quotaUser) {
          return (Get) super.setQuotaUser(quotaUser);
        }

        @Override
        public Get setUploadType(java.lang.String uploadType) {
          return (Get) super.setUploadType(uploadType);
        }

        @Override
        public Get setUploadProtocol(java.lang.String uploadProtocol) {
          return (Get) super.setUploadProtocol(uploadProtocol);
        }

        /** Resource name for the location. */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** Resource name for the location.
         */
        public java.lang.String getName() {
          return name;
        }

        /** Resource name for the location. */
        public Get setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+/locations/[^/]+$");
          }
          this.name = name;
          return this;
        }

        @Override
        public Get set(String parameterName, Object value) {
          return (Get) super.set(parameterName, value);
        }
      }
      /**
       * Lists information about the supported locations for this service.
       *
       * Create a request for the method "locations.list".
       *
       * This request holds the parameters needed by the managedkafka server.  After setting any optional
       * parameters, call the {@link List#execute()} method to invoke the remote operation.
       *
       * @param name The resource that owns the locations collection, if applicable.
       * @return the request
       */
      public List list(java.lang.String name) throws java.io.IOException {
        List result = new List(name);
        initialize(result);
        return result;
      }

      public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ListLocationsResponse> {

        private static final String REST_PATH = "v1/{+name}/locations";

        private final java.util.regex.Pattern NAME_PATTERN =
            java.util.regex.Pattern.compile("^projects/[^/]+$");

        /**
         * Lists information about the supported locations for this service.
         *
         * Create a request for the method "locations.list".
         *
         * This request holds the parameters needed by the the managedkafka server.  After setting any
         * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
         * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
         * must be called to initialize this instance immediately after invoking the constructor. </p>
         *
         * @param name The resource that owns the locations collection, if applicable.
         * @since 1.13
         */
        protected List(java.lang.String name) {
          super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ListLocationsResponse.class);
          this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
        }

        @Override
        public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
          return super.executeUsingHead();
        }

        @Override
        public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
          return super.buildHttpRequestUsingHead();
        }

        @Override
        public List set$Xgafv(java.lang.String $Xgafv) {
          return (List) super.set$Xgafv($Xgafv);
        }

        @Override
        public List setAccessToken(java.lang.String accessToken) {
          return (List) super.setAccessToken(accessToken);
        }

        @Override
        public List setAlt(java.lang.String alt) {
          return (List) super.setAlt(alt);
        }

        @Override
        public List setCallback(java.lang.String callback) {
          return (List) super.setCallback(callback);
        }

        @Override
        public List setFields(java.lang.String fields) {
          return (List) super.setFields(fields);
        }

        @Override
        public List setKey(java.lang.String key) {
          return (List) super.setKey(key);
        }

        @Override
        public List setOauthToken(java.lang.String oauthToken) {
          return (List) super.setOauthToken(oauthToken);
        }

        @Override
        public List setPrettyPrint(java.lang.Boolean prettyPrint) {
          return (List) super.setPrettyPrint(prettyPrint);
        }

        @Override
        public List setQuotaUser(java.lang.String quotaUser) {
          return (List) super.setQuotaUser(quotaUser);
        }

        @Override
        public List setUploadType(java.lang.String uploadType) {
          return (List) super.setUploadType(uploadType);
        }

        @Override
        public List setUploadProtocol(java.lang.String uploadProtocol) {
          return (List) super.setUploadProtocol(uploadProtocol);
        }

        /** The resource that owns the locations collection, if applicable. */
        @com.google.api.client.util.Key
        private java.lang.String name;

        /** The resource that owns the locations collection, if applicable.
         */
        public java.lang.String getName() {
          return name;
        }

        /** The resource that owns the locations collection, if applicable. */
        public List setName(java.lang.String name) {
          if (!getSuppressPatternChecks()) {
            com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                "Parameter name must conform to the pattern " +
                "^projects/[^/]+$");
          }
          this.name = name;
          return this;
        }

        /**
         * Optional. A list of extra location types that should be used as conditions for
         * controlling the visibility of the locations.
         */
        @com.google.api.client.util.Key
        private java.util.List<java.lang.String> extraLocationTypes;

        /** Optional. A list of extra location types that should be used as conditions for controlling the
       visibility of the locations.
         */
        public java.util.List<java.lang.String> getExtraLocationTypes() {
          return extraLocationTypes;
        }

        /**
         * Optional. A list of extra location types that should be used as conditions for
         * controlling the visibility of the locations.
         */
        public List setExtraLocationTypes(java.util.List<java.lang.String> extraLocationTypes) {
          this.extraLocationTypes = extraLocationTypes;
          return this;
        }

        /**
         * A filter to narrow down results to a preferred subset. The filtering language accepts
         * strings like `"displayName=tokyo"`, and is documented in more detail in
         * [AIP-160](https://google.aip.dev/160).
         */
        @com.google.api.client.util.Key
        private java.lang.String filter;

        /** A filter to narrow down results to a preferred subset. The filtering language accepts strings like
       `"displayName=tokyo"`, and is documented in more detail in [AIP-160](https://google.aip.dev/160).
         */
        public java.lang.String getFilter() {
          return filter;
        }

        /**
         * A filter to narrow down results to a preferred subset. The filtering language accepts
         * strings like `"displayName=tokyo"`, and is documented in more detail in
         * [AIP-160](https://google.aip.dev/160).
         */
        public List setFilter(java.lang.String filter) {
          this.filter = filter;
          return this;
        }

        /** The maximum number of results to return. If not set, the service selects a default. */
        @com.google.api.client.util.Key
        private java.lang.Integer pageSize;

        /** The maximum number of results to return. If not set, the service selects a default.
         */
        public java.lang.Integer getPageSize() {
          return pageSize;
        }

        /** The maximum number of results to return. If not set, the service selects a default. */
        public List setPageSize(java.lang.Integer pageSize) {
          this.pageSize = pageSize;
          return this;
        }

        /**
         * A page token received from the `next_page_token` field in the response. Send that page
         * token to receive the subsequent page.
         */
        @com.google.api.client.util.Key
        private java.lang.String pageToken;

        /** A page token received from the `next_page_token` field in the response. Send that page token to
       receive the subsequent page.
         */
        public java.lang.String getPageToken() {
          return pageToken;
        }

        /**
         * A page token received from the `next_page_token` field in the response. Send that page
         * token to receive the subsequent page.
         */
        public List setPageToken(java.lang.String pageToken) {
          this.pageToken = pageToken;
          return this;
        }

        @Override
        public List set(String parameterName, Object value) {
          return (List) super.set(parameterName, value);
        }
      }

      /**
       * An accessor for creating requests from the Clusters collection.
       *
       * <p>The typical use is:</p>
       * <pre>
       *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
       *   {@code ManagedKafka.Clusters.List request = managedkafka.clusters().list(parameters ...)}
       * </pre>
       *
       * @return the resource collection
       */
      public Clusters clusters() {
        return new Clusters();
      }

      /**
       * The "clusters" collection of methods.
       */
      public class Clusters {

        /**
         * Creates a new cluster in a given project and location.
         *
         * Create a request for the method "clusters.create".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Create#execute()} method to invoke the remote operation.
         *
         * @param parent Required. The parent region in which to create the cluster. Structured like
         *        `projects/{project}/locations/{location}`.
         * @param content the {@link com.google.api.services.managedkafka.v1.model.Cluster}
         * @return the request
         */
        public Create create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.Cluster content) throws java.io.IOException {
          Create result = new Create(parent, content);
          initialize(result);
          return result;
        }

        public class Create extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Operation> {

          private static final String REST_PATH = "v1/{+parent}/clusters";

          private final java.util.regex.Pattern PARENT_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+$");

          /**
           * Creates a new cluster in a given project and location.
           *
           * Create a request for the method "clusters.create".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
           * <p> {@link
           * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
           * be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param parent Required. The parent region in which to create the cluster. Structured like
         *        `projects/{project}/locations/{location}`.
           * @param content the {@link com.google.api.services.managedkafka.v1.model.Cluster}
           * @since 1.13
           */
          protected Create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.Cluster content) {
            super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Operation.class);
            this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
          }

          @Override
          public Create set$Xgafv(java.lang.String $Xgafv) {
            return (Create) super.set$Xgafv($Xgafv);
          }

          @Override
          public Create setAccessToken(java.lang.String accessToken) {
            return (Create) super.setAccessToken(accessToken);
          }

          @Override
          public Create setAlt(java.lang.String alt) {
            return (Create) super.setAlt(alt);
          }

          @Override
          public Create setCallback(java.lang.String callback) {
            return (Create) super.setCallback(callback);
          }

          @Override
          public Create setFields(java.lang.String fields) {
            return (Create) super.setFields(fields);
          }

          @Override
          public Create setKey(java.lang.String key) {
            return (Create) super.setKey(key);
          }

          @Override
          public Create setOauthToken(java.lang.String oauthToken) {
            return (Create) super.setOauthToken(oauthToken);
          }

          @Override
          public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Create) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Create setQuotaUser(java.lang.String quotaUser) {
            return (Create) super.setQuotaUser(quotaUser);
          }

          @Override
          public Create setUploadType(java.lang.String uploadType) {
            return (Create) super.setUploadType(uploadType);
          }

          @Override
          public Create setUploadProtocol(java.lang.String uploadProtocol) {
            return (Create) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Required. The parent region in which to create the cluster. Structured like
           * `projects/{project}/locations/{location}`.
           */
          @com.google.api.client.util.Key
          private java.lang.String parent;

          /** Required. The parent region in which to create the cluster. Structured like
         `projects/{project}/locations/{location}`.
           */
          public java.lang.String getParent() {
            return parent;
          }

          /**
           * Required. The parent region in which to create the cluster. Structured like
           * `projects/{project}/locations/{location}`.
           */
          public Create setParent(java.lang.String parent) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
            this.parent = parent;
            return this;
          }

          /**
           * Required. The ID to use for the cluster, which will become the final component of the
           * cluster's name. The ID must be 1-63 characters long, and match the regular expression
           * `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value is structured like:
           * `my-cluster-id`.
           */
          @com.google.api.client.util.Key
          private java.lang.String clusterId;

          /** Required. The ID to use for the cluster, which will become the final component of the cluster's
         name. The ID must be 1-63 characters long, and match the regular expression
         `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value is structured like: `my-cluster-
         id`.
           */
          public java.lang.String getClusterId() {
            return clusterId;
          }

          /**
           * Required. The ID to use for the cluster, which will become the final component of the
           * cluster's name. The ID must be 1-63 characters long, and match the regular expression
           * `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value is structured like:
           * `my-cluster-id`.
           */
          public Create setClusterId(java.lang.String clusterId) {
            this.clusterId = clusterId;
            return this;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          @com.google.api.client.util.Key
          private java.lang.String requestId;

          /** Optional. An optional request ID to identify requests. Specify a unique request ID to avoid
         duplication of requests. If a request times out or fails, retrying with the same ID allows the
         server to recognize the previous attempt. For at least 60 minutes, the server ignores duplicate
         requests bearing the same ID. For example, consider a situation where you make an initial request
         and the request times out. If you make the request again with the same request ID within 60 minutes
         of the last request, the server checks if an original operation with the same request ID was
         received. If so, the server ignores the second request. The request ID must be a valid UUID. A zero
         UUID is not supported (00000000-0000-0000-0000-000000000000).
           */
          public java.lang.String getRequestId() {
            return requestId;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          public Create setRequestId(java.lang.String requestId) {
            this.requestId = requestId;
            return this;
          }

          @Override
          public Create set(String parameterName, Object value) {
            return (Create) super.set(parameterName, value);
          }
        }
        /**
         * Deletes a single cluster.
         *
         * Create a request for the method "clusters.delete".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
         *
         * @param name Required. The name of the cluster to delete.
         * @return the request
         */
        public Delete delete(java.lang.String name) throws java.io.IOException {
          Delete result = new Delete(name);
          initialize(result);
          return result;
        }

        public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Operation> {

          private static final String REST_PATH = "v1/{+name}";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");

          /**
           * Deletes a single cluster.
           *
           * Create a request for the method "clusters.delete".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
           * <p> {@link
           * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
           * be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name Required. The name of the cluster to delete.
           * @since 1.13
           */
          protected Delete(java.lang.String name) {
            super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Operation.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
            }
          }

          @Override
          public Delete set$Xgafv(java.lang.String $Xgafv) {
            return (Delete) super.set$Xgafv($Xgafv);
          }

          @Override
          public Delete setAccessToken(java.lang.String accessToken) {
            return (Delete) super.setAccessToken(accessToken);
          }

          @Override
          public Delete setAlt(java.lang.String alt) {
            return (Delete) super.setAlt(alt);
          }

          @Override
          public Delete setCallback(java.lang.String callback) {
            return (Delete) super.setCallback(callback);
          }

          @Override
          public Delete setFields(java.lang.String fields) {
            return (Delete) super.setFields(fields);
          }

          @Override
          public Delete setKey(java.lang.String key) {
            return (Delete) super.setKey(key);
          }

          @Override
          public Delete setOauthToken(java.lang.String oauthToken) {
            return (Delete) super.setOauthToken(oauthToken);
          }

          @Override
          public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Delete) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Delete setQuotaUser(java.lang.String quotaUser) {
            return (Delete) super.setQuotaUser(quotaUser);
          }

          @Override
          public Delete setUploadType(java.lang.String uploadType) {
            return (Delete) super.setUploadType(uploadType);
          }

          @Override
          public Delete setUploadProtocol(java.lang.String uploadProtocol) {
            return (Delete) super.setUploadProtocol(uploadProtocol);
          }

          /** Required. The name of the cluster to delete. */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** Required. The name of the cluster to delete.
           */
          public java.lang.String getName() {
            return name;
          }

          /** Required. The name of the cluster to delete. */
          public Delete setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
            }
            this.name = name;
            return this;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          @com.google.api.client.util.Key
          private java.lang.String requestId;

          /** Optional. An optional request ID to identify requests. Specify a unique request ID to avoid
         duplication of requests. If a request times out or fails, retrying with the same ID allows the
         server to recognize the previous attempt. For at least 60 minutes, the server ignores duplicate
         requests bearing the same ID. For example, consider a situation where you make an initial request
         and the request times out. If you make the request again with the same request ID within 60 minutes
         of the last request, the server checks if an original operation with the same request ID was
         received. If so, the server ignores the second request. The request ID must be a valid UUID. A zero
         UUID is not supported (00000000-0000-0000-0000-000000000000).
           */
          public java.lang.String getRequestId() {
            return requestId;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          public Delete setRequestId(java.lang.String requestId) {
            this.requestId = requestId;
            return this;
          }

          @Override
          public Delete set(String parameterName, Object value) {
            return (Delete) super.set(parameterName, value);
          }
        }
        /**
         * Returns the properties of a single cluster.
         *
         * Create a request for the method "clusters.get".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Get#execute()} method to invoke the remote operation.
         *
         * @param name Required. The name of the cluster whose configuration to return.
         * @return the request
         */
        public Get get(java.lang.String name) throws java.io.IOException {
          Get result = new Get(name);
          initialize(result);
          return result;
        }

        public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Cluster> {

          private static final String REST_PATH = "v1/{+name}";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");

          /**
           * Returns the properties of a single cluster.
           *
           * Create a request for the method "clusters.get".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
           * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
           * must be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name Required. The name of the cluster whose configuration to return.
           * @since 1.13
           */
          protected Get(java.lang.String name) {
            super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Cluster.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
            }
          }

          @Override
          public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
            return super.executeUsingHead();
          }

          @Override
          public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
            return super.buildHttpRequestUsingHead();
          }

          @Override
          public Get set$Xgafv(java.lang.String $Xgafv) {
            return (Get) super.set$Xgafv($Xgafv);
          }

          @Override
          public Get setAccessToken(java.lang.String accessToken) {
            return (Get) super.setAccessToken(accessToken);
          }

          @Override
          public Get setAlt(java.lang.String alt) {
            return (Get) super.setAlt(alt);
          }

          @Override
          public Get setCallback(java.lang.String callback) {
            return (Get) super.setCallback(callback);
          }

          @Override
          public Get setFields(java.lang.String fields) {
            return (Get) super.setFields(fields);
          }

          @Override
          public Get setKey(java.lang.String key) {
            return (Get) super.setKey(key);
          }

          @Override
          public Get setOauthToken(java.lang.String oauthToken) {
            return (Get) super.setOauthToken(oauthToken);
          }

          @Override
          public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Get) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Get setQuotaUser(java.lang.String quotaUser) {
            return (Get) super.setQuotaUser(quotaUser);
          }

          @Override
          public Get setUploadType(java.lang.String uploadType) {
            return (Get) super.setUploadType(uploadType);
          }

          @Override
          public Get setUploadProtocol(java.lang.String uploadProtocol) {
            return (Get) super.setUploadProtocol(uploadProtocol);
          }

          /** Required. The name of the cluster whose configuration to return. */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** Required. The name of the cluster whose configuration to return.
           */
          public java.lang.String getName() {
            return name;
          }

          /** Required. The name of the cluster whose configuration to return. */
          public Get setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
            }
            this.name = name;
            return this;
          }

          @Override
          public Get set(String parameterName, Object value) {
            return (Get) super.set(parameterName, value);
          }
        }
        /**
         * Lists the clusters in a given project and location.
         *
         * Create a request for the method "clusters.list".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link List#execute()} method to invoke the remote operation.
         *
         * @param parent Required. The parent location whose clusters are to be listed. Structured like
         *        `projects/{project}/locations/{location}`.
         * @return the request
         */
        public List list(java.lang.String parent) throws java.io.IOException {
          List result = new List(parent);
          initialize(result);
          return result;
        }

        public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ListClustersResponse> {

          private static final String REST_PATH = "v1/{+parent}/clusters";

          private final java.util.regex.Pattern PARENT_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+$");

          /**
           * Lists the clusters in a given project and location.
           *
           * Create a request for the method "clusters.list".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
           * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
           * must be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param parent Required. The parent location whose clusters are to be listed. Structured like
         *        `projects/{project}/locations/{location}`.
           * @since 1.13
           */
          protected List(java.lang.String parent) {
            super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ListClustersResponse.class);
            this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
          }

          @Override
          public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
            return super.executeUsingHead();
          }

          @Override
          public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
            return super.buildHttpRequestUsingHead();
          }

          @Override
          public List set$Xgafv(java.lang.String $Xgafv) {
            return (List) super.set$Xgafv($Xgafv);
          }

          @Override
          public List setAccessToken(java.lang.String accessToken) {
            return (List) super.setAccessToken(accessToken);
          }

          @Override
          public List setAlt(java.lang.String alt) {
            return (List) super.setAlt(alt);
          }

          @Override
          public List setCallback(java.lang.String callback) {
            return (List) super.setCallback(callback);
          }

          @Override
          public List setFields(java.lang.String fields) {
            return (List) super.setFields(fields);
          }

          @Override
          public List setKey(java.lang.String key) {
            return (List) super.setKey(key);
          }

          @Override
          public List setOauthToken(java.lang.String oauthToken) {
            return (List) super.setOauthToken(oauthToken);
          }

          @Override
          public List setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (List) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public List setQuotaUser(java.lang.String quotaUser) {
            return (List) super.setQuotaUser(quotaUser);
          }

          @Override
          public List setUploadType(java.lang.String uploadType) {
            return (List) super.setUploadType(uploadType);
          }

          @Override
          public List setUploadProtocol(java.lang.String uploadProtocol) {
            return (List) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Required. The parent location whose clusters are to be listed. Structured like
           * `projects/{project}/locations/{location}`.
           */
          @com.google.api.client.util.Key
          private java.lang.String parent;

          /** Required. The parent location whose clusters are to be listed. Structured like
         `projects/{project}/locations/{location}`.
           */
          public java.lang.String getParent() {
            return parent;
          }

          /**
           * Required. The parent location whose clusters are to be listed. Structured like
           * `projects/{project}/locations/{location}`.
           */
          public List setParent(java.lang.String parent) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
            this.parent = parent;
            return this;
          }

          /** Optional. Filter expression for the result. */
          @com.google.api.client.util.Key
          private java.lang.String filter;

          /** Optional. Filter expression for the result.
           */
          public java.lang.String getFilter() {
            return filter;
          }

          /** Optional. Filter expression for the result. */
          public List setFilter(java.lang.String filter) {
            this.filter = filter;
            return this;
          }

          /** Optional. Order by fields for the result. */
          @com.google.api.client.util.Key
          private java.lang.String orderBy;

          /** Optional. Order by fields for the result.
           */
          public java.lang.String getOrderBy() {
            return orderBy;
          }

          /** Optional. Order by fields for the result. */
          public List setOrderBy(java.lang.String orderBy) {
            this.orderBy = orderBy;
            return this;
          }

          /**
           * Optional. The maximum number of clusters to return. The service may return fewer than
           * this value. If unspecified, server will pick an appropriate default.
           */
          @com.google.api.client.util.Key
          private java.lang.Integer pageSize;

          /** Optional. The maximum number of clusters to return. The service may return fewer than this value.
         If unspecified, server will pick an appropriate default.
           */
          public java.lang.Integer getPageSize() {
            return pageSize;
          }

          /**
           * Optional. The maximum number of clusters to return. The service may return fewer than
           * this value. If unspecified, server will pick an appropriate default.
           */
          public List setPageSize(java.lang.Integer pageSize) {
            this.pageSize = pageSize;
            return this;
          }

          /**
           * Optional. A page token, received from a previous `ListClusters` call. Provide this to
           * retrieve the subsequent page. When paginating, all other parameters provided to
           * `ListClusters` must match the call that provided the page token.
           */
          @com.google.api.client.util.Key
          private java.lang.String pageToken;

          /** Optional. A page token, received from a previous `ListClusters` call. Provide this to retrieve the
         subsequent page. When paginating, all other parameters provided to `ListClusters` must match the
         call that provided the page token.
           */
          public java.lang.String getPageToken() {
            return pageToken;
          }

          /**
           * Optional. A page token, received from a previous `ListClusters` call. Provide this to
           * retrieve the subsequent page. When paginating, all other parameters provided to
           * `ListClusters` must match the call that provided the page token.
           */
          public List setPageToken(java.lang.String pageToken) {
            this.pageToken = pageToken;
            return this;
          }

          @Override
          public List set(String parameterName, Object value) {
            return (List) super.set(parameterName, value);
          }
        }
        /**
         * Updates the properties of a single cluster.
         *
         * Create a request for the method "clusters.patch".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Patch#execute()} method to invoke the remote operation.
         *
         * @param name Identifier. The name of the cluster. Structured like:
         *        projects/{project_number}/locations/{location}/clusters/{cluster_id}
         * @param content the {@link com.google.api.services.managedkafka.v1.model.Cluster}
         * @return the request
         */
        public Patch patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.Cluster content) throws java.io.IOException {
          Patch result = new Patch(name, content);
          initialize(result);
          return result;
        }

        public class Patch extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Operation> {

          private static final String REST_PATH = "v1/{+name}";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");

          /**
           * Updates the properties of a single cluster.
           *
           * Create a request for the method "clusters.patch".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Patch#execute()} method to invoke the remote operation.
           * <p> {@link
           * Patch#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
           * be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name Identifier. The name of the cluster. Structured like:
         *        projects/{project_number}/locations/{location}/clusters/{cluster_id}
           * @param content the {@link com.google.api.services.managedkafka.v1.model.Cluster}
           * @since 1.13
           */
          protected Patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.Cluster content) {
            super(ManagedKafka.this, "PATCH", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Operation.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
            }
          }

          @Override
          public Patch set$Xgafv(java.lang.String $Xgafv) {
            return (Patch) super.set$Xgafv($Xgafv);
          }

          @Override
          public Patch setAccessToken(java.lang.String accessToken) {
            return (Patch) super.setAccessToken(accessToken);
          }

          @Override
          public Patch setAlt(java.lang.String alt) {
            return (Patch) super.setAlt(alt);
          }

          @Override
          public Patch setCallback(java.lang.String callback) {
            return (Patch) super.setCallback(callback);
          }

          @Override
          public Patch setFields(java.lang.String fields) {
            return (Patch) super.setFields(fields);
          }

          @Override
          public Patch setKey(java.lang.String key) {
            return (Patch) super.setKey(key);
          }

          @Override
          public Patch setOauthToken(java.lang.String oauthToken) {
            return (Patch) super.setOauthToken(oauthToken);
          }

          @Override
          public Patch setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Patch) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Patch setQuotaUser(java.lang.String quotaUser) {
            return (Patch) super.setQuotaUser(quotaUser);
          }

          @Override
          public Patch setUploadType(java.lang.String uploadType) {
            return (Patch) super.setUploadType(uploadType);
          }

          @Override
          public Patch setUploadProtocol(java.lang.String uploadProtocol) {
            return (Patch) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Identifier. The name of the cluster. Structured like:
           * projects/{project_number}/locations/{location}/clusters/{cluster_id}
           */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** Identifier. The name of the cluster. Structured like:
         projects/{project_number}/locations/{location}/clusters/{cluster_id}
           */
          public java.lang.String getName() {
            return name;
          }

          /**
           * Identifier. The name of the cluster. Structured like:
           * projects/{project_number}/locations/{location}/clusters/{cluster_id}
           */
          public Patch setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
            }
            this.name = name;
            return this;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          @com.google.api.client.util.Key
          private java.lang.String requestId;

          /** Optional. An optional request ID to identify requests. Specify a unique request ID to avoid
         duplication of requests. If a request times out or fails, retrying with the same ID allows the
         server to recognize the previous attempt. For at least 60 minutes, the server ignores duplicate
         requests bearing the same ID. For example, consider a situation where you make an initial request
         and the request times out. If you make the request again with the same request ID within 60 minutes
         of the last request, the server checks if an original operation with the same request ID was
         received. If so, the server ignores the second request. The request ID must be a valid UUID. A zero
         UUID is not supported (00000000-0000-0000-0000-000000000000).
           */
          public java.lang.String getRequestId() {
            return requestId;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          public Patch setRequestId(java.lang.String requestId) {
            this.requestId = requestId;
            return this;
          }

          /**
           * Required. Field mask is used to specify the fields to be overwritten in the cluster
           * resource by the update. The fields specified in the update_mask are relative to the
           * resource, not the full request. A field will be overwritten if it is in the mask. The
           * mask is required and a value of * will update all fields.
           */
          @com.google.api.client.util.Key
          private String updateMask;

          /** Required. Field mask is used to specify the fields to be overwritten in the cluster resource by the
         update. The fields specified in the update_mask are relative to the resource, not the full request.
         A field will be overwritten if it is in the mask. The mask is required and a value of * will update
         all fields.
           */
          public String getUpdateMask() {
            return updateMask;
          }

          /**
           * Required. Field mask is used to specify the fields to be overwritten in the cluster
           * resource by the update. The fields specified in the update_mask are relative to the
           * resource, not the full request. A field will be overwritten if it is in the mask. The
           * mask is required and a value of * will update all fields.
           */
          public Patch setUpdateMask(String updateMask) {
            this.updateMask = updateMask;
            return this;
          }

          @Override
          public Patch set(String parameterName, Object value) {
            return (Patch) super.set(parameterName, value);
          }
        }

        /**
         * An accessor for creating requests from the Acls collection.
         *
         * <p>The typical use is:</p>
         * <pre>
         *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
         *   {@code ManagedKafka.Acls.List request = managedkafka.acls().list(parameters ...)}
         * </pre>
         *
         * @return the resource collection
         */
        public Acls acls() {
          return new Acls();
        }

        /**
         * The "acls" collection of methods.
         */
        public class Acls {

          /**
           * Incremental update: Adds an acl entry to an acl. Creates the acl if it does not exist yet.
           *
           * Create a request for the method "acls.addAclEntry".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link AddAclEntry#execute()} method to invoke the remote operation.
           *
           * @param acl Required. The name of the acl to add the acl entry to. Structured like:
           *        `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure
           *        of `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of
           *        the acl. See `Acl.name` for details.
           * @param content the {@link com.google.api.services.managedkafka.v1.model.AclEntry}
           * @return the request
           */
          public AddAclEntry addAclEntry(java.lang.String acl, com.google.api.services.managedkafka.v1.model.AclEntry content) throws java.io.IOException {
            AddAclEntry result = new AddAclEntry(acl, content);
            initialize(result);
            return result;
          }

          public class AddAclEntry extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.AddAclEntryResponse> {

            private static final String REST_PATH = "v1/{+acl}:addAclEntry";

            private final java.util.regex.Pattern ACL_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");

            /**
             * Incremental update: Adds an acl entry to an acl. Creates the acl if it does not exist yet.
             *
             * Create a request for the method "acls.addAclEntry".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link AddAclEntry#execute()} method to invoke the remote
             * operation. <p> {@link
             * AddAclEntry#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param acl Required. The name of the acl to add the acl entry to. Structured like:
           *        `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure
           *        of `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of
           *        the acl. See `Acl.name` for details.
             * @param content the {@link com.google.api.services.managedkafka.v1.model.AclEntry}
             * @since 1.13
             */
            protected AddAclEntry(java.lang.String acl, com.google.api.services.managedkafka.v1.model.AclEntry content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.AddAclEntryResponse.class);
              this.acl = com.google.api.client.util.Preconditions.checkNotNull(acl, "Required parameter acl must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(ACL_PATTERN.matcher(acl).matches(),
                    "Parameter acl must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
            }

            @Override
            public AddAclEntry set$Xgafv(java.lang.String $Xgafv) {
              return (AddAclEntry) super.set$Xgafv($Xgafv);
            }

            @Override
            public AddAclEntry setAccessToken(java.lang.String accessToken) {
              return (AddAclEntry) super.setAccessToken(accessToken);
            }

            @Override
            public AddAclEntry setAlt(java.lang.String alt) {
              return (AddAclEntry) super.setAlt(alt);
            }

            @Override
            public AddAclEntry setCallback(java.lang.String callback) {
              return (AddAclEntry) super.setCallback(callback);
            }

            @Override
            public AddAclEntry setFields(java.lang.String fields) {
              return (AddAclEntry) super.setFields(fields);
            }

            @Override
            public AddAclEntry setKey(java.lang.String key) {
              return (AddAclEntry) super.setKey(key);
            }

            @Override
            public AddAclEntry setOauthToken(java.lang.String oauthToken) {
              return (AddAclEntry) super.setOauthToken(oauthToken);
            }

            @Override
            public AddAclEntry setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (AddAclEntry) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public AddAclEntry setQuotaUser(java.lang.String quotaUser) {
              return (AddAclEntry) super.setQuotaUser(quotaUser);
            }

            @Override
            public AddAclEntry setUploadType(java.lang.String uploadType) {
              return (AddAclEntry) super.setUploadType(uploadType);
            }

            @Override
            public AddAclEntry setUploadProtocol(java.lang.String uploadProtocol) {
              return (AddAclEntry) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the acl to add the acl entry to. Structured like:
             * `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. See `Acl.name` for details.
             */
            @com.google.api.client.util.Key
            private java.lang.String acl;

            /** Required. The name of the acl to add the acl entry to. Structured like:
           `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure of
           `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of the acl. See
           `Acl.name` for details.
             */
            public java.lang.String getAcl() {
              return acl;
            }

            /**
             * Required. The name of the acl to add the acl entry to. Structured like:
             * `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. See `Acl.name` for details.
             */
            public AddAclEntry setAcl(java.lang.String acl) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(ACL_PATTERN.matcher(acl).matches(),
                    "Parameter acl must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
              this.acl = acl;
              return this;
            }

            @Override
            public AddAclEntry set(String parameterName, Object value) {
              return (AddAclEntry) super.set(parameterName, value);
            }
          }
          /**
           * Creates a new acl in the given project, location, and cluster.
           *
           * Create a request for the method "acls.create".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Create#execute()} method to invoke the remote operation.
           *
           * @param parent Required. The parent cluster in which to create the acl. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
           * @param content the {@link com.google.api.services.managedkafka.v1.model.Acl}
           * @return the request
           */
          public Create create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.Acl content) throws java.io.IOException {
            Create result = new Create(parent, content);
            initialize(result);
            return result;
          }

          public class Create extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Acl> {

            private static final String REST_PATH = "v1/{+parent}/acls";

            private final java.util.regex.Pattern PARENT_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");

            /**
             * Creates a new acl in the given project, location, and cluster.
             *
             * Create a request for the method "acls.create".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
             * <p> {@link
             * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param parent Required. The parent cluster in which to create the acl. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
             * @param content the {@link com.google.api.services.managedkafka.v1.model.Acl}
             * @since 1.13
             */
            protected Create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.Acl content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Acl.class);
              this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
            }

            @Override
            public Create set$Xgafv(java.lang.String $Xgafv) {
              return (Create) super.set$Xgafv($Xgafv);
            }

            @Override
            public Create setAccessToken(java.lang.String accessToken) {
              return (Create) super.setAccessToken(accessToken);
            }

            @Override
            public Create setAlt(java.lang.String alt) {
              return (Create) super.setAlt(alt);
            }

            @Override
            public Create setCallback(java.lang.String callback) {
              return (Create) super.setCallback(callback);
            }

            @Override
            public Create setFields(java.lang.String fields) {
              return (Create) super.setFields(fields);
            }

            @Override
            public Create setKey(java.lang.String key) {
              return (Create) super.setKey(key);
            }

            @Override
            public Create setOauthToken(java.lang.String oauthToken) {
              return (Create) super.setOauthToken(oauthToken);
            }

            @Override
            public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Create) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Create setQuotaUser(java.lang.String quotaUser) {
              return (Create) super.setQuotaUser(quotaUser);
            }

            @Override
            public Create setUploadType(java.lang.String uploadType) {
              return (Create) super.setUploadType(uploadType);
            }

            @Override
            public Create setUploadProtocol(java.lang.String uploadProtocol) {
              return (Create) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The parent cluster in which to create the acl. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String parent;

            /** Required. The parent cluster in which to create the acl. Structured like
           `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public java.lang.String getParent() {
              return parent;
            }

            /**
             * Required. The parent cluster in which to create the acl. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public Create setParent(java.lang.String parent) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
              this.parent = parent;
              return this;
            }

            /**
             * Required. The ID to use for the acl, which will become the final component of the
             * acl's name. The structure of `acl_id` defines the Resource Pattern (resource_type,
             * resource_name, pattern_type) of the acl. `acl_id` is structured like one of the
             * following: For acls on the cluster: `cluster` For acls on a single resource within
             * the cluster: `topic/{resource_name}` `consumerGroup/{resource_name}`
             * `transactionalId/{resource_name}` For acls on all resources that match a prefix:
             * `topicPrefixed/{resource_name}` `consumerGroupPrefixed/{resource_name}`
             * `transactionalIdPrefixed/{resource_name}` For acls on all resources of a given type
             * (i.e. the wildcard literal "*"): `allTopics` (represents `topic`) `allConsumerGroups`
             * (represents `consumerGroup`) `allTransactionalIds` (represents `transactionalId`)
             */
            @com.google.api.client.util.Key
            private java.lang.String aclId;

            /** Required. The ID to use for the acl, which will become the final component of the acl's name. The
           structure of `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of
           the acl. `acl_id` is structured like one of the following: For acls on the cluster: `cluster` For
           acls on a single resource within the cluster: `topic/{resource_name}`
           `consumerGroup/{resource_name}` `transactionalId/{resource_name}` For acls on all resources that
           match a prefix: `topicPrefixed/{resource_name}` `consumerGroupPrefixed/{resource_name}`
           `transactionalIdPrefixed/{resource_name}` For acls on all resources of a given type (i.e. the
           wildcard literal "*"): `allTopics` (represents `topic`) `allConsumerGroups` (represents
           `consumerGroup`) `allTransactionalIds` (represents `transactionalId`)
             */
            public java.lang.String getAclId() {
              return aclId;
            }

            /**
             * Required. The ID to use for the acl, which will become the final component of the
             * acl's name. The structure of `acl_id` defines the Resource Pattern (resource_type,
             * resource_name, pattern_type) of the acl. `acl_id` is structured like one of the
             * following: For acls on the cluster: `cluster` For acls on a single resource within
             * the cluster: `topic/{resource_name}` `consumerGroup/{resource_name}`
             * `transactionalId/{resource_name}` For acls on all resources that match a prefix:
             * `topicPrefixed/{resource_name}` `consumerGroupPrefixed/{resource_name}`
             * `transactionalIdPrefixed/{resource_name}` For acls on all resources of a given type
             * (i.e. the wildcard literal "*"): `allTopics` (represents `topic`) `allConsumerGroups`
             * (represents `consumerGroup`) `allTransactionalIds` (represents `transactionalId`)
             */
            public Create setAclId(java.lang.String aclId) {
              this.aclId = aclId;
              return this;
            }

            @Override
            public Create set(String parameterName, Object value) {
              return (Create) super.set(parameterName, value);
            }
          }
          /**
           * Deletes an acl.
           *
           * Create a request for the method "acls.delete".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the acl to delete. Structured like:
           *        `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure
           *        of `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of
           *        the acl. See `Acl.name` for details.
           * @return the request
           */
          public Delete delete(java.lang.String name) throws java.io.IOException {
            Delete result = new Delete(name);
            initialize(result);
            return result;
          }

          public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Empty> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");

            /**
             * Deletes an acl.
             *
             * Create a request for the method "acls.delete".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
             * <p> {@link
             * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the acl to delete. Structured like:
           *        `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure
           *        of `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of
           *        the acl. See `Acl.name` for details.
             * @since 1.13
             */
            protected Delete(java.lang.String name) {
              super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Empty.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
            }

            @Override
            public Delete set$Xgafv(java.lang.String $Xgafv) {
              return (Delete) super.set$Xgafv($Xgafv);
            }

            @Override
            public Delete setAccessToken(java.lang.String accessToken) {
              return (Delete) super.setAccessToken(accessToken);
            }

            @Override
            public Delete setAlt(java.lang.String alt) {
              return (Delete) super.setAlt(alt);
            }

            @Override
            public Delete setCallback(java.lang.String callback) {
              return (Delete) super.setCallback(callback);
            }

            @Override
            public Delete setFields(java.lang.String fields) {
              return (Delete) super.setFields(fields);
            }

            @Override
            public Delete setKey(java.lang.String key) {
              return (Delete) super.setKey(key);
            }

            @Override
            public Delete setOauthToken(java.lang.String oauthToken) {
              return (Delete) super.setOauthToken(oauthToken);
            }

            @Override
            public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Delete) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Delete setQuotaUser(java.lang.String quotaUser) {
              return (Delete) super.setQuotaUser(quotaUser);
            }

            @Override
            public Delete setUploadType(java.lang.String uploadType) {
              return (Delete) super.setUploadType(uploadType);
            }

            @Override
            public Delete setUploadProtocol(java.lang.String uploadProtocol) {
              return (Delete) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the acl to delete. Structured like:
             * `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. See `Acl.name` for details.
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the acl to delete. Structured like:
           `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure of
           `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of the acl. See
           `Acl.name` for details.
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the acl to delete. Structured like:
             * `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. See `Acl.name` for details.
             */
            public Delete setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Delete set(String parameterName, Object value) {
              return (Delete) super.set(parameterName, value);
            }
          }
          /**
           * Returns the properties of a single acl.
           *
           * Create a request for the method "acls.get".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Get#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the acl to return. Structured like:
           *        `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure
           *        of `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of
           *        the acl. See `Acl.name` for details.
           * @return the request
           */
          public Get get(java.lang.String name) throws java.io.IOException {
            Get result = new Get(name);
            initialize(result);
            return result;
          }

          public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Acl> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");

            /**
             * Returns the properties of a single acl.
             *
             * Create a request for the method "acls.get".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
             * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the acl to return. Structured like:
           *        `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure
           *        of `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of
           *        the acl. See `Acl.name` for details.
             * @since 1.13
             */
            protected Get(java.lang.String name) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Acl.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public Get set$Xgafv(java.lang.String $Xgafv) {
              return (Get) super.set$Xgafv($Xgafv);
            }

            @Override
            public Get setAccessToken(java.lang.String accessToken) {
              return (Get) super.setAccessToken(accessToken);
            }

            @Override
            public Get setAlt(java.lang.String alt) {
              return (Get) super.setAlt(alt);
            }

            @Override
            public Get setCallback(java.lang.String callback) {
              return (Get) super.setCallback(callback);
            }

            @Override
            public Get setFields(java.lang.String fields) {
              return (Get) super.setFields(fields);
            }

            @Override
            public Get setKey(java.lang.String key) {
              return (Get) super.setKey(key);
            }

            @Override
            public Get setOauthToken(java.lang.String oauthToken) {
              return (Get) super.setOauthToken(oauthToken);
            }

            @Override
            public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Get) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Get setQuotaUser(java.lang.String quotaUser) {
              return (Get) super.setQuotaUser(quotaUser);
            }

            @Override
            public Get setUploadType(java.lang.String uploadType) {
              return (Get) super.setUploadType(uploadType);
            }

            @Override
            public Get setUploadProtocol(java.lang.String uploadProtocol) {
              return (Get) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the acl to return. Structured like:
             * `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. See `Acl.name` for details.
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the acl to return. Structured like:
           `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure of
           `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of the acl. See
           `Acl.name` for details.
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the acl to return. Structured like:
             * `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. See `Acl.name` for details.
             */
            public Get setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Get set(String parameterName, Object value) {
              return (Get) super.set(parameterName, value);
            }
          }
          /**
           * Lists the acls in a given cluster.
           *
           * Create a request for the method "acls.list".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link List#execute()} method to invoke the remote operation.
           *
           * @param parent Required. The parent cluster whose acls are to be listed. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
           * @return the request
           */
          public List list(java.lang.String parent) throws java.io.IOException {
            List result = new List(parent);
            initialize(result);
            return result;
          }

          public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ListAclsResponse> {

            private static final String REST_PATH = "v1/{+parent}/acls";

            private final java.util.regex.Pattern PARENT_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");

            /**
             * Lists the acls in a given cluster.
             *
             * Create a request for the method "acls.list".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
             * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param parent Required. The parent cluster whose acls are to be listed. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
             * @since 1.13
             */
            protected List(java.lang.String parent) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ListAclsResponse.class);
              this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public List set$Xgafv(java.lang.String $Xgafv) {
              return (List) super.set$Xgafv($Xgafv);
            }

            @Override
            public List setAccessToken(java.lang.String accessToken) {
              return (List) super.setAccessToken(accessToken);
            }

            @Override
            public List setAlt(java.lang.String alt) {
              return (List) super.setAlt(alt);
            }

            @Override
            public List setCallback(java.lang.String callback) {
              return (List) super.setCallback(callback);
            }

            @Override
            public List setFields(java.lang.String fields) {
              return (List) super.setFields(fields);
            }

            @Override
            public List setKey(java.lang.String key) {
              return (List) super.setKey(key);
            }

            @Override
            public List setOauthToken(java.lang.String oauthToken) {
              return (List) super.setOauthToken(oauthToken);
            }

            @Override
            public List setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (List) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public List setQuotaUser(java.lang.String quotaUser) {
              return (List) super.setQuotaUser(quotaUser);
            }

            @Override
            public List setUploadType(java.lang.String uploadType) {
              return (List) super.setUploadType(uploadType);
            }

            @Override
            public List setUploadProtocol(java.lang.String uploadProtocol) {
              return (List) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The parent cluster whose acls are to be listed. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String parent;

            /** Required. The parent cluster whose acls are to be listed. Structured like
           `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public java.lang.String getParent() {
              return parent;
            }

            /**
             * Required. The parent cluster whose acls are to be listed. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public List setParent(java.lang.String parent) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
              this.parent = parent;
              return this;
            }

            /**
             * Optional. The maximum number of acls to return. The service may return fewer than
             * this value. If unset or zero, all acls for the parent is returned.
             */
            @com.google.api.client.util.Key
            private java.lang.Integer pageSize;

            /** Optional. The maximum number of acls to return. The service may return fewer than this value. If
           unset or zero, all acls for the parent is returned.
             */
            public java.lang.Integer getPageSize() {
              return pageSize;
            }

            /**
             * Optional. The maximum number of acls to return. The service may return fewer than
             * this value. If unset or zero, all acls for the parent is returned.
             */
            public List setPageSize(java.lang.Integer pageSize) {
              this.pageSize = pageSize;
              return this;
            }

            /**
             * Optional. A page token, received from a previous `ListAcls` call. Provide this to
             * retrieve the subsequent page. When paginating, all other parameters provided to
             * `ListAcls` must match the call that provided the page token.
             */
            @com.google.api.client.util.Key
            private java.lang.String pageToken;

            /** Optional. A page token, received from a previous `ListAcls` call. Provide this to retrieve the
           subsequent page. When paginating, all other parameters provided to `ListAcls` must match the call
           that provided the page token.
             */
            public java.lang.String getPageToken() {
              return pageToken;
            }

            /**
             * Optional. A page token, received from a previous `ListAcls` call. Provide this to
             * retrieve the subsequent page. When paginating, all other parameters provided to
             * `ListAcls` must match the call that provided the page token.
             */
            public List setPageToken(java.lang.String pageToken) {
              this.pageToken = pageToken;
              return this;
            }

            @Override
            public List set(String parameterName, Object value) {
              return (List) super.set(parameterName, value);
            }
          }
          /**
           * Updates the properties of a single acl.
           *
           * Create a request for the method "acls.patch".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Patch#execute()} method to invoke the remote operation.
           *
           * @param name Identifier. The name for the acl. Represents a single Resource Pattern. Structured like:
           *        projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id} The structure of
           *        `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of the
           *        acl. `acl_id` is structured like one of the following: For acls on the cluster: `cluster`
           *        For acls on a single resource within the cluster: `topic/{resource_name}`
           *        `consumerGroup/{resource_name}` `transactionalId/{resource_name}` For acls on all
           *        resources that match a prefix: `topicPrefixed/{resource_name}`
           *        `consumerGroupPrefixed/{resource_name}` `transactionalIdPrefixed/{resource_name}` For acls
           *        on all resources of a given type (i.e. the wildcard literal "*"): `allTopics` (represents
           *        `topic`) `allConsumerGroups` (represents `consumerGroup`) `allTransactionalIds`
           *        (represents `transactionalId`)
           * @param content the {@link com.google.api.services.managedkafka.v1.model.Acl}
           * @return the request
           */
          public Patch patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.Acl content) throws java.io.IOException {
            Patch result = new Patch(name, content);
            initialize(result);
            return result;
          }

          public class Patch extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Acl> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");

            /**
             * Updates the properties of a single acl.
             *
             * Create a request for the method "acls.patch".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Patch#execute()} method to invoke the remote operation.
             * <p> {@link
             * Patch#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Identifier. The name for the acl. Represents a single Resource Pattern. Structured like:
           *        projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id} The structure of
           *        `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of the
           *        acl. `acl_id` is structured like one of the following: For acls on the cluster: `cluster`
           *        For acls on a single resource within the cluster: `topic/{resource_name}`
           *        `consumerGroup/{resource_name}` `transactionalId/{resource_name}` For acls on all
           *        resources that match a prefix: `topicPrefixed/{resource_name}`
           *        `consumerGroupPrefixed/{resource_name}` `transactionalIdPrefixed/{resource_name}` For acls
           *        on all resources of a given type (i.e. the wildcard literal "*"): `allTopics` (represents
           *        `topic`) `allConsumerGroups` (represents `consumerGroup`) `allTransactionalIds`
           *        (represents `transactionalId`)
             * @param content the {@link com.google.api.services.managedkafka.v1.model.Acl}
             * @since 1.13
             */
            protected Patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.Acl content) {
              super(ManagedKafka.this, "PATCH", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Acl.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
            }

            @Override
            public Patch set$Xgafv(java.lang.String $Xgafv) {
              return (Patch) super.set$Xgafv($Xgafv);
            }

            @Override
            public Patch setAccessToken(java.lang.String accessToken) {
              return (Patch) super.setAccessToken(accessToken);
            }

            @Override
            public Patch setAlt(java.lang.String alt) {
              return (Patch) super.setAlt(alt);
            }

            @Override
            public Patch setCallback(java.lang.String callback) {
              return (Patch) super.setCallback(callback);
            }

            @Override
            public Patch setFields(java.lang.String fields) {
              return (Patch) super.setFields(fields);
            }

            @Override
            public Patch setKey(java.lang.String key) {
              return (Patch) super.setKey(key);
            }

            @Override
            public Patch setOauthToken(java.lang.String oauthToken) {
              return (Patch) super.setOauthToken(oauthToken);
            }

            @Override
            public Patch setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Patch) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Patch setQuotaUser(java.lang.String quotaUser) {
              return (Patch) super.setQuotaUser(quotaUser);
            }

            @Override
            public Patch setUploadType(java.lang.String uploadType) {
              return (Patch) super.setUploadType(uploadType);
            }

            @Override
            public Patch setUploadProtocol(java.lang.String uploadProtocol) {
              return (Patch) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Identifier. The name for the acl. Represents a single Resource Pattern. Structured
             * like: projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id} The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. `acl_id` is structured like one of the following: For acls
             * on the cluster: `cluster` For acls on a single resource within the cluster:
             * `topic/{resource_name}` `consumerGroup/{resource_name}`
             * `transactionalId/{resource_name}` For acls on all resources that match a prefix:
             * `topicPrefixed/{resource_name}` `consumerGroupPrefixed/{resource_name}`
             * `transactionalIdPrefixed/{resource_name}` For acls on all resources of a given type
             * (i.e. the wildcard literal "*"): `allTopics` (represents `topic`) `allConsumerGroups`
             * (represents `consumerGroup`) `allTransactionalIds` (represents `transactionalId`)
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Identifier. The name for the acl. Represents a single Resource Pattern. Structured like:
           projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id} The structure of `acl_id`
           defines the Resource Pattern (resource_type, resource_name, pattern_type) of the acl. `acl_id` is
           structured like one of the following: For acls on the cluster: `cluster` For acls on a single
           resource within the cluster: `topic/{resource_name}` `consumerGroup/{resource_name}`
           `transactionalId/{resource_name}` For acls on all resources that match a prefix:
           `topicPrefixed/{resource_name}` `consumerGroupPrefixed/{resource_name}`
           `transactionalIdPrefixed/{resource_name}` For acls on all resources of a given type (i.e. the
           wildcard literal "*"): `allTopics` (represents `topic`) `allConsumerGroups` (represents
           `consumerGroup`) `allTransactionalIds` (represents `transactionalId`)
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Identifier. The name for the acl. Represents a single Resource Pattern. Structured
             * like: projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id} The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. `acl_id` is structured like one of the following: For acls
             * on the cluster: `cluster` For acls on a single resource within the cluster:
             * `topic/{resource_name}` `consumerGroup/{resource_name}`
             * `transactionalId/{resource_name}` For acls on all resources that match a prefix:
             * `topicPrefixed/{resource_name}` `consumerGroupPrefixed/{resource_name}`
             * `transactionalIdPrefixed/{resource_name}` For acls on all resources of a given type
             * (i.e. the wildcard literal "*"): `allTopics` (represents `topic`) `allConsumerGroups`
             * (represents `consumerGroup`) `allTransactionalIds` (represents `transactionalId`)
             */
            public Patch setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
              this.name = name;
              return this;
            }

            /**
             * Optional. Field mask is used to specify the fields to be overwritten in the Acl
             * resource by the update. The fields specified in the update_mask are relative to the
             * resource, not the full request. A field will be overwritten if it is in the mask.
             */
            @com.google.api.client.util.Key
            private String updateMask;

            /** Optional. Field mask is used to specify the fields to be overwritten in the Acl resource by the
           update. The fields specified in the update_mask are relative to the resource, not the full request.
           A field will be overwritten if it is in the mask.
             */
            public String getUpdateMask() {
              return updateMask;
            }

            /**
             * Optional. Field mask is used to specify the fields to be overwritten in the Acl
             * resource by the update. The fields specified in the update_mask are relative to the
             * resource, not the full request. A field will be overwritten if it is in the mask.
             */
            public Patch setUpdateMask(String updateMask) {
              this.updateMask = updateMask;
              return this;
            }

            @Override
            public Patch set(String parameterName, Object value) {
              return (Patch) super.set(parameterName, value);
            }
          }
          /**
           * Incremental update: Removes an acl entry from an acl. Deletes the acl if its acl entries become
           * empty (i.e. if the removed entry was the last one in the acl).
           *
           * Create a request for the method "acls.removeAclEntry".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link RemoveAclEntry#execute()} method to invoke the remote operation.
           *
           * @param acl Required. The name of the acl to remove the acl entry from. Structured like:
           *        `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure
           *        of `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of
           *        the acl. See `Acl.name` for details.
           * @param content the {@link com.google.api.services.managedkafka.v1.model.AclEntry}
           * @return the request
           */
          public RemoveAclEntry removeAclEntry(java.lang.String acl, com.google.api.services.managedkafka.v1.model.AclEntry content) throws java.io.IOException {
            RemoveAclEntry result = new RemoveAclEntry(acl, content);
            initialize(result);
            return result;
          }

          public class RemoveAclEntry extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.RemoveAclEntryResponse> {

            private static final String REST_PATH = "v1/{+acl}:removeAclEntry";

            private final java.util.regex.Pattern ACL_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");

            /**
             * Incremental update: Removes an acl entry from an acl. Deletes the acl if its acl entries become
             * empty (i.e. if the removed entry was the last one in the acl).
             *
             * Create a request for the method "acls.removeAclEntry".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link RemoveAclEntry#execute()} method to invoke the remote
             * operation. <p> {@link RemoveAclEntry#initialize(com.google.api.client.googleapis.services.Abstr
             * actGoogleClientRequest)} must be called to initialize this instance immediately after invoking
             * the constructor. </p>
             *
             * @param acl Required. The name of the acl to remove the acl entry from. Structured like:
           *        `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure
           *        of `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of
           *        the acl. See `Acl.name` for details.
             * @param content the {@link com.google.api.services.managedkafka.v1.model.AclEntry}
             * @since 1.13
             */
            protected RemoveAclEntry(java.lang.String acl, com.google.api.services.managedkafka.v1.model.AclEntry content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.RemoveAclEntryResponse.class);
              this.acl = com.google.api.client.util.Preconditions.checkNotNull(acl, "Required parameter acl must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(ACL_PATTERN.matcher(acl).matches(),
                    "Parameter acl must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
            }

            @Override
            public RemoveAclEntry set$Xgafv(java.lang.String $Xgafv) {
              return (RemoveAclEntry) super.set$Xgafv($Xgafv);
            }

            @Override
            public RemoveAclEntry setAccessToken(java.lang.String accessToken) {
              return (RemoveAclEntry) super.setAccessToken(accessToken);
            }

            @Override
            public RemoveAclEntry setAlt(java.lang.String alt) {
              return (RemoveAclEntry) super.setAlt(alt);
            }

            @Override
            public RemoveAclEntry setCallback(java.lang.String callback) {
              return (RemoveAclEntry) super.setCallback(callback);
            }

            @Override
            public RemoveAclEntry setFields(java.lang.String fields) {
              return (RemoveAclEntry) super.setFields(fields);
            }

            @Override
            public RemoveAclEntry setKey(java.lang.String key) {
              return (RemoveAclEntry) super.setKey(key);
            }

            @Override
            public RemoveAclEntry setOauthToken(java.lang.String oauthToken) {
              return (RemoveAclEntry) super.setOauthToken(oauthToken);
            }

            @Override
            public RemoveAclEntry setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (RemoveAclEntry) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public RemoveAclEntry setQuotaUser(java.lang.String quotaUser) {
              return (RemoveAclEntry) super.setQuotaUser(quotaUser);
            }

            @Override
            public RemoveAclEntry setUploadType(java.lang.String uploadType) {
              return (RemoveAclEntry) super.setUploadType(uploadType);
            }

            @Override
            public RemoveAclEntry setUploadProtocol(java.lang.String uploadProtocol) {
              return (RemoveAclEntry) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the acl to remove the acl entry from. Structured like:
             * `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. See `Acl.name` for details.
             */
            @com.google.api.client.util.Key
            private java.lang.String acl;

            /** Required. The name of the acl to remove the acl entry from. Structured like:
           `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The structure of
           `acl_id` defines the Resource Pattern (resource_type, resource_name, pattern_type) of the acl. See
           `Acl.name` for details.
             */
            public java.lang.String getAcl() {
              return acl;
            }

            /**
             * Required. The name of the acl to remove the acl entry from. Structured like:
             * `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`. The
             * structure of `acl_id` defines the Resource Pattern (resource_type, resource_name,
             * pattern_type) of the acl. See `Acl.name` for details.
             */
            public RemoveAclEntry setAcl(java.lang.String acl) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(ACL_PATTERN.matcher(acl).matches(),
                    "Parameter acl must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/acls/.*$");
              }
              this.acl = acl;
              return this;
            }

            @Override
            public RemoveAclEntry set(String parameterName, Object value) {
              return (RemoveAclEntry) super.set(parameterName, value);
            }
          }

        }
        /**
         * An accessor for creating requests from the ConsumerGroups collection.
         *
         * <p>The typical use is:</p>
         * <pre>
         *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
         *   {@code ManagedKafka.ConsumerGroups.List request = managedkafka.consumerGroups().list(parameters ...)}
         * </pre>
         *
         * @return the resource collection
         */
        public ConsumerGroups consumerGroups() {
          return new ConsumerGroups();
        }

        /**
         * The "consumerGroups" collection of methods.
         */
        public class ConsumerGroups {

          /**
           * Deletes a single consumer group.
           *
           * Create a request for the method "consumerGroups.delete".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the consumer group to delete.
           *        `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}
           *        `.
           * @return the request
           */
          public Delete delete(java.lang.String name) throws java.io.IOException {
            Delete result = new Delete(name);
            initialize(result);
            return result;
          }

          public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Empty> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/consumerGroups/.*$");

            /**
             * Deletes a single consumer group.
             *
             * Create a request for the method "consumerGroups.delete".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
             * <p> {@link
             * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the consumer group to delete.
           *        `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}
           *        `.
             * @since 1.13
             */
            protected Delete(java.lang.String name) {
              super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Empty.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/consumerGroups/.*$");
              }
            }

            @Override
            public Delete set$Xgafv(java.lang.String $Xgafv) {
              return (Delete) super.set$Xgafv($Xgafv);
            }

            @Override
            public Delete setAccessToken(java.lang.String accessToken) {
              return (Delete) super.setAccessToken(accessToken);
            }

            @Override
            public Delete setAlt(java.lang.String alt) {
              return (Delete) super.setAlt(alt);
            }

            @Override
            public Delete setCallback(java.lang.String callback) {
              return (Delete) super.setCallback(callback);
            }

            @Override
            public Delete setFields(java.lang.String fields) {
              return (Delete) super.setFields(fields);
            }

            @Override
            public Delete setKey(java.lang.String key) {
              return (Delete) super.setKey(key);
            }

            @Override
            public Delete setOauthToken(java.lang.String oauthToken) {
              return (Delete) super.setOauthToken(oauthToken);
            }

            @Override
            public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Delete) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Delete setQuotaUser(java.lang.String quotaUser) {
              return (Delete) super.setQuotaUser(quotaUser);
            }

            @Override
            public Delete setUploadType(java.lang.String uploadType) {
              return (Delete) super.setUploadType(uploadType);
            }

            @Override
            public Delete setUploadProtocol(java.lang.String uploadProtocol) {
              return (Delete) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the consumer group to delete. `projects/{project}/locations/{lo
             * cation}/clusters/{cluster}/consumerGroups/{consumerGroup}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the consumer group to delete.
           `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}`.
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the consumer group to delete. `projects/{project}/locations/{lo
             * cation}/clusters/{cluster}/consumerGroups/{consumerGroup}`.
             */
            public Delete setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/consumerGroups/.*$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Delete set(String parameterName, Object value) {
              return (Delete) super.set(parameterName, value);
            }
          }
          /**
           * Returns the properties of a single consumer group.
           *
           * Create a request for the method "consumerGroups.get".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Get#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the consumer group whose configuration to return.
           *        `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}
           *        `.
           * @return the request
           */
          public Get get(java.lang.String name) throws java.io.IOException {
            Get result = new Get(name);
            initialize(result);
            return result;
          }

          public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ConsumerGroup> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/consumerGroups/.*$");

            /**
             * Returns the properties of a single consumer group.
             *
             * Create a request for the method "consumerGroups.get".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
             * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the consumer group whose configuration to return.
           *        `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}
           *        `.
             * @since 1.13
             */
            protected Get(java.lang.String name) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ConsumerGroup.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/consumerGroups/.*$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public Get set$Xgafv(java.lang.String $Xgafv) {
              return (Get) super.set$Xgafv($Xgafv);
            }

            @Override
            public Get setAccessToken(java.lang.String accessToken) {
              return (Get) super.setAccessToken(accessToken);
            }

            @Override
            public Get setAlt(java.lang.String alt) {
              return (Get) super.setAlt(alt);
            }

            @Override
            public Get setCallback(java.lang.String callback) {
              return (Get) super.setCallback(callback);
            }

            @Override
            public Get setFields(java.lang.String fields) {
              return (Get) super.setFields(fields);
            }

            @Override
            public Get setKey(java.lang.String key) {
              return (Get) super.setKey(key);
            }

            @Override
            public Get setOauthToken(java.lang.String oauthToken) {
              return (Get) super.setOauthToken(oauthToken);
            }

            @Override
            public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Get) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Get setQuotaUser(java.lang.String quotaUser) {
              return (Get) super.setQuotaUser(quotaUser);
            }

            @Override
            public Get setUploadType(java.lang.String uploadType) {
              return (Get) super.setUploadType(uploadType);
            }

            @Override
            public Get setUploadProtocol(java.lang.String uploadProtocol) {
              return (Get) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the consumer group whose configuration to return. `projects/{pr
             * oject}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the consumer group whose configuration to return.
           `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}`.
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the consumer group whose configuration to return. `projects/{pr
             * oject}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}`.
             */
            public Get setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/consumerGroups/.*$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Get set(String parameterName, Object value) {
              return (Get) super.set(parameterName, value);
            }
          }
          /**
           * Lists the consumer groups in a given cluster.
           *
           * Create a request for the method "consumerGroups.list".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link List#execute()} method to invoke the remote operation.
           *
           * @param parent Required. The parent cluster whose consumer groups are to be listed. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
           * @return the request
           */
          public List list(java.lang.String parent) throws java.io.IOException {
            List result = new List(parent);
            initialize(result);
            return result;
          }

          public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ListConsumerGroupsResponse> {

            private static final String REST_PATH = "v1/{+parent}/consumerGroups";

            private final java.util.regex.Pattern PARENT_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");

            /**
             * Lists the consumer groups in a given cluster.
             *
             * Create a request for the method "consumerGroups.list".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
             * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param parent Required. The parent cluster whose consumer groups are to be listed. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
             * @since 1.13
             */
            protected List(java.lang.String parent) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ListConsumerGroupsResponse.class);
              this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public List set$Xgafv(java.lang.String $Xgafv) {
              return (List) super.set$Xgafv($Xgafv);
            }

            @Override
            public List setAccessToken(java.lang.String accessToken) {
              return (List) super.setAccessToken(accessToken);
            }

            @Override
            public List setAlt(java.lang.String alt) {
              return (List) super.setAlt(alt);
            }

            @Override
            public List setCallback(java.lang.String callback) {
              return (List) super.setCallback(callback);
            }

            @Override
            public List setFields(java.lang.String fields) {
              return (List) super.setFields(fields);
            }

            @Override
            public List setKey(java.lang.String key) {
              return (List) super.setKey(key);
            }

            @Override
            public List setOauthToken(java.lang.String oauthToken) {
              return (List) super.setOauthToken(oauthToken);
            }

            @Override
            public List setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (List) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public List setQuotaUser(java.lang.String quotaUser) {
              return (List) super.setQuotaUser(quotaUser);
            }

            @Override
            public List setUploadType(java.lang.String uploadType) {
              return (List) super.setUploadType(uploadType);
            }

            @Override
            public List setUploadProtocol(java.lang.String uploadProtocol) {
              return (List) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The parent cluster whose consumer groups are to be listed. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String parent;

            /** Required. The parent cluster whose consumer groups are to be listed. Structured like
           `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public java.lang.String getParent() {
              return parent;
            }

            /**
             * Required. The parent cluster whose consumer groups are to be listed. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public List setParent(java.lang.String parent) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
              this.parent = parent;
              return this;
            }

            /**
             * Optional. The maximum number of consumer groups to return. The service may return
             * fewer than this value. If unset or zero, all consumer groups for the parent is
             * returned.
             */
            @com.google.api.client.util.Key
            private java.lang.Integer pageSize;

            /** Optional. The maximum number of consumer groups to return. The service may return fewer than this
           value. If unset or zero, all consumer groups for the parent is returned.
             */
            public java.lang.Integer getPageSize() {
              return pageSize;
            }

            /**
             * Optional. The maximum number of consumer groups to return. The service may return
             * fewer than this value. If unset or zero, all consumer groups for the parent is
             * returned.
             */
            public List setPageSize(java.lang.Integer pageSize) {
              this.pageSize = pageSize;
              return this;
            }

            /**
             * Optional. A page token, received from a previous `ListConsumerGroups` call. Provide
             * this to retrieve the subsequent page. When paginating, all other parameters provided
             * to `ListConsumerGroups` must match the call that provided the page token.
             */
            @com.google.api.client.util.Key
            private java.lang.String pageToken;

            /** Optional. A page token, received from a previous `ListConsumerGroups` call. Provide this to
           retrieve the subsequent page. When paginating, all other parameters provided to
           `ListConsumerGroups` must match the call that provided the page token.
             */
            public java.lang.String getPageToken() {
              return pageToken;
            }

            /**
             * Optional. A page token, received from a previous `ListConsumerGroups` call. Provide
             * this to retrieve the subsequent page. When paginating, all other parameters provided
             * to `ListConsumerGroups` must match the call that provided the page token.
             */
            public List setPageToken(java.lang.String pageToken) {
              this.pageToken = pageToken;
              return this;
            }

            @Override
            public List set(String parameterName, Object value) {
              return (List) super.set(parameterName, value);
            }
          }
          /**
           * Updates the properties of a single consumer group.
           *
           * Create a request for the method "consumerGroups.patch".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Patch#execute()} method to invoke the remote operation.
           *
           * @param name Identifier. The name of the consumer group. The `consumer_group` segment is used when connecting
           *        directly to the cluster. Structured like:
           *        projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumer_group}
           * @param content the {@link com.google.api.services.managedkafka.v1.model.ConsumerGroup}
           * @return the request
           */
          public Patch patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.ConsumerGroup content) throws java.io.IOException {
            Patch result = new Patch(name, content);
            initialize(result);
            return result;
          }

          public class Patch extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ConsumerGroup> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/consumerGroups/.*$");

            /**
             * Updates the properties of a single consumer group.
             *
             * Create a request for the method "consumerGroups.patch".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Patch#execute()} method to invoke the remote operation.
             * <p> {@link
             * Patch#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Identifier. The name of the consumer group. The `consumer_group` segment is used when connecting
           *        directly to the cluster. Structured like:
           *        projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumer_group}
             * @param content the {@link com.google.api.services.managedkafka.v1.model.ConsumerGroup}
             * @since 1.13
             */
            protected Patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.ConsumerGroup content) {
              super(ManagedKafka.this, "PATCH", REST_PATH, content, com.google.api.services.managedkafka.v1.model.ConsumerGroup.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/consumerGroups/.*$");
              }
            }

            @Override
            public Patch set$Xgafv(java.lang.String $Xgafv) {
              return (Patch) super.set$Xgafv($Xgafv);
            }

            @Override
            public Patch setAccessToken(java.lang.String accessToken) {
              return (Patch) super.setAccessToken(accessToken);
            }

            @Override
            public Patch setAlt(java.lang.String alt) {
              return (Patch) super.setAlt(alt);
            }

            @Override
            public Patch setCallback(java.lang.String callback) {
              return (Patch) super.setCallback(callback);
            }

            @Override
            public Patch setFields(java.lang.String fields) {
              return (Patch) super.setFields(fields);
            }

            @Override
            public Patch setKey(java.lang.String key) {
              return (Patch) super.setKey(key);
            }

            @Override
            public Patch setOauthToken(java.lang.String oauthToken) {
              return (Patch) super.setOauthToken(oauthToken);
            }

            @Override
            public Patch setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Patch) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Patch setQuotaUser(java.lang.String quotaUser) {
              return (Patch) super.setQuotaUser(quotaUser);
            }

            @Override
            public Patch setUploadType(java.lang.String uploadType) {
              return (Patch) super.setUploadType(uploadType);
            }

            @Override
            public Patch setUploadProtocol(java.lang.String uploadProtocol) {
              return (Patch) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Identifier. The name of the consumer group. The `consumer_group` segment is used when
             * connecting directly to the cluster. Structured like: projects/{project}/locations/{lo
             * cation}/clusters/{cluster}/consumerGroups/{consumer_group}
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Identifier. The name of the consumer group. The `consumer_group` segment is used when connecting
           directly to the cluster. Structured like:
           projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumer_group}
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Identifier. The name of the consumer group. The `consumer_group` segment is used when
             * connecting directly to the cluster. Structured like: projects/{project}/locations/{lo
             * cation}/clusters/{cluster}/consumerGroups/{consumer_group}
             */
            public Patch setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/consumerGroups/.*$");
              }
              this.name = name;
              return this;
            }

            /**
             * Required. Field mask is used to specify the fields to be overwritten in the
             * ConsumerGroup resource by the update. The fields specified in the update_mask are
             * relative to the resource, not the full request. A field will be overwritten if it is
             * in the mask. The mask is required and a value of * will update all fields.
             */
            @com.google.api.client.util.Key
            private String updateMask;

            /** Required. Field mask is used to specify the fields to be overwritten in the ConsumerGroup resource
           by the update. The fields specified in the update_mask are relative to the resource, not the full
           request. A field will be overwritten if it is in the mask. The mask is required and a value of *
           will update all fields.
             */
            public String getUpdateMask() {
              return updateMask;
            }

            /**
             * Required. Field mask is used to specify the fields to be overwritten in the
             * ConsumerGroup resource by the update. The fields specified in the update_mask are
             * relative to the resource, not the full request. A field will be overwritten if it is
             * in the mask. The mask is required and a value of * will update all fields.
             */
            public Patch setUpdateMask(String updateMask) {
              this.updateMask = updateMask;
              return this;
            }

            @Override
            public Patch set(String parameterName, Object value) {
              return (Patch) super.set(parameterName, value);
            }
          }

        }
        /**
         * An accessor for creating requests from the Topics collection.
         *
         * <p>The typical use is:</p>
         * <pre>
         *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
         *   {@code ManagedKafka.Topics.List request = managedkafka.topics().list(parameters ...)}
         * </pre>
         *
         * @return the resource collection
         */
        public Topics topics() {
          return new Topics();
        }

        /**
         * The "topics" collection of methods.
         */
        public class Topics {

          /**
           * Creates a new topic in a given project and location.
           *
           * Create a request for the method "topics.create".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Create#execute()} method to invoke the remote operation.
           *
           * @param parent Required. The parent cluster in which to create the topic. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
           * @param content the {@link com.google.api.services.managedkafka.v1.model.Topic}
           * @return the request
           */
          public Create create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.Topic content) throws java.io.IOException {
            Create result = new Create(parent, content);
            initialize(result);
            return result;
          }

          public class Create extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Topic> {

            private static final String REST_PATH = "v1/{+parent}/topics";

            private final java.util.regex.Pattern PARENT_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");

            /**
             * Creates a new topic in a given project and location.
             *
             * Create a request for the method "topics.create".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
             * <p> {@link
             * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param parent Required. The parent cluster in which to create the topic. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
             * @param content the {@link com.google.api.services.managedkafka.v1.model.Topic}
             * @since 1.13
             */
            protected Create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.Topic content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Topic.class);
              this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
            }

            @Override
            public Create set$Xgafv(java.lang.String $Xgafv) {
              return (Create) super.set$Xgafv($Xgafv);
            }

            @Override
            public Create setAccessToken(java.lang.String accessToken) {
              return (Create) super.setAccessToken(accessToken);
            }

            @Override
            public Create setAlt(java.lang.String alt) {
              return (Create) super.setAlt(alt);
            }

            @Override
            public Create setCallback(java.lang.String callback) {
              return (Create) super.setCallback(callback);
            }

            @Override
            public Create setFields(java.lang.String fields) {
              return (Create) super.setFields(fields);
            }

            @Override
            public Create setKey(java.lang.String key) {
              return (Create) super.setKey(key);
            }

            @Override
            public Create setOauthToken(java.lang.String oauthToken) {
              return (Create) super.setOauthToken(oauthToken);
            }

            @Override
            public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Create) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Create setQuotaUser(java.lang.String quotaUser) {
              return (Create) super.setQuotaUser(quotaUser);
            }

            @Override
            public Create setUploadType(java.lang.String uploadType) {
              return (Create) super.setUploadType(uploadType);
            }

            @Override
            public Create setUploadProtocol(java.lang.String uploadProtocol) {
              return (Create) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The parent cluster in which to create the topic. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String parent;

            /** Required. The parent cluster in which to create the topic. Structured like
           `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public java.lang.String getParent() {
              return parent;
            }

            /**
             * Required. The parent cluster in which to create the topic. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public Create setParent(java.lang.String parent) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
              this.parent = parent;
              return this;
            }

            /**
             * Required. The ID to use for the topic, which will become the final component of the
             * topic's name. This value is structured like: `my-topic-name`.
             */
            @com.google.api.client.util.Key
            private java.lang.String topicId;

            /** Required. The ID to use for the topic, which will become the final component of the topic's name.
           This value is structured like: `my-topic-name`.
             */
            public java.lang.String getTopicId() {
              return topicId;
            }

            /**
             * Required. The ID to use for the topic, which will become the final component of the
             * topic's name. This value is structured like: `my-topic-name`.
             */
            public Create setTopicId(java.lang.String topicId) {
              this.topicId = topicId;
              return this;
            }

            @Override
            public Create set(String parameterName, Object value) {
              return (Create) super.set(parameterName, value);
            }
          }
          /**
           * Deletes a single topic.
           *
           * Create a request for the method "topics.delete".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the topic to delete.
           *        `projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}`.
           * @return the request
           */
          public Delete delete(java.lang.String name) throws java.io.IOException {
            Delete result = new Delete(name);
            initialize(result);
            return result;
          }

          public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Empty> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/topics/[^/]+$");

            /**
             * Deletes a single topic.
             *
             * Create a request for the method "topics.delete".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
             * <p> {@link
             * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the topic to delete.
           *        `projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}`.
             * @since 1.13
             */
            protected Delete(java.lang.String name) {
              super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Empty.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/topics/[^/]+$");
              }
            }

            @Override
            public Delete set$Xgafv(java.lang.String $Xgafv) {
              return (Delete) super.set$Xgafv($Xgafv);
            }

            @Override
            public Delete setAccessToken(java.lang.String accessToken) {
              return (Delete) super.setAccessToken(accessToken);
            }

            @Override
            public Delete setAlt(java.lang.String alt) {
              return (Delete) super.setAlt(alt);
            }

            @Override
            public Delete setCallback(java.lang.String callback) {
              return (Delete) super.setCallback(callback);
            }

            @Override
            public Delete setFields(java.lang.String fields) {
              return (Delete) super.setFields(fields);
            }

            @Override
            public Delete setKey(java.lang.String key) {
              return (Delete) super.setKey(key);
            }

            @Override
            public Delete setOauthToken(java.lang.String oauthToken) {
              return (Delete) super.setOauthToken(oauthToken);
            }

            @Override
            public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Delete) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Delete setQuotaUser(java.lang.String quotaUser) {
              return (Delete) super.setQuotaUser(quotaUser);
            }

            @Override
            public Delete setUploadType(java.lang.String uploadType) {
              return (Delete) super.setUploadType(uploadType);
            }

            @Override
            public Delete setUploadProtocol(java.lang.String uploadProtocol) {
              return (Delete) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the topic to delete.
             * `projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the topic to delete.
           `projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}`.
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the topic to delete.
             * `projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}`.
             */
            public Delete setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/topics/[^/]+$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Delete set(String parameterName, Object value) {
              return (Delete) super.set(parameterName, value);
            }
          }
          /**
           * Returns the properties of a single topic.
           *
           * Create a request for the method "topics.get".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Get#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the topic whose configuration to return. Structured like:
           *        projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}.
           * @return the request
           */
          public Get get(java.lang.String name) throws java.io.IOException {
            Get result = new Get(name);
            initialize(result);
            return result;
          }

          public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Topic> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/topics/[^/]+$");

            /**
             * Returns the properties of a single topic.
             *
             * Create a request for the method "topics.get".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
             * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the topic whose configuration to return. Structured like:
           *        projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}.
             * @since 1.13
             */
            protected Get(java.lang.String name) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Topic.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/topics/[^/]+$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public Get set$Xgafv(java.lang.String $Xgafv) {
              return (Get) super.set$Xgafv($Xgafv);
            }

            @Override
            public Get setAccessToken(java.lang.String accessToken) {
              return (Get) super.setAccessToken(accessToken);
            }

            @Override
            public Get setAlt(java.lang.String alt) {
              return (Get) super.setAlt(alt);
            }

            @Override
            public Get setCallback(java.lang.String callback) {
              return (Get) super.setCallback(callback);
            }

            @Override
            public Get setFields(java.lang.String fields) {
              return (Get) super.setFields(fields);
            }

            @Override
            public Get setKey(java.lang.String key) {
              return (Get) super.setKey(key);
            }

            @Override
            public Get setOauthToken(java.lang.String oauthToken) {
              return (Get) super.setOauthToken(oauthToken);
            }

            @Override
            public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Get) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Get setQuotaUser(java.lang.String quotaUser) {
              return (Get) super.setQuotaUser(quotaUser);
            }

            @Override
            public Get setUploadType(java.lang.String uploadType) {
              return (Get) super.setUploadType(uploadType);
            }

            @Override
            public Get setUploadProtocol(java.lang.String uploadProtocol) {
              return (Get) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the topic whose configuration to return. Structured like:
             * projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}.
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the topic whose configuration to return. Structured like:
           projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}.
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the topic whose configuration to return. Structured like:
             * projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}.
             */
            public Get setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/topics/[^/]+$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Get set(String parameterName, Object value) {
              return (Get) super.set(parameterName, value);
            }
          }
          /**
           * Lists the topics in a given cluster.
           *
           * Create a request for the method "topics.list".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link List#execute()} method to invoke the remote operation.
           *
           * @param parent Required. The parent cluster whose topics are to be listed. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
           * @return the request
           */
          public List list(java.lang.String parent) throws java.io.IOException {
            List result = new List(parent);
            initialize(result);
            return result;
          }

          public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ListTopicsResponse> {

            private static final String REST_PATH = "v1/{+parent}/topics";

            private final java.util.regex.Pattern PARENT_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");

            /**
             * Lists the topics in a given cluster.
             *
             * Create a request for the method "topics.list".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
             * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param parent Required. The parent cluster whose topics are to be listed. Structured like
           *        `projects/{project}/locations/{location}/clusters/{cluster}`.
             * @since 1.13
             */
            protected List(java.lang.String parent) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ListTopicsResponse.class);
              this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public List set$Xgafv(java.lang.String $Xgafv) {
              return (List) super.set$Xgafv($Xgafv);
            }

            @Override
            public List setAccessToken(java.lang.String accessToken) {
              return (List) super.setAccessToken(accessToken);
            }

            @Override
            public List setAlt(java.lang.String alt) {
              return (List) super.setAlt(alt);
            }

            @Override
            public List setCallback(java.lang.String callback) {
              return (List) super.setCallback(callback);
            }

            @Override
            public List setFields(java.lang.String fields) {
              return (List) super.setFields(fields);
            }

            @Override
            public List setKey(java.lang.String key) {
              return (List) super.setKey(key);
            }

            @Override
            public List setOauthToken(java.lang.String oauthToken) {
              return (List) super.setOauthToken(oauthToken);
            }

            @Override
            public List setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (List) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public List setQuotaUser(java.lang.String quotaUser) {
              return (List) super.setQuotaUser(quotaUser);
            }

            @Override
            public List setUploadType(java.lang.String uploadType) {
              return (List) super.setUploadType(uploadType);
            }

            @Override
            public List setUploadProtocol(java.lang.String uploadProtocol) {
              return (List) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The parent cluster whose topics are to be listed. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String parent;

            /** Required. The parent cluster whose topics are to be listed. Structured like
           `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public java.lang.String getParent() {
              return parent;
            }

            /**
             * Required. The parent cluster whose topics are to be listed. Structured like
             * `projects/{project}/locations/{location}/clusters/{cluster}`.
             */
            public List setParent(java.lang.String parent) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+$");
              }
              this.parent = parent;
              return this;
            }

            /**
             * Optional. The maximum number of topics to return. The service may return fewer than
             * this value. If unset or zero, all topics for the parent is returned.
             */
            @com.google.api.client.util.Key
            private java.lang.Integer pageSize;

            /** Optional. The maximum number of topics to return. The service may return fewer than this value. If
           unset or zero, all topics for the parent is returned.
             */
            public java.lang.Integer getPageSize() {
              return pageSize;
            }

            /**
             * Optional. The maximum number of topics to return. The service may return fewer than
             * this value. If unset or zero, all topics for the parent is returned.
             */
            public List setPageSize(java.lang.Integer pageSize) {
              this.pageSize = pageSize;
              return this;
            }

            /**
             * Optional. A page token, received from a previous `ListTopics` call. Provide this to
             * retrieve the subsequent page. When paginating, all other parameters provided to
             * `ListTopics` must match the call that provided the page token.
             */
            @com.google.api.client.util.Key
            private java.lang.String pageToken;

            /** Optional. A page token, received from a previous `ListTopics` call. Provide this to retrieve the
           subsequent page. When paginating, all other parameters provided to `ListTopics` must match the call
           that provided the page token.
             */
            public java.lang.String getPageToken() {
              return pageToken;
            }

            /**
             * Optional. A page token, received from a previous `ListTopics` call. Provide this to
             * retrieve the subsequent page. When paginating, all other parameters provided to
             * `ListTopics` must match the call that provided the page token.
             */
            public List setPageToken(java.lang.String pageToken) {
              this.pageToken = pageToken;
              return this;
            }

            @Override
            public List set(String parameterName, Object value) {
              return (List) super.set(parameterName, value);
            }
          }
          /**
           * Updates the properties of a single topic.
           *
           * Create a request for the method "topics.patch".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Patch#execute()} method to invoke the remote operation.
           *
           * @param name Identifier. The name of the topic. The `topic` segment is used when connecting directly to the
           *        cluster. Structured like:
           *        projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
           * @param content the {@link com.google.api.services.managedkafka.v1.model.Topic}
           * @return the request
           */
          public Patch patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.Topic content) throws java.io.IOException {
            Patch result = new Patch(name, content);
            initialize(result);
            return result;
          }

          public class Patch extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Topic> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/clusters/[^/]+/topics/[^/]+$");

            /**
             * Updates the properties of a single topic.
             *
             * Create a request for the method "topics.patch".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Patch#execute()} method to invoke the remote operation.
             * <p> {@link
             * Patch#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Identifier. The name of the topic. The `topic` segment is used when connecting directly to the
           *        cluster. Structured like:
           *        projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
             * @param content the {@link com.google.api.services.managedkafka.v1.model.Topic}
             * @since 1.13
             */
            protected Patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.Topic content) {
              super(ManagedKafka.this, "PATCH", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Topic.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/topics/[^/]+$");
              }
            }

            @Override
            public Patch set$Xgafv(java.lang.String $Xgafv) {
              return (Patch) super.set$Xgafv($Xgafv);
            }

            @Override
            public Patch setAccessToken(java.lang.String accessToken) {
              return (Patch) super.setAccessToken(accessToken);
            }

            @Override
            public Patch setAlt(java.lang.String alt) {
              return (Patch) super.setAlt(alt);
            }

            @Override
            public Patch setCallback(java.lang.String callback) {
              return (Patch) super.setCallback(callback);
            }

            @Override
            public Patch setFields(java.lang.String fields) {
              return (Patch) super.setFields(fields);
            }

            @Override
            public Patch setKey(java.lang.String key) {
              return (Patch) super.setKey(key);
            }

            @Override
            public Patch setOauthToken(java.lang.String oauthToken) {
              return (Patch) super.setOauthToken(oauthToken);
            }

            @Override
            public Patch setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Patch) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Patch setQuotaUser(java.lang.String quotaUser) {
              return (Patch) super.setQuotaUser(quotaUser);
            }

            @Override
            public Patch setUploadType(java.lang.String uploadType) {
              return (Patch) super.setUploadType(uploadType);
            }

            @Override
            public Patch setUploadProtocol(java.lang.String uploadProtocol) {
              return (Patch) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Identifier. The name of the topic. The `topic` segment is used when connecting
             * directly to the cluster. Structured like:
             * projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Identifier. The name of the topic. The `topic` segment is used when connecting directly to the
           cluster. Structured like: projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Identifier. The name of the topic. The `topic` segment is used when connecting
             * directly to the cluster. Structured like:
             * projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
             */
            public Patch setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/clusters/[^/]+/topics/[^/]+$");
              }
              this.name = name;
              return this;
            }

            /**
             * Required. Field mask is used to specify the fields to be overwritten in the Topic
             * resource by the update. The fields specified in the update_mask are relative to the
             * resource, not the full request. A field will be overwritten if it is in the mask. The
             * mask is required and a value of * will update all fields.
             */
            @com.google.api.client.util.Key
            private String updateMask;

            /** Required. Field mask is used to specify the fields to be overwritten in the Topic resource by the
           update. The fields specified in the update_mask are relative to the resource, not the full request.
           A field will be overwritten if it is in the mask. The mask is required and a value of * will update
           all fields.
             */
            public String getUpdateMask() {
              return updateMask;
            }

            /**
             * Required. Field mask is used to specify the fields to be overwritten in the Topic
             * resource by the update. The fields specified in the update_mask are relative to the
             * resource, not the full request. A field will be overwritten if it is in the mask. The
             * mask is required and a value of * will update all fields.
             */
            public Patch setUpdateMask(String updateMask) {
              this.updateMask = updateMask;
              return this;
            }

            @Override
            public Patch set(String parameterName, Object value) {
              return (Patch) super.set(parameterName, value);
            }
          }

        }
      }
      /**
       * An accessor for creating requests from the ConnectClusters collection.
       *
       * <p>The typical use is:</p>
       * <pre>
       *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
       *   {@code ManagedKafka.ConnectClusters.List request = managedkafka.connectClusters().list(parameters ...)}
       * </pre>
       *
       * @return the resource collection
       */
      public ConnectClusters connectClusters() {
        return new ConnectClusters();
      }

      /**
       * The "connectClusters" collection of methods.
       */
      public class ConnectClusters {

        /**
         * Creates a new Kafka Connect cluster in a given project and location.
         *
         * Create a request for the method "connectClusters.create".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Create#execute()} method to invoke the remote operation.
         *
         * @param parent Required. The parent project/location in which to create the Kafka Connect cluster. Structured like
         *        `projects/{project}/locations/{location}/`.
         * @param content the {@link com.google.api.services.managedkafka.v1.model.ConnectCluster}
         * @return the request
         */
        public Create create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.ConnectCluster content) throws java.io.IOException {
          Create result = new Create(parent, content);
          initialize(result);
          return result;
        }

        public class Create extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Operation> {

          private static final String REST_PATH = "v1/{+parent}/connectClusters";

          private final java.util.regex.Pattern PARENT_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+$");

          /**
           * Creates a new Kafka Connect cluster in a given project and location.
           *
           * Create a request for the method "connectClusters.create".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
           * <p> {@link
           * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
           * be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param parent Required. The parent project/location in which to create the Kafka Connect cluster. Structured like
         *        `projects/{project}/locations/{location}/`.
           * @param content the {@link com.google.api.services.managedkafka.v1.model.ConnectCluster}
           * @since 1.13
           */
          protected Create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.ConnectCluster content) {
            super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Operation.class);
            this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
          }

          @Override
          public Create set$Xgafv(java.lang.String $Xgafv) {
            return (Create) super.set$Xgafv($Xgafv);
          }

          @Override
          public Create setAccessToken(java.lang.String accessToken) {
            return (Create) super.setAccessToken(accessToken);
          }

          @Override
          public Create setAlt(java.lang.String alt) {
            return (Create) super.setAlt(alt);
          }

          @Override
          public Create setCallback(java.lang.String callback) {
            return (Create) super.setCallback(callback);
          }

          @Override
          public Create setFields(java.lang.String fields) {
            return (Create) super.setFields(fields);
          }

          @Override
          public Create setKey(java.lang.String key) {
            return (Create) super.setKey(key);
          }

          @Override
          public Create setOauthToken(java.lang.String oauthToken) {
            return (Create) super.setOauthToken(oauthToken);
          }

          @Override
          public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Create) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Create setQuotaUser(java.lang.String quotaUser) {
            return (Create) super.setQuotaUser(quotaUser);
          }

          @Override
          public Create setUploadType(java.lang.String uploadType) {
            return (Create) super.setUploadType(uploadType);
          }

          @Override
          public Create setUploadProtocol(java.lang.String uploadProtocol) {
            return (Create) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Required. The parent project/location in which to create the Kafka Connect cluster.
           * Structured like `projects/{project}/locations/{location}/`.
           */
          @com.google.api.client.util.Key
          private java.lang.String parent;

          /** Required. The parent project/location in which to create the Kafka Connect cluster. Structured like
         `projects/{project}/locations/{location}/`.
           */
          public java.lang.String getParent() {
            return parent;
          }

          /**
           * Required. The parent project/location in which to create the Kafka Connect cluster.
           * Structured like `projects/{project}/locations/{location}/`.
           */
          public Create setParent(java.lang.String parent) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
            this.parent = parent;
            return this;
          }

          /**
           * Required. The ID to use for the Connect cluster, which will become the final component
           * of the cluster's name. The ID must be 1-63 characters long, and match the regular
           * expression `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value is
           * structured like: `my-cluster-id`.
           */
          @com.google.api.client.util.Key
          private java.lang.String connectClusterId;

          /** Required. The ID to use for the Connect cluster, which will become the final component of the
         cluster's name. The ID must be 1-63 characters long, and match the regular expression
         `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value is structured like: `my-cluster-
         id`.
           */
          public java.lang.String getConnectClusterId() {
            return connectClusterId;
          }

          /**
           * Required. The ID to use for the Connect cluster, which will become the final component
           * of the cluster's name. The ID must be 1-63 characters long, and match the regular
           * expression `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value is
           * structured like: `my-cluster-id`.
           */
          public Create setConnectClusterId(java.lang.String connectClusterId) {
            this.connectClusterId = connectClusterId;
            return this;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          @com.google.api.client.util.Key
          private java.lang.String requestId;

          /** Optional. An optional request ID to identify requests. Specify a unique request ID to avoid
         duplication of requests. If a request times out or fails, retrying with the same ID allows the
         server to recognize the previous attempt. For at least 60 minutes, the server ignores duplicate
         requests bearing the same ID. For example, consider a situation where you make an initial request
         and the request times out. If you make the request again with the same request ID within 60 minutes
         of the last request, the server checks if an original operation with the same request ID was
         received. If so, the server ignores the second request. The request ID must be a valid UUID. A zero
         UUID is not supported (00000000-0000-0000-0000-000000000000).
           */
          public java.lang.String getRequestId() {
            return requestId;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          public Create setRequestId(java.lang.String requestId) {
            this.requestId = requestId;
            return this;
          }

          @Override
          public Create set(String parameterName, Object value) {
            return (Create) super.set(parameterName, value);
          }
        }
        /**
         * Deletes a single Connect cluster.
         *
         * Create a request for the method "connectClusters.delete".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
         *
         * @param name Required. The name of the Kafka Connect cluster to delete. Structured like
         *        `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
         * @return the request
         */
        public Delete delete(java.lang.String name) throws java.io.IOException {
          Delete result = new Delete(name);
          initialize(result);
          return result;
        }

        public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Operation> {

          private static final String REST_PATH = "v1/{+name}";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");

          /**
           * Deletes a single Connect cluster.
           *
           * Create a request for the method "connectClusters.delete".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
           * <p> {@link
           * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
           * be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name Required. The name of the Kafka Connect cluster to delete. Structured like
         *        `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           * @since 1.13
           */
          protected Delete(java.lang.String name) {
            super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Operation.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
            }
          }

          @Override
          public Delete set$Xgafv(java.lang.String $Xgafv) {
            return (Delete) super.set$Xgafv($Xgafv);
          }

          @Override
          public Delete setAccessToken(java.lang.String accessToken) {
            return (Delete) super.setAccessToken(accessToken);
          }

          @Override
          public Delete setAlt(java.lang.String alt) {
            return (Delete) super.setAlt(alt);
          }

          @Override
          public Delete setCallback(java.lang.String callback) {
            return (Delete) super.setCallback(callback);
          }

          @Override
          public Delete setFields(java.lang.String fields) {
            return (Delete) super.setFields(fields);
          }

          @Override
          public Delete setKey(java.lang.String key) {
            return (Delete) super.setKey(key);
          }

          @Override
          public Delete setOauthToken(java.lang.String oauthToken) {
            return (Delete) super.setOauthToken(oauthToken);
          }

          @Override
          public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Delete) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Delete setQuotaUser(java.lang.String quotaUser) {
            return (Delete) super.setQuotaUser(quotaUser);
          }

          @Override
          public Delete setUploadType(java.lang.String uploadType) {
            return (Delete) super.setUploadType(uploadType);
          }

          @Override
          public Delete setUploadProtocol(java.lang.String uploadProtocol) {
            return (Delete) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Required. The name of the Kafka Connect cluster to delete. Structured like
           * `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** Required. The name of the Kafka Connect cluster to delete. Structured like
         `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           */
          public java.lang.String getName() {
            return name;
          }

          /**
           * Required. The name of the Kafka Connect cluster to delete. Structured like
           * `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           */
          public Delete setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
            }
            this.name = name;
            return this;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          @com.google.api.client.util.Key
          private java.lang.String requestId;

          /** Optional. An optional request ID to identify requests. Specify a unique request ID to avoid
         duplication of requests. If a request times out or fails, retrying with the same ID allows the
         server to recognize the previous attempt. For at least 60 minutes, the server ignores duplicate
         requests bearing the same ID. For example, consider a situation where you make an initial request
         and the request times out. If you make the request again with the same request ID within 60 minutes
         of the last request, the server checks if an original operation with the same request ID was
         received. If so, the server ignores the second request. The request ID must be a valid UUID. A zero
         UUID is not supported (00000000-0000-0000-0000-000000000000).
           */
          public java.lang.String getRequestId() {
            return requestId;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          public Delete setRequestId(java.lang.String requestId) {
            this.requestId = requestId;
            return this;
          }

          @Override
          public Delete set(String parameterName, Object value) {
            return (Delete) super.set(parameterName, value);
          }
        }
        /**
         * Returns the properties of a single Kafka Connect cluster.
         *
         * Create a request for the method "connectClusters.get".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Get#execute()} method to invoke the remote operation.
         *
         * @param name Required. The name of the Kafka Connect cluster whose configuration to return. Structured like
         *        `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
         * @return the request
         */
        public Get get(java.lang.String name) throws java.io.IOException {
          Get result = new Get(name);
          initialize(result);
          return result;
        }

        public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ConnectCluster> {

          private static final String REST_PATH = "v1/{+name}";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");

          /**
           * Returns the properties of a single Kafka Connect cluster.
           *
           * Create a request for the method "connectClusters.get".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
           * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
           * must be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name Required. The name of the Kafka Connect cluster whose configuration to return. Structured like
         *        `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           * @since 1.13
           */
          protected Get(java.lang.String name) {
            super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ConnectCluster.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
            }
          }

          @Override
          public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
            return super.executeUsingHead();
          }

          @Override
          public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
            return super.buildHttpRequestUsingHead();
          }

          @Override
          public Get set$Xgafv(java.lang.String $Xgafv) {
            return (Get) super.set$Xgafv($Xgafv);
          }

          @Override
          public Get setAccessToken(java.lang.String accessToken) {
            return (Get) super.setAccessToken(accessToken);
          }

          @Override
          public Get setAlt(java.lang.String alt) {
            return (Get) super.setAlt(alt);
          }

          @Override
          public Get setCallback(java.lang.String callback) {
            return (Get) super.setCallback(callback);
          }

          @Override
          public Get setFields(java.lang.String fields) {
            return (Get) super.setFields(fields);
          }

          @Override
          public Get setKey(java.lang.String key) {
            return (Get) super.setKey(key);
          }

          @Override
          public Get setOauthToken(java.lang.String oauthToken) {
            return (Get) super.setOauthToken(oauthToken);
          }

          @Override
          public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Get) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Get setQuotaUser(java.lang.String quotaUser) {
            return (Get) super.setQuotaUser(quotaUser);
          }

          @Override
          public Get setUploadType(java.lang.String uploadType) {
            return (Get) super.setUploadType(uploadType);
          }

          @Override
          public Get setUploadProtocol(java.lang.String uploadProtocol) {
            return (Get) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Required. The name of the Kafka Connect cluster whose configuration to return.
           * Structured like
           * `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** Required. The name of the Kafka Connect cluster whose configuration to return. Structured like
         `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           */
          public java.lang.String getName() {
            return name;
          }

          /**
           * Required. The name of the Kafka Connect cluster whose configuration to return.
           * Structured like
           * `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           */
          public Get setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
            }
            this.name = name;
            return this;
          }

          @Override
          public Get set(String parameterName, Object value) {
            return (Get) super.set(parameterName, value);
          }
        }
        /**
         * Lists the Kafka Connect clusters in a given project and location.
         *
         * Create a request for the method "connectClusters.list".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link List#execute()} method to invoke the remote operation.
         *
         * @param parent Required. The parent project/location whose Connect clusters are to be listed. Structured like
         *        `projects/{project}/locations/{location}`.
         * @return the request
         */
        public List list(java.lang.String parent) throws java.io.IOException {
          List result = new List(parent);
          initialize(result);
          return result;
        }

        public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ListConnectClustersResponse> {

          private static final String REST_PATH = "v1/{+parent}/connectClusters";

          private final java.util.regex.Pattern PARENT_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+$");

          /**
           * Lists the Kafka Connect clusters in a given project and location.
           *
           * Create a request for the method "connectClusters.list".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
           * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
           * must be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param parent Required. The parent project/location whose Connect clusters are to be listed. Structured like
         *        `projects/{project}/locations/{location}`.
           * @since 1.13
           */
          protected List(java.lang.String parent) {
            super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ListConnectClustersResponse.class);
            this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
          }

          @Override
          public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
            return super.executeUsingHead();
          }

          @Override
          public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
            return super.buildHttpRequestUsingHead();
          }

          @Override
          public List set$Xgafv(java.lang.String $Xgafv) {
            return (List) super.set$Xgafv($Xgafv);
          }

          @Override
          public List setAccessToken(java.lang.String accessToken) {
            return (List) super.setAccessToken(accessToken);
          }

          @Override
          public List setAlt(java.lang.String alt) {
            return (List) super.setAlt(alt);
          }

          @Override
          public List setCallback(java.lang.String callback) {
            return (List) super.setCallback(callback);
          }

          @Override
          public List setFields(java.lang.String fields) {
            return (List) super.setFields(fields);
          }

          @Override
          public List setKey(java.lang.String key) {
            return (List) super.setKey(key);
          }

          @Override
          public List setOauthToken(java.lang.String oauthToken) {
            return (List) super.setOauthToken(oauthToken);
          }

          @Override
          public List setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (List) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public List setQuotaUser(java.lang.String quotaUser) {
            return (List) super.setQuotaUser(quotaUser);
          }

          @Override
          public List setUploadType(java.lang.String uploadType) {
            return (List) super.setUploadType(uploadType);
          }

          @Override
          public List setUploadProtocol(java.lang.String uploadProtocol) {
            return (List) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Required. The parent project/location whose Connect clusters are to be listed.
           * Structured like `projects/{project}/locations/{location}`.
           */
          @com.google.api.client.util.Key
          private java.lang.String parent;

          /** Required. The parent project/location whose Connect clusters are to be listed. Structured like
         `projects/{project}/locations/{location}`.
           */
          public java.lang.String getParent() {
            return parent;
          }

          /**
           * Required. The parent project/location whose Connect clusters are to be listed.
           * Structured like `projects/{project}/locations/{location}`.
           */
          public List setParent(java.lang.String parent) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
            this.parent = parent;
            return this;
          }

          /** Optional. Filter expression for the result. */
          @com.google.api.client.util.Key
          private java.lang.String filter;

          /** Optional. Filter expression for the result.
           */
          public java.lang.String getFilter() {
            return filter;
          }

          /** Optional. Filter expression for the result. */
          public List setFilter(java.lang.String filter) {
            this.filter = filter;
            return this;
          }

          /** Optional. Order by fields for the result. */
          @com.google.api.client.util.Key
          private java.lang.String orderBy;

          /** Optional. Order by fields for the result.
           */
          public java.lang.String getOrderBy() {
            return orderBy;
          }

          /** Optional. Order by fields for the result. */
          public List setOrderBy(java.lang.String orderBy) {
            this.orderBy = orderBy;
            return this;
          }

          /**
           * Optional. The maximum number of Connect clusters to return. The service may return
           * fewer than this value. If unspecified, server will pick an appropriate default.
           */
          @com.google.api.client.util.Key
          private java.lang.Integer pageSize;

          /** Optional. The maximum number of Connect clusters to return. The service may return fewer than this
         value. If unspecified, server will pick an appropriate default.
           */
          public java.lang.Integer getPageSize() {
            return pageSize;
          }

          /**
           * Optional. The maximum number of Connect clusters to return. The service may return
           * fewer than this value. If unspecified, server will pick an appropriate default.
           */
          public List setPageSize(java.lang.Integer pageSize) {
            this.pageSize = pageSize;
            return this;
          }

          /**
           * Optional. A page token, received from a previous `ListConnectClusters` call. Provide
           * this to retrieve the subsequent page. When paginating, all other parameters provided to
           * `ListConnectClusters` must match the call that provided the page token.
           */
          @com.google.api.client.util.Key
          private java.lang.String pageToken;

          /** Optional. A page token, received from a previous `ListConnectClusters` call. Provide this to
         retrieve the subsequent page. When paginating, all other parameters provided to
         `ListConnectClusters` must match the call that provided the page token.
           */
          public java.lang.String getPageToken() {
            return pageToken;
          }

          /**
           * Optional. A page token, received from a previous `ListConnectClusters` call. Provide
           * this to retrieve the subsequent page. When paginating, all other parameters provided to
           * `ListConnectClusters` must match the call that provided the page token.
           */
          public List setPageToken(java.lang.String pageToken) {
            this.pageToken = pageToken;
            return this;
          }

          @Override
          public List set(String parameterName, Object value) {
            return (List) super.set(parameterName, value);
          }
        }
        /**
         * Updates the properties of a single Kafka Connect cluster.
         *
         * Create a request for the method "connectClusters.patch".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Patch#execute()} method to invoke the remote operation.
         *
         * @param name Identifier. The name of the Kafka Connect cluster. Structured like:
         *        projects/{project_number}/locations/{location}/connectClusters/{connect_cluster_id}
         * @param content the {@link com.google.api.services.managedkafka.v1.model.ConnectCluster}
         * @return the request
         */
        public Patch patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.ConnectCluster content) throws java.io.IOException {
          Patch result = new Patch(name, content);
          initialize(result);
          return result;
        }

        public class Patch extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Operation> {

          private static final String REST_PATH = "v1/{+name}";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");

          /**
           * Updates the properties of a single Kafka Connect cluster.
           *
           * Create a request for the method "connectClusters.patch".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Patch#execute()} method to invoke the remote operation.
           * <p> {@link
           * Patch#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
           * be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name Identifier. The name of the Kafka Connect cluster. Structured like:
         *        projects/{project_number}/locations/{location}/connectClusters/{connect_cluster_id}
           * @param content the {@link com.google.api.services.managedkafka.v1.model.ConnectCluster}
           * @since 1.13
           */
          protected Patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.ConnectCluster content) {
            super(ManagedKafka.this, "PATCH", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Operation.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
            }
          }

          @Override
          public Patch set$Xgafv(java.lang.String $Xgafv) {
            return (Patch) super.set$Xgafv($Xgafv);
          }

          @Override
          public Patch setAccessToken(java.lang.String accessToken) {
            return (Patch) super.setAccessToken(accessToken);
          }

          @Override
          public Patch setAlt(java.lang.String alt) {
            return (Patch) super.setAlt(alt);
          }

          @Override
          public Patch setCallback(java.lang.String callback) {
            return (Patch) super.setCallback(callback);
          }

          @Override
          public Patch setFields(java.lang.String fields) {
            return (Patch) super.setFields(fields);
          }

          @Override
          public Patch setKey(java.lang.String key) {
            return (Patch) super.setKey(key);
          }

          @Override
          public Patch setOauthToken(java.lang.String oauthToken) {
            return (Patch) super.setOauthToken(oauthToken);
          }

          @Override
          public Patch setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Patch) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Patch setQuotaUser(java.lang.String quotaUser) {
            return (Patch) super.setQuotaUser(quotaUser);
          }

          @Override
          public Patch setUploadType(java.lang.String uploadType) {
            return (Patch) super.setUploadType(uploadType);
          }

          @Override
          public Patch setUploadProtocol(java.lang.String uploadProtocol) {
            return (Patch) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Identifier. The name of the Kafka Connect cluster. Structured like:
           * projects/{project_number}/locations/{location}/connectClusters/{connect_cluster_id}
           */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** Identifier. The name of the Kafka Connect cluster. Structured like:
         projects/{project_number}/locations/{location}/connectClusters/{connect_cluster_id}
           */
          public java.lang.String getName() {
            return name;
          }

          /**
           * Identifier. The name of the Kafka Connect cluster. Structured like:
           * projects/{project_number}/locations/{location}/connectClusters/{connect_cluster_id}
           */
          public Patch setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
            }
            this.name = name;
            return this;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          @com.google.api.client.util.Key
          private java.lang.String requestId;

          /** Optional. An optional request ID to identify requests. Specify a unique request ID to avoid
         duplication of requests. If a request times out or fails, retrying with the same ID allows the
         server to recognize the previous attempt. For at least 60 minutes, the server ignores duplicate
         requests bearing the same ID. For example, consider a situation where you make an initial request
         and the request times out. If you make the request again with the same request ID within 60 minutes
         of the last request, the server checks if an original operation with the same request ID was
         received. If so, the server ignores the second request. The request ID must be a valid UUID. A zero
         UUID is not supported (00000000-0000-0000-0000-000000000000).
           */
          public java.lang.String getRequestId() {
            return requestId;
          }

          /**
           * Optional. An optional request ID to identify requests. Specify a unique request ID to
           * avoid duplication of requests. If a request times out or fails, retrying with the same
           * ID allows the server to recognize the previous attempt. For at least 60 minutes, the
           * server ignores duplicate requests bearing the same ID. For example, consider a
           * situation where you make an initial request and the request times out. If you make the
           * request again with the same request ID within 60 minutes of the last request, the
           * server checks if an original operation with the same request ID was received. If so,
           * the server ignores the second request. The request ID must be a valid UUID. A zero UUID
           * is not supported (00000000-0000-0000-0000-000000000000).
           */
          public Patch setRequestId(java.lang.String requestId) {
            this.requestId = requestId;
            return this;
          }

          /**
           * Required. Field mask is used to specify the fields to be overwritten in the cluster
           * resource by the update. The fields specified in the update_mask are relative to the
           * resource, not the full request. A field will be overwritten if it is in the mask. The
           * mask is required and a value of * will update all fields.
           */
          @com.google.api.client.util.Key
          private String updateMask;

          /** Required. Field mask is used to specify the fields to be overwritten in the cluster resource by the
         update. The fields specified in the update_mask are relative to the resource, not the full request.
         A field will be overwritten if it is in the mask. The mask is required and a value of * will update
         all fields.
           */
          public String getUpdateMask() {
            return updateMask;
          }

          /**
           * Required. Field mask is used to specify the fields to be overwritten in the cluster
           * resource by the update. The fields specified in the update_mask are relative to the
           * resource, not the full request. A field will be overwritten if it is in the mask. The
           * mask is required and a value of * will update all fields.
           */
          public Patch setUpdateMask(String updateMask) {
            this.updateMask = updateMask;
            return this;
          }

          @Override
          public Patch set(String parameterName, Object value) {
            return (Patch) super.set(parameterName, value);
          }
        }

        /**
         * An accessor for creating requests from the Connectors collection.
         *
         * <p>The typical use is:</p>
         * <pre>
         *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
         *   {@code ManagedKafka.Connectors.List request = managedkafka.connectors().list(parameters ...)}
         * </pre>
         *
         * @return the resource collection
         */
        public Connectors connectors() {
          return new Connectors();
        }

        /**
         * The "connectors" collection of methods.
         */
        public class Connectors {

          /**
           * Creates a new connector in a given Connect cluster.
           *
           * Create a request for the method "connectors.create".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Create#execute()} method to invoke the remote operation.
           *
           * @param parent Required. The parent Connect cluster in which to create the connector. Structured like
           *        `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           * @param content the {@link com.google.api.services.managedkafka.v1.model.Connector}
           * @return the request
           */
          public Create create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.Connector content) throws java.io.IOException {
            Create result = new Create(parent, content);
            initialize(result);
            return result;
          }

          public class Create extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Connector> {

            private static final String REST_PATH = "v1/{+parent}/connectors";

            private final java.util.regex.Pattern PARENT_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");

            /**
             * Creates a new connector in a given Connect cluster.
             *
             * Create a request for the method "connectors.create".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
             * <p> {@link
             * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param parent Required. The parent Connect cluster in which to create the connector. Structured like
           *        `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
             * @param content the {@link com.google.api.services.managedkafka.v1.model.Connector}
             * @since 1.13
             */
            protected Create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.Connector content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Connector.class);
              this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
              }
            }

            @Override
            public Create set$Xgafv(java.lang.String $Xgafv) {
              return (Create) super.set$Xgafv($Xgafv);
            }

            @Override
            public Create setAccessToken(java.lang.String accessToken) {
              return (Create) super.setAccessToken(accessToken);
            }

            @Override
            public Create setAlt(java.lang.String alt) {
              return (Create) super.setAlt(alt);
            }

            @Override
            public Create setCallback(java.lang.String callback) {
              return (Create) super.setCallback(callback);
            }

            @Override
            public Create setFields(java.lang.String fields) {
              return (Create) super.setFields(fields);
            }

            @Override
            public Create setKey(java.lang.String key) {
              return (Create) super.setKey(key);
            }

            @Override
            public Create setOauthToken(java.lang.String oauthToken) {
              return (Create) super.setOauthToken(oauthToken);
            }

            @Override
            public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Create) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Create setQuotaUser(java.lang.String quotaUser) {
              return (Create) super.setQuotaUser(quotaUser);
            }

            @Override
            public Create setUploadType(java.lang.String uploadType) {
              return (Create) super.setUploadType(uploadType);
            }

            @Override
            public Create setUploadProtocol(java.lang.String uploadProtocol) {
              return (Create) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The parent Connect cluster in which to create the connector. Structured
             * like `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String parent;

            /** Required. The parent Connect cluster in which to create the connector. Structured like
           `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
             */
            public java.lang.String getParent() {
              return parent;
            }

            /**
             * Required. The parent Connect cluster in which to create the connector. Structured
             * like `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
             */
            public Create setParent(java.lang.String parent) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
              }
              this.parent = parent;
              return this;
            }

            /**
             * Required. The ID to use for the connector, which will become the final component of
             * the connector's name. The ID must be 1-63 characters long, and match the regular
             * expression `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value is
             * structured like: `my-connector-id`.
             */
            @com.google.api.client.util.Key
            private java.lang.String connectorId;

            /** Required. The ID to use for the connector, which will become the final component of the connector's
           name. The ID must be 1-63 characters long, and match the regular expression
           `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value is structured like: `my-connector-
           id`.
             */
            public java.lang.String getConnectorId() {
              return connectorId;
            }

            /**
             * Required. The ID to use for the connector, which will become the final component of
             * the connector's name. The ID must be 1-63 characters long, and match the regular
             * expression `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value is
             * structured like: `my-connector-id`.
             */
            public Create setConnectorId(java.lang.String connectorId) {
              this.connectorId = connectorId;
              return this;
            }

            @Override
            public Create set(String parameterName, Object value) {
              return (Create) super.set(parameterName, value);
            }
          }
          /**
           * Deletes a connector.
           *
           * Create a request for the method "connectors.delete".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the connector to delete. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
           * @return the request
           */
          public Delete delete(java.lang.String name) throws java.io.IOException {
            Delete result = new Delete(name);
            initialize(result);
            return result;
          }

          public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Empty> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");

            /**
             * Deletes a connector.
             *
             * Create a request for the method "connectors.delete".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
             * <p> {@link
             * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the connector to delete. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
             * @since 1.13
             */
            protected Delete(java.lang.String name) {
              super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Empty.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
            }

            @Override
            public Delete set$Xgafv(java.lang.String $Xgafv) {
              return (Delete) super.set$Xgafv($Xgafv);
            }

            @Override
            public Delete setAccessToken(java.lang.String accessToken) {
              return (Delete) super.setAccessToken(accessToken);
            }

            @Override
            public Delete setAlt(java.lang.String alt) {
              return (Delete) super.setAlt(alt);
            }

            @Override
            public Delete setCallback(java.lang.String callback) {
              return (Delete) super.setCallback(callback);
            }

            @Override
            public Delete setFields(java.lang.String fields) {
              return (Delete) super.setFields(fields);
            }

            @Override
            public Delete setKey(java.lang.String key) {
              return (Delete) super.setKey(key);
            }

            @Override
            public Delete setOauthToken(java.lang.String oauthToken) {
              return (Delete) super.setOauthToken(oauthToken);
            }

            @Override
            public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Delete) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Delete setQuotaUser(java.lang.String quotaUser) {
              return (Delete) super.setQuotaUser(quotaUser);
            }

            @Override
            public Delete setUploadType(java.lang.String uploadType) {
              return (Delete) super.setUploadType(uploadType);
            }

            @Override
            public Delete setUploadProtocol(java.lang.String uploadProtocol) {
              return (Delete) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the connector to delete. Structured like: projects/{project}/lo
             * cations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the connector to delete. Structured like:
           projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the connector to delete. Structured like: projects/{project}/lo
             * cations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public Delete setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Delete set(String parameterName, Object value) {
              return (Delete) super.set(parameterName, value);
            }
          }
          /**
           * Returns the properties of a single connector.
           *
           * Create a request for the method "connectors.get".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Get#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the connector whose configuration to return. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
           * @return the request
           */
          public Get get(java.lang.String name) throws java.io.IOException {
            Get result = new Get(name);
            initialize(result);
            return result;
          }

          public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Connector> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");

            /**
             * Returns the properties of a single connector.
             *
             * Create a request for the method "connectors.get".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
             * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the connector whose configuration to return. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
             * @since 1.13
             */
            protected Get(java.lang.String name) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Connector.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public Get set$Xgafv(java.lang.String $Xgafv) {
              return (Get) super.set$Xgafv($Xgafv);
            }

            @Override
            public Get setAccessToken(java.lang.String accessToken) {
              return (Get) super.setAccessToken(accessToken);
            }

            @Override
            public Get setAlt(java.lang.String alt) {
              return (Get) super.setAlt(alt);
            }

            @Override
            public Get setCallback(java.lang.String callback) {
              return (Get) super.setCallback(callback);
            }

            @Override
            public Get setFields(java.lang.String fields) {
              return (Get) super.setFields(fields);
            }

            @Override
            public Get setKey(java.lang.String key) {
              return (Get) super.setKey(key);
            }

            @Override
            public Get setOauthToken(java.lang.String oauthToken) {
              return (Get) super.setOauthToken(oauthToken);
            }

            @Override
            public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Get) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Get setQuotaUser(java.lang.String quotaUser) {
              return (Get) super.setQuotaUser(quotaUser);
            }

            @Override
            public Get setUploadType(java.lang.String uploadType) {
              return (Get) super.setUploadType(uploadType);
            }

            @Override
            public Get setUploadProtocol(java.lang.String uploadProtocol) {
              return (Get) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the connector whose configuration to return. Structured like: p
             * rojects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{c
             * onnector}
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the connector whose configuration to return. Structured like:
           projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the connector whose configuration to return. Structured like: p
             * rojects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{c
             * onnector}
             */
            public Get setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Get set(String parameterName, Object value) {
              return (Get) super.set(parameterName, value);
            }
          }
          /**
           * Lists the connectors in a given Connect cluster.
           *
           * Create a request for the method "connectors.list".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link List#execute()} method to invoke the remote operation.
           *
           * @param parent Required. The parent Connect cluster whose connectors are to be listed. Structured like
           *        `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
           * @return the request
           */
          public List list(java.lang.String parent) throws java.io.IOException {
            List result = new List(parent);
            initialize(result);
            return result;
          }

          public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ListConnectorsResponse> {

            private static final String REST_PATH = "v1/{+parent}/connectors";

            private final java.util.regex.Pattern PARENT_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");

            /**
             * Lists the connectors in a given Connect cluster.
             *
             * Create a request for the method "connectors.list".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
             * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param parent Required. The parent Connect cluster whose connectors are to be listed. Structured like
           *        `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
             * @since 1.13
             */
            protected List(java.lang.String parent) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ListConnectorsResponse.class);
              this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public List set$Xgafv(java.lang.String $Xgafv) {
              return (List) super.set$Xgafv($Xgafv);
            }

            @Override
            public List setAccessToken(java.lang.String accessToken) {
              return (List) super.setAccessToken(accessToken);
            }

            @Override
            public List setAlt(java.lang.String alt) {
              return (List) super.setAlt(alt);
            }

            @Override
            public List setCallback(java.lang.String callback) {
              return (List) super.setCallback(callback);
            }

            @Override
            public List setFields(java.lang.String fields) {
              return (List) super.setFields(fields);
            }

            @Override
            public List setKey(java.lang.String key) {
              return (List) super.setKey(key);
            }

            @Override
            public List setOauthToken(java.lang.String oauthToken) {
              return (List) super.setOauthToken(oauthToken);
            }

            @Override
            public List setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (List) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public List setQuotaUser(java.lang.String quotaUser) {
              return (List) super.setQuotaUser(quotaUser);
            }

            @Override
            public List setUploadType(java.lang.String uploadType) {
              return (List) super.setUploadType(uploadType);
            }

            @Override
            public List setUploadProtocol(java.lang.String uploadProtocol) {
              return (List) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The parent Connect cluster whose connectors are to be listed. Structured
             * like `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
             */
            @com.google.api.client.util.Key
            private java.lang.String parent;

            /** Required. The parent Connect cluster whose connectors are to be listed. Structured like
           `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
             */
            public java.lang.String getParent() {
              return parent;
            }

            /**
             * Required. The parent Connect cluster whose connectors are to be listed. Structured
             * like `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
             */
            public List setParent(java.lang.String parent) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+$");
              }
              this.parent = parent;
              return this;
            }

            /**
             * Optional. The maximum number of connectors to return. The service may return fewer
             * than this value. If unspecified, server will pick an appropriate default.
             */
            @com.google.api.client.util.Key
            private java.lang.Integer pageSize;

            /** Optional. The maximum number of connectors to return. The service may return fewer than this value.
           If unspecified, server will pick an appropriate default.
             */
            public java.lang.Integer getPageSize() {
              return pageSize;
            }

            /**
             * Optional. The maximum number of connectors to return. The service may return fewer
             * than this value. If unspecified, server will pick an appropriate default.
             */
            public List setPageSize(java.lang.Integer pageSize) {
              this.pageSize = pageSize;
              return this;
            }

            /**
             * Optional. A page token, received from a previous `ListConnectors` call. Provide this
             * to retrieve the subsequent page. When paginating, all other parameters provided to
             * `ListConnectors` must match the call that provided the page token.
             */
            @com.google.api.client.util.Key
            private java.lang.String pageToken;

            /** Optional. A page token, received from a previous `ListConnectors` call. Provide this to retrieve
           the subsequent page. When paginating, all other parameters provided to `ListConnectors` must match
           the call that provided the page token.
             */
            public java.lang.String getPageToken() {
              return pageToken;
            }

            /**
             * Optional. A page token, received from a previous `ListConnectors` call. Provide this
             * to retrieve the subsequent page. When paginating, all other parameters provided to
             * `ListConnectors` must match the call that provided the page token.
             */
            public List setPageToken(java.lang.String pageToken) {
              this.pageToken = pageToken;
              return this;
            }

            @Override
            public List set(String parameterName, Object value) {
              return (List) super.set(parameterName, value);
            }
          }
          /**
           * Updates the properties of a connector.
           *
           * Create a request for the method "connectors.patch".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Patch#execute()} method to invoke the remote operation.
           *
           * @param name Identifier. The name of the connector. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connect_cluster}/connectors/{conn
           *        ector}
           * @param content the {@link com.google.api.services.managedkafka.v1.model.Connector}
           * @return the request
           */
          public Patch patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.Connector content) throws java.io.IOException {
            Patch result = new Patch(name, content);
            initialize(result);
            return result;
          }

          public class Patch extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Connector> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");

            /**
             * Updates the properties of a connector.
             *
             * Create a request for the method "connectors.patch".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Patch#execute()} method to invoke the remote operation.
             * <p> {@link
             * Patch#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Identifier. The name of the connector. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connect_cluster}/connectors/{conn
           *        ector}
             * @param content the {@link com.google.api.services.managedkafka.v1.model.Connector}
             * @since 1.13
             */
            protected Patch(java.lang.String name, com.google.api.services.managedkafka.v1.model.Connector content) {
              super(ManagedKafka.this, "PATCH", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Connector.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
            }

            @Override
            public Patch set$Xgafv(java.lang.String $Xgafv) {
              return (Patch) super.set$Xgafv($Xgafv);
            }

            @Override
            public Patch setAccessToken(java.lang.String accessToken) {
              return (Patch) super.setAccessToken(accessToken);
            }

            @Override
            public Patch setAlt(java.lang.String alt) {
              return (Patch) super.setAlt(alt);
            }

            @Override
            public Patch setCallback(java.lang.String callback) {
              return (Patch) super.setCallback(callback);
            }

            @Override
            public Patch setFields(java.lang.String fields) {
              return (Patch) super.setFields(fields);
            }

            @Override
            public Patch setKey(java.lang.String key) {
              return (Patch) super.setKey(key);
            }

            @Override
            public Patch setOauthToken(java.lang.String oauthToken) {
              return (Patch) super.setOauthToken(oauthToken);
            }

            @Override
            public Patch setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Patch) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Patch setQuotaUser(java.lang.String quotaUser) {
              return (Patch) super.setQuotaUser(quotaUser);
            }

            @Override
            public Patch setUploadType(java.lang.String uploadType) {
              return (Patch) super.setUploadType(uploadType);
            }

            @Override
            public Patch setUploadProtocol(java.lang.String uploadProtocol) {
              return (Patch) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Identifier. The name of the connector. Structured like: projects/{project}/locations/
             * {location}/connectClusters/{connect_cluster}/connectors/{connector}
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Identifier. The name of the connector. Structured like:
           projects/{project}/locations/{location}/connectClusters/{connect_cluster}/connectors/{connector}
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Identifier. The name of the connector. Structured like: projects/{project}/locations/
             * {location}/connectClusters/{connect_cluster}/connectors/{connector}
             */
            public Patch setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
              this.name = name;
              return this;
            }

            /**
             * Required. Field mask is used to specify the fields to be overwritten in the cluster
             * resource by the update. The fields specified in the update_mask are relative to the
             * resource, not the full request. A field will be overwritten if it is in the mask. The
             * mask is required and a value of * will update all fields.
             */
            @com.google.api.client.util.Key
            private String updateMask;

            /** Required. Field mask is used to specify the fields to be overwritten in the cluster resource by the
           update. The fields specified in the update_mask are relative to the resource, not the full request.
           A field will be overwritten if it is in the mask. The mask is required and a value of * will update
           all fields.
             */
            public String getUpdateMask() {
              return updateMask;
            }

            /**
             * Required. Field mask is used to specify the fields to be overwritten in the cluster
             * resource by the update. The fields specified in the update_mask are relative to the
             * resource, not the full request. A field will be overwritten if it is in the mask. The
             * mask is required and a value of * will update all fields.
             */
            public Patch setUpdateMask(String updateMask) {
              this.updateMask = updateMask;
              return this;
            }

            @Override
            public Patch set(String parameterName, Object value) {
              return (Patch) super.set(parameterName, value);
            }
          }
          /**
           * Pauses the connector and its tasks.
           *
           * Create a request for the method "connectors.pause".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Pause#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the connector to pause. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
           * @param content the {@link com.google.api.services.managedkafka.v1.model.PauseConnectorRequest}
           * @return the request
           */
          public Pause pause(java.lang.String name, com.google.api.services.managedkafka.v1.model.PauseConnectorRequest content) throws java.io.IOException {
            Pause result = new Pause(name, content);
            initialize(result);
            return result;
          }

          public class Pause extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.PauseConnectorResponse> {

            private static final String REST_PATH = "v1/{+name}:pause";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");

            /**
             * Pauses the connector and its tasks.
             *
             * Create a request for the method "connectors.pause".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Pause#execute()} method to invoke the remote operation.
             * <p> {@link
             * Pause#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the connector to pause. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
             * @param content the {@link com.google.api.services.managedkafka.v1.model.PauseConnectorRequest}
             * @since 1.13
             */
            protected Pause(java.lang.String name, com.google.api.services.managedkafka.v1.model.PauseConnectorRequest content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.PauseConnectorResponse.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
            }

            @Override
            public Pause set$Xgafv(java.lang.String $Xgafv) {
              return (Pause) super.set$Xgafv($Xgafv);
            }

            @Override
            public Pause setAccessToken(java.lang.String accessToken) {
              return (Pause) super.setAccessToken(accessToken);
            }

            @Override
            public Pause setAlt(java.lang.String alt) {
              return (Pause) super.setAlt(alt);
            }

            @Override
            public Pause setCallback(java.lang.String callback) {
              return (Pause) super.setCallback(callback);
            }

            @Override
            public Pause setFields(java.lang.String fields) {
              return (Pause) super.setFields(fields);
            }

            @Override
            public Pause setKey(java.lang.String key) {
              return (Pause) super.setKey(key);
            }

            @Override
            public Pause setOauthToken(java.lang.String oauthToken) {
              return (Pause) super.setOauthToken(oauthToken);
            }

            @Override
            public Pause setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Pause) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Pause setQuotaUser(java.lang.String quotaUser) {
              return (Pause) super.setQuotaUser(quotaUser);
            }

            @Override
            public Pause setUploadType(java.lang.String uploadType) {
              return (Pause) super.setUploadType(uploadType);
            }

            @Override
            public Pause setUploadProtocol(java.lang.String uploadProtocol) {
              return (Pause) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the connector to pause. Structured like: projects/{project}/loc
             * ations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the connector to pause. Structured like:
           projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the connector to pause. Structured like: projects/{project}/loc
             * ations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public Pause setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Pause set(String parameterName, Object value) {
              return (Pause) super.set(parameterName, value);
            }
          }
          /**
           * Restarts the connector.
           *
           * Create a request for the method "connectors.restart".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Restart#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the connector to restart. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
           * @param content the {@link com.google.api.services.managedkafka.v1.model.RestartConnectorRequest}
           * @return the request
           */
          public Restart restart(java.lang.String name, com.google.api.services.managedkafka.v1.model.RestartConnectorRequest content) throws java.io.IOException {
            Restart result = new Restart(name, content);
            initialize(result);
            return result;
          }

          public class Restart extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.RestartConnectorResponse> {

            private static final String REST_PATH = "v1/{+name}:restart";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");

            /**
             * Restarts the connector.
             *
             * Create a request for the method "connectors.restart".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Restart#execute()} method to invoke the remote operation.
             * <p> {@link
             * Restart#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the connector to restart. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
             * @param content the {@link com.google.api.services.managedkafka.v1.model.RestartConnectorRequest}
             * @since 1.13
             */
            protected Restart(java.lang.String name, com.google.api.services.managedkafka.v1.model.RestartConnectorRequest content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.RestartConnectorResponse.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
            }

            @Override
            public Restart set$Xgafv(java.lang.String $Xgafv) {
              return (Restart) super.set$Xgafv($Xgafv);
            }

            @Override
            public Restart setAccessToken(java.lang.String accessToken) {
              return (Restart) super.setAccessToken(accessToken);
            }

            @Override
            public Restart setAlt(java.lang.String alt) {
              return (Restart) super.setAlt(alt);
            }

            @Override
            public Restart setCallback(java.lang.String callback) {
              return (Restart) super.setCallback(callback);
            }

            @Override
            public Restart setFields(java.lang.String fields) {
              return (Restart) super.setFields(fields);
            }

            @Override
            public Restart setKey(java.lang.String key) {
              return (Restart) super.setKey(key);
            }

            @Override
            public Restart setOauthToken(java.lang.String oauthToken) {
              return (Restart) super.setOauthToken(oauthToken);
            }

            @Override
            public Restart setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Restart) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Restart setQuotaUser(java.lang.String quotaUser) {
              return (Restart) super.setQuotaUser(quotaUser);
            }

            @Override
            public Restart setUploadType(java.lang.String uploadType) {
              return (Restart) super.setUploadType(uploadType);
            }

            @Override
            public Restart setUploadProtocol(java.lang.String uploadProtocol) {
              return (Restart) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the connector to restart. Structured like: projects/{project}/l
             * ocations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the connector to restart. Structured like:
           projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the connector to restart. Structured like: projects/{project}/l
             * ocations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public Restart setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Restart set(String parameterName, Object value) {
              return (Restart) super.set(parameterName, value);
            }
          }
          /**
           * Resumes the connector and its tasks.
           *
           * Create a request for the method "connectors.resume".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Resume#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the connector to pause. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
           * @param content the {@link com.google.api.services.managedkafka.v1.model.ResumeConnectorRequest}
           * @return the request
           */
          public Resume resume(java.lang.String name, com.google.api.services.managedkafka.v1.model.ResumeConnectorRequest content) throws java.io.IOException {
            Resume result = new Resume(name, content);
            initialize(result);
            return result;
          }

          public class Resume extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ResumeConnectorResponse> {

            private static final String REST_PATH = "v1/{+name}:resume";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");

            /**
             * Resumes the connector and its tasks.
             *
             * Create a request for the method "connectors.resume".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Resume#execute()} method to invoke the remote operation.
             * <p> {@link
             * Resume#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the connector to pause. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
             * @param content the {@link com.google.api.services.managedkafka.v1.model.ResumeConnectorRequest}
             * @since 1.13
             */
            protected Resume(java.lang.String name, com.google.api.services.managedkafka.v1.model.ResumeConnectorRequest content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.ResumeConnectorResponse.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
            }

            @Override
            public Resume set$Xgafv(java.lang.String $Xgafv) {
              return (Resume) super.set$Xgafv($Xgafv);
            }

            @Override
            public Resume setAccessToken(java.lang.String accessToken) {
              return (Resume) super.setAccessToken(accessToken);
            }

            @Override
            public Resume setAlt(java.lang.String alt) {
              return (Resume) super.setAlt(alt);
            }

            @Override
            public Resume setCallback(java.lang.String callback) {
              return (Resume) super.setCallback(callback);
            }

            @Override
            public Resume setFields(java.lang.String fields) {
              return (Resume) super.setFields(fields);
            }

            @Override
            public Resume setKey(java.lang.String key) {
              return (Resume) super.setKey(key);
            }

            @Override
            public Resume setOauthToken(java.lang.String oauthToken) {
              return (Resume) super.setOauthToken(oauthToken);
            }

            @Override
            public Resume setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Resume) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Resume setQuotaUser(java.lang.String quotaUser) {
              return (Resume) super.setQuotaUser(quotaUser);
            }

            @Override
            public Resume setUploadType(java.lang.String uploadType) {
              return (Resume) super.setUploadType(uploadType);
            }

            @Override
            public Resume setUploadProtocol(java.lang.String uploadProtocol) {
              return (Resume) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the connector to pause. Structured like: projects/{project}/loc
             * ations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the connector to pause. Structured like:
           projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the connector to pause. Structured like: projects/{project}/loc
             * ations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public Resume setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Resume set(String parameterName, Object value) {
              return (Resume) super.set(parameterName, value);
            }
          }
          /**
           * Stops the connector.
           *
           * Create a request for the method "connectors.stop".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Stop#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the connector to stop. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
           * @param content the {@link com.google.api.services.managedkafka.v1.model.StopConnectorRequest}
           * @return the request
           */
          public Stop stop(java.lang.String name, com.google.api.services.managedkafka.v1.model.StopConnectorRequest content) throws java.io.IOException {
            Stop result = new Stop(name, content);
            initialize(result);
            return result;
          }

          public class Stop extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.StopConnectorResponse> {

            private static final String REST_PATH = "v1/{+name}:stop";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");

            /**
             * Stops the connector.
             *
             * Create a request for the method "connectors.stop".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Stop#execute()} method to invoke the remote operation. <p>
             * {@link Stop#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the connector to stop. Structured like:
           *        projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{conne
           *        ctor}
             * @param content the {@link com.google.api.services.managedkafka.v1.model.StopConnectorRequest}
             * @since 1.13
             */
            protected Stop(java.lang.String name, com.google.api.services.managedkafka.v1.model.StopConnectorRequest content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.StopConnectorResponse.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
            }

            @Override
            public Stop set$Xgafv(java.lang.String $Xgafv) {
              return (Stop) super.set$Xgafv($Xgafv);
            }

            @Override
            public Stop setAccessToken(java.lang.String accessToken) {
              return (Stop) super.setAccessToken(accessToken);
            }

            @Override
            public Stop setAlt(java.lang.String alt) {
              return (Stop) super.setAlt(alt);
            }

            @Override
            public Stop setCallback(java.lang.String callback) {
              return (Stop) super.setCallback(callback);
            }

            @Override
            public Stop setFields(java.lang.String fields) {
              return (Stop) super.setFields(fields);
            }

            @Override
            public Stop setKey(java.lang.String key) {
              return (Stop) super.setKey(key);
            }

            @Override
            public Stop setOauthToken(java.lang.String oauthToken) {
              return (Stop) super.setOauthToken(oauthToken);
            }

            @Override
            public Stop setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Stop) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Stop setQuotaUser(java.lang.String quotaUser) {
              return (Stop) super.setQuotaUser(quotaUser);
            }

            @Override
            public Stop setUploadType(java.lang.String uploadType) {
              return (Stop) super.setUploadType(uploadType);
            }

            @Override
            public Stop setUploadProtocol(java.lang.String uploadProtocol) {
              return (Stop) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the connector to stop. Structured like: projects/{project}/loca
             * tions/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the connector to stop. Structured like:
           projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the connector to stop. Structured like: projects/{project}/loca
             * tions/{location}/connectClusters/{connectCluster}/connectors/{connector}
             */
            public Stop setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/connectClusters/[^/]+/connectors/[^/]+$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Stop set(String parameterName, Object value) {
              return (Stop) super.set(parameterName, value);
            }
          }

        }
      }
      /**
       * An accessor for creating requests from the Operations collection.
       *
       * <p>The typical use is:</p>
       * <pre>
       *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
       *   {@code ManagedKafka.Operations.List request = managedkafka.operations().list(parameters ...)}
       * </pre>
       *
       * @return the resource collection
       */
      public Operations operations() {
        return new Operations();
      }

      /**
       * The "operations" collection of methods.
       */
      public class Operations {

        /**
         * Starts asynchronous cancellation on a long-running operation. The server makes a best effort to
         * cancel the operation, but success is not guaranteed. If the server doesn't support this method,
         * it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other
         * methods to check whether the cancellation succeeded or whether the operation completed despite
         * cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an
         * operation with an Operation.error value with a google.rpc.Status.code of `1`, corresponding to
         * `Code.CANCELLED`.
         *
         * Create a request for the method "operations.cancel".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Cancel#execute()} method to invoke the remote operation.
         *
         * @param name The name of the operation resource to be cancelled.
         * @param content the {@link com.google.api.services.managedkafka.v1.model.CancelOperationRequest}
         * @return the request
         */
        public Cancel cancel(java.lang.String name, com.google.api.services.managedkafka.v1.model.CancelOperationRequest content) throws java.io.IOException {
          Cancel result = new Cancel(name, content);
          initialize(result);
          return result;
        }

        public class Cancel extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Empty> {

          private static final String REST_PATH = "v1/{+name}:cancel";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/operations/[^/]+$");

          /**
           * Starts asynchronous cancellation on a long-running operation. The server makes a best effort to
           * cancel the operation, but success is not guaranteed. If the server doesn't support this method,
           * it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other
           * methods to check whether the cancellation succeeded or whether the operation completed despite
           * cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an
           * operation with an Operation.error value with a google.rpc.Status.code of `1`, corresponding to
           * `Code.CANCELLED`.
           *
           * Create a request for the method "operations.cancel".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Cancel#execute()} method to invoke the remote operation.
           * <p> {@link
           * Cancel#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
           * be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name The name of the operation resource to be cancelled.
           * @param content the {@link com.google.api.services.managedkafka.v1.model.CancelOperationRequest}
           * @since 1.13
           */
          protected Cancel(java.lang.String name, com.google.api.services.managedkafka.v1.model.CancelOperationRequest content) {
            super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.Empty.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/operations/[^/]+$");
            }
          }

          @Override
          public Cancel set$Xgafv(java.lang.String $Xgafv) {
            return (Cancel) super.set$Xgafv($Xgafv);
          }

          @Override
          public Cancel setAccessToken(java.lang.String accessToken) {
            return (Cancel) super.setAccessToken(accessToken);
          }

          @Override
          public Cancel setAlt(java.lang.String alt) {
            return (Cancel) super.setAlt(alt);
          }

          @Override
          public Cancel setCallback(java.lang.String callback) {
            return (Cancel) super.setCallback(callback);
          }

          @Override
          public Cancel setFields(java.lang.String fields) {
            return (Cancel) super.setFields(fields);
          }

          @Override
          public Cancel setKey(java.lang.String key) {
            return (Cancel) super.setKey(key);
          }

          @Override
          public Cancel setOauthToken(java.lang.String oauthToken) {
            return (Cancel) super.setOauthToken(oauthToken);
          }

          @Override
          public Cancel setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Cancel) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Cancel setQuotaUser(java.lang.String quotaUser) {
            return (Cancel) super.setQuotaUser(quotaUser);
          }

          @Override
          public Cancel setUploadType(java.lang.String uploadType) {
            return (Cancel) super.setUploadType(uploadType);
          }

          @Override
          public Cancel setUploadProtocol(java.lang.String uploadProtocol) {
            return (Cancel) super.setUploadProtocol(uploadProtocol);
          }

          /** The name of the operation resource to be cancelled. */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** The name of the operation resource to be cancelled.
           */
          public java.lang.String getName() {
            return name;
          }

          /** The name of the operation resource to be cancelled. */
          public Cancel setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/operations/[^/]+$");
            }
            this.name = name;
            return this;
          }

          @Override
          public Cancel set(String parameterName, Object value) {
            return (Cancel) super.set(parameterName, value);
          }
        }
        /**
         * Deletes a long-running operation. This method indicates that the client is no longer interested
         * in the operation result. It does not cancel the operation. If the server doesn't support this
         * method, it returns `google.rpc.Code.UNIMPLEMENTED`.
         *
         * Create a request for the method "operations.delete".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
         *
         * @param name The name of the operation resource to be deleted.
         * @return the request
         */
        public Delete delete(java.lang.String name) throws java.io.IOException {
          Delete result = new Delete(name);
          initialize(result);
          return result;
        }

        public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Empty> {

          private static final String REST_PATH = "v1/{+name}";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/operations/[^/]+$");

          /**
           * Deletes a long-running operation. This method indicates that the client is no longer interested
           * in the operation result. It does not cancel the operation. If the server doesn't support this
           * method, it returns `google.rpc.Code.UNIMPLEMENTED`.
           *
           * Create a request for the method "operations.delete".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
           * <p> {@link
           * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
           * be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name The name of the operation resource to be deleted.
           * @since 1.13
           */
          protected Delete(java.lang.String name) {
            super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Empty.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/operations/[^/]+$");
            }
          }

          @Override
          public Delete set$Xgafv(java.lang.String $Xgafv) {
            return (Delete) super.set$Xgafv($Xgafv);
          }

          @Override
          public Delete setAccessToken(java.lang.String accessToken) {
            return (Delete) super.setAccessToken(accessToken);
          }

          @Override
          public Delete setAlt(java.lang.String alt) {
            return (Delete) super.setAlt(alt);
          }

          @Override
          public Delete setCallback(java.lang.String callback) {
            return (Delete) super.setCallback(callback);
          }

          @Override
          public Delete setFields(java.lang.String fields) {
            return (Delete) super.setFields(fields);
          }

          @Override
          public Delete setKey(java.lang.String key) {
            return (Delete) super.setKey(key);
          }

          @Override
          public Delete setOauthToken(java.lang.String oauthToken) {
            return (Delete) super.setOauthToken(oauthToken);
          }

          @Override
          public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Delete) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Delete setQuotaUser(java.lang.String quotaUser) {
            return (Delete) super.setQuotaUser(quotaUser);
          }

          @Override
          public Delete setUploadType(java.lang.String uploadType) {
            return (Delete) super.setUploadType(uploadType);
          }

          @Override
          public Delete setUploadProtocol(java.lang.String uploadProtocol) {
            return (Delete) super.setUploadProtocol(uploadProtocol);
          }

          /** The name of the operation resource to be deleted. */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** The name of the operation resource to be deleted.
           */
          public java.lang.String getName() {
            return name;
          }

          /** The name of the operation resource to be deleted. */
          public Delete setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/operations/[^/]+$");
            }
            this.name = name;
            return this;
          }

          @Override
          public Delete set(String parameterName, Object value) {
            return (Delete) super.set(parameterName, value);
          }
        }
        /**
         * Gets the latest state of a long-running operation. Clients can use this method to poll the
         * operation result at intervals as recommended by the API service.
         *
         * Create a request for the method "operations.get".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Get#execute()} method to invoke the remote operation.
         *
         * @param name The name of the operation resource.
         * @return the request
         */
        public Get get(java.lang.String name) throws java.io.IOException {
          Get result = new Get(name);
          initialize(result);
          return result;
        }

        public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Operation> {

          private static final String REST_PATH = "v1/{+name}";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/operations/[^/]+$");

          /**
           * Gets the latest state of a long-running operation. Clients can use this method to poll the
           * operation result at intervals as recommended by the API service.
           *
           * Create a request for the method "operations.get".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
           * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
           * must be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name The name of the operation resource.
           * @since 1.13
           */
          protected Get(java.lang.String name) {
            super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Operation.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/operations/[^/]+$");
            }
          }

          @Override
          public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
            return super.executeUsingHead();
          }

          @Override
          public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
            return super.buildHttpRequestUsingHead();
          }

          @Override
          public Get set$Xgafv(java.lang.String $Xgafv) {
            return (Get) super.set$Xgafv($Xgafv);
          }

          @Override
          public Get setAccessToken(java.lang.String accessToken) {
            return (Get) super.setAccessToken(accessToken);
          }

          @Override
          public Get setAlt(java.lang.String alt) {
            return (Get) super.setAlt(alt);
          }

          @Override
          public Get setCallback(java.lang.String callback) {
            return (Get) super.setCallback(callback);
          }

          @Override
          public Get setFields(java.lang.String fields) {
            return (Get) super.setFields(fields);
          }

          @Override
          public Get setKey(java.lang.String key) {
            return (Get) super.setKey(key);
          }

          @Override
          public Get setOauthToken(java.lang.String oauthToken) {
            return (Get) super.setOauthToken(oauthToken);
          }

          @Override
          public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Get) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Get setQuotaUser(java.lang.String quotaUser) {
            return (Get) super.setQuotaUser(quotaUser);
          }

          @Override
          public Get setUploadType(java.lang.String uploadType) {
            return (Get) super.setUploadType(uploadType);
          }

          @Override
          public Get setUploadProtocol(java.lang.String uploadProtocol) {
            return (Get) super.setUploadProtocol(uploadProtocol);
          }

          /** The name of the operation resource. */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** The name of the operation resource.
           */
          public java.lang.String getName() {
            return name;
          }

          /** The name of the operation resource. */
          public Get setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/operations/[^/]+$");
            }
            this.name = name;
            return this;
          }

          @Override
          public Get set(String parameterName, Object value) {
            return (Get) super.set(parameterName, value);
          }
        }
        /**
         * Lists operations that match the specified filter in the request. If the server doesn't support
         * this method, it returns `UNIMPLEMENTED`.
         *
         * Create a request for the method "operations.list".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link List#execute()} method to invoke the remote operation.
         *
         * @param name The name of the operation's parent resource.
         * @return the request
         */
        public List list(java.lang.String name) throws java.io.IOException {
          List result = new List(name);
          initialize(result);
          return result;
        }

        public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ListOperationsResponse> {

          private static final String REST_PATH = "v1/{+name}/operations";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+$");

          /**
           * Lists operations that match the specified filter in the request. If the server doesn't support
           * this method, it returns `UNIMPLEMENTED`.
           *
           * Create a request for the method "operations.list".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
           * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
           * must be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name The name of the operation's parent resource.
           * @since 1.13
           */
          protected List(java.lang.String name) {
            super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ListOperationsResponse.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
          }

          @Override
          public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
            return super.executeUsingHead();
          }

          @Override
          public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
            return super.buildHttpRequestUsingHead();
          }

          @Override
          public List set$Xgafv(java.lang.String $Xgafv) {
            return (List) super.set$Xgafv($Xgafv);
          }

          @Override
          public List setAccessToken(java.lang.String accessToken) {
            return (List) super.setAccessToken(accessToken);
          }

          @Override
          public List setAlt(java.lang.String alt) {
            return (List) super.setAlt(alt);
          }

          @Override
          public List setCallback(java.lang.String callback) {
            return (List) super.setCallback(callback);
          }

          @Override
          public List setFields(java.lang.String fields) {
            return (List) super.setFields(fields);
          }

          @Override
          public List setKey(java.lang.String key) {
            return (List) super.setKey(key);
          }

          @Override
          public List setOauthToken(java.lang.String oauthToken) {
            return (List) super.setOauthToken(oauthToken);
          }

          @Override
          public List setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (List) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public List setQuotaUser(java.lang.String quotaUser) {
            return (List) super.setQuotaUser(quotaUser);
          }

          @Override
          public List setUploadType(java.lang.String uploadType) {
            return (List) super.setUploadType(uploadType);
          }

          @Override
          public List setUploadProtocol(java.lang.String uploadProtocol) {
            return (List) super.setUploadProtocol(uploadProtocol);
          }

          /** The name of the operation's parent resource. */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** The name of the operation's parent resource.
           */
          public java.lang.String getName() {
            return name;
          }

          /** The name of the operation's parent resource. */
          public List setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
            this.name = name;
            return this;
          }

          /** The standard list filter. */
          @com.google.api.client.util.Key
          private java.lang.String filter;

          /** The standard list filter.
           */
          public java.lang.String getFilter() {
            return filter;
          }

          /** The standard list filter. */
          public List setFilter(java.lang.String filter) {
            this.filter = filter;
            return this;
          }

          /** The standard list page size. */
          @com.google.api.client.util.Key
          private java.lang.Integer pageSize;

          /** The standard list page size.
           */
          public java.lang.Integer getPageSize() {
            return pageSize;
          }

          /** The standard list page size. */
          public List setPageSize(java.lang.Integer pageSize) {
            this.pageSize = pageSize;
            return this;
          }

          /** The standard list page token. */
          @com.google.api.client.util.Key
          private java.lang.String pageToken;

          /** The standard list page token.
           */
          public java.lang.String getPageToken() {
            return pageToken;
          }

          /** The standard list page token. */
          public List setPageToken(java.lang.String pageToken) {
            this.pageToken = pageToken;
            return this;
          }

          @Override
          public List set(String parameterName, Object value) {
            return (List) super.set(parameterName, value);
          }
        }

      }
      /**
       * An accessor for creating requests from the SchemaRegistries collection.
       *
       * <p>The typical use is:</p>
       * <pre>
       *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
       *   {@code ManagedKafka.SchemaRegistries.List request = managedkafka.schemaRegistries().list(parameters ...)}
       * </pre>
       *
       * @return the resource collection
       */
      public SchemaRegistries schemaRegistries() {
        return new SchemaRegistries();
      }

      /**
       * The "schemaRegistries" collection of methods.
       */
      public class SchemaRegistries {

        /**
         * Create a schema registry instance.
         *
         * Create a request for the method "schemaRegistries.create".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Create#execute()} method to invoke the remote operation.
         *
         * @param parent Required. The parent whose schema registry instance is to be created. Structured like:
         *        `projects/{project}/locations/{location}`
         * @param content the {@link com.google.api.services.managedkafka.v1.model.CreateSchemaRegistryRequest}
         * @return the request
         */
        public Create create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.CreateSchemaRegistryRequest content) throws java.io.IOException {
          Create result = new Create(parent, content);
          initialize(result);
          return result;
        }

        public class Create extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.SchemaRegistry> {

          private static final String REST_PATH = "v1/{+parent}/schemaRegistries";

          private final java.util.regex.Pattern PARENT_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+$");

          /**
           * Create a schema registry instance.
           *
           * Create a request for the method "schemaRegistries.create".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
           * <p> {@link
           * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
           * be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param parent Required. The parent whose schema registry instance is to be created. Structured like:
         *        `projects/{project}/locations/{location}`
           * @param content the {@link com.google.api.services.managedkafka.v1.model.CreateSchemaRegistryRequest}
           * @since 1.13
           */
          protected Create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.CreateSchemaRegistryRequest content) {
            super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.SchemaRegistry.class);
            this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
          }

          @Override
          public Create set$Xgafv(java.lang.String $Xgafv) {
            return (Create) super.set$Xgafv($Xgafv);
          }

          @Override
          public Create setAccessToken(java.lang.String accessToken) {
            return (Create) super.setAccessToken(accessToken);
          }

          @Override
          public Create setAlt(java.lang.String alt) {
            return (Create) super.setAlt(alt);
          }

          @Override
          public Create setCallback(java.lang.String callback) {
            return (Create) super.setCallback(callback);
          }

          @Override
          public Create setFields(java.lang.String fields) {
            return (Create) super.setFields(fields);
          }

          @Override
          public Create setKey(java.lang.String key) {
            return (Create) super.setKey(key);
          }

          @Override
          public Create setOauthToken(java.lang.String oauthToken) {
            return (Create) super.setOauthToken(oauthToken);
          }

          @Override
          public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Create) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Create setQuotaUser(java.lang.String quotaUser) {
            return (Create) super.setQuotaUser(quotaUser);
          }

          @Override
          public Create setUploadType(java.lang.String uploadType) {
            return (Create) super.setUploadType(uploadType);
          }

          @Override
          public Create setUploadProtocol(java.lang.String uploadProtocol) {
            return (Create) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Required. The parent whose schema registry instance is to be created. Structured like:
           * `projects/{project}/locations/{location}`
           */
          @com.google.api.client.util.Key
          private java.lang.String parent;

          /** Required. The parent whose schema registry instance is to be created. Structured like:
         `projects/{project}/locations/{location}`
           */
          public java.lang.String getParent() {
            return parent;
          }

          /**
           * Required. The parent whose schema registry instance is to be created. Structured like:
           * `projects/{project}/locations/{location}`
           */
          public Create setParent(java.lang.String parent) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
            this.parent = parent;
            return this;
          }

          @Override
          public Create set(String parameterName, Object value) {
            return (Create) super.set(parameterName, value);
          }
        }
        /**
         * Delete a schema registry instance.
         *
         * Create a request for the method "schemaRegistries.delete".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
         *
         * @param name Required. The name of the schema registry instance to delete. Structured like:
         *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
         * @return the request
         */
        public Delete delete(java.lang.String name) throws java.io.IOException {
          Delete result = new Delete(name);
          initialize(result);
          return result;
        }

        public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Empty> {

          private static final String REST_PATH = "v1/{+name}";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+$");

          /**
           * Delete a schema registry instance.
           *
           * Create a request for the method "schemaRegistries.delete".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
           * <p> {@link
           * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
           * be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name Required. The name of the schema registry instance to delete. Structured like:
         *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
           * @since 1.13
           */
          protected Delete(java.lang.String name) {
            super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Empty.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+$");
            }
          }

          @Override
          public Delete set$Xgafv(java.lang.String $Xgafv) {
            return (Delete) super.set$Xgafv($Xgafv);
          }

          @Override
          public Delete setAccessToken(java.lang.String accessToken) {
            return (Delete) super.setAccessToken(accessToken);
          }

          @Override
          public Delete setAlt(java.lang.String alt) {
            return (Delete) super.setAlt(alt);
          }

          @Override
          public Delete setCallback(java.lang.String callback) {
            return (Delete) super.setCallback(callback);
          }

          @Override
          public Delete setFields(java.lang.String fields) {
            return (Delete) super.setFields(fields);
          }

          @Override
          public Delete setKey(java.lang.String key) {
            return (Delete) super.setKey(key);
          }

          @Override
          public Delete setOauthToken(java.lang.String oauthToken) {
            return (Delete) super.setOauthToken(oauthToken);
          }

          @Override
          public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Delete) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Delete setQuotaUser(java.lang.String quotaUser) {
            return (Delete) super.setQuotaUser(quotaUser);
          }

          @Override
          public Delete setUploadType(java.lang.String uploadType) {
            return (Delete) super.setUploadType(uploadType);
          }

          @Override
          public Delete setUploadProtocol(java.lang.String uploadProtocol) {
            return (Delete) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Required. The name of the schema registry instance to delete. Structured like:
           * `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
           */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** Required. The name of the schema registry instance to delete. Structured like:
         `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
           */
          public java.lang.String getName() {
            return name;
          }

          /**
           * Required. The name of the schema registry instance to delete. Structured like:
           * `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
           */
          public Delete setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+$");
            }
            this.name = name;
            return this;
          }

          @Override
          public Delete set(String parameterName, Object value) {
            return (Delete) super.set(parameterName, value);
          }
        }
        /**
         * Get the schema registry instance.
         *
         * Create a request for the method "schemaRegistries.get".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link Get#execute()} method to invoke the remote operation.
         *
         * @param name Required. The name of the schema registry instance to return. Structured like:
         *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
         * @return the request
         */
        public Get get(java.lang.String name) throws java.io.IOException {
          Get result = new Get(name);
          initialize(result);
          return result;
        }

        public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.SchemaRegistry> {

          private static final String REST_PATH = "v1/{+name}";

          private final java.util.regex.Pattern NAME_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+$");

          /**
           * Get the schema registry instance.
           *
           * Create a request for the method "schemaRegistries.get".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
           * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
           * must be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param name Required. The name of the schema registry instance to return. Structured like:
         *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
           * @since 1.13
           */
          protected Get(java.lang.String name) {
            super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.SchemaRegistry.class);
            this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+$");
            }
          }

          @Override
          public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
            return super.executeUsingHead();
          }

          @Override
          public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
            return super.buildHttpRequestUsingHead();
          }

          @Override
          public Get set$Xgafv(java.lang.String $Xgafv) {
            return (Get) super.set$Xgafv($Xgafv);
          }

          @Override
          public Get setAccessToken(java.lang.String accessToken) {
            return (Get) super.setAccessToken(accessToken);
          }

          @Override
          public Get setAlt(java.lang.String alt) {
            return (Get) super.setAlt(alt);
          }

          @Override
          public Get setCallback(java.lang.String callback) {
            return (Get) super.setCallback(callback);
          }

          @Override
          public Get setFields(java.lang.String fields) {
            return (Get) super.setFields(fields);
          }

          @Override
          public Get setKey(java.lang.String key) {
            return (Get) super.setKey(key);
          }

          @Override
          public Get setOauthToken(java.lang.String oauthToken) {
            return (Get) super.setOauthToken(oauthToken);
          }

          @Override
          public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (Get) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public Get setQuotaUser(java.lang.String quotaUser) {
            return (Get) super.setQuotaUser(quotaUser);
          }

          @Override
          public Get setUploadType(java.lang.String uploadType) {
            return (Get) super.setUploadType(uploadType);
          }

          @Override
          public Get setUploadProtocol(java.lang.String uploadProtocol) {
            return (Get) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Required. The name of the schema registry instance to return. Structured like:
           * `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
           */
          @com.google.api.client.util.Key
          private java.lang.String name;

          /** Required. The name of the schema registry instance to return. Structured like:
         `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
           */
          public java.lang.String getName() {
            return name;
          }

          /**
           * Required. The name of the schema registry instance to return. Structured like:
           * `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
           */
          public Get setName(java.lang.String name) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                  "Parameter name must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+$");
            }
            this.name = name;
            return this;
          }

          @Override
          public Get set(String parameterName, Object value) {
            return (Get) super.set(parameterName, value);
          }
        }
        /**
         * List schema registries.
         *
         * Create a request for the method "schemaRegistries.list".
         *
         * This request holds the parameters needed by the managedkafka server.  After setting any optional
         * parameters, call the {@link List#execute()} method to invoke the remote operation.
         *
         * @param parent Required. The parent whose schema registry instances are to be listed. Structured like:
         *        `projects/{project}/locations/{location}`
         * @return the request
         */
        public List list(java.lang.String parent) throws java.io.IOException {
          List result = new List(parent);
          initialize(result);
          return result;
        }

        public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.ListSchemaRegistriesResponse> {

          private static final String REST_PATH = "v1/{+parent}/schemaRegistries";

          private final java.util.regex.Pattern PARENT_PATTERN =
              java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+$");

          /**
           * List schema registries.
           *
           * Create a request for the method "schemaRegistries.list".
           *
           * This request holds the parameters needed by the the managedkafka server.  After setting any
           * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
           * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
           * must be called to initialize this instance immediately after invoking the constructor. </p>
           *
           * @param parent Required. The parent whose schema registry instances are to be listed. Structured like:
         *        `projects/{project}/locations/{location}`
           * @since 1.13
           */
          protected List(java.lang.String parent) {
            super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.ListSchemaRegistriesResponse.class);
            this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
          }

          @Override
          public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
            return super.executeUsingHead();
          }

          @Override
          public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
            return super.buildHttpRequestUsingHead();
          }

          @Override
          public List set$Xgafv(java.lang.String $Xgafv) {
            return (List) super.set$Xgafv($Xgafv);
          }

          @Override
          public List setAccessToken(java.lang.String accessToken) {
            return (List) super.setAccessToken(accessToken);
          }

          @Override
          public List setAlt(java.lang.String alt) {
            return (List) super.setAlt(alt);
          }

          @Override
          public List setCallback(java.lang.String callback) {
            return (List) super.setCallback(callback);
          }

          @Override
          public List setFields(java.lang.String fields) {
            return (List) super.setFields(fields);
          }

          @Override
          public List setKey(java.lang.String key) {
            return (List) super.setKey(key);
          }

          @Override
          public List setOauthToken(java.lang.String oauthToken) {
            return (List) super.setOauthToken(oauthToken);
          }

          @Override
          public List setPrettyPrint(java.lang.Boolean prettyPrint) {
            return (List) super.setPrettyPrint(prettyPrint);
          }

          @Override
          public List setQuotaUser(java.lang.String quotaUser) {
            return (List) super.setQuotaUser(quotaUser);
          }

          @Override
          public List setUploadType(java.lang.String uploadType) {
            return (List) super.setUploadType(uploadType);
          }

          @Override
          public List setUploadProtocol(java.lang.String uploadProtocol) {
            return (List) super.setUploadProtocol(uploadProtocol);
          }

          /**
           * Required. The parent whose schema registry instances are to be listed. Structured like:
           * `projects/{project}/locations/{location}`
           */
          @com.google.api.client.util.Key
          private java.lang.String parent;

          /** Required. The parent whose schema registry instances are to be listed. Structured like:
         `projects/{project}/locations/{location}`
           */
          public java.lang.String getParent() {
            return parent;
          }

          /**
           * Required. The parent whose schema registry instances are to be listed. Structured like:
           * `projects/{project}/locations/{location}`
           */
          public List setParent(java.lang.String parent) {
            if (!getSuppressPatternChecks()) {
              com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                  "Parameter parent must conform to the pattern " +
                  "^projects/[^/]+/locations/[^/]+$");
            }
            this.parent = parent;
            return this;
          }

          @Override
          public List set(String parameterName, Object value) {
            return (List) super.set(parameterName, value);
          }
        }

        /**
         * An accessor for creating requests from the Compatibility collection.
         *
         * <p>The typical use is:</p>
         * <pre>
         *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
         *   {@code ManagedKafka.Compatibility.List request = managedkafka.compatibility().list(parameters ...)}
         * </pre>
         *
         * @return the resource collection
         */
        public Compatibility compatibility() {
          return new Compatibility();
        }

        /**
         * The "compatibility" collection of methods.
         */
        public class Compatibility {

          /**
           * Check compatibility of a schema with all versions or a specific version of a subject.
           *
           * Create a request for the method "compatibility.checkCompatibility".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link CheckCompatibility#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the resource to check compatibility for. The format is either of following: *
           *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/s
           *        ubjects/versions: Check compatibility with one or more versions of the specified subject.
           *        * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility
           *        /subjects/{subject}/versions/{version}: Check compatibility with a specific version of the
           *        subject.
           * @param content the {@link com.google.api.services.managedkafka.v1.model.CheckCompatibilityRequest}
           * @return the request
           */
          public CheckCompatibility checkCompatibility(java.lang.String name, com.google.api.services.managedkafka.v1.model.CheckCompatibilityRequest content) throws java.io.IOException {
            CheckCompatibility result = new CheckCompatibility(name, content);
            initialize(result);
            return result;
          }

          public class CheckCompatibility extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.CheckCompatibilityResponse> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/compatibility/.*$");

            /**
             * Check compatibility of a schema with all versions or a specific version of a subject.
             *
             * Create a request for the method "compatibility.checkCompatibility".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link CheckCompatibility#execute()} method to invoke the remote
             * operation. <p> {@link CheckCompatibility#initialize(com.google.api.client.googleapis.services.A
             * bstractGoogleClientRequest)} must be called to initialize this instance immediately after
             * invoking the constructor. </p>
             *
             * @param name Required. The name of the resource to check compatibility for. The format is either of following: *
           *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/s
           *        ubjects/versions: Check compatibility with one or more versions of the specified subject.
           *        * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility
           *        /subjects/{subject}/versions/{version}: Check compatibility with a specific version of the
           *        subject.
             * @param content the {@link com.google.api.services.managedkafka.v1.model.CheckCompatibilityRequest}
             * @since 1.13
             */
            protected CheckCompatibility(java.lang.String name, com.google.api.services.managedkafka.v1.model.CheckCompatibilityRequest content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.CheckCompatibilityResponse.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/compatibility/.*$");
              }
            }

            @Override
            public CheckCompatibility set$Xgafv(java.lang.String $Xgafv) {
              return (CheckCompatibility) super.set$Xgafv($Xgafv);
            }

            @Override
            public CheckCompatibility setAccessToken(java.lang.String accessToken) {
              return (CheckCompatibility) super.setAccessToken(accessToken);
            }

            @Override
            public CheckCompatibility setAlt(java.lang.String alt) {
              return (CheckCompatibility) super.setAlt(alt);
            }

            @Override
            public CheckCompatibility setCallback(java.lang.String callback) {
              return (CheckCompatibility) super.setCallback(callback);
            }

            @Override
            public CheckCompatibility setFields(java.lang.String fields) {
              return (CheckCompatibility) super.setFields(fields);
            }

            @Override
            public CheckCompatibility setKey(java.lang.String key) {
              return (CheckCompatibility) super.setKey(key);
            }

            @Override
            public CheckCompatibility setOauthToken(java.lang.String oauthToken) {
              return (CheckCompatibility) super.setOauthToken(oauthToken);
            }

            @Override
            public CheckCompatibility setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (CheckCompatibility) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public CheckCompatibility setQuotaUser(java.lang.String quotaUser) {
              return (CheckCompatibility) super.setQuotaUser(quotaUser);
            }

            @Override
            public CheckCompatibility setUploadType(java.lang.String uploadType) {
              return (CheckCompatibility) super.setUploadType(uploadType);
            }

            @Override
            public CheckCompatibility setUploadProtocol(java.lang.String uploadProtocol) {
              return (CheckCompatibility) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the resource to check compatibility for. The format is either
             * of following: * projects/{project}/locations/{location}/schemaRegistries/{schema_regi
             * stry}/compatibility/subjects/versions: Check compatibility with one or more versions
             * of the specified subject. * projects/{project}/locations/{location}/schemaRegistries/
             * {schema_registry}/compatibility/subjects/{subject}/versions/{version}: Check
             * compatibility with a specific version of the subject.
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the resource to check compatibility for. The format is either of following: *
           projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/v
           ersions: Check compatibility with one or more versions of the specified subject. * projects/{projec
           t}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/{subject}/version
           s/{version}: Check compatibility with a specific version of the subject.
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the resource to check compatibility for. The format is either
             * of following: * projects/{project}/locations/{location}/schemaRegistries/{schema_regi
             * stry}/compatibility/subjects/versions: Check compatibility with one or more versions
             * of the specified subject. * projects/{project}/locations/{location}/schemaRegistries/
             * {schema_registry}/compatibility/subjects/{subject}/versions/{version}: Check
             * compatibility with a specific version of the subject.
             */
            public CheckCompatibility setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/compatibility/.*$");
              }
              this.name = name;
              return this;
            }

            @Override
            public CheckCompatibility set(String parameterName, Object value) {
              return (CheckCompatibility) super.set(parameterName, value);
            }
          }

        }
        /**
         * An accessor for creating requests from the Config collection.
         *
         * <p>The typical use is:</p>
         * <pre>
         *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
         *   {@code ManagedKafka.Config.List request = managedkafka.config().list(parameters ...)}
         * </pre>
         *
         * @return the resource collection
         */
        public Config config() {
          return new Config();
        }

        /**
         * The "config" collection of methods.
         */
        public class Config {

          /**
           * Delete schema config for a subject.
           *
           * Create a request for the method "config.delete".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
           *
           * @param name Required. The resource name of subject to delete the config for. The format is *
           *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject
           *        }
           * @return the request
           */
          public Delete delete(java.lang.String name) throws java.io.IOException {
            Delete result = new Delete(name);
            initialize(result);
            return result;
          }

          public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.SchemaConfig> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/config/.*$");

            /**
             * Delete schema config for a subject.
             *
             * Create a request for the method "config.delete".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
             * <p> {@link
             * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The resource name of subject to delete the config for. The format is *
           *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject
           *        }
             * @since 1.13
             */
            protected Delete(java.lang.String name) {
              super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.SchemaConfig.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/config/.*$");
              }
            }

            @Override
            public Delete set$Xgafv(java.lang.String $Xgafv) {
              return (Delete) super.set$Xgafv($Xgafv);
            }

            @Override
            public Delete setAccessToken(java.lang.String accessToken) {
              return (Delete) super.setAccessToken(accessToken);
            }

            @Override
            public Delete setAlt(java.lang.String alt) {
              return (Delete) super.setAlt(alt);
            }

            @Override
            public Delete setCallback(java.lang.String callback) {
              return (Delete) super.setCallback(callback);
            }

            @Override
            public Delete setFields(java.lang.String fields) {
              return (Delete) super.setFields(fields);
            }

            @Override
            public Delete setKey(java.lang.String key) {
              return (Delete) super.setKey(key);
            }

            @Override
            public Delete setOauthToken(java.lang.String oauthToken) {
              return (Delete) super.setOauthToken(oauthToken);
            }

            @Override
            public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Delete) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Delete setQuotaUser(java.lang.String quotaUser) {
              return (Delete) super.setQuotaUser(quotaUser);
            }

            @Override
            public Delete setUploadType(java.lang.String uploadType) {
              return (Delete) super.setUploadType(uploadType);
            }

            @Override
            public Delete setUploadProtocol(java.lang.String uploadProtocol) {
              return (Delete) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The resource name of subject to delete the config for. The format is * proj
             * ects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subjec
             * t}
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The resource name of subject to delete the config for. The format is *
           projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The resource name of subject to delete the config for. The format is * proj
             * ects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subjec
             * t}
             */
            public Delete setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/config/.*$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Delete set(String parameterName, Object value) {
              return (Delete) super.set(parameterName, value);
            }
          }
          /**
           * Get schema config at global level or for a subject.
           *
           * Create a request for the method "config.get".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Get#execute()} method to invoke the remote operation.
           *
           * @param name Required. The resource name to get the config for. It can be either of following: *
           *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Get
           *        config at global level. * projects/{project}/locations/{location}/schemaRegistries/{schema
           *        _registry}/config/{subject}: Get config for a specific subject.
           * @return the request
           */
          public Get get(java.lang.String name) throws java.io.IOException {
            Get result = new Get(name);
            initialize(result);
            return result;
          }

          public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.SchemaConfig> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/config/.*$");

            /**
             * Get schema config at global level or for a subject.
             *
             * Create a request for the method "config.get".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
             * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The resource name to get the config for. It can be either of following: *
           *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Get
           *        config at global level. * projects/{project}/locations/{location}/schemaRegistries/{schema
           *        _registry}/config/{subject}: Get config for a specific subject.
             * @since 1.13
             */
            protected Get(java.lang.String name) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.SchemaConfig.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/config/.*$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public Get set$Xgafv(java.lang.String $Xgafv) {
              return (Get) super.set$Xgafv($Xgafv);
            }

            @Override
            public Get setAccessToken(java.lang.String accessToken) {
              return (Get) super.setAccessToken(accessToken);
            }

            @Override
            public Get setAlt(java.lang.String alt) {
              return (Get) super.setAlt(alt);
            }

            @Override
            public Get setCallback(java.lang.String callback) {
              return (Get) super.setCallback(callback);
            }

            @Override
            public Get setFields(java.lang.String fields) {
              return (Get) super.setFields(fields);
            }

            @Override
            public Get setKey(java.lang.String key) {
              return (Get) super.setKey(key);
            }

            @Override
            public Get setOauthToken(java.lang.String oauthToken) {
              return (Get) super.setOauthToken(oauthToken);
            }

            @Override
            public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Get) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Get setQuotaUser(java.lang.String quotaUser) {
              return (Get) super.setQuotaUser(quotaUser);
            }

            @Override
            public Get setUploadType(java.lang.String uploadType) {
              return (Get) super.setUploadType(uploadType);
            }

            @Override
            public Get setUploadProtocol(java.lang.String uploadProtocol) {
              return (Get) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The resource name to get the config for. It can be either of following: *
             * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config:
             * Get config at global level. * projects/{project}/locations/{location}/schemaRegistrie
             * s/{schema_registry}/config/{subject}: Get config for a specific subject.
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The resource name to get the config for. It can be either of following: *
           projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Get config at
           global level. *
           projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}: Get
           config for a specific subject.
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The resource name to get the config for. It can be either of following: *
             * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config:
             * Get config at global level. * projects/{project}/locations/{location}/schemaRegistrie
             * s/{schema_registry}/config/{subject}: Get config for a specific subject.
             */
            public Get setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/config/.*$");
              }
              this.name = name;
              return this;
            }

            /**
             * Optional. If true, the config will fall back to the config at the global level if no
             * subject level config is found.
             */
            @com.google.api.client.util.Key
            private java.lang.Boolean defaultToGlobal;

            /** Optional. If true, the config will fall back to the config at the global level if no subject level
           config is found.
             */
            public java.lang.Boolean getDefaultToGlobal() {
              return defaultToGlobal;
            }

            /**
             * Optional. If true, the config will fall back to the config at the global level if no
             * subject level config is found.
             */
            public Get setDefaultToGlobal(java.lang.Boolean defaultToGlobal) {
              this.defaultToGlobal = defaultToGlobal;
              return this;
            }

            @Override
            public Get set(String parameterName, Object value) {
              return (Get) super.set(parameterName, value);
            }
          }
          /**
           * Update config at global level or for a subject. Creates a SchemaSubject-level SchemaConfig if it
           * does not exist.
           *
           * Create a request for the method "config.update".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Update#execute()} method to invoke the remote operation.
           *
           * @param name Required. The resource name to update the config for. It can be either of following: *
           *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Update
           *        config at global level. * projects/{project}/locations/{location}/schemaRegistries/{schema
           *        _registry}/config/{subject}: Update config for a specific subject.
           * @param content the {@link com.google.api.services.managedkafka.v1.model.UpdateSchemaConfigRequest}
           * @return the request
           */
          public Update update(java.lang.String name, com.google.api.services.managedkafka.v1.model.UpdateSchemaConfigRequest content) throws java.io.IOException {
            Update result = new Update(name, content);
            initialize(result);
            return result;
          }

          public class Update extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.SchemaConfig> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/config/.*$");

            /**
             * Update config at global level or for a subject. Creates a SchemaSubject-level SchemaConfig if
             * it does not exist.
             *
             * Create a request for the method "config.update".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Update#execute()} method to invoke the remote operation.
             * <p> {@link
             * Update#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The resource name to update the config for. It can be either of following: *
           *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Update
           *        config at global level. * projects/{project}/locations/{location}/schemaRegistries/{schema
           *        _registry}/config/{subject}: Update config for a specific subject.
             * @param content the {@link com.google.api.services.managedkafka.v1.model.UpdateSchemaConfigRequest}
             * @since 1.13
             */
            protected Update(java.lang.String name, com.google.api.services.managedkafka.v1.model.UpdateSchemaConfigRequest content) {
              super(ManagedKafka.this, "PUT", REST_PATH, content, com.google.api.services.managedkafka.v1.model.SchemaConfig.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/config/.*$");
              }
            }

            @Override
            public Update set$Xgafv(java.lang.String $Xgafv) {
              return (Update) super.set$Xgafv($Xgafv);
            }

            @Override
            public Update setAccessToken(java.lang.String accessToken) {
              return (Update) super.setAccessToken(accessToken);
            }

            @Override
            public Update setAlt(java.lang.String alt) {
              return (Update) super.setAlt(alt);
            }

            @Override
            public Update setCallback(java.lang.String callback) {
              return (Update) super.setCallback(callback);
            }

            @Override
            public Update setFields(java.lang.String fields) {
              return (Update) super.setFields(fields);
            }

            @Override
            public Update setKey(java.lang.String key) {
              return (Update) super.setKey(key);
            }

            @Override
            public Update setOauthToken(java.lang.String oauthToken) {
              return (Update) super.setOauthToken(oauthToken);
            }

            @Override
            public Update setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Update) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Update setQuotaUser(java.lang.String quotaUser) {
              return (Update) super.setQuotaUser(quotaUser);
            }

            @Override
            public Update setUploadType(java.lang.String uploadType) {
              return (Update) super.setUploadType(uploadType);
            }

            @Override
            public Update setUploadProtocol(java.lang.String uploadProtocol) {
              return (Update) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The resource name to update the config for. It can be either of following:
             * * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config:
             * Update config at global level. * projects/{project}/locations/{location}/schemaRegist
             * ries/{schema_registry}/config/{subject}: Update config for a specific subject.
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The resource name to update the config for. It can be either of following: *
           projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Update config at
           global level. *
           projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}: Update
           config for a specific subject.
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The resource name to update the config for. It can be either of following:
             * * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config:
             * Update config at global level. * projects/{project}/locations/{location}/schemaRegist
             * ries/{schema_registry}/config/{subject}: Update config for a specific subject.
             */
            public Update setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/config/.*$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Update set(String parameterName, Object value) {
              return (Update) super.set(parameterName, value);
            }
          }

        }
        /**
         * An accessor for creating requests from the Contexts collection.
         *
         * <p>The typical use is:</p>
         * <pre>
         *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
         *   {@code ManagedKafka.Contexts.List request = managedkafka.contexts().list(parameters ...)}
         * </pre>
         *
         * @return the resource collection
         */
        public Contexts contexts() {
          return new Contexts();
        }

        /**
         * The "contexts" collection of methods.
         */
        public class Contexts {

          /**
           * Get the context.
           *
           * Create a request for the method "contexts.get".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Get#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the context to return. Structured like:
           *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{cont
           *        ext}`
           * @return the request
           */
          public Get get(java.lang.String name) throws java.io.IOException {
            Get result = new Get(name);
            initialize(result);
            return result;
          }

          public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Context> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+$");

            /**
             * Get the context.
             *
             * Create a request for the method "contexts.get".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
             * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the context to return. Structured like:
           *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{cont
           *        ext}`
             * @since 1.13
             */
            protected Get(java.lang.String name) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Context.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public Get set$Xgafv(java.lang.String $Xgafv) {
              return (Get) super.set$Xgafv($Xgafv);
            }

            @Override
            public Get setAccessToken(java.lang.String accessToken) {
              return (Get) super.setAccessToken(accessToken);
            }

            @Override
            public Get setAlt(java.lang.String alt) {
              return (Get) super.setAlt(alt);
            }

            @Override
            public Get setCallback(java.lang.String callback) {
              return (Get) super.setCallback(callback);
            }

            @Override
            public Get setFields(java.lang.String fields) {
              return (Get) super.setFields(fields);
            }

            @Override
            public Get setKey(java.lang.String key) {
              return (Get) super.setKey(key);
            }

            @Override
            public Get setOauthToken(java.lang.String oauthToken) {
              return (Get) super.setOauthToken(oauthToken);
            }

            @Override
            public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Get) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Get setQuotaUser(java.lang.String quotaUser) {
              return (Get) super.setQuotaUser(quotaUser);
            }

            @Override
            public Get setUploadType(java.lang.String uploadType) {
              return (Get) super.setUploadType(uploadType);
            }

            @Override
            public Get setUploadProtocol(java.lang.String uploadProtocol) {
              return (Get) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the context to return. Structured like: `projects/{project}/loc
             * ations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the context to return. Structured like:
           `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the context to return. Structured like: `projects/{project}/loc
             * ations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
             */
            public Get setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Get set(String parameterName, Object value) {
              return (Get) super.set(parameterName, value);
            }
          }
          /**
           * List contexts for a schema registry.
           *
           * Create a request for the method "contexts.list".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link List#execute()} method to invoke the remote operation.
           *
           * @param parent Required. The parent of the contexts. Structured like:
           *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
           * @return the request
           */
          public List list(java.lang.String parent) throws java.io.IOException {
            List result = new List(parent);
            initialize(result);
            return result;
          }

          public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

            private static final String REST_PATH = "v1/{+parent}/contexts";

            private final java.util.regex.Pattern PARENT_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+$");

            /**
             * List contexts for a schema registry.
             *
             * Create a request for the method "contexts.list".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
             * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param parent Required. The parent of the contexts. Structured like:
           *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
             * @since 1.13
             */
            protected List(java.lang.String parent) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
              this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public List set$Xgafv(java.lang.String $Xgafv) {
              return (List) super.set$Xgafv($Xgafv);
            }

            @Override
            public List setAccessToken(java.lang.String accessToken) {
              return (List) super.setAccessToken(accessToken);
            }

            @Override
            public List setAlt(java.lang.String alt) {
              return (List) super.setAlt(alt);
            }

            @Override
            public List setCallback(java.lang.String callback) {
              return (List) super.setCallback(callback);
            }

            @Override
            public List setFields(java.lang.String fields) {
              return (List) super.setFields(fields);
            }

            @Override
            public List setKey(java.lang.String key) {
              return (List) super.setKey(key);
            }

            @Override
            public List setOauthToken(java.lang.String oauthToken) {
              return (List) super.setOauthToken(oauthToken);
            }

            @Override
            public List setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (List) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public List setQuotaUser(java.lang.String quotaUser) {
              return (List) super.setQuotaUser(quotaUser);
            }

            @Override
            public List setUploadType(java.lang.String uploadType) {
              return (List) super.setUploadType(uploadType);
            }

            @Override
            public List setUploadProtocol(java.lang.String uploadProtocol) {
              return (List) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The parent of the contexts. Structured like:
             * `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
             */
            @com.google.api.client.util.Key
            private java.lang.String parent;

            /** Required. The parent of the contexts. Structured like:
           `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
             */
            public java.lang.String getParent() {
              return parent;
            }

            /**
             * Required. The parent of the contexts. Structured like:
             * `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
             */
            public List setParent(java.lang.String parent) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+$");
              }
              this.parent = parent;
              return this;
            }

            @Override
            public List set(String parameterName, Object value) {
              return (List) super.set(parameterName, value);
            }
          }

          /**
           * An accessor for creating requests from the Compatibility collection.
           *
           * <p>The typical use is:</p>
           * <pre>
           *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
           *   {@code ManagedKafka.Compatibility.List request = managedkafka.compatibility().list(parameters ...)}
           * </pre>
           *
           * @return the resource collection
           */
          public Compatibility compatibility() {
            return new Compatibility();
          }

          /**
           * The "compatibility" collection of methods.
           */
          public class Compatibility {

            /**
             * Check compatibility of a schema with all versions or a specific version of a subject.
             *
             * Create a request for the method "compatibility.checkCompatibility".
             *
             * This request holds the parameters needed by the managedkafka server.  After setting any optional
             * parameters, call the {@link CheckCompatibility#execute()} method to invoke the remote operation.
             *
             * @param name Required. The name of the resource to check compatibility for. The format is either of following: *
             *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/s
             *        ubjects/versions: Check compatibility with one or more versions of the specified subject.
             *        * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility
             *        /subjects/{subject}/versions/{version}: Check compatibility with a specific version of the
             *        subject.
             * @param content the {@link com.google.api.services.managedkafka.v1.model.CheckCompatibilityRequest}
             * @return the request
             */
            public CheckCompatibility checkCompatibility(java.lang.String name, com.google.api.services.managedkafka.v1.model.CheckCompatibilityRequest content) throws java.io.IOException {
              CheckCompatibility result = new CheckCompatibility(name, content);
              initialize(result);
              return result;
            }

            public class CheckCompatibility extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.CheckCompatibilityResponse> {

              private static final String REST_PATH = "v1/{+name}";

              private final java.util.regex.Pattern NAME_PATTERN =
                  java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/compatibility/.*$");

              /**
               * Check compatibility of a schema with all versions or a specific version of a subject.
               *
               * Create a request for the method "compatibility.checkCompatibility".
               *
               * This request holds the parameters needed by the the managedkafka server.  After setting any
               * optional parameters, call the {@link CheckCompatibility#execute()} method to invoke the remote
               * operation. <p> {@link CheckCompatibility#initialize(com.google.api.client.googleapis.services.A
               * bstractGoogleClientRequest)} must be called to initialize this instance immediately after
               * invoking the constructor. </p>
               *
               * @param name Required. The name of the resource to check compatibility for. The format is either of following: *
             *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/s
             *        ubjects/versions: Check compatibility with one or more versions of the specified subject.
             *        * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility
             *        /subjects/{subject}/versions/{version}: Check compatibility with a specific version of the
             *        subject.
               * @param content the {@link com.google.api.services.managedkafka.v1.model.CheckCompatibilityRequest}
               * @since 1.13
               */
              protected CheckCompatibility(java.lang.String name, com.google.api.services.managedkafka.v1.model.CheckCompatibilityRequest content) {
                super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.CheckCompatibilityResponse.class);
                this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/compatibility/.*$");
                }
              }

              @Override
              public CheckCompatibility set$Xgafv(java.lang.String $Xgafv) {
                return (CheckCompatibility) super.set$Xgafv($Xgafv);
              }

              @Override
              public CheckCompatibility setAccessToken(java.lang.String accessToken) {
                return (CheckCompatibility) super.setAccessToken(accessToken);
              }

              @Override
              public CheckCompatibility setAlt(java.lang.String alt) {
                return (CheckCompatibility) super.setAlt(alt);
              }

              @Override
              public CheckCompatibility setCallback(java.lang.String callback) {
                return (CheckCompatibility) super.setCallback(callback);
              }

              @Override
              public CheckCompatibility setFields(java.lang.String fields) {
                return (CheckCompatibility) super.setFields(fields);
              }

              @Override
              public CheckCompatibility setKey(java.lang.String key) {
                return (CheckCompatibility) super.setKey(key);
              }

              @Override
              public CheckCompatibility setOauthToken(java.lang.String oauthToken) {
                return (CheckCompatibility) super.setOauthToken(oauthToken);
              }

              @Override
              public CheckCompatibility setPrettyPrint(java.lang.Boolean prettyPrint) {
                return (CheckCompatibility) super.setPrettyPrint(prettyPrint);
              }

              @Override
              public CheckCompatibility setQuotaUser(java.lang.String quotaUser) {
                return (CheckCompatibility) super.setQuotaUser(quotaUser);
              }

              @Override
              public CheckCompatibility setUploadType(java.lang.String uploadType) {
                return (CheckCompatibility) super.setUploadType(uploadType);
              }

              @Override
              public CheckCompatibility setUploadProtocol(java.lang.String uploadProtocol) {
                return (CheckCompatibility) super.setUploadProtocol(uploadProtocol);
              }

              /**
               * Required. The name of the resource to check compatibility for. The format is either
               * of following: * projects/{project}/locations/{location}/schemaRegistries/{schema_re
               * gistry}/compatibility/subjects/versions: Check compatibility with one or more
               * versions of the specified subject. * projects/{project}/locations/{location}/schema
               * Registries/{schema_registry}/compatibility/subjects/{subject}/versions/{version}:
               * Check compatibility with a specific version of the subject.
               */
              @com.google.api.client.util.Key
              private java.lang.String name;

              /** Required. The name of the resource to check compatibility for. The format is either of following: *
             projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/v
             ersions: Check compatibility with one or more versions of the specified subject. * projects/{projec
             t}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/{subject}/version
             s/{version}: Check compatibility with a specific version of the subject.
               */
              public java.lang.String getName() {
                return name;
              }

              /**
               * Required. The name of the resource to check compatibility for. The format is either
               * of following: * projects/{project}/locations/{location}/schemaRegistries/{schema_re
               * gistry}/compatibility/subjects/versions: Check compatibility with one or more
               * versions of the specified subject. * projects/{project}/locations/{location}/schema
               * Registries/{schema_registry}/compatibility/subjects/{subject}/versions/{version}:
               * Check compatibility with a specific version of the subject.
               */
              public CheckCompatibility setName(java.lang.String name) {
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/compatibility/.*$");
                }
                this.name = name;
                return this;
              }

              @Override
              public CheckCompatibility set(String parameterName, Object value) {
                return (CheckCompatibility) super.set(parameterName, value);
              }
            }

          }
          /**
           * An accessor for creating requests from the Config collection.
           *
           * <p>The typical use is:</p>
           * <pre>
           *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
           *   {@code ManagedKafka.Config.List request = managedkafka.config().list(parameters ...)}
           * </pre>
           *
           * @return the resource collection
           */
          public Config config() {
            return new Config();
          }

          /**
           * The "config" collection of methods.
           */
          public class Config {

            /**
             * Delete schema config for a subject.
             *
             * Create a request for the method "config.delete".
             *
             * This request holds the parameters needed by the managedkafka server.  After setting any optional
             * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
             *
             * @param name Required. The resource name of subject to delete the config for. The format is *
             *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject
             *        }
             * @return the request
             */
            public Delete delete(java.lang.String name) throws java.io.IOException {
              Delete result = new Delete(name);
              initialize(result);
              return result;
            }

            public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.SchemaConfig> {

              private static final String REST_PATH = "v1/{+name}";

              private final java.util.regex.Pattern NAME_PATTERN =
                  java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/config/.*$");

              /**
               * Delete schema config for a subject.
               *
               * Create a request for the method "config.delete".
               *
               * This request holds the parameters needed by the the managedkafka server.  After setting any
               * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
               * <p> {@link
               * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
               * be called to initialize this instance immediately after invoking the constructor. </p>
               *
               * @param name Required. The resource name of subject to delete the config for. The format is *
             *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject
             *        }
               * @since 1.13
               */
              protected Delete(java.lang.String name) {
                super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.SchemaConfig.class);
                this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/config/.*$");
                }
              }

              @Override
              public Delete set$Xgafv(java.lang.String $Xgafv) {
                return (Delete) super.set$Xgafv($Xgafv);
              }

              @Override
              public Delete setAccessToken(java.lang.String accessToken) {
                return (Delete) super.setAccessToken(accessToken);
              }

              @Override
              public Delete setAlt(java.lang.String alt) {
                return (Delete) super.setAlt(alt);
              }

              @Override
              public Delete setCallback(java.lang.String callback) {
                return (Delete) super.setCallback(callback);
              }

              @Override
              public Delete setFields(java.lang.String fields) {
                return (Delete) super.setFields(fields);
              }

              @Override
              public Delete setKey(java.lang.String key) {
                return (Delete) super.setKey(key);
              }

              @Override
              public Delete setOauthToken(java.lang.String oauthToken) {
                return (Delete) super.setOauthToken(oauthToken);
              }

              @Override
              public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
                return (Delete) super.setPrettyPrint(prettyPrint);
              }

              @Override
              public Delete setQuotaUser(java.lang.String quotaUser) {
                return (Delete) super.setQuotaUser(quotaUser);
              }

              @Override
              public Delete setUploadType(java.lang.String uploadType) {
                return (Delete) super.setUploadType(uploadType);
              }

              @Override
              public Delete setUploadProtocol(java.lang.String uploadProtocol) {
                return (Delete) super.setUploadProtocol(uploadProtocol);
              }

              /**
               * Required. The resource name of subject to delete the config for. The format is * pr
               * ojects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{su
               * bject}
               */
              @com.google.api.client.util.Key
              private java.lang.String name;

              /** Required. The resource name of subject to delete the config for. The format is *
             projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}
               */
              public java.lang.String getName() {
                return name;
              }

              /**
               * Required. The resource name of subject to delete the config for. The format is * pr
               * ojects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{su
               * bject}
               */
              public Delete setName(java.lang.String name) {
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/config/.*$");
                }
                this.name = name;
                return this;
              }

              @Override
              public Delete set(String parameterName, Object value) {
                return (Delete) super.set(parameterName, value);
              }
            }
            /**
             * Get schema config at global level or for a subject.
             *
             * Create a request for the method "config.get".
             *
             * This request holds the parameters needed by the managedkafka server.  After setting any optional
             * parameters, call the {@link Get#execute()} method to invoke the remote operation.
             *
             * @param name Required. The resource name to get the config for. It can be either of following: *
             *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Get
             *        config at global level. * projects/{project}/locations/{location}/schemaRegistries/{schema
             *        _registry}/config/{subject}: Get config for a specific subject.
             * @return the request
             */
            public Get get(java.lang.String name) throws java.io.IOException {
              Get result = new Get(name);
              initialize(result);
              return result;
            }

            public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.SchemaConfig> {

              private static final String REST_PATH = "v1/{+name}";

              private final java.util.regex.Pattern NAME_PATTERN =
                  java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/config/.*$");

              /**
               * Get schema config at global level or for a subject.
               *
               * Create a request for the method "config.get".
               *
               * This request holds the parameters needed by the the managedkafka server.  After setting any
               * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
               * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
               * must be called to initialize this instance immediately after invoking the constructor. </p>
               *
               * @param name Required. The resource name to get the config for. It can be either of following: *
             *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Get
             *        config at global level. * projects/{project}/locations/{location}/schemaRegistries/{schema
             *        _registry}/config/{subject}: Get config for a specific subject.
               * @since 1.13
               */
              protected Get(java.lang.String name) {
                super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.SchemaConfig.class);
                this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/config/.*$");
                }
              }

              @Override
              public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
                return super.executeUsingHead();
              }

              @Override
              public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
                return super.buildHttpRequestUsingHead();
              }

              @Override
              public Get set$Xgafv(java.lang.String $Xgafv) {
                return (Get) super.set$Xgafv($Xgafv);
              }

              @Override
              public Get setAccessToken(java.lang.String accessToken) {
                return (Get) super.setAccessToken(accessToken);
              }

              @Override
              public Get setAlt(java.lang.String alt) {
                return (Get) super.setAlt(alt);
              }

              @Override
              public Get setCallback(java.lang.String callback) {
                return (Get) super.setCallback(callback);
              }

              @Override
              public Get setFields(java.lang.String fields) {
                return (Get) super.setFields(fields);
              }

              @Override
              public Get setKey(java.lang.String key) {
                return (Get) super.setKey(key);
              }

              @Override
              public Get setOauthToken(java.lang.String oauthToken) {
                return (Get) super.setOauthToken(oauthToken);
              }

              @Override
              public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
                return (Get) super.setPrettyPrint(prettyPrint);
              }

              @Override
              public Get setQuotaUser(java.lang.String quotaUser) {
                return (Get) super.setQuotaUser(quotaUser);
              }

              @Override
              public Get setUploadType(java.lang.String uploadType) {
                return (Get) super.setUploadType(uploadType);
              }

              @Override
              public Get setUploadProtocol(java.lang.String uploadProtocol) {
                return (Get) super.setUploadProtocol(uploadProtocol);
              }

              /**
               * Required. The resource name to get the config for. It can be either of following: *
               * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config:
               * Get config at global level. * projects/{project}/locations/{location}/schemaRegistr
               * ies/{schema_registry}/config/{subject}: Get config for a specific subject.
               */
              @com.google.api.client.util.Key
              private java.lang.String name;

              /** Required. The resource name to get the config for. It can be either of following: *
             projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Get config at
             global level. *
             projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}: Get
             config for a specific subject.
               */
              public java.lang.String getName() {
                return name;
              }

              /**
               * Required. The resource name to get the config for. It can be either of following: *
               * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config:
               * Get config at global level. * projects/{project}/locations/{location}/schemaRegistr
               * ies/{schema_registry}/config/{subject}: Get config for a specific subject.
               */
              public Get setName(java.lang.String name) {
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/config/.*$");
                }
                this.name = name;
                return this;
              }

              /**
               * Optional. If true, the config will fall back to the config at the global level if
               * no subject level config is found.
               */
              @com.google.api.client.util.Key
              private java.lang.Boolean defaultToGlobal;

              /** Optional. If true, the config will fall back to the config at the global level if no subject level
             config is found.
               */
              public java.lang.Boolean getDefaultToGlobal() {
                return defaultToGlobal;
              }

              /**
               * Optional. If true, the config will fall back to the config at the global level if
               * no subject level config is found.
               */
              public Get setDefaultToGlobal(java.lang.Boolean defaultToGlobal) {
                this.defaultToGlobal = defaultToGlobal;
                return this;
              }

              @Override
              public Get set(String parameterName, Object value) {
                return (Get) super.set(parameterName, value);
              }
            }
            /**
             * Update config at global level or for a subject. Creates a SchemaSubject-level SchemaConfig if it
             * does not exist.
             *
             * Create a request for the method "config.update".
             *
             * This request holds the parameters needed by the managedkafka server.  After setting any optional
             * parameters, call the {@link Update#execute()} method to invoke the remote operation.
             *
             * @param name Required. The resource name to update the config for. It can be either of following: *
             *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Update
             *        config at global level. * projects/{project}/locations/{location}/schemaRegistries/{schema
             *        _registry}/config/{subject}: Update config for a specific subject.
             * @param content the {@link com.google.api.services.managedkafka.v1.model.UpdateSchemaConfigRequest}
             * @return the request
             */
            public Update update(java.lang.String name, com.google.api.services.managedkafka.v1.model.UpdateSchemaConfigRequest content) throws java.io.IOException {
              Update result = new Update(name, content);
              initialize(result);
              return result;
            }

            public class Update extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.SchemaConfig> {

              private static final String REST_PATH = "v1/{+name}";

              private final java.util.regex.Pattern NAME_PATTERN =
                  java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/config/.*$");

              /**
               * Update config at global level or for a subject. Creates a SchemaSubject-level SchemaConfig if
               * it does not exist.
               *
               * Create a request for the method "config.update".
               *
               * This request holds the parameters needed by the the managedkafka server.  After setting any
               * optional parameters, call the {@link Update#execute()} method to invoke the remote operation.
               * <p> {@link
               * Update#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
               * be called to initialize this instance immediately after invoking the constructor. </p>
               *
               * @param name Required. The resource name to update the config for. It can be either of following: *
             *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Update
             *        config at global level. * projects/{project}/locations/{location}/schemaRegistries/{schema
             *        _registry}/config/{subject}: Update config for a specific subject.
               * @param content the {@link com.google.api.services.managedkafka.v1.model.UpdateSchemaConfigRequest}
               * @since 1.13
               */
              protected Update(java.lang.String name, com.google.api.services.managedkafka.v1.model.UpdateSchemaConfigRequest content) {
                super(ManagedKafka.this, "PUT", REST_PATH, content, com.google.api.services.managedkafka.v1.model.SchemaConfig.class);
                this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/config/.*$");
                }
              }

              @Override
              public Update set$Xgafv(java.lang.String $Xgafv) {
                return (Update) super.set$Xgafv($Xgafv);
              }

              @Override
              public Update setAccessToken(java.lang.String accessToken) {
                return (Update) super.setAccessToken(accessToken);
              }

              @Override
              public Update setAlt(java.lang.String alt) {
                return (Update) super.setAlt(alt);
              }

              @Override
              public Update setCallback(java.lang.String callback) {
                return (Update) super.setCallback(callback);
              }

              @Override
              public Update setFields(java.lang.String fields) {
                return (Update) super.setFields(fields);
              }

              @Override
              public Update setKey(java.lang.String key) {
                return (Update) super.setKey(key);
              }

              @Override
              public Update setOauthToken(java.lang.String oauthToken) {
                return (Update) super.setOauthToken(oauthToken);
              }

              @Override
              public Update setPrettyPrint(java.lang.Boolean prettyPrint) {
                return (Update) super.setPrettyPrint(prettyPrint);
              }

              @Override
              public Update setQuotaUser(java.lang.String quotaUser) {
                return (Update) super.setQuotaUser(quotaUser);
              }

              @Override
              public Update setUploadType(java.lang.String uploadType) {
                return (Update) super.setUploadType(uploadType);
              }

              @Override
              public Update setUploadProtocol(java.lang.String uploadProtocol) {
                return (Update) super.setUploadProtocol(uploadProtocol);
              }

              /**
               * Required. The resource name to update the config for. It can be either of
               * following: *
               * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config:
               * Update config at global level. * projects/{project}/locations/{location}/schemaRegi
               * stries/{schema_registry}/config/{subject}: Update config for a specific subject.
               */
              @com.google.api.client.util.Key
              private java.lang.String name;

              /** Required. The resource name to update the config for. It can be either of following: *
             projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Update config at
             global level. *
             projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}: Update
             config for a specific subject.
               */
              public java.lang.String getName() {
                return name;
              }

              /**
               * Required. The resource name to update the config for. It can be either of
               * following: *
               * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config:
               * Update config at global level. * projects/{project}/locations/{location}/schemaRegi
               * stries/{schema_registry}/config/{subject}: Update config for a specific subject.
               */
              public Update setName(java.lang.String name) {
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/config/.*$");
                }
                this.name = name;
                return this;
              }

              @Override
              public Update set(String parameterName, Object value) {
                return (Update) super.set(parameterName, value);
              }
            }

          }
          /**
           * An accessor for creating requests from the Mode collection.
           *
           * <p>The typical use is:</p>
           * <pre>
           *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
           *   {@code ManagedKafka.Mode.List request = managedkafka.mode().list(parameters ...)}
           * </pre>
           *
           * @return the resource collection
           */
          public Mode mode() {
            return new Mode();
          }

          /**
           * The "mode" collection of methods.
           */
          public class Mode {

            /**
             * Get mode at global level or for a subject.
             *
             * Create a request for the method "mode.get".
             *
             * This request holds the parameters needed by the managedkafka server.  After setting any optional
             * parameters, call the {@link Get#execute()} method to invoke the remote operation.
             *
             * @param name Required. The resource name of the mode. The format is *
             *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}:
             *        mode for a schema registry, or * projects/{project}/locations/{location}/schemaRegistries/
             *        {schema_registry}/contexts/{context}/mode/{subject}: mode for a specific subject in a
             *        specific context
             * @return the request
             */
            public Get get(java.lang.String name) throws java.io.IOException {
              Get result = new Get(name);
              initialize(result);
              return result;
            }

            public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.SchemaMode> {

              private static final String REST_PATH = "v1/{+name}";

              private final java.util.regex.Pattern NAME_PATTERN =
                  java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/mode/.*$");

              /**
               * Get mode at global level or for a subject.
               *
               * Create a request for the method "mode.get".
               *
               * This request holds the parameters needed by the the managedkafka server.  After setting any
               * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
               * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
               * must be called to initialize this instance immediately after invoking the constructor. </p>
               *
               * @param name Required. The resource name of the mode. The format is *
             *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}:
             *        mode for a schema registry, or * projects/{project}/locations/{location}/schemaRegistries/
             *        {schema_registry}/contexts/{context}/mode/{subject}: mode for a specific subject in a
             *        specific context
               * @since 1.13
               */
              protected Get(java.lang.String name) {
                super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.SchemaMode.class);
                this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/mode/.*$");
                }
              }

              @Override
              public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
                return super.executeUsingHead();
              }

              @Override
              public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
                return super.buildHttpRequestUsingHead();
              }

              @Override
              public Get set$Xgafv(java.lang.String $Xgafv) {
                return (Get) super.set$Xgafv($Xgafv);
              }

              @Override
              public Get setAccessToken(java.lang.String accessToken) {
                return (Get) super.setAccessToken(accessToken);
              }

              @Override
              public Get setAlt(java.lang.String alt) {
                return (Get) super.setAlt(alt);
              }

              @Override
              public Get setCallback(java.lang.String callback) {
                return (Get) super.setCallback(callback);
              }

              @Override
              public Get setFields(java.lang.String fields) {
                return (Get) super.setFields(fields);
              }

              @Override
              public Get setKey(java.lang.String key) {
                return (Get) super.setKey(key);
              }

              @Override
              public Get setOauthToken(java.lang.String oauthToken) {
                return (Get) super.setOauthToken(oauthToken);
              }

              @Override
              public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
                return (Get) super.setPrettyPrint(prettyPrint);
              }

              @Override
              public Get setQuotaUser(java.lang.String quotaUser) {
                return (Get) super.setQuotaUser(quotaUser);
              }

              @Override
              public Get setUploadType(java.lang.String uploadType) {
                return (Get) super.setUploadType(uploadType);
              }

              @Override
              public Get setUploadProtocol(java.lang.String uploadProtocol) {
                return (Get) super.setUploadProtocol(uploadProtocol);
              }

              /**
               * Required. The resource name of the mode. The format is * projects/{project}/locatio
               * ns/{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for a schema
               * registry, or * projects/{project}/locations/{location}/schemaRegistries/{schema_reg
               * istry}/contexts/{context}/mode/{subject}: mode for a specific subject in a specific
               * context
               */
              @com.google.api.client.util.Key
              private java.lang.String name;

              /** Required. The resource name of the mode. The format is *
             projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for
             a schema registry, or * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
             contexts/{context}/mode/{subject}: mode for a specific subject in a specific context
               */
              public java.lang.String getName() {
                return name;
              }

              /**
               * Required. The resource name of the mode. The format is * projects/{project}/locatio
               * ns/{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for a schema
               * registry, or * projects/{project}/locations/{location}/schemaRegistries/{schema_reg
               * istry}/contexts/{context}/mode/{subject}: mode for a specific subject in a specific
               * context
               */
              public Get setName(java.lang.String name) {
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/mode/.*$");
                }
                this.name = name;
                return this;
              }

              @Override
              public Get set(String parameterName, Object value) {
                return (Get) super.set(parameterName, value);
              }
            }
            /**
             * Update mode at global level or for a subject.
             *
             * Create a request for the method "mode.update".
             *
             * This request holds the parameters needed by the managedkafka server.  After setting any optional
             * parameters, call the {@link Update#execute()} method to invoke the remote operation.
             *
             * @param name Required. The resource name of the mode. The format is *
             *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}:
             *        mode for a schema registry, or * projects/{project}/locations/{location}/schemaRegistries/
             *        {schema_registry}/contexts/{context}/mode/{subject}: mode for a specific subject in a
             *        specific context
             * @param content the {@link com.google.api.services.managedkafka.v1.model.UpdateSchemaModeRequest}
             * @return the request
             */
            public Update update(java.lang.String name, com.google.api.services.managedkafka.v1.model.UpdateSchemaModeRequest content) throws java.io.IOException {
              Update result = new Update(name, content);
              initialize(result);
              return result;
            }

            public class Update extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.SchemaMode> {

              private static final String REST_PATH = "v1/{+name}";

              private final java.util.regex.Pattern NAME_PATTERN =
                  java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/mode/.*$");

              /**
               * Update mode at global level or for a subject.
               *
               * Create a request for the method "mode.update".
               *
               * This request holds the parameters needed by the the managedkafka server.  After setting any
               * optional parameters, call the {@link Update#execute()} method to invoke the remote operation.
               * <p> {@link
               * Update#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
               * be called to initialize this instance immediately after invoking the constructor. </p>
               *
               * @param name Required. The resource name of the mode. The format is *
             *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}:
             *        mode for a schema registry, or * projects/{project}/locations/{location}/schemaRegistries/
             *        {schema_registry}/contexts/{context}/mode/{subject}: mode for a specific subject in a
             *        specific context
               * @param content the {@link com.google.api.services.managedkafka.v1.model.UpdateSchemaModeRequest}
               * @since 1.13
               */
              protected Update(java.lang.String name, com.google.api.services.managedkafka.v1.model.UpdateSchemaModeRequest content) {
                super(ManagedKafka.this, "PUT", REST_PATH, content, com.google.api.services.managedkafka.v1.model.SchemaMode.class);
                this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/mode/.*$");
                }
              }

              @Override
              public Update set$Xgafv(java.lang.String $Xgafv) {
                return (Update) super.set$Xgafv($Xgafv);
              }

              @Override
              public Update setAccessToken(java.lang.String accessToken) {
                return (Update) super.setAccessToken(accessToken);
              }

              @Override
              public Update setAlt(java.lang.String alt) {
                return (Update) super.setAlt(alt);
              }

              @Override
              public Update setCallback(java.lang.String callback) {
                return (Update) super.setCallback(callback);
              }

              @Override
              public Update setFields(java.lang.String fields) {
                return (Update) super.setFields(fields);
              }

              @Override
              public Update setKey(java.lang.String key) {
                return (Update) super.setKey(key);
              }

              @Override
              public Update setOauthToken(java.lang.String oauthToken) {
                return (Update) super.setOauthToken(oauthToken);
              }

              @Override
              public Update setPrettyPrint(java.lang.Boolean prettyPrint) {
                return (Update) super.setPrettyPrint(prettyPrint);
              }

              @Override
              public Update setQuotaUser(java.lang.String quotaUser) {
                return (Update) super.setQuotaUser(quotaUser);
              }

              @Override
              public Update setUploadType(java.lang.String uploadType) {
                return (Update) super.setUploadType(uploadType);
              }

              @Override
              public Update setUploadProtocol(java.lang.String uploadProtocol) {
                return (Update) super.setUploadProtocol(uploadProtocol);
              }

              /**
               * Required. The resource name of the mode. The format is * projects/{project}/locatio
               * ns/{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for a schema
               * registry, or * projects/{project}/locations/{location}/schemaRegistries/{schema_reg
               * istry}/contexts/{context}/mode/{subject}: mode for a specific subject in a specific
               * context
               */
              @com.google.api.client.util.Key
              private java.lang.String name;

              /** Required. The resource name of the mode. The format is *
             projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for
             a schema registry, or * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
             contexts/{context}/mode/{subject}: mode for a specific subject in a specific context
               */
              public java.lang.String getName() {
                return name;
              }

              /**
               * Required. The resource name of the mode. The format is * projects/{project}/locatio
               * ns/{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for a schema
               * registry, or * projects/{project}/locations/{location}/schemaRegistries/{schema_reg
               * istry}/contexts/{context}/mode/{subject}: mode for a specific subject in a specific
               * context
               */
              public Update setName(java.lang.String name) {
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/mode/.*$");
                }
                this.name = name;
                return this;
              }

              @Override
              public Update set(String parameterName, Object value) {
                return (Update) super.set(parameterName, value);
              }
            }

          }
          /**
           * An accessor for creating requests from the Schemas collection.
           *
           * <p>The typical use is:</p>
           * <pre>
           *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
           *   {@code ManagedKafka.Schemas.List request = managedkafka.schemas().list(parameters ...)}
           * </pre>
           *
           * @return the resource collection
           */
          public Schemas schemas() {
            return new Schemas();
          }

          /**
           * The "schemas" collection of methods.
           */
          public class Schemas {

            /**
             * Get the schema for the given schema id.
             *
             * Create a request for the method "schemas.get".
             *
             * This request holds the parameters needed by the managedkafka server.  After setting any optional
             * parameters, call the {@link Get#execute()} method to invoke the remote operation.
             *
             * @param name Required. The name of the schema to return. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{s
             *        chema}`
             * @return the request
             */
            public Get get(java.lang.String name) throws java.io.IOException {
              Get result = new Get(name);
              initialize(result);
              return result;
            }

            public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Schema> {

              private static final String REST_PATH = "v1/{+name}";

              private final java.util.regex.Pattern NAME_PATTERN =
                  java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/schemas/.*$");

              /**
               * Get the schema for the given schema id.
               *
               * Create a request for the method "schemas.get".
               *
               * This request holds the parameters needed by the the managedkafka server.  After setting any
               * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
               * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
               * must be called to initialize this instance immediately after invoking the constructor. </p>
               *
               * @param name Required. The name of the schema to return. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{s
             *        chema}`
               * @since 1.13
               */
              protected Get(java.lang.String name) {
                super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Schema.class);
                this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/schemas/.*$");
                }
              }

              @Override
              public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
                return super.executeUsingHead();
              }

              @Override
              public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
                return super.buildHttpRequestUsingHead();
              }

              @Override
              public Get set$Xgafv(java.lang.String $Xgafv) {
                return (Get) super.set$Xgafv($Xgafv);
              }

              @Override
              public Get setAccessToken(java.lang.String accessToken) {
                return (Get) super.setAccessToken(accessToken);
              }

              @Override
              public Get setAlt(java.lang.String alt) {
                return (Get) super.setAlt(alt);
              }

              @Override
              public Get setCallback(java.lang.String callback) {
                return (Get) super.setCallback(callback);
              }

              @Override
              public Get setFields(java.lang.String fields) {
                return (Get) super.setFields(fields);
              }

              @Override
              public Get setKey(java.lang.String key) {
                return (Get) super.setKey(key);
              }

              @Override
              public Get setOauthToken(java.lang.String oauthToken) {
                return (Get) super.setOauthToken(oauthToken);
              }

              @Override
              public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
                return (Get) super.setPrettyPrint(prettyPrint);
              }

              @Override
              public Get setQuotaUser(java.lang.String quotaUser) {
                return (Get) super.setQuotaUser(quotaUser);
              }

              @Override
              public Get setUploadType(java.lang.String uploadType) {
                return (Get) super.setUploadType(uploadType);
              }

              @Override
              public Get setUploadProtocol(java.lang.String uploadProtocol) {
                return (Get) super.setUploadProtocol(uploadProtocol);
              }

              /**
               * Required. The name of the schema to return. Structured like: `projects/{project}/lo
               * cations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
               */
              @com.google.api.client.util.Key
              private java.lang.String name;

              /** Required. The name of the schema to return. Structured like:
             `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
               */
              public java.lang.String getName() {
                return name;
              }

              /**
               * Required. The name of the schema to return. Structured like: `projects/{project}/lo
               * cations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
               */
              public Get setName(java.lang.String name) {
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/schemas/.*$");
                }
                this.name = name;
                return this;
              }

              /**
               * Optional. Used to limit the search for the schema ID to a specific subject,
               * otherwise the schema ID will be searched for in all subjects in the given specified
               * context.
               */
              @com.google.api.client.util.Key
              private java.lang.String subject;

              /** Optional. Used to limit the search for the schema ID to a specific subject, otherwise the schema ID
             will be searched for in all subjects in the given specified context.
               */
              public java.lang.String getSubject() {
                return subject;
              }

              /**
               * Optional. Used to limit the search for the schema ID to a specific subject,
               * otherwise the schema ID will be searched for in all subjects in the given specified
               * context.
               */
              public Get setSubject(java.lang.String subject) {
                this.subject = subject;
                return this;
              }

              @Override
              public Get set(String parameterName, Object value) {
                return (Get) super.set(parameterName, value);
              }
            }
            /**
             * Get the schema string for the given schema id. The response will be the schema string.
             *
             * Create a request for the method "schemas.getSchema".
             *
             * This request holds the parameters needed by the managedkafka server.  After setting any optional
             * parameters, call the {@link GetSchema#execute()} method to invoke the remote operation.
             *
             * @param name Required. The name of the schema to return. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{s
             *        chema}`
             * @return the request
             */
            public GetSchema getSchema(java.lang.String name) throws java.io.IOException {
              GetSchema result = new GetSchema(name);
              initialize(result);
              return result;
            }

            public class GetSchema extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

              private static final String REST_PATH = "v1/{+name}/schema";

              private final java.util.regex.Pattern NAME_PATTERN =
                  java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/schemas/.*$");

              /**
               * Get the schema string for the given schema id. The response will be the schema string.
               *
               * Create a request for the method "schemas.getSchema".
               *
               * This request holds the parameters needed by the the managedkafka server.  After setting any
               * optional parameters, call the {@link GetSchema#execute()} method to invoke the remote
               * operation. <p> {@link
               * GetSchema#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
               * must be called to initialize this instance immediately after invoking the constructor. </p>
               *
               * @param name Required. The name of the schema to return. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{s
             *        chema}`
               * @since 1.13
               */
              protected GetSchema(java.lang.String name) {
                super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
                this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/schemas/.*$");
                }
              }

              @Override
              public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
                return super.executeUsingHead();
              }

              @Override
              public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
                return super.buildHttpRequestUsingHead();
              }

              @Override
              public GetSchema set$Xgafv(java.lang.String $Xgafv) {
                return (GetSchema) super.set$Xgafv($Xgafv);
              }

              @Override
              public GetSchema setAccessToken(java.lang.String accessToken) {
                return (GetSchema) super.setAccessToken(accessToken);
              }

              @Override
              public GetSchema setAlt(java.lang.String alt) {
                return (GetSchema) super.setAlt(alt);
              }

              @Override
              public GetSchema setCallback(java.lang.String callback) {
                return (GetSchema) super.setCallback(callback);
              }

              @Override
              public GetSchema setFields(java.lang.String fields) {
                return (GetSchema) super.setFields(fields);
              }

              @Override
              public GetSchema setKey(java.lang.String key) {
                return (GetSchema) super.setKey(key);
              }

              @Override
              public GetSchema setOauthToken(java.lang.String oauthToken) {
                return (GetSchema) super.setOauthToken(oauthToken);
              }

              @Override
              public GetSchema setPrettyPrint(java.lang.Boolean prettyPrint) {
                return (GetSchema) super.setPrettyPrint(prettyPrint);
              }

              @Override
              public GetSchema setQuotaUser(java.lang.String quotaUser) {
                return (GetSchema) super.setQuotaUser(quotaUser);
              }

              @Override
              public GetSchema setUploadType(java.lang.String uploadType) {
                return (GetSchema) super.setUploadType(uploadType);
              }

              @Override
              public GetSchema setUploadProtocol(java.lang.String uploadProtocol) {
                return (GetSchema) super.setUploadProtocol(uploadProtocol);
              }

              /**
               * Required. The name of the schema to return. Structured like: `projects/{project}/lo
               * cations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
               */
              @com.google.api.client.util.Key
              private java.lang.String name;

              /** Required. The name of the schema to return. Structured like:
             `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
               */
              public java.lang.String getName() {
                return name;
              }

              /**
               * Required. The name of the schema to return. Structured like: `projects/{project}/lo
               * cations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
               */
              public GetSchema setName(java.lang.String name) {
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/schemas/.*$");
                }
                this.name = name;
                return this;
              }

              /**
               * Optional. Used to limit the search for the schema ID to a specific subject,
               * otherwise the schema ID will be searched for in all subjects in the given specified
               * context.
               */
              @com.google.api.client.util.Key
              private java.lang.String subject;

              /** Optional. Used to limit the search for the schema ID to a specific subject, otherwise the schema ID
             will be searched for in all subjects in the given specified context.
               */
              public java.lang.String getSubject() {
                return subject;
              }

              /**
               * Optional. Used to limit the search for the schema ID to a specific subject,
               * otherwise the schema ID will be searched for in all subjects in the given specified
               * context.
               */
              public GetSchema setSubject(java.lang.String subject) {
                this.subject = subject;
                return this;
              }

              @Override
              public GetSchema set(String parameterName, Object value) {
                return (GetSchema) super.set(parameterName, value);
              }
            }

            /**
             * An accessor for creating requests from the Subjects collection.
             *
             * <p>The typical use is:</p>
             * <pre>
             *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
             *   {@code ManagedKafka.Subjects.List request = managedkafka.subjects().list(parameters ...)}
             * </pre>
             *
             * @return the resource collection
             */
            public Subjects subjects() {
              return new Subjects();
            }

            /**
             * The "subjects" collection of methods.
             */
            public class Subjects {

              /**
               * List subjects which reference a particular schema id. The response will be an array of subject
               * names.
               *
               * Create a request for the method "subjects.list".
               *
               * This request holds the parameters needed by the managedkafka server.  After setting any optional
               * parameters, call the {@link List#execute()} method to invoke the remote operation.
               *
               * @param parent Required. The schema resource whose associated subjects are to be listed. Structured like:
               *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{s
               *        chema}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/con
               *        texts/{context}/schemas/ids/{schema}`
               * @return the request
               */
              public List list(java.lang.String parent) throws java.io.IOException {
                List result = new List(parent);
                initialize(result);
                return result;
              }

              public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

                private static final String REST_PATH = "v1/{+parent}/subjects";

                private final java.util.regex.Pattern PARENT_PATTERN =
                    java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/schemas/.*$");

                /**
                 * List subjects which reference a particular schema id. The response will be an array of subject
                 * names.
                 *
                 * Create a request for the method "subjects.list".
                 *
                 * This request holds the parameters needed by the the managedkafka server.  After setting any
                 * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
                 * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
                 * must be called to initialize this instance immediately after invoking the constructor. </p>
                 *
                 * @param parent Required. The schema resource whose associated subjects are to be listed. Structured like:
               *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{s
               *        chema}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/con
               *        texts/{context}/schemas/ids/{schema}`
                 * @since 1.13
                 */
                protected List(java.lang.String parent) {
                  super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
                  this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
                  if (!getSuppressPatternChecks()) {
                    com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                        "Parameter parent must conform to the pattern " +
                        "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/schemas/.*$");
                  }
                }

                @Override
                public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
                  return super.executeUsingHead();
                }

                @Override
                public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
                  return super.buildHttpRequestUsingHead();
                }

                @Override
                public List set$Xgafv(java.lang.String $Xgafv) {
                  return (List) super.set$Xgafv($Xgafv);
                }

                @Override
                public List setAccessToken(java.lang.String accessToken) {
                  return (List) super.setAccessToken(accessToken);
                }

                @Override
                public List setAlt(java.lang.String alt) {
                  return (List) super.setAlt(alt);
                }

                @Override
                public List setCallback(java.lang.String callback) {
                  return (List) super.setCallback(callback);
                }

                @Override
                public List setFields(java.lang.String fields) {
                  return (List) super.setFields(fields);
                }

                @Override
                public List setKey(java.lang.String key) {
                  return (List) super.setKey(key);
                }

                @Override
                public List setOauthToken(java.lang.String oauthToken) {
                  return (List) super.setOauthToken(oauthToken);
                }

                @Override
                public List setPrettyPrint(java.lang.Boolean prettyPrint) {
                  return (List) super.setPrettyPrint(prettyPrint);
                }

                @Override
                public List setQuotaUser(java.lang.String quotaUser) {
                  return (List) super.setQuotaUser(quotaUser);
                }

                @Override
                public List setUploadType(java.lang.String uploadType) {
                  return (List) super.setUploadType(uploadType);
                }

                @Override
                public List setUploadProtocol(java.lang.String uploadProtocol) {
                  return (List) super.setUploadProtocol(uploadProtocol);
                }

                /**
                 * Required. The schema resource whose associated subjects are to be listed.
                 * Structured like: `projects/{project}/locations/{location}/schemaRegistries/{schem
                 * a_registry}/schemas/ids/{schema}` or `projects/{project}/locations/{location}/sch
                 * emaRegistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
                 */
                @com.google.api.client.util.Key
                private java.lang.String parent;

                /** Required. The schema resource whose associated subjects are to be listed. Structured like:
               `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
               or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/s
               chemas/ids/{schema}`
                 */
                public java.lang.String getParent() {
                  return parent;
                }

                /**
                 * Required. The schema resource whose associated subjects are to be listed.
                 * Structured like: `projects/{project}/locations/{location}/schemaRegistries/{schem
                 * a_registry}/schemas/ids/{schema}` or `projects/{project}/locations/{location}/sch
                 * emaRegistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
                 */
                public List setParent(java.lang.String parent) {
                  if (!getSuppressPatternChecks()) {
                    com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                        "Parameter parent must conform to the pattern " +
                        "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/schemas/.*$");
                  }
                  this.parent = parent;
                  return this;
                }

                /**
                 * Optional. If true, the response will include soft-deleted subjects. The default
                 * is false.
                 */
                @com.google.api.client.util.Key
                private java.lang.Boolean deleted;

                /** Optional. If true, the response will include soft-deleted subjects. The default is false.
                 */
                public java.lang.Boolean getDeleted() {
                  return deleted;
                }

                /**
                 * Optional. If true, the response will include soft-deleted subjects. The default
                 * is false.
                 */
                public List setDeleted(java.lang.Boolean deleted) {
                  this.deleted = deleted;
                  return this;
                }

                /** Optional. The subject to filter the subjects by. */
                @com.google.api.client.util.Key
                private java.lang.String subject;

                /** Optional. The subject to filter the subjects by.
                 */
                public java.lang.String getSubject() {
                  return subject;
                }

                /** Optional. The subject to filter the subjects by. */
                public List setSubject(java.lang.String subject) {
                  this.subject = subject;
                  return this;
                }

                @Override
                public List set(String parameterName, Object value) {
                  return (List) super.set(parameterName, value);
                }
              }

            }
            /**
             * An accessor for creating requests from the Types collection.
             *
             * <p>The typical use is:</p>
             * <pre>
             *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
             *   {@code ManagedKafka.Types.List request = managedkafka.types().list(parameters ...)}
             * </pre>
             *
             * @return the resource collection
             */
            public Types types() {
              return new Types();
            }

            /**
             * The "types" collection of methods.
             */
            public class Types {

              /**
               * List the supported schema types. The response will be an array of schema types.
               *
               * Create a request for the method "types.list".
               *
               * This request holds the parameters needed by the managedkafka server.  After setting any optional
               * parameters, call the {@link List#execute()} method to invoke the remote operation.
               *
               * @param parent Required. The parent schema registry whose schema types are to be listed. Structured like:
               *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
               * @return the request
               */
              public List list(java.lang.String parent) throws java.io.IOException {
                List result = new List(parent);
                initialize(result);
                return result;
              }

              public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

                private static final String REST_PATH = "v1/{+parent}/schemas/types";

                private final java.util.regex.Pattern PARENT_PATTERN =
                    java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+$");

                /**
                 * List the supported schema types. The response will be an array of schema types.
                 *
                 * Create a request for the method "types.list".
                 *
                 * This request holds the parameters needed by the the managedkafka server.  After setting any
                 * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
                 * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
                 * must be called to initialize this instance immediately after invoking the constructor. </p>
                 *
                 * @param parent Required. The parent schema registry whose schema types are to be listed. Structured like:
               *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
                 * @since 1.13
                 */
                protected List(java.lang.String parent) {
                  super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
                  this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
                  if (!getSuppressPatternChecks()) {
                    com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                        "Parameter parent must conform to the pattern " +
                        "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+$");
                  }
                }

                @Override
                public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
                  return super.executeUsingHead();
                }

                @Override
                public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
                  return super.buildHttpRequestUsingHead();
                }

                @Override
                public List set$Xgafv(java.lang.String $Xgafv) {
                  return (List) super.set$Xgafv($Xgafv);
                }

                @Override
                public List setAccessToken(java.lang.String accessToken) {
                  return (List) super.setAccessToken(accessToken);
                }

                @Override
                public List setAlt(java.lang.String alt) {
                  return (List) super.setAlt(alt);
                }

                @Override
                public List setCallback(java.lang.String callback) {
                  return (List) super.setCallback(callback);
                }

                @Override
                public List setFields(java.lang.String fields) {
                  return (List) super.setFields(fields);
                }

                @Override
                public List setKey(java.lang.String key) {
                  return (List) super.setKey(key);
                }

                @Override
                public List setOauthToken(java.lang.String oauthToken) {
                  return (List) super.setOauthToken(oauthToken);
                }

                @Override
                public List setPrettyPrint(java.lang.Boolean prettyPrint) {
                  return (List) super.setPrettyPrint(prettyPrint);
                }

                @Override
                public List setQuotaUser(java.lang.String quotaUser) {
                  return (List) super.setQuotaUser(quotaUser);
                }

                @Override
                public List setUploadType(java.lang.String uploadType) {
                  return (List) super.setUploadType(uploadType);
                }

                @Override
                public List setUploadProtocol(java.lang.String uploadProtocol) {
                  return (List) super.setUploadProtocol(uploadProtocol);
                }

                /**
                 * Required. The parent schema registry whose schema types are to be listed.
                 * Structured like:
                 * `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
                 */
                @com.google.api.client.util.Key
                private java.lang.String parent;

                /** Required. The parent schema registry whose schema types are to be listed. Structured like:
               `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
                 */
                public java.lang.String getParent() {
                  return parent;
                }

                /**
                 * Required. The parent schema registry whose schema types are to be listed.
                 * Structured like:
                 * `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
                 */
                public List setParent(java.lang.String parent) {
                  if (!getSuppressPatternChecks()) {
                    com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                        "Parameter parent must conform to the pattern " +
                        "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+$");
                  }
                  this.parent = parent;
                  return this;
                }

                @Override
                public List set(String parameterName, Object value) {
                  return (List) super.set(parameterName, value);
                }
              }

            }
            /**
             * An accessor for creating requests from the Versions collection.
             *
             * <p>The typical use is:</p>
             * <pre>
             *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
             *   {@code ManagedKafka.Versions.List request = managedkafka.versions().list(parameters ...)}
             * </pre>
             *
             * @return the resource collection
             */
            public Versions versions() {
              return new Versions();
            }

            /**
             * The "versions" collection of methods.
             */
            public class Versions {

              /**
               * List the schema versions for the given schema id. The response will be an array of subject-
               * version pairs as: [{"subject":"subject1", "version":1}, {"subject":"subject2", "version":2}].
               *
               * Create a request for the method "versions.list".
               *
               * This request holds the parameters needed by the managedkafka server.  After setting any optional
               * parameters, call the {@link List#execute()} method to invoke the remote operation.
               *
               * @param parent Required. The schema whose schema versions are to be listed. Structured like:
               *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{s
               *        chema}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/con
               *        texts/{context}/schemas/ids/{schema}`
               * @return the request
               */
              public List list(java.lang.String parent) throws java.io.IOException {
                List result = new List(parent);
                initialize(result);
                return result;
              }

              public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

                private static final String REST_PATH = "v1/{+parent}/versions";

                private final java.util.regex.Pattern PARENT_PATTERN =
                    java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/schemas/.*$");

                /**
                 * List the schema versions for the given schema id. The response will be an array of subject-
                 * version pairs as: [{"subject":"subject1", "version":1}, {"subject":"subject2", "version":2}].
                 *
                 * Create a request for the method "versions.list".
                 *
                 * This request holds the parameters needed by the the managedkafka server.  After setting any
                 * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
                 * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
                 * must be called to initialize this instance immediately after invoking the constructor. </p>
                 *
                 * @param parent Required. The schema whose schema versions are to be listed. Structured like:
               *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{s
               *        chema}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/con
               *        texts/{context}/schemas/ids/{schema}`
                 * @since 1.13
                 */
                protected List(java.lang.String parent) {
                  super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
                  this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
                  if (!getSuppressPatternChecks()) {
                    com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                        "Parameter parent must conform to the pattern " +
                        "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/schemas/.*$");
                  }
                }

                @Override
                public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
                  return super.executeUsingHead();
                }

                @Override
                public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
                  return super.buildHttpRequestUsingHead();
                }

                @Override
                public List set$Xgafv(java.lang.String $Xgafv) {
                  return (List) super.set$Xgafv($Xgafv);
                }

                @Override
                public List setAccessToken(java.lang.String accessToken) {
                  return (List) super.setAccessToken(accessToken);
                }

                @Override
                public List setAlt(java.lang.String alt) {
                  return (List) super.setAlt(alt);
                }

                @Override
                public List setCallback(java.lang.String callback) {
                  return (List) super.setCallback(callback);
                }

                @Override
                public List setFields(java.lang.String fields) {
                  return (List) super.setFields(fields);
                }

                @Override
                public List setKey(java.lang.String key) {
                  return (List) super.setKey(key);
                }

                @Override
                public List setOauthToken(java.lang.String oauthToken) {
                  return (List) super.setOauthToken(oauthToken);
                }

                @Override
                public List setPrettyPrint(java.lang.Boolean prettyPrint) {
                  return (List) super.setPrettyPrint(prettyPrint);
                }

                @Override
                public List setQuotaUser(java.lang.String quotaUser) {
                  return (List) super.setQuotaUser(quotaUser);
                }

                @Override
                public List setUploadType(java.lang.String uploadType) {
                  return (List) super.setUploadType(uploadType);
                }

                @Override
                public List setUploadProtocol(java.lang.String uploadProtocol) {
                  return (List) super.setUploadProtocol(uploadProtocol);
                }

                /**
                 * Required. The schema whose schema versions are to be listed. Structured like: `pr
                 * ojects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/
                 * ids/{schema}` or `projects/{project}/locations/{location}/schemaRegistries/{schem
                 * a_registry}/contexts/{context}/schemas/ids/{schema}`
                 */
                @com.google.api.client.util.Key
                private java.lang.String parent;

                /** Required. The schema whose schema versions are to be listed. Structured like:
               `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
               or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/s
               chemas/ids/{schema}`
                 */
                public java.lang.String getParent() {
                  return parent;
                }

                /**
                 * Required. The schema whose schema versions are to be listed. Structured like: `pr
                 * ojects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/
                 * ids/{schema}` or `projects/{project}/locations/{location}/schemaRegistries/{schem
                 * a_registry}/contexts/{context}/schemas/ids/{schema}`
                 */
                public List setParent(java.lang.String parent) {
                  if (!getSuppressPatternChecks()) {
                    com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                        "Parameter parent must conform to the pattern " +
                        "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/schemas/.*$");
                  }
                  this.parent = parent;
                  return this;
                }

                /**
                 * Optional. If true, the response will include soft-deleted versions of the schema,
                 * even if the subject is soft-deleted. The default is false.
                 */
                @com.google.api.client.util.Key
                private java.lang.Boolean deleted;

                /** Optional. If true, the response will include soft-deleted versions of the schema, even if the
               subject is soft-deleted. The default is false.
                 */
                public java.lang.Boolean getDeleted() {
                  return deleted;
                }

                /**
                 * Optional. If true, the response will include soft-deleted versions of the schema,
                 * even if the subject is soft-deleted. The default is false.
                 */
                public List setDeleted(java.lang.Boolean deleted) {
                  this.deleted = deleted;
                  return this;
                }

                /** Optional. The subject to filter the subjects by. */
                @com.google.api.client.util.Key
                private java.lang.String subject;

                /** Optional. The subject to filter the subjects by.
                 */
                public java.lang.String getSubject() {
                  return subject;
                }

                /** Optional. The subject to filter the subjects by. */
                public List setSubject(java.lang.String subject) {
                  this.subject = subject;
                  return this;
                }

                @Override
                public List set(String parameterName, Object value) {
                  return (List) super.set(parameterName, value);
                }
              }

            }
          }
          /**
           * An accessor for creating requests from the Subjects collection.
           *
           * <p>The typical use is:</p>
           * <pre>
           *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
           *   {@code ManagedKafka.Subjects.List request = managedkafka.subjects().list(parameters ...)}
           * </pre>
           *
           * @return the resource collection
           */
          public Subjects subjects() {
            return new Subjects();
          }

          /**
           * The "subjects" collection of methods.
           */
          public class Subjects {

            /**
             * Delete a subject. The response will be an array of versions of the deleted subject.
             *
             * Create a request for the method "subjects.delete".
             *
             * This request holds the parameters needed by the managedkafka server.  After setting any optional
             * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
             *
             * @param name Required. The name of the subject to delete. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subj
             *        ect}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/conte
             *        xts/{context}/subjects/{subject}`
             * @return the request
             */
            public Delete delete(java.lang.String name) throws java.io.IOException {
              Delete result = new Delete(name);
              initialize(result);
              return result;
            }

            public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

              private static final String REST_PATH = "v1/{+name}";

              private final java.util.regex.Pattern NAME_PATTERN =
                  java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+$");

              /**
               * Delete a subject. The response will be an array of versions of the deleted subject.
               *
               * Create a request for the method "subjects.delete".
               *
               * This request holds the parameters needed by the the managedkafka server.  After setting any
               * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
               * <p> {@link
               * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
               * be called to initialize this instance immediately after invoking the constructor. </p>
               *
               * @param name Required. The name of the subject to delete. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subj
             *        ect}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/conte
             *        xts/{context}/subjects/{subject}`
               * @since 1.13
               */
              protected Delete(java.lang.String name) {
                super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
                this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+$");
                }
              }

              @Override
              public Delete set$Xgafv(java.lang.String $Xgafv) {
                return (Delete) super.set$Xgafv($Xgafv);
              }

              @Override
              public Delete setAccessToken(java.lang.String accessToken) {
                return (Delete) super.setAccessToken(accessToken);
              }

              @Override
              public Delete setAlt(java.lang.String alt) {
                return (Delete) super.setAlt(alt);
              }

              @Override
              public Delete setCallback(java.lang.String callback) {
                return (Delete) super.setCallback(callback);
              }

              @Override
              public Delete setFields(java.lang.String fields) {
                return (Delete) super.setFields(fields);
              }

              @Override
              public Delete setKey(java.lang.String key) {
                return (Delete) super.setKey(key);
              }

              @Override
              public Delete setOauthToken(java.lang.String oauthToken) {
                return (Delete) super.setOauthToken(oauthToken);
              }

              @Override
              public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
                return (Delete) super.setPrettyPrint(prettyPrint);
              }

              @Override
              public Delete setQuotaUser(java.lang.String quotaUser) {
                return (Delete) super.setQuotaUser(quotaUser);
              }

              @Override
              public Delete setUploadType(java.lang.String uploadType) {
                return (Delete) super.setUploadType(uploadType);
              }

              @Override
              public Delete setUploadProtocol(java.lang.String uploadProtocol) {
                return (Delete) super.setUploadProtocol(uploadProtocol);
              }

              /**
               * Required. The name of the subject to delete. Structured like: `projects/{project}/l
               * ocations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}` or `proj
               * ects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{co
               * ntext}/subjects/{subject}`
               */
              @com.google.api.client.util.Key
              private java.lang.String name;

              /** Required. The name of the subject to delete. Structured like:
             `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}` or
             `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subj
             ects/{subject}`
               */
              public java.lang.String getName() {
                return name;
              }

              /**
               * Required. The name of the subject to delete. Structured like: `projects/{project}/l
               * ocations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}` or `proj
               * ects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{co
               * ntext}/subjects/{subject}`
               */
              public Delete setName(java.lang.String name) {
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+$");
                }
                this.name = name;
                return this;
              }

              /**
               * Optional. If true, the subject and all associated metadata including the schema ID
               * will be deleted permanently. Otherwise, only the subject is soft-deleted. The
               * default is false. Soft-deleted subjects can still be searched in ListSubjects API
               * call with deleted=true query parameter. A soft-delete of a subject must be
               * performed before a hard-delete.
               */
              @com.google.api.client.util.Key
              private java.lang.Boolean permanent;

              /** Optional. If true, the subject and all associated metadata including the schema ID will be deleted
             permanently. Otherwise, only the subject is soft-deleted. The default is false. Soft-deleted
             subjects can still be searched in ListSubjects API call with deleted=true query parameter. A soft-
             delete of a subject must be performed before a hard-delete.
               */
              public java.lang.Boolean getPermanent() {
                return permanent;
              }

              /**
               * Optional. If true, the subject and all associated metadata including the schema ID
               * will be deleted permanently. Otherwise, only the subject is soft-deleted. The
               * default is false. Soft-deleted subjects can still be searched in ListSubjects API
               * call with deleted=true query parameter. A soft-delete of a subject must be
               * performed before a hard-delete.
               */
              public Delete setPermanent(java.lang.Boolean permanent) {
                this.permanent = permanent;
                return this;
              }

              @Override
              public Delete set(String parameterName, Object value) {
                return (Delete) super.set(parameterName, value);
              }
            }
            /**
             * List subjects in the schema registry. The response will be an array of subject names.
             *
             * Create a request for the method "subjects.list".
             *
             * This request holds the parameters needed by the managedkafka server.  After setting any optional
             * parameters, call the {@link List#execute()} method to invoke the remote operation.
             *
             * @param parent Required. The parent schema registry/context whose subjects are to be listed. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}` or `projects/
             *        {project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
             * @return the request
             */
            public List list(java.lang.String parent) throws java.io.IOException {
              List result = new List(parent);
              initialize(result);
              return result;
            }

            public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

              private static final String REST_PATH = "v1/{+parent}/subjects";

              private final java.util.regex.Pattern PARENT_PATTERN =
                  java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+$");

              /**
               * List subjects in the schema registry. The response will be an array of subject names.
               *
               * Create a request for the method "subjects.list".
               *
               * This request holds the parameters needed by the the managedkafka server.  After setting any
               * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
               * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
               * must be called to initialize this instance immediately after invoking the constructor. </p>
               *
               * @param parent Required. The parent schema registry/context whose subjects are to be listed. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}` or `projects/
             *        {project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
               * @since 1.13
               */
              protected List(java.lang.String parent) {
                super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
                this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                      "Parameter parent must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+$");
                }
              }

              @Override
              public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
                return super.executeUsingHead();
              }

              @Override
              public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
                return super.buildHttpRequestUsingHead();
              }

              @Override
              public List set$Xgafv(java.lang.String $Xgafv) {
                return (List) super.set$Xgafv($Xgafv);
              }

              @Override
              public List setAccessToken(java.lang.String accessToken) {
                return (List) super.setAccessToken(accessToken);
              }

              @Override
              public List setAlt(java.lang.String alt) {
                return (List) super.setAlt(alt);
              }

              @Override
              public List setCallback(java.lang.String callback) {
                return (List) super.setCallback(callback);
              }

              @Override
              public List setFields(java.lang.String fields) {
                return (List) super.setFields(fields);
              }

              @Override
              public List setKey(java.lang.String key) {
                return (List) super.setKey(key);
              }

              @Override
              public List setOauthToken(java.lang.String oauthToken) {
                return (List) super.setOauthToken(oauthToken);
              }

              @Override
              public List setPrettyPrint(java.lang.Boolean prettyPrint) {
                return (List) super.setPrettyPrint(prettyPrint);
              }

              @Override
              public List setQuotaUser(java.lang.String quotaUser) {
                return (List) super.setQuotaUser(quotaUser);
              }

              @Override
              public List setUploadType(java.lang.String uploadType) {
                return (List) super.setUploadType(uploadType);
              }

              @Override
              public List setUploadProtocol(java.lang.String uploadProtocol) {
                return (List) super.setUploadProtocol(uploadProtocol);
              }

              /**
               * Required. The parent schema registry/context whose subjects are to be listed.
               * Structured like:
               * `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}` or `pr
               * ojects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{
               * context}`
               */
              @com.google.api.client.util.Key
              private java.lang.String parent;

              /** Required. The parent schema registry/context whose subjects are to be listed. Structured like:
             `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}` or
             `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
               */
              public java.lang.String getParent() {
                return parent;
              }

              /**
               * Required. The parent schema registry/context whose subjects are to be listed.
               * Structured like:
               * `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}` or `pr
               * ojects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{
               * context}`
               */
              public List setParent(java.lang.String parent) {
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                      "Parameter parent must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+$");
                }
                this.parent = parent;
                return this;
              }

              /**
               * Optional. If true, the response will include soft-deleted subjects. The default is
               * false.
               */
              @com.google.api.client.util.Key
              private java.lang.Boolean deleted;

              /** Optional. If true, the response will include soft-deleted subjects. The default is false.
               */
              public java.lang.Boolean getDeleted() {
                return deleted;
              }

              /**
               * Optional. If true, the response will include soft-deleted subjects. The default is
               * false.
               */
              public List setDeleted(java.lang.Boolean deleted) {
                this.deleted = deleted;
                return this;
              }

              /**
               * Optional. The context to filter the subjects by, in the format of `:.{context}:`.
               * If unset, all subjects in the registry are returned. Set to empty string or add as
               * '?subjectPrefix=' at the end of this request to list subjects in the default
               * context.
               */
              @com.google.api.client.util.Key
              private java.lang.String subjectPrefix;

              /** Optional. The context to filter the subjects by, in the format of `:.{context}:`. If unset, all
             subjects in the registry are returned. Set to empty string or add as '?subjectPrefix=' at the end
             of this request to list subjects in the default context.
               */
              public java.lang.String getSubjectPrefix() {
                return subjectPrefix;
              }

              /**
               * Optional. The context to filter the subjects by, in the format of `:.{context}:`.
               * If unset, all subjects in the registry are returned. Set to empty string or add as
               * '?subjectPrefix=' at the end of this request to list subjects in the default
               * context.
               */
              public List setSubjectPrefix(java.lang.String subjectPrefix) {
                this.subjectPrefix = subjectPrefix;
                return this;
              }

              @Override
              public List set(String parameterName, Object value) {
                return (List) super.set(parameterName, value);
              }
            }
            /**
             * Lookup a schema under the specified subject.
             *
             * Create a request for the method "subjects.lookupVersion".
             *
             * This request holds the parameters needed by the managedkafka server.  After setting any optional
             * parameters, call the {@link LookupVersion#execute()} method to invoke the remote operation.
             *
             * @param parent Required. The subject to lookup the schema in. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subj
             *        ect}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/conte
             *        xts/{context}/subjects/{subject}`
             * @param content the {@link com.google.api.services.managedkafka.v1.model.LookupVersionRequest}
             * @return the request
             */
            public LookupVersion lookupVersion(java.lang.String parent, com.google.api.services.managedkafka.v1.model.LookupVersionRequest content) throws java.io.IOException {
              LookupVersion result = new LookupVersion(parent, content);
              initialize(result);
              return result;
            }

            public class LookupVersion extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.SchemaVersion> {

              private static final String REST_PATH = "v1/{+parent}";

              private final java.util.regex.Pattern PARENT_PATTERN =
                  java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+$");

              /**
               * Lookup a schema under the specified subject.
               *
               * Create a request for the method "subjects.lookupVersion".
               *
               * This request holds the parameters needed by the the managedkafka server.  After setting any
               * optional parameters, call the {@link LookupVersion#execute()} method to invoke the remote
               * operation. <p> {@link LookupVersion#initialize(com.google.api.client.googleapis.services.Abstra
               * ctGoogleClientRequest)} must be called to initialize this instance immediately after invoking
               * the constructor. </p>
               *
               * @param parent Required. The subject to lookup the schema in. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subj
             *        ect}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/conte
             *        xts/{context}/subjects/{subject}`
               * @param content the {@link com.google.api.services.managedkafka.v1.model.LookupVersionRequest}
               * @since 1.13
               */
              protected LookupVersion(java.lang.String parent, com.google.api.services.managedkafka.v1.model.LookupVersionRequest content) {
                super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.SchemaVersion.class);
                this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                      "Parameter parent must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+$");
                }
              }

              @Override
              public LookupVersion set$Xgafv(java.lang.String $Xgafv) {
                return (LookupVersion) super.set$Xgafv($Xgafv);
              }

              @Override
              public LookupVersion setAccessToken(java.lang.String accessToken) {
                return (LookupVersion) super.setAccessToken(accessToken);
              }

              @Override
              public LookupVersion setAlt(java.lang.String alt) {
                return (LookupVersion) super.setAlt(alt);
              }

              @Override
              public LookupVersion setCallback(java.lang.String callback) {
                return (LookupVersion) super.setCallback(callback);
              }

              @Override
              public LookupVersion setFields(java.lang.String fields) {
                return (LookupVersion) super.setFields(fields);
              }

              @Override
              public LookupVersion setKey(java.lang.String key) {
                return (LookupVersion) super.setKey(key);
              }

              @Override
              public LookupVersion setOauthToken(java.lang.String oauthToken) {
                return (LookupVersion) super.setOauthToken(oauthToken);
              }

              @Override
              public LookupVersion setPrettyPrint(java.lang.Boolean prettyPrint) {
                return (LookupVersion) super.setPrettyPrint(prettyPrint);
              }

              @Override
              public LookupVersion setQuotaUser(java.lang.String quotaUser) {
                return (LookupVersion) super.setQuotaUser(quotaUser);
              }

              @Override
              public LookupVersion setUploadType(java.lang.String uploadType) {
                return (LookupVersion) super.setUploadType(uploadType);
              }

              @Override
              public LookupVersion setUploadProtocol(java.lang.String uploadProtocol) {
                return (LookupVersion) super.setUploadProtocol(uploadProtocol);
              }

              /**
               * Required. The subject to lookup the schema in. Structured like: `projects/{project}
               * /locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}` or `pr
               * ojects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{
               * context}/subjects/{subject}`
               */
              @com.google.api.client.util.Key
              private java.lang.String parent;

              /** Required. The subject to lookup the schema in. Structured like:
             `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}` or
             `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subj
             ects/{subject}`
               */
              public java.lang.String getParent() {
                return parent;
              }

              /**
               * Required. The subject to lookup the schema in. Structured like: `projects/{project}
               * /locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}` or `pr
               * ojects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{
               * context}/subjects/{subject}`
               */
              public LookupVersion setParent(java.lang.String parent) {
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                      "Parameter parent must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+$");
                }
                this.parent = parent;
                return this;
              }

              @Override
              public LookupVersion set(String parameterName, Object value) {
                return (LookupVersion) super.set(parameterName, value);
              }
            }

            /**
             * An accessor for creating requests from the Versions collection.
             *
             * <p>The typical use is:</p>
             * <pre>
             *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
             *   {@code ManagedKafka.Versions.List request = managedkafka.versions().list(parameters ...)}
             * </pre>
             *
             * @return the resource collection
             */
            public Versions versions() {
              return new Versions();
            }

            /**
             * The "versions" collection of methods.
             */
            public class Versions {

              /**
               * Register a new version under a given subject with the given schema.
               *
               * Create a request for the method "versions.create".
               *
               * This request holds the parameters needed by the managedkafka server.  After setting any optional
               * parameters, call the {@link Create#execute()} method to invoke the remote operation.
               *
               * @param parent Required. The subject to create the version for. Structured like:
               *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subj
               *        ect}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/conte
               *        xts/{context}/subjects/{subject}`
               * @param content the {@link com.google.api.services.managedkafka.v1.model.CreateVersionRequest}
               * @return the request
               */
              public Create create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.CreateVersionRequest content) throws java.io.IOException {
                Create result = new Create(parent, content);
                initialize(result);
                return result;
              }

              public class Create extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.CreateVersionResponse> {

                private static final String REST_PATH = "v1/{+parent}/versions";

                private final java.util.regex.Pattern PARENT_PATTERN =
                    java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+$");

                /**
                 * Register a new version under a given subject with the given schema.
                 *
                 * Create a request for the method "versions.create".
                 *
                 * This request holds the parameters needed by the the managedkafka server.  After setting any
                 * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
                 * <p> {@link
                 * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
                 * be called to initialize this instance immediately after invoking the constructor. </p>
                 *
                 * @param parent Required. The subject to create the version for. Structured like:
               *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subj
               *        ect}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/conte
               *        xts/{context}/subjects/{subject}`
                 * @param content the {@link com.google.api.services.managedkafka.v1.model.CreateVersionRequest}
                 * @since 1.13
                 */
                protected Create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.CreateVersionRequest content) {
                  super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.CreateVersionResponse.class);
                  this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
                  if (!getSuppressPatternChecks()) {
                    com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                        "Parameter parent must conform to the pattern " +
                        "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+$");
                  }
                }

                @Override
                public Create set$Xgafv(java.lang.String $Xgafv) {
                  return (Create) super.set$Xgafv($Xgafv);
                }

                @Override
                public Create setAccessToken(java.lang.String accessToken) {
                  return (Create) super.setAccessToken(accessToken);
                }

                @Override
                public Create setAlt(java.lang.String alt) {
                  return (Create) super.setAlt(alt);
                }

                @Override
                public Create setCallback(java.lang.String callback) {
                  return (Create) super.setCallback(callback);
                }

                @Override
                public Create setFields(java.lang.String fields) {
                  return (Create) super.setFields(fields);
                }

                @Override
                public Create setKey(java.lang.String key) {
                  return (Create) super.setKey(key);
                }

                @Override
                public Create setOauthToken(java.lang.String oauthToken) {
                  return (Create) super.setOauthToken(oauthToken);
                }

                @Override
                public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
                  return (Create) super.setPrettyPrint(prettyPrint);
                }

                @Override
                public Create setQuotaUser(java.lang.String quotaUser) {
                  return (Create) super.setQuotaUser(quotaUser);
                }

                @Override
                public Create setUploadType(java.lang.String uploadType) {
                  return (Create) super.setUploadType(uploadType);
                }

                @Override
                public Create setUploadProtocol(java.lang.String uploadProtocol) {
                  return (Create) super.setUploadProtocol(uploadProtocol);
                }

                /**
                 * Required. The subject to create the version for. Structured like: `projects/{proj
                 * ect}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
                 * or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/co
                 * ntexts/{context}/subjects/{subject}`
                 */
                @com.google.api.client.util.Key
                private java.lang.String parent;

                /** Required. The subject to create the version for. Structured like:
               `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}` or
               `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subj
               ects/{subject}`
                 */
                public java.lang.String getParent() {
                  return parent;
                }

                /**
                 * Required. The subject to create the version for. Structured like: `projects/{proj
                 * ect}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
                 * or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/co
                 * ntexts/{context}/subjects/{subject}`
                 */
                public Create setParent(java.lang.String parent) {
                  if (!getSuppressPatternChecks()) {
                    com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                        "Parameter parent must conform to the pattern " +
                        "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+$");
                  }
                  this.parent = parent;
                  return this;
                }

                @Override
                public Create set(String parameterName, Object value) {
                  return (Create) super.set(parameterName, value);
                }
              }
              /**
               * Delete a version of a subject. The response will be the deleted version id.
               *
               * Create a request for the method "versions.delete".
               *
               * This request holds the parameters needed by the managedkafka server.  After setting any optional
               * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
               *
               * @param name Required. The name of the subject version to delete. Structured like: `projects/{project}/locations/
               *        {location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `p
               *        rojects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{contex
               *        t}/subjects/{subject}/versions/{version}`
               * @return the request
               */
              public Delete delete(java.lang.String name) throws java.io.IOException {
                Delete result = new Delete(name);
                initialize(result);
                return result;
              }

              public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

                private static final String REST_PATH = "v1/{+name}";

                private final java.util.regex.Pattern NAME_PATTERN =
                    java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+/versions/[^/]+$");

                /**
                 * Delete a version of a subject. The response will be the deleted version id.
                 *
                 * Create a request for the method "versions.delete".
                 *
                 * This request holds the parameters needed by the the managedkafka server.  After setting any
                 * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
                 * <p> {@link
                 * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
                 * be called to initialize this instance immediately after invoking the constructor. </p>
                 *
                 * @param name Required. The name of the subject version to delete. Structured like: `projects/{project}/locations/
               *        {location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `p
               *        rojects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{contex
               *        t}/subjects/{subject}/versions/{version}`
                 * @since 1.13
                 */
                protected Delete(java.lang.String name) {
                  super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
                  this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
                  if (!getSuppressPatternChecks()) {
                    com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                        "Parameter name must conform to the pattern " +
                        "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+/versions/[^/]+$");
                  }
                }

                @Override
                public Delete set$Xgafv(java.lang.String $Xgafv) {
                  return (Delete) super.set$Xgafv($Xgafv);
                }

                @Override
                public Delete setAccessToken(java.lang.String accessToken) {
                  return (Delete) super.setAccessToken(accessToken);
                }

                @Override
                public Delete setAlt(java.lang.String alt) {
                  return (Delete) super.setAlt(alt);
                }

                @Override
                public Delete setCallback(java.lang.String callback) {
                  return (Delete) super.setCallback(callback);
                }

                @Override
                public Delete setFields(java.lang.String fields) {
                  return (Delete) super.setFields(fields);
                }

                @Override
                public Delete setKey(java.lang.String key) {
                  return (Delete) super.setKey(key);
                }

                @Override
                public Delete setOauthToken(java.lang.String oauthToken) {
                  return (Delete) super.setOauthToken(oauthToken);
                }

                @Override
                public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
                  return (Delete) super.setPrettyPrint(prettyPrint);
                }

                @Override
                public Delete setQuotaUser(java.lang.String quotaUser) {
                  return (Delete) super.setQuotaUser(quotaUser);
                }

                @Override
                public Delete setUploadType(java.lang.String uploadType) {
                  return (Delete) super.setUploadType(uploadType);
                }

                @Override
                public Delete setUploadProtocol(java.lang.String uploadProtocol) {
                  return (Delete) super.setUploadProtocol(uploadProtocol);
                }

                /**
                 * Required. The name of the subject version to delete. Structured like: `projects/{
                 * project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subjec
                 * t}/versions/{version}` or `projects/{project}/locations/{location}/schemaRegistri
                 * es/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
                 */
                @com.google.api.client.util.Key
                private java.lang.String name;

                /** Required. The name of the subject version to delete. Structured like: `projects/{project}/locations
               /{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `projects/
               {project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subj
               ect}/versions/{version}`
                 */
                public java.lang.String getName() {
                  return name;
                }

                /**
                 * Required. The name of the subject version to delete. Structured like: `projects/{
                 * project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subjec
                 * t}/versions/{version}` or `projects/{project}/locations/{location}/schemaRegistri
                 * es/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
                 */
                public Delete setName(java.lang.String name) {
                  if (!getSuppressPatternChecks()) {
                    com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                        "Parameter name must conform to the pattern " +
                        "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+/versions/[^/]+$");
                  }
                  this.name = name;
                  return this;
                }

                /**
                 * Optional. If true, both the version and the referenced schema ID will be
                 * permanently deleted. The default is false. If false, the version will be deleted
                 * but the schema ID will be retained. Soft-deleted versions can still be searched
                 * in ListVersions API call with deleted=true query parameter. A soft-delete of a
                 * version must be performed before a hard-delete.
                 */
                @com.google.api.client.util.Key
                private java.lang.Boolean permanent;

                /** Optional. If true, both the version and the referenced schema ID will be permanently deleted. The
               default is false. If false, the version will be deleted but the schema ID will be retained. Soft-
               deleted versions can still be searched in ListVersions API call with deleted=true query parameter.
               A soft-delete of a version must be performed before a hard-delete.
                 */
                public java.lang.Boolean getPermanent() {
                  return permanent;
                }

                /**
                 * Optional. If true, both the version and the referenced schema ID will be
                 * permanently deleted. The default is false. If false, the version will be deleted
                 * but the schema ID will be retained. Soft-deleted versions can still be searched
                 * in ListVersions API call with deleted=true query parameter. A soft-delete of a
                 * version must be performed before a hard-delete.
                 */
                public Delete setPermanent(java.lang.Boolean permanent) {
                  this.permanent = permanent;
                  return this;
                }

                @Override
                public Delete set(String parameterName, Object value) {
                  return (Delete) super.set(parameterName, value);
                }
              }
              /**
               * Get a versioned schema (schema with subject/version) of a subject.
               *
               * Create a request for the method "versions.get".
               *
               * This request holds the parameters needed by the managedkafka server.  After setting any optional
               * parameters, call the {@link Get#execute()} method to invoke the remote operation.
               *
               * @param name Required. The name of the subject to return versions. Structured like: `projects/{project}/locations
               *        /{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `
               *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{conte
               *        xt}/subjects/{subject}/versions/{version}`
               * @return the request
               */
              public Get get(java.lang.String name) throws java.io.IOException {
                Get result = new Get(name);
                initialize(result);
                return result;
              }

              public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.SchemaVersion> {

                private static final String REST_PATH = "v1/{+name}";

                private final java.util.regex.Pattern NAME_PATTERN =
                    java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+/versions/[^/]+$");

                /**
                 * Get a versioned schema (schema with subject/version) of a subject.
                 *
                 * Create a request for the method "versions.get".
                 *
                 * This request holds the parameters needed by the the managedkafka server.  After setting any
                 * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
                 * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
                 * must be called to initialize this instance immediately after invoking the constructor. </p>
                 *
                 * @param name Required. The name of the subject to return versions. Structured like: `projects/{project}/locations
               *        /{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `
               *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{conte
               *        xt}/subjects/{subject}/versions/{version}`
                 * @since 1.13
                 */
                protected Get(java.lang.String name) {
                  super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.SchemaVersion.class);
                  this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
                  if (!getSuppressPatternChecks()) {
                    com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                        "Parameter name must conform to the pattern " +
                        "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+/versions/[^/]+$");
                  }
                }

                @Override
                public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
                  return super.executeUsingHead();
                }

                @Override
                public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
                  return super.buildHttpRequestUsingHead();
                }

                @Override
                public Get set$Xgafv(java.lang.String $Xgafv) {
                  return (Get) super.set$Xgafv($Xgafv);
                }

                @Override
                public Get setAccessToken(java.lang.String accessToken) {
                  return (Get) super.setAccessToken(accessToken);
                }

                @Override
                public Get setAlt(java.lang.String alt) {
                  return (Get) super.setAlt(alt);
                }

                @Override
                public Get setCallback(java.lang.String callback) {
                  return (Get) super.setCallback(callback);
                }

                @Override
                public Get setFields(java.lang.String fields) {
                  return (Get) super.setFields(fields);
                }

                @Override
                public Get setKey(java.lang.String key) {
                  return (Get) super.setKey(key);
                }

                @Override
                public Get setOauthToken(java.lang.String oauthToken) {
                  return (Get) super.setOauthToken(oauthToken);
                }

                @Override
                public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
                  return (Get) super.setPrettyPrint(prettyPrint);
                }

                @Override
                public Get setQuotaUser(java.lang.String quotaUser) {
                  return (Get) super.setQuotaUser(quotaUser);
                }

                @Override
                public Get setUploadType(java.lang.String uploadType) {
                  return (Get) super.setUploadType(uploadType);
                }

                @Override
                public Get setUploadProtocol(java.lang.String uploadProtocol) {
                  return (Get) super.setUploadProtocol(uploadProtocol);
                }

                /**
                 * Required. The name of the subject to return versions. Structured like: `projects/
                 * {project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subje
                 * ct}/versions/{version}` or `projects/{project}/locations/{location}/schemaRegistr
                 * ies/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
                 */
                @com.google.api.client.util.Key
                private java.lang.String name;

                /** Required. The name of the subject to return versions. Structured like: `projects/{project}/location
               s/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `projects
               /{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{sub
               ject}/versions/{version}`
                 */
                public java.lang.String getName() {
                  return name;
                }

                /**
                 * Required. The name of the subject to return versions. Structured like: `projects/
                 * {project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subje
                 * ct}/versions/{version}` or `projects/{project}/locations/{location}/schemaRegistr
                 * ies/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
                 */
                public Get setName(java.lang.String name) {
                  if (!getSuppressPatternChecks()) {
                    com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                        "Parameter name must conform to the pattern " +
                        "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+/versions/[^/]+$");
                  }
                  this.name = name;
                  return this;
                }

                /**
                 * Optional. If true, no matter if the subject/version is soft-deleted or not, it
                 * returns the version details. If false, it returns NOT_FOUND error if the
                 * subject/version is soft-deleted. The default is false.
                 */
                @com.google.api.client.util.Key
                private java.lang.Boolean deleted;

                /** Optional. If true, no matter if the subject/version is soft-deleted or not, it returns the version
               details. If false, it returns NOT_FOUND error if the subject/version is soft-deleted. The default
               is false.
                 */
                public java.lang.Boolean getDeleted() {
                  return deleted;
                }

                /**
                 * Optional. If true, no matter if the subject/version is soft-deleted or not, it
                 * returns the version details. If false, it returns NOT_FOUND error if the
                 * subject/version is soft-deleted. The default is false.
                 */
                public Get setDeleted(java.lang.Boolean deleted) {
                  this.deleted = deleted;
                  return this;
                }

                @Override
                public Get set(String parameterName, Object value) {
                  return (Get) super.set(parameterName, value);
                }
              }
              /**
               * Get the schema string only for a version of a subject. The response will be the schema string.
               *
               * Create a request for the method "versions.getSchema".
               *
               * This request holds the parameters needed by the managedkafka server.  After setting any optional
               * parameters, call the {@link GetSchema#execute()} method to invoke the remote operation.
               *
               * @param name Required. The name of the subject to return versions. Structured like: `projects/{project}/locations
               *        /{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `
               *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{conte
               *        xt}/subjects/{subject}/versions/{version}`
               * @return the request
               */
              public GetSchema getSchema(java.lang.String name) throws java.io.IOException {
                GetSchema result = new GetSchema(name);
                initialize(result);
                return result;
              }

              public class GetSchema extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

                private static final String REST_PATH = "v1/{+name}/schema";

                private final java.util.regex.Pattern NAME_PATTERN =
                    java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+/versions/[^/]+$");

                /**
                 * Get the schema string only for a version of a subject. The response will be the schema string.
                 *
                 * Create a request for the method "versions.getSchema".
                 *
                 * This request holds the parameters needed by the the managedkafka server.  After setting any
                 * optional parameters, call the {@link GetSchema#execute()} method to invoke the remote
                 * operation. <p> {@link
                 * GetSchema#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
                 * must be called to initialize this instance immediately after invoking the constructor. </p>
                 *
                 * @param name Required. The name of the subject to return versions. Structured like: `projects/{project}/locations
               *        /{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `
               *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{conte
               *        xt}/subjects/{subject}/versions/{version}`
                 * @since 1.13
                 */
                protected GetSchema(java.lang.String name) {
                  super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
                  this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
                  if (!getSuppressPatternChecks()) {
                    com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                        "Parameter name must conform to the pattern " +
                        "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+/versions/[^/]+$");
                  }
                }

                @Override
                public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
                  return super.executeUsingHead();
                }

                @Override
                public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
                  return super.buildHttpRequestUsingHead();
                }

                @Override
                public GetSchema set$Xgafv(java.lang.String $Xgafv) {
                  return (GetSchema) super.set$Xgafv($Xgafv);
                }

                @Override
                public GetSchema setAccessToken(java.lang.String accessToken) {
                  return (GetSchema) super.setAccessToken(accessToken);
                }

                @Override
                public GetSchema setAlt(java.lang.String alt) {
                  return (GetSchema) super.setAlt(alt);
                }

                @Override
                public GetSchema setCallback(java.lang.String callback) {
                  return (GetSchema) super.setCallback(callback);
                }

                @Override
                public GetSchema setFields(java.lang.String fields) {
                  return (GetSchema) super.setFields(fields);
                }

                @Override
                public GetSchema setKey(java.lang.String key) {
                  return (GetSchema) super.setKey(key);
                }

                @Override
                public GetSchema setOauthToken(java.lang.String oauthToken) {
                  return (GetSchema) super.setOauthToken(oauthToken);
                }

                @Override
                public GetSchema setPrettyPrint(java.lang.Boolean prettyPrint) {
                  return (GetSchema) super.setPrettyPrint(prettyPrint);
                }

                @Override
                public GetSchema setQuotaUser(java.lang.String quotaUser) {
                  return (GetSchema) super.setQuotaUser(quotaUser);
                }

                @Override
                public GetSchema setUploadType(java.lang.String uploadType) {
                  return (GetSchema) super.setUploadType(uploadType);
                }

                @Override
                public GetSchema setUploadProtocol(java.lang.String uploadProtocol) {
                  return (GetSchema) super.setUploadProtocol(uploadProtocol);
                }

                /**
                 * Required. The name of the subject to return versions. Structured like: `projects/
                 * {project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subje
                 * ct}/versions/{version}` or `projects/{project}/locations/{location}/schemaRegistr
                 * ies/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
                 */
                @com.google.api.client.util.Key
                private java.lang.String name;

                /** Required. The name of the subject to return versions. Structured like: `projects/{project}/location
               s/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `projects
               /{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{sub
               ject}/versions/{version}`
                 */
                public java.lang.String getName() {
                  return name;
                }

                /**
                 * Required. The name of the subject to return versions. Structured like: `projects/
                 * {project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subje
                 * ct}/versions/{version}` or `projects/{project}/locations/{location}/schemaRegistr
                 * ies/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
                 */
                public GetSchema setName(java.lang.String name) {
                  if (!getSuppressPatternChecks()) {
                    com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                        "Parameter name must conform to the pattern " +
                        "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+/versions/[^/]+$");
                  }
                  this.name = name;
                  return this;
                }

                /**
                 * Optional. If true, no matter if the subject/version is soft-deleted or not, it
                 * returns the version details. If false, it returns NOT_FOUND error if the
                 * subject/version is soft-deleted. The default is false.
                 */
                @com.google.api.client.util.Key
                private java.lang.Boolean deleted;

                /** Optional. If true, no matter if the subject/version is soft-deleted or not, it returns the version
               details. If false, it returns NOT_FOUND error if the subject/version is soft-deleted. The default
               is false.
                 */
                public java.lang.Boolean getDeleted() {
                  return deleted;
                }

                /**
                 * Optional. If true, no matter if the subject/version is soft-deleted or not, it
                 * returns the version details. If false, it returns NOT_FOUND error if the
                 * subject/version is soft-deleted. The default is false.
                 */
                public GetSchema setDeleted(java.lang.Boolean deleted) {
                  this.deleted = deleted;
                  return this;
                }

                @Override
                public GetSchema set(String parameterName, Object value) {
                  return (GetSchema) super.set(parameterName, value);
                }
              }
              /**
               * Get all versions of a subject. The response will be an array of versions of the subject.
               *
               * Create a request for the method "versions.list".
               *
               * This request holds the parameters needed by the managedkafka server.  After setting any optional
               * parameters, call the {@link List#execute()} method to invoke the remote operation.
               *
               * @param parent Required. The subject whose versions are to be listed. Structured like:
               *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subj
               *        ect}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/conte
               *        xts/{context}/subjects/{subject}`
               * @return the request
               */
              public List list(java.lang.String parent) throws java.io.IOException {
                List result = new List(parent);
                initialize(result);
                return result;
              }

              public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

                private static final String REST_PATH = "v1/{+parent}/versions";

                private final java.util.regex.Pattern PARENT_PATTERN =
                    java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+$");

                /**
                 * Get all versions of a subject. The response will be an array of versions of the subject.
                 *
                 * Create a request for the method "versions.list".
                 *
                 * This request holds the parameters needed by the the managedkafka server.  After setting any
                 * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
                 * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
                 * must be called to initialize this instance immediately after invoking the constructor. </p>
                 *
                 * @param parent Required. The subject whose versions are to be listed. Structured like:
               *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subj
               *        ect}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/conte
               *        xts/{context}/subjects/{subject}`
                 * @since 1.13
                 */
                protected List(java.lang.String parent) {
                  super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
                  this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
                  if (!getSuppressPatternChecks()) {
                    com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                        "Parameter parent must conform to the pattern " +
                        "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+$");
                  }
                }

                @Override
                public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
                  return super.executeUsingHead();
                }

                @Override
                public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
                  return super.buildHttpRequestUsingHead();
                }

                @Override
                public List set$Xgafv(java.lang.String $Xgafv) {
                  return (List) super.set$Xgafv($Xgafv);
                }

                @Override
                public List setAccessToken(java.lang.String accessToken) {
                  return (List) super.setAccessToken(accessToken);
                }

                @Override
                public List setAlt(java.lang.String alt) {
                  return (List) super.setAlt(alt);
                }

                @Override
                public List setCallback(java.lang.String callback) {
                  return (List) super.setCallback(callback);
                }

                @Override
                public List setFields(java.lang.String fields) {
                  return (List) super.setFields(fields);
                }

                @Override
                public List setKey(java.lang.String key) {
                  return (List) super.setKey(key);
                }

                @Override
                public List setOauthToken(java.lang.String oauthToken) {
                  return (List) super.setOauthToken(oauthToken);
                }

                @Override
                public List setPrettyPrint(java.lang.Boolean prettyPrint) {
                  return (List) super.setPrettyPrint(prettyPrint);
                }

                @Override
                public List setQuotaUser(java.lang.String quotaUser) {
                  return (List) super.setQuotaUser(quotaUser);
                }

                @Override
                public List setUploadType(java.lang.String uploadType) {
                  return (List) super.setUploadType(uploadType);
                }

                @Override
                public List setUploadProtocol(java.lang.String uploadProtocol) {
                  return (List) super.setUploadProtocol(uploadProtocol);
                }

                /**
                 * Required. The subject whose versions are to be listed. Structured like: `projects
                 * /{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subj
                 * ect}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_regist
                 * ry}/contexts/{context}/subjects/{subject}`
                 */
                @com.google.api.client.util.Key
                private java.lang.String parent;

                /** Required. The subject whose versions are to be listed. Structured like:
               `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}` or
               `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subj
               ects/{subject}`
                 */
                public java.lang.String getParent() {
                  return parent;
                }

                /**
                 * Required. The subject whose versions are to be listed. Structured like: `projects
                 * /{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subj
                 * ect}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_regist
                 * ry}/contexts/{context}/subjects/{subject}`
                 */
                public List setParent(java.lang.String parent) {
                  if (!getSuppressPatternChecks()) {
                    com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                        "Parameter parent must conform to the pattern " +
                        "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+$");
                  }
                  this.parent = parent;
                  return this;
                }

                /**
                 * Optional. If true, the response will include soft-deleted versions of an active
                 * or soft-deleted subject. The default is false.
                 */
                @com.google.api.client.util.Key
                private java.lang.Boolean deleted;

                /** Optional. If true, the response will include soft-deleted versions of an active or soft-deleted
               subject. The default is false.
                 */
                public java.lang.Boolean getDeleted() {
                  return deleted;
                }

                /**
                 * Optional. If true, the response will include soft-deleted versions of an active
                 * or soft-deleted subject. The default is false.
                 */
                public List setDeleted(java.lang.Boolean deleted) {
                  this.deleted = deleted;
                  return this;
                }

                @Override
                public List set(String parameterName, Object value) {
                  return (List) super.set(parameterName, value);
                }
              }

              /**
               * An accessor for creating requests from the Referencedby collection.
               *
               * <p>The typical use is:</p>
               * <pre>
               *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
               *   {@code ManagedKafka.Referencedby.List request = managedkafka.referencedby().list(parameters ...)}
               * </pre>
               *
               * @return the resource collection
               */
              public Referencedby referencedby() {
                return new Referencedby();
              }

              /**
               * The "referencedby" collection of methods.
               */
              public class Referencedby {

                /**
                 * Get a list of IDs of schemas that reference the schema with the given subject and version.
                 *
                 * Create a request for the method "referencedby.list".
                 *
                 * This request holds the parameters needed by the managedkafka server.  After setting any optional
                 * parameters, call the {@link List#execute()} method to invoke the remote operation.
                 *
                 * @param parent Required. The version to list referenced by. Structured like: `projects/{project}/locations/{locatio
                 *        n}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `projects/
                 *        {project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subje
                 *        cts/{subject}/versions/{version}`
                 * @return the request
                 */
                public List list(java.lang.String parent) throws java.io.IOException {
                  List result = new List(parent);
                  initialize(result);
                  return result;
                }

                public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

                  private static final String REST_PATH = "v1/{+parent}/referencedby";

                  private final java.util.regex.Pattern PARENT_PATTERN =
                      java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+/versions/[^/]+$");

                  /**
                   * Get a list of IDs of schemas that reference the schema with the given subject and version.
                   *
                   * Create a request for the method "referencedby.list".
                   *
                   * This request holds the parameters needed by the the managedkafka server.  After setting any
                   * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
                   * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
                   * must be called to initialize this instance immediately after invoking the constructor. </p>
                   *
                   * @param parent Required. The version to list referenced by. Structured like: `projects/{project}/locations/{locatio
                 *        n}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `projects/
                 *        {project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subje
                 *        cts/{subject}/versions/{version}`
                   * @since 1.13
                   */
                  protected List(java.lang.String parent) {
                    super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
                    this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
                    if (!getSuppressPatternChecks()) {
                      com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                          "Parameter parent must conform to the pattern " +
                          "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+/versions/[^/]+$");
                    }
                  }

                  @Override
                  public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
                    return super.executeUsingHead();
                  }

                  @Override
                  public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
                    return super.buildHttpRequestUsingHead();
                  }

                  @Override
                  public List set$Xgafv(java.lang.String $Xgafv) {
                    return (List) super.set$Xgafv($Xgafv);
                  }

                  @Override
                  public List setAccessToken(java.lang.String accessToken) {
                    return (List) super.setAccessToken(accessToken);
                  }

                  @Override
                  public List setAlt(java.lang.String alt) {
                    return (List) super.setAlt(alt);
                  }

                  @Override
                  public List setCallback(java.lang.String callback) {
                    return (List) super.setCallback(callback);
                  }

                  @Override
                  public List setFields(java.lang.String fields) {
                    return (List) super.setFields(fields);
                  }

                  @Override
                  public List setKey(java.lang.String key) {
                    return (List) super.setKey(key);
                  }

                  @Override
                  public List setOauthToken(java.lang.String oauthToken) {
                    return (List) super.setOauthToken(oauthToken);
                  }

                  @Override
                  public List setPrettyPrint(java.lang.Boolean prettyPrint) {
                    return (List) super.setPrettyPrint(prettyPrint);
                  }

                  @Override
                  public List setQuotaUser(java.lang.String quotaUser) {
                    return (List) super.setQuotaUser(quotaUser);
                  }

                  @Override
                  public List setUploadType(java.lang.String uploadType) {
                    return (List) super.setUploadType(uploadType);
                  }

                  @Override
                  public List setUploadProtocol(java.lang.String uploadProtocol) {
                    return (List) super.setUploadProtocol(uploadProtocol);
                  }

                  /**
                   * Required. The version to list referenced by. Structured like: `projects/{projec
                   * t}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/v
                   * ersions/{version}` or `projects/{project}/locations/{location}/schemaRegistries
                   * /{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
                   */
                  @com.google.api.client.util.Key
                  private java.lang.String parent;

                  /** Required. The version to list referenced by. Structured like: `projects/{project}/locations/{locati
                 on}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `projects/{project
                 }/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/ver
                 sions/{version}`
                   */
                  public java.lang.String getParent() {
                    return parent;
                  }

                  /**
                   * Required. The version to list referenced by. Structured like: `projects/{projec
                   * t}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/v
                   * ersions/{version}` or `projects/{project}/locations/{location}/schemaRegistries
                   * /{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
                   */
                  public List setParent(java.lang.String parent) {
                    if (!getSuppressPatternChecks()) {
                      com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                          "Parameter parent must conform to the pattern " +
                          "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/contexts/[^/]+/subjects/[^/]+/versions/[^/]+$");
                    }
                    this.parent = parent;
                    return this;
                  }

                  @Override
                  public List set(String parameterName, Object value) {
                    return (List) super.set(parameterName, value);
                  }
                }

              }
            }
          }
        }
        /**
         * An accessor for creating requests from the Mode collection.
         *
         * <p>The typical use is:</p>
         * <pre>
         *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
         *   {@code ManagedKafka.Mode.List request = managedkafka.mode().list(parameters ...)}
         * </pre>
         *
         * @return the resource collection
         */
        public Mode mode() {
          return new Mode();
        }

        /**
         * The "mode" collection of methods.
         */
        public class Mode {

          /**
           * Get mode at global level or for a subject.
           *
           * Create a request for the method "mode.get".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Get#execute()} method to invoke the remote operation.
           *
           * @param name Required. The resource name of the mode. The format is *
           *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}:
           *        mode for a schema registry, or * projects/{project}/locations/{location}/schemaRegistries/
           *        {schema_registry}/contexts/{context}/mode/{subject}: mode for a specific subject in a
           *        specific context
           * @return the request
           */
          public Get get(java.lang.String name) throws java.io.IOException {
            Get result = new Get(name);
            initialize(result);
            return result;
          }

          public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.SchemaMode> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/mode/.*$");

            /**
             * Get mode at global level or for a subject.
             *
             * Create a request for the method "mode.get".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
             * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The resource name of the mode. The format is *
           *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}:
           *        mode for a schema registry, or * projects/{project}/locations/{location}/schemaRegistries/
           *        {schema_registry}/contexts/{context}/mode/{subject}: mode for a specific subject in a
           *        specific context
             * @since 1.13
             */
            protected Get(java.lang.String name) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.SchemaMode.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/mode/.*$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public Get set$Xgafv(java.lang.String $Xgafv) {
              return (Get) super.set$Xgafv($Xgafv);
            }

            @Override
            public Get setAccessToken(java.lang.String accessToken) {
              return (Get) super.setAccessToken(accessToken);
            }

            @Override
            public Get setAlt(java.lang.String alt) {
              return (Get) super.setAlt(alt);
            }

            @Override
            public Get setCallback(java.lang.String callback) {
              return (Get) super.setCallback(callback);
            }

            @Override
            public Get setFields(java.lang.String fields) {
              return (Get) super.setFields(fields);
            }

            @Override
            public Get setKey(java.lang.String key) {
              return (Get) super.setKey(key);
            }

            @Override
            public Get setOauthToken(java.lang.String oauthToken) {
              return (Get) super.setOauthToken(oauthToken);
            }

            @Override
            public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Get) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Get setQuotaUser(java.lang.String quotaUser) {
              return (Get) super.setQuotaUser(quotaUser);
            }

            @Override
            public Get setUploadType(java.lang.String uploadType) {
              return (Get) super.setUploadType(uploadType);
            }

            @Override
            public Get setUploadProtocol(java.lang.String uploadProtocol) {
              return (Get) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The resource name of the mode. The format is * projects/{project}/locations
             * /{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for a schema
             * registry, or * projects/{project}/locations/{location}/schemaRegistries/{schema_regis
             * try}/contexts/{context}/mode/{subject}: mode for a specific subject in a specific
             * context
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The resource name of the mode. The format is *
           projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for
           a schema registry, or * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
           contexts/{context}/mode/{subject}: mode for a specific subject in a specific context
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The resource name of the mode. The format is * projects/{project}/locations
             * /{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for a schema
             * registry, or * projects/{project}/locations/{location}/schemaRegistries/{schema_regis
             * try}/contexts/{context}/mode/{subject}: mode for a specific subject in a specific
             * context
             */
            public Get setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/mode/.*$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Get set(String parameterName, Object value) {
              return (Get) super.set(parameterName, value);
            }
          }
          /**
           * Update mode at global level or for a subject.
           *
           * Create a request for the method "mode.update".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Update#execute()} method to invoke the remote operation.
           *
           * @param name Required. The resource name of the mode. The format is *
           *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}:
           *        mode for a schema registry, or * projects/{project}/locations/{location}/schemaRegistries/
           *        {schema_registry}/contexts/{context}/mode/{subject}: mode for a specific subject in a
           *        specific context
           * @param content the {@link com.google.api.services.managedkafka.v1.model.UpdateSchemaModeRequest}
           * @return the request
           */
          public Update update(java.lang.String name, com.google.api.services.managedkafka.v1.model.UpdateSchemaModeRequest content) throws java.io.IOException {
            Update result = new Update(name, content);
            initialize(result);
            return result;
          }

          public class Update extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.SchemaMode> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/mode/.*$");

            /**
             * Update mode at global level or for a subject.
             *
             * Create a request for the method "mode.update".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Update#execute()} method to invoke the remote operation.
             * <p> {@link
             * Update#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The resource name of the mode. The format is *
           *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}:
           *        mode for a schema registry, or * projects/{project}/locations/{location}/schemaRegistries/
           *        {schema_registry}/contexts/{context}/mode/{subject}: mode for a specific subject in a
           *        specific context
             * @param content the {@link com.google.api.services.managedkafka.v1.model.UpdateSchemaModeRequest}
             * @since 1.13
             */
            protected Update(java.lang.String name, com.google.api.services.managedkafka.v1.model.UpdateSchemaModeRequest content) {
              super(ManagedKafka.this, "PUT", REST_PATH, content, com.google.api.services.managedkafka.v1.model.SchemaMode.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/mode/.*$");
              }
            }

            @Override
            public Update set$Xgafv(java.lang.String $Xgafv) {
              return (Update) super.set$Xgafv($Xgafv);
            }

            @Override
            public Update setAccessToken(java.lang.String accessToken) {
              return (Update) super.setAccessToken(accessToken);
            }

            @Override
            public Update setAlt(java.lang.String alt) {
              return (Update) super.setAlt(alt);
            }

            @Override
            public Update setCallback(java.lang.String callback) {
              return (Update) super.setCallback(callback);
            }

            @Override
            public Update setFields(java.lang.String fields) {
              return (Update) super.setFields(fields);
            }

            @Override
            public Update setKey(java.lang.String key) {
              return (Update) super.setKey(key);
            }

            @Override
            public Update setOauthToken(java.lang.String oauthToken) {
              return (Update) super.setOauthToken(oauthToken);
            }

            @Override
            public Update setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Update) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Update setQuotaUser(java.lang.String quotaUser) {
              return (Update) super.setQuotaUser(quotaUser);
            }

            @Override
            public Update setUploadType(java.lang.String uploadType) {
              return (Update) super.setUploadType(uploadType);
            }

            @Override
            public Update setUploadProtocol(java.lang.String uploadProtocol) {
              return (Update) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The resource name of the mode. The format is * projects/{project}/locations
             * /{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for a schema
             * registry, or * projects/{project}/locations/{location}/schemaRegistries/{schema_regis
             * try}/contexts/{context}/mode/{subject}: mode for a specific subject in a specific
             * context
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The resource name of the mode. The format is *
           projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for
           a schema registry, or * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
           contexts/{context}/mode/{subject}: mode for a specific subject in a specific context
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The resource name of the mode. The format is * projects/{project}/locations
             * /{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for a schema
             * registry, or * projects/{project}/locations/{location}/schemaRegistries/{schema_regis
             * try}/contexts/{context}/mode/{subject}: mode for a specific subject in a specific
             * context
             */
            public Update setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/mode/.*$");
              }
              this.name = name;
              return this;
            }

            @Override
            public Update set(String parameterName, Object value) {
              return (Update) super.set(parameterName, value);
            }
          }

        }
        /**
         * An accessor for creating requests from the Schemas collection.
         *
         * <p>The typical use is:</p>
         * <pre>
         *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
         *   {@code ManagedKafka.Schemas.List request = managedkafka.schemas().list(parameters ...)}
         * </pre>
         *
         * @return the resource collection
         */
        public Schemas schemas() {
          return new Schemas();
        }

        /**
         * The "schemas" collection of methods.
         */
        public class Schemas {

          /**
           * Get the schema for the given schema id.
           *
           * Create a request for the method "schemas.get".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Get#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the schema to return. Structured like:
           *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{s
           *        chema}`
           * @return the request
           */
          public Get get(java.lang.String name) throws java.io.IOException {
            Get result = new Get(name);
            initialize(result);
            return result;
          }

          public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.Schema> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/schemas/.*$");

            /**
             * Get the schema for the given schema id.
             *
             * Create a request for the method "schemas.get".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
             * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the schema to return. Structured like:
           *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{s
           *        chema}`
             * @since 1.13
             */
            protected Get(java.lang.String name) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.Schema.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/schemas/.*$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public Get set$Xgafv(java.lang.String $Xgafv) {
              return (Get) super.set$Xgafv($Xgafv);
            }

            @Override
            public Get setAccessToken(java.lang.String accessToken) {
              return (Get) super.setAccessToken(accessToken);
            }

            @Override
            public Get setAlt(java.lang.String alt) {
              return (Get) super.setAlt(alt);
            }

            @Override
            public Get setCallback(java.lang.String callback) {
              return (Get) super.setCallback(callback);
            }

            @Override
            public Get setFields(java.lang.String fields) {
              return (Get) super.setFields(fields);
            }

            @Override
            public Get setKey(java.lang.String key) {
              return (Get) super.setKey(key);
            }

            @Override
            public Get setOauthToken(java.lang.String oauthToken) {
              return (Get) super.setOauthToken(oauthToken);
            }

            @Override
            public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Get) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Get setQuotaUser(java.lang.String quotaUser) {
              return (Get) super.setQuotaUser(quotaUser);
            }

            @Override
            public Get setUploadType(java.lang.String uploadType) {
              return (Get) super.setUploadType(uploadType);
            }

            @Override
            public Get setUploadProtocol(java.lang.String uploadProtocol) {
              return (Get) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the schema to return. Structured like: `projects/{project}/loca
             * tions/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the schema to return. Structured like:
           `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the schema to return. Structured like: `projects/{project}/loca
             * tions/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
             */
            public Get setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/schemas/.*$");
              }
              this.name = name;
              return this;
            }

            /**
             * Optional. Used to limit the search for the schema ID to a specific subject, otherwise
             * the schema ID will be searched for in all subjects in the given specified context.
             */
            @com.google.api.client.util.Key
            private java.lang.String subject;

            /** Optional. Used to limit the search for the schema ID to a specific subject, otherwise the schema ID
           will be searched for in all subjects in the given specified context.
             */
            public java.lang.String getSubject() {
              return subject;
            }

            /**
             * Optional. Used to limit the search for the schema ID to a specific subject, otherwise
             * the schema ID will be searched for in all subjects in the given specified context.
             */
            public Get setSubject(java.lang.String subject) {
              this.subject = subject;
              return this;
            }

            @Override
            public Get set(String parameterName, Object value) {
              return (Get) super.set(parameterName, value);
            }
          }
          /**
           * Get the schema string for the given schema id. The response will be the schema string.
           *
           * Create a request for the method "schemas.getSchema".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link GetSchema#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the schema to return. Structured like:
           *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{s
           *        chema}`
           * @return the request
           */
          public GetSchema getSchema(java.lang.String name) throws java.io.IOException {
            GetSchema result = new GetSchema(name);
            initialize(result);
            return result;
          }

          public class GetSchema extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

            private static final String REST_PATH = "v1/{+name}/schema";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/schemas/.*$");

            /**
             * Get the schema string for the given schema id. The response will be the schema string.
             *
             * Create a request for the method "schemas.getSchema".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link GetSchema#execute()} method to invoke the remote
             * operation. <p> {@link
             * GetSchema#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the schema to return. Structured like:
           *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{s
           *        chema}`
             * @since 1.13
             */
            protected GetSchema(java.lang.String name) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/schemas/.*$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public GetSchema set$Xgafv(java.lang.String $Xgafv) {
              return (GetSchema) super.set$Xgafv($Xgafv);
            }

            @Override
            public GetSchema setAccessToken(java.lang.String accessToken) {
              return (GetSchema) super.setAccessToken(accessToken);
            }

            @Override
            public GetSchema setAlt(java.lang.String alt) {
              return (GetSchema) super.setAlt(alt);
            }

            @Override
            public GetSchema setCallback(java.lang.String callback) {
              return (GetSchema) super.setCallback(callback);
            }

            @Override
            public GetSchema setFields(java.lang.String fields) {
              return (GetSchema) super.setFields(fields);
            }

            @Override
            public GetSchema setKey(java.lang.String key) {
              return (GetSchema) super.setKey(key);
            }

            @Override
            public GetSchema setOauthToken(java.lang.String oauthToken) {
              return (GetSchema) super.setOauthToken(oauthToken);
            }

            @Override
            public GetSchema setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (GetSchema) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public GetSchema setQuotaUser(java.lang.String quotaUser) {
              return (GetSchema) super.setQuotaUser(quotaUser);
            }

            @Override
            public GetSchema setUploadType(java.lang.String uploadType) {
              return (GetSchema) super.setUploadType(uploadType);
            }

            @Override
            public GetSchema setUploadProtocol(java.lang.String uploadProtocol) {
              return (GetSchema) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the schema to return. Structured like: `projects/{project}/loca
             * tions/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the schema to return. Structured like:
           `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the schema to return. Structured like: `projects/{project}/loca
             * tions/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
             */
            public GetSchema setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/schemas/.*$");
              }
              this.name = name;
              return this;
            }

            /**
             * Optional. Used to limit the search for the schema ID to a specific subject, otherwise
             * the schema ID will be searched for in all subjects in the given specified context.
             */
            @com.google.api.client.util.Key
            private java.lang.String subject;

            /** Optional. Used to limit the search for the schema ID to a specific subject, otherwise the schema ID
           will be searched for in all subjects in the given specified context.
             */
            public java.lang.String getSubject() {
              return subject;
            }

            /**
             * Optional. Used to limit the search for the schema ID to a specific subject, otherwise
             * the schema ID will be searched for in all subjects in the given specified context.
             */
            public GetSchema setSubject(java.lang.String subject) {
              this.subject = subject;
              return this;
            }

            @Override
            public GetSchema set(String parameterName, Object value) {
              return (GetSchema) super.set(parameterName, value);
            }
          }

          /**
           * An accessor for creating requests from the Subjects collection.
           *
           * <p>The typical use is:</p>
           * <pre>
           *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
           *   {@code ManagedKafka.Subjects.List request = managedkafka.subjects().list(parameters ...)}
           * </pre>
           *
           * @return the resource collection
           */
          public Subjects subjects() {
            return new Subjects();
          }

          /**
           * The "subjects" collection of methods.
           */
          public class Subjects {

            /**
             * List subjects which reference a particular schema id. The response will be an array of subject
             * names.
             *
             * Create a request for the method "subjects.list".
             *
             * This request holds the parameters needed by the managedkafka server.  After setting any optional
             * parameters, call the {@link List#execute()} method to invoke the remote operation.
             *
             * @param parent Required. The schema resource whose associated subjects are to be listed. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{s
             *        chema}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/con
             *        texts/{context}/schemas/ids/{schema}`
             * @return the request
             */
            public List list(java.lang.String parent) throws java.io.IOException {
              List result = new List(parent);
              initialize(result);
              return result;
            }

            public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

              private static final String REST_PATH = "v1/{+parent}/subjects";

              private final java.util.regex.Pattern PARENT_PATTERN =
                  java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/schemas/.*$");

              /**
               * List subjects which reference a particular schema id. The response will be an array of subject
               * names.
               *
               * Create a request for the method "subjects.list".
               *
               * This request holds the parameters needed by the the managedkafka server.  After setting any
               * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
               * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
               * must be called to initialize this instance immediately after invoking the constructor. </p>
               *
               * @param parent Required. The schema resource whose associated subjects are to be listed. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{s
             *        chema}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/con
             *        texts/{context}/schemas/ids/{schema}`
               * @since 1.13
               */
              protected List(java.lang.String parent) {
                super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
                this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                      "Parameter parent must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/schemas/.*$");
                }
              }

              @Override
              public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
                return super.executeUsingHead();
              }

              @Override
              public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
                return super.buildHttpRequestUsingHead();
              }

              @Override
              public List set$Xgafv(java.lang.String $Xgafv) {
                return (List) super.set$Xgafv($Xgafv);
              }

              @Override
              public List setAccessToken(java.lang.String accessToken) {
                return (List) super.setAccessToken(accessToken);
              }

              @Override
              public List setAlt(java.lang.String alt) {
                return (List) super.setAlt(alt);
              }

              @Override
              public List setCallback(java.lang.String callback) {
                return (List) super.setCallback(callback);
              }

              @Override
              public List setFields(java.lang.String fields) {
                return (List) super.setFields(fields);
              }

              @Override
              public List setKey(java.lang.String key) {
                return (List) super.setKey(key);
              }

              @Override
              public List setOauthToken(java.lang.String oauthToken) {
                return (List) super.setOauthToken(oauthToken);
              }

              @Override
              public List setPrettyPrint(java.lang.Boolean prettyPrint) {
                return (List) super.setPrettyPrint(prettyPrint);
              }

              @Override
              public List setQuotaUser(java.lang.String quotaUser) {
                return (List) super.setQuotaUser(quotaUser);
              }

              @Override
              public List setUploadType(java.lang.String uploadType) {
                return (List) super.setUploadType(uploadType);
              }

              @Override
              public List setUploadProtocol(java.lang.String uploadProtocol) {
                return (List) super.setUploadProtocol(uploadProtocol);
              }

              /**
               * Required. The schema resource whose associated subjects are to be listed.
               * Structured like: `projects/{project}/locations/{location}/schemaRegistries/{schema_
               * registry}/schemas/ids/{schema}` or `projects/{project}/locations/{location}/schemaR
               * egistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
               */
              @com.google.api.client.util.Key
              private java.lang.String parent;

              /** Required. The schema resource whose associated subjects are to be listed. Structured like:
             `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
             or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/s
             chemas/ids/{schema}`
               */
              public java.lang.String getParent() {
                return parent;
              }

              /**
               * Required. The schema resource whose associated subjects are to be listed.
               * Structured like: `projects/{project}/locations/{location}/schemaRegistries/{schema_
               * registry}/schemas/ids/{schema}` or `projects/{project}/locations/{location}/schemaR
               * egistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
               */
              public List setParent(java.lang.String parent) {
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                      "Parameter parent must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/schemas/.*$");
                }
                this.parent = parent;
                return this;
              }

              /**
               * Optional. If true, the response will include soft-deleted subjects. The default is
               * false.
               */
              @com.google.api.client.util.Key
              private java.lang.Boolean deleted;

              /** Optional. If true, the response will include soft-deleted subjects. The default is false.
               */
              public java.lang.Boolean getDeleted() {
                return deleted;
              }

              /**
               * Optional. If true, the response will include soft-deleted subjects. The default is
               * false.
               */
              public List setDeleted(java.lang.Boolean deleted) {
                this.deleted = deleted;
                return this;
              }

              /** Optional. The subject to filter the subjects by. */
              @com.google.api.client.util.Key
              private java.lang.String subject;

              /** Optional. The subject to filter the subjects by.
               */
              public java.lang.String getSubject() {
                return subject;
              }

              /** Optional. The subject to filter the subjects by. */
              public List setSubject(java.lang.String subject) {
                this.subject = subject;
                return this;
              }

              @Override
              public List set(String parameterName, Object value) {
                return (List) super.set(parameterName, value);
              }
            }

          }
          /**
           * An accessor for creating requests from the Types collection.
           *
           * <p>The typical use is:</p>
           * <pre>
           *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
           *   {@code ManagedKafka.Types.List request = managedkafka.types().list(parameters ...)}
           * </pre>
           *
           * @return the resource collection
           */
          public Types types() {
            return new Types();
          }

          /**
           * The "types" collection of methods.
           */
          public class Types {

            /**
             * List the supported schema types. The response will be an array of schema types.
             *
             * Create a request for the method "types.list".
             *
             * This request holds the parameters needed by the managedkafka server.  After setting any optional
             * parameters, call the {@link List#execute()} method to invoke the remote operation.
             *
             * @param parent Required. The parent schema registry whose schema types are to be listed. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
             * @return the request
             */
            public List list(java.lang.String parent) throws java.io.IOException {
              List result = new List(parent);
              initialize(result);
              return result;
            }

            public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

              private static final String REST_PATH = "v1/{+parent}/schemas/types";

              private final java.util.regex.Pattern PARENT_PATTERN =
                  java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+$");

              /**
               * List the supported schema types. The response will be an array of schema types.
               *
               * Create a request for the method "types.list".
               *
               * This request holds the parameters needed by the the managedkafka server.  After setting any
               * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
               * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
               * must be called to initialize this instance immediately after invoking the constructor. </p>
               *
               * @param parent Required. The parent schema registry whose schema types are to be listed. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
               * @since 1.13
               */
              protected List(java.lang.String parent) {
                super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
                this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                      "Parameter parent must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+$");
                }
              }

              @Override
              public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
                return super.executeUsingHead();
              }

              @Override
              public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
                return super.buildHttpRequestUsingHead();
              }

              @Override
              public List set$Xgafv(java.lang.String $Xgafv) {
                return (List) super.set$Xgafv($Xgafv);
              }

              @Override
              public List setAccessToken(java.lang.String accessToken) {
                return (List) super.setAccessToken(accessToken);
              }

              @Override
              public List setAlt(java.lang.String alt) {
                return (List) super.setAlt(alt);
              }

              @Override
              public List setCallback(java.lang.String callback) {
                return (List) super.setCallback(callback);
              }

              @Override
              public List setFields(java.lang.String fields) {
                return (List) super.setFields(fields);
              }

              @Override
              public List setKey(java.lang.String key) {
                return (List) super.setKey(key);
              }

              @Override
              public List setOauthToken(java.lang.String oauthToken) {
                return (List) super.setOauthToken(oauthToken);
              }

              @Override
              public List setPrettyPrint(java.lang.Boolean prettyPrint) {
                return (List) super.setPrettyPrint(prettyPrint);
              }

              @Override
              public List setQuotaUser(java.lang.String quotaUser) {
                return (List) super.setQuotaUser(quotaUser);
              }

              @Override
              public List setUploadType(java.lang.String uploadType) {
                return (List) super.setUploadType(uploadType);
              }

              @Override
              public List setUploadProtocol(java.lang.String uploadProtocol) {
                return (List) super.setUploadProtocol(uploadProtocol);
              }

              /**
               * Required. The parent schema registry whose schema types are to be listed.
               * Structured like:
               * `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
               */
              @com.google.api.client.util.Key
              private java.lang.String parent;

              /** Required. The parent schema registry whose schema types are to be listed. Structured like:
             `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
               */
              public java.lang.String getParent() {
                return parent;
              }

              /**
               * Required. The parent schema registry whose schema types are to be listed.
               * Structured like:
               * `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
               */
              public List setParent(java.lang.String parent) {
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                      "Parameter parent must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+$");
                }
                this.parent = parent;
                return this;
              }

              @Override
              public List set(String parameterName, Object value) {
                return (List) super.set(parameterName, value);
              }
            }

          }
          /**
           * An accessor for creating requests from the Versions collection.
           *
           * <p>The typical use is:</p>
           * <pre>
           *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
           *   {@code ManagedKafka.Versions.List request = managedkafka.versions().list(parameters ...)}
           * </pre>
           *
           * @return the resource collection
           */
          public Versions versions() {
            return new Versions();
          }

          /**
           * The "versions" collection of methods.
           */
          public class Versions {

            /**
             * List the schema versions for the given schema id. The response will be an array of subject-
             * version pairs as: [{"subject":"subject1", "version":1}, {"subject":"subject2", "version":2}].
             *
             * Create a request for the method "versions.list".
             *
             * This request holds the parameters needed by the managedkafka server.  After setting any optional
             * parameters, call the {@link List#execute()} method to invoke the remote operation.
             *
             * @param parent Required. The schema whose schema versions are to be listed. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{s
             *        chema}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/con
             *        texts/{context}/schemas/ids/{schema}`
             * @return the request
             */
            public List list(java.lang.String parent) throws java.io.IOException {
              List result = new List(parent);
              initialize(result);
              return result;
            }

            public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

              private static final String REST_PATH = "v1/{+parent}/versions";

              private final java.util.regex.Pattern PARENT_PATTERN =
                  java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/schemas/.*$");

              /**
               * List the schema versions for the given schema id. The response will be an array of subject-
               * version pairs as: [{"subject":"subject1", "version":1}, {"subject":"subject2", "version":2}].
               *
               * Create a request for the method "versions.list".
               *
               * This request holds the parameters needed by the the managedkafka server.  After setting any
               * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
               * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
               * must be called to initialize this instance immediately after invoking the constructor. </p>
               *
               * @param parent Required. The schema whose schema versions are to be listed. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{s
             *        chema}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/con
             *        texts/{context}/schemas/ids/{schema}`
               * @since 1.13
               */
              protected List(java.lang.String parent) {
                super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
                this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                      "Parameter parent must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/schemas/.*$");
                }
              }

              @Override
              public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
                return super.executeUsingHead();
              }

              @Override
              public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
                return super.buildHttpRequestUsingHead();
              }

              @Override
              public List set$Xgafv(java.lang.String $Xgafv) {
                return (List) super.set$Xgafv($Xgafv);
              }

              @Override
              public List setAccessToken(java.lang.String accessToken) {
                return (List) super.setAccessToken(accessToken);
              }

              @Override
              public List setAlt(java.lang.String alt) {
                return (List) super.setAlt(alt);
              }

              @Override
              public List setCallback(java.lang.String callback) {
                return (List) super.setCallback(callback);
              }

              @Override
              public List setFields(java.lang.String fields) {
                return (List) super.setFields(fields);
              }

              @Override
              public List setKey(java.lang.String key) {
                return (List) super.setKey(key);
              }

              @Override
              public List setOauthToken(java.lang.String oauthToken) {
                return (List) super.setOauthToken(oauthToken);
              }

              @Override
              public List setPrettyPrint(java.lang.Boolean prettyPrint) {
                return (List) super.setPrettyPrint(prettyPrint);
              }

              @Override
              public List setQuotaUser(java.lang.String quotaUser) {
                return (List) super.setQuotaUser(quotaUser);
              }

              @Override
              public List setUploadType(java.lang.String uploadType) {
                return (List) super.setUploadType(uploadType);
              }

              @Override
              public List setUploadProtocol(java.lang.String uploadProtocol) {
                return (List) super.setUploadProtocol(uploadProtocol);
              }

              /**
               * Required. The schema whose schema versions are to be listed. Structured like: `proj
               * ects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/
               * {schema}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_regi
               * stry}/contexts/{context}/schemas/ids/{schema}`
               */
              @com.google.api.client.util.Key
              private java.lang.String parent;

              /** Required. The schema whose schema versions are to be listed. Structured like:
             `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
             or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/s
             chemas/ids/{schema}`
               */
              public java.lang.String getParent() {
                return parent;
              }

              /**
               * Required. The schema whose schema versions are to be listed. Structured like: `proj
               * ects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/
               * {schema}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_regi
               * stry}/contexts/{context}/schemas/ids/{schema}`
               */
              public List setParent(java.lang.String parent) {
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                      "Parameter parent must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/schemas/.*$");
                }
                this.parent = parent;
                return this;
              }

              /**
               * Optional. If true, the response will include soft-deleted versions of the schema,
               * even if the subject is soft-deleted. The default is false.
               */
              @com.google.api.client.util.Key
              private java.lang.Boolean deleted;

              /** Optional. If true, the response will include soft-deleted versions of the schema, even if the
             subject is soft-deleted. The default is false.
               */
              public java.lang.Boolean getDeleted() {
                return deleted;
              }

              /**
               * Optional. If true, the response will include soft-deleted versions of the schema,
               * even if the subject is soft-deleted. The default is false.
               */
              public List setDeleted(java.lang.Boolean deleted) {
                this.deleted = deleted;
                return this;
              }

              /** Optional. The subject to filter the subjects by. */
              @com.google.api.client.util.Key
              private java.lang.String subject;

              /** Optional. The subject to filter the subjects by.
               */
              public java.lang.String getSubject() {
                return subject;
              }

              /** Optional. The subject to filter the subjects by. */
              public List setSubject(java.lang.String subject) {
                this.subject = subject;
                return this;
              }

              @Override
              public List set(String parameterName, Object value) {
                return (List) super.set(parameterName, value);
              }
            }

          }
        }
        /**
         * An accessor for creating requests from the Subjects collection.
         *
         * <p>The typical use is:</p>
         * <pre>
         *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
         *   {@code ManagedKafka.Subjects.List request = managedkafka.subjects().list(parameters ...)}
         * </pre>
         *
         * @return the resource collection
         */
        public Subjects subjects() {
          return new Subjects();
        }

        /**
         * The "subjects" collection of methods.
         */
        public class Subjects {

          /**
           * Delete a subject. The response will be an array of versions of the deleted subject.
           *
           * Create a request for the method "subjects.delete".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
           *
           * @param name Required. The name of the subject to delete. Structured like:
           *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subj
           *        ect}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/conte
           *        xts/{context}/subjects/{subject}`
           * @return the request
           */
          public Delete delete(java.lang.String name) throws java.io.IOException {
            Delete result = new Delete(name);
            initialize(result);
            return result;
          }

          public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

            private static final String REST_PATH = "v1/{+name}";

            private final java.util.regex.Pattern NAME_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+$");

            /**
             * Delete a subject. The response will be an array of versions of the deleted subject.
             *
             * Create a request for the method "subjects.delete".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
             * <p> {@link
             * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
             * be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param name Required. The name of the subject to delete. Structured like:
           *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subj
           *        ect}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/conte
           *        xts/{context}/subjects/{subject}`
             * @since 1.13
             */
            protected Delete(java.lang.String name) {
              super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
              this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+$");
              }
            }

            @Override
            public Delete set$Xgafv(java.lang.String $Xgafv) {
              return (Delete) super.set$Xgafv($Xgafv);
            }

            @Override
            public Delete setAccessToken(java.lang.String accessToken) {
              return (Delete) super.setAccessToken(accessToken);
            }

            @Override
            public Delete setAlt(java.lang.String alt) {
              return (Delete) super.setAlt(alt);
            }

            @Override
            public Delete setCallback(java.lang.String callback) {
              return (Delete) super.setCallback(callback);
            }

            @Override
            public Delete setFields(java.lang.String fields) {
              return (Delete) super.setFields(fields);
            }

            @Override
            public Delete setKey(java.lang.String key) {
              return (Delete) super.setKey(key);
            }

            @Override
            public Delete setOauthToken(java.lang.String oauthToken) {
              return (Delete) super.setOauthToken(oauthToken);
            }

            @Override
            public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (Delete) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public Delete setQuotaUser(java.lang.String quotaUser) {
              return (Delete) super.setQuotaUser(quotaUser);
            }

            @Override
            public Delete setUploadType(java.lang.String uploadType) {
              return (Delete) super.setUploadType(uploadType);
            }

            @Override
            public Delete setUploadProtocol(java.lang.String uploadProtocol) {
              return (Delete) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The name of the subject to delete. Structured like: `projects/{project}/loc
             * ations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}` or `projects
             * /{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}
             * /subjects/{subject}`
             */
            @com.google.api.client.util.Key
            private java.lang.String name;

            /** Required. The name of the subject to delete. Structured like:
           `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}` or
           `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subj
           ects/{subject}`
             */
            public java.lang.String getName() {
              return name;
            }

            /**
             * Required. The name of the subject to delete. Structured like: `projects/{project}/loc
             * ations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}` or `projects
             * /{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}
             * /subjects/{subject}`
             */
            public Delete setName(java.lang.String name) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                    "Parameter name must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+$");
              }
              this.name = name;
              return this;
            }

            /**
             * Optional. If true, the subject and all associated metadata including the schema ID
             * will be deleted permanently. Otherwise, only the subject is soft-deleted. The default
             * is false. Soft-deleted subjects can still be searched in ListSubjects API call with
             * deleted=true query parameter. A soft-delete of a subject must be performed before a
             * hard-delete.
             */
            @com.google.api.client.util.Key
            private java.lang.Boolean permanent;

            /** Optional. If true, the subject and all associated metadata including the schema ID will be deleted
           permanently. Otherwise, only the subject is soft-deleted. The default is false. Soft-deleted
           subjects can still be searched in ListSubjects API call with deleted=true query parameter. A soft-
           delete of a subject must be performed before a hard-delete.
             */
            public java.lang.Boolean getPermanent() {
              return permanent;
            }

            /**
             * Optional. If true, the subject and all associated metadata including the schema ID
             * will be deleted permanently. Otherwise, only the subject is soft-deleted. The default
             * is false. Soft-deleted subjects can still be searched in ListSubjects API call with
             * deleted=true query parameter. A soft-delete of a subject must be performed before a
             * hard-delete.
             */
            public Delete setPermanent(java.lang.Boolean permanent) {
              this.permanent = permanent;
              return this;
            }

            @Override
            public Delete set(String parameterName, Object value) {
              return (Delete) super.set(parameterName, value);
            }
          }
          /**
           * List subjects in the schema registry. The response will be an array of subject names.
           *
           * Create a request for the method "subjects.list".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link List#execute()} method to invoke the remote operation.
           *
           * @param parent Required. The parent schema registry/context whose subjects are to be listed. Structured like:
           *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}` or `projects/
           *        {project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
           * @return the request
           */
          public List list(java.lang.String parent) throws java.io.IOException {
            List result = new List(parent);
            initialize(result);
            return result;
          }

          public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

            private static final String REST_PATH = "v1/{+parent}/subjects";

            private final java.util.regex.Pattern PARENT_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+$");

            /**
             * List subjects in the schema registry. The response will be an array of subject names.
             *
             * Create a request for the method "subjects.list".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
             * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
             * must be called to initialize this instance immediately after invoking the constructor. </p>
             *
             * @param parent Required. The parent schema registry/context whose subjects are to be listed. Structured like:
           *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}` or `projects/
           *        {project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
             * @since 1.13
             */
            protected List(java.lang.String parent) {
              super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
              this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+$");
              }
            }

            @Override
            public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
              return super.executeUsingHead();
            }

            @Override
            public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
              return super.buildHttpRequestUsingHead();
            }

            @Override
            public List set$Xgafv(java.lang.String $Xgafv) {
              return (List) super.set$Xgafv($Xgafv);
            }

            @Override
            public List setAccessToken(java.lang.String accessToken) {
              return (List) super.setAccessToken(accessToken);
            }

            @Override
            public List setAlt(java.lang.String alt) {
              return (List) super.setAlt(alt);
            }

            @Override
            public List setCallback(java.lang.String callback) {
              return (List) super.setCallback(callback);
            }

            @Override
            public List setFields(java.lang.String fields) {
              return (List) super.setFields(fields);
            }

            @Override
            public List setKey(java.lang.String key) {
              return (List) super.setKey(key);
            }

            @Override
            public List setOauthToken(java.lang.String oauthToken) {
              return (List) super.setOauthToken(oauthToken);
            }

            @Override
            public List setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (List) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public List setQuotaUser(java.lang.String quotaUser) {
              return (List) super.setQuotaUser(quotaUser);
            }

            @Override
            public List setUploadType(java.lang.String uploadType) {
              return (List) super.setUploadType(uploadType);
            }

            @Override
            public List setUploadProtocol(java.lang.String uploadProtocol) {
              return (List) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The parent schema registry/context whose subjects are to be listed.
             * Structured like:
             * `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}` or `proj
             * ects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{cont
             * ext}`
             */
            @com.google.api.client.util.Key
            private java.lang.String parent;

            /** Required. The parent schema registry/context whose subjects are to be listed. Structured like:
           `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}` or
           `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
             */
            public java.lang.String getParent() {
              return parent;
            }

            /**
             * Required. The parent schema registry/context whose subjects are to be listed.
             * Structured like:
             * `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}` or `proj
             * ects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{cont
             * ext}`
             */
            public List setParent(java.lang.String parent) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+$");
              }
              this.parent = parent;
              return this;
            }

            /**
             * Optional. If true, the response will include soft-deleted subjects. The default is
             * false.
             */
            @com.google.api.client.util.Key
            private java.lang.Boolean deleted;

            /** Optional. If true, the response will include soft-deleted subjects. The default is false.
             */
            public java.lang.Boolean getDeleted() {
              return deleted;
            }

            /**
             * Optional. If true, the response will include soft-deleted subjects. The default is
             * false.
             */
            public List setDeleted(java.lang.Boolean deleted) {
              this.deleted = deleted;
              return this;
            }

            /**
             * Optional. The context to filter the subjects by, in the format of `:.{context}:`. If
             * unset, all subjects in the registry are returned. Set to empty string or add as
             * '?subjectPrefix=' at the end of this request to list subjects in the default context.
             */
            @com.google.api.client.util.Key
            private java.lang.String subjectPrefix;

            /** Optional. The context to filter the subjects by, in the format of `:.{context}:`. If unset, all
           subjects in the registry are returned. Set to empty string or add as '?subjectPrefix=' at the end
           of this request to list subjects in the default context.
             */
            public java.lang.String getSubjectPrefix() {
              return subjectPrefix;
            }

            /**
             * Optional. The context to filter the subjects by, in the format of `:.{context}:`. If
             * unset, all subjects in the registry are returned. Set to empty string or add as
             * '?subjectPrefix=' at the end of this request to list subjects in the default context.
             */
            public List setSubjectPrefix(java.lang.String subjectPrefix) {
              this.subjectPrefix = subjectPrefix;
              return this;
            }

            @Override
            public List set(String parameterName, Object value) {
              return (List) super.set(parameterName, value);
            }
          }
          /**
           * Lookup a schema under the specified subject.
           *
           * Create a request for the method "subjects.lookupVersion".
           *
           * This request holds the parameters needed by the managedkafka server.  After setting any optional
           * parameters, call the {@link LookupVersion#execute()} method to invoke the remote operation.
           *
           * @param parent Required. The subject to lookup the schema in. Structured like:
           *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subj
           *        ect}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/conte
           *        xts/{context}/subjects/{subject}`
           * @param content the {@link com.google.api.services.managedkafka.v1.model.LookupVersionRequest}
           * @return the request
           */
          public LookupVersion lookupVersion(java.lang.String parent, com.google.api.services.managedkafka.v1.model.LookupVersionRequest content) throws java.io.IOException {
            LookupVersion result = new LookupVersion(parent, content);
            initialize(result);
            return result;
          }

          public class LookupVersion extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.SchemaVersion> {

            private static final String REST_PATH = "v1/{+parent}";

            private final java.util.regex.Pattern PARENT_PATTERN =
                java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+$");

            /**
             * Lookup a schema under the specified subject.
             *
             * Create a request for the method "subjects.lookupVersion".
             *
             * This request holds the parameters needed by the the managedkafka server.  After setting any
             * optional parameters, call the {@link LookupVersion#execute()} method to invoke the remote
             * operation. <p> {@link LookupVersion#initialize(com.google.api.client.googleapis.services.Abstra
             * ctGoogleClientRequest)} must be called to initialize this instance immediately after invoking
             * the constructor. </p>
             *
             * @param parent Required. The subject to lookup the schema in. Structured like:
           *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subj
           *        ect}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/conte
           *        xts/{context}/subjects/{subject}`
             * @param content the {@link com.google.api.services.managedkafka.v1.model.LookupVersionRequest}
             * @since 1.13
             */
            protected LookupVersion(java.lang.String parent, com.google.api.services.managedkafka.v1.model.LookupVersionRequest content) {
              super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.SchemaVersion.class);
              this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+$");
              }
            }

            @Override
            public LookupVersion set$Xgafv(java.lang.String $Xgafv) {
              return (LookupVersion) super.set$Xgafv($Xgafv);
            }

            @Override
            public LookupVersion setAccessToken(java.lang.String accessToken) {
              return (LookupVersion) super.setAccessToken(accessToken);
            }

            @Override
            public LookupVersion setAlt(java.lang.String alt) {
              return (LookupVersion) super.setAlt(alt);
            }

            @Override
            public LookupVersion setCallback(java.lang.String callback) {
              return (LookupVersion) super.setCallback(callback);
            }

            @Override
            public LookupVersion setFields(java.lang.String fields) {
              return (LookupVersion) super.setFields(fields);
            }

            @Override
            public LookupVersion setKey(java.lang.String key) {
              return (LookupVersion) super.setKey(key);
            }

            @Override
            public LookupVersion setOauthToken(java.lang.String oauthToken) {
              return (LookupVersion) super.setOauthToken(oauthToken);
            }

            @Override
            public LookupVersion setPrettyPrint(java.lang.Boolean prettyPrint) {
              return (LookupVersion) super.setPrettyPrint(prettyPrint);
            }

            @Override
            public LookupVersion setQuotaUser(java.lang.String quotaUser) {
              return (LookupVersion) super.setQuotaUser(quotaUser);
            }

            @Override
            public LookupVersion setUploadType(java.lang.String uploadType) {
              return (LookupVersion) super.setUploadType(uploadType);
            }

            @Override
            public LookupVersion setUploadProtocol(java.lang.String uploadProtocol) {
              return (LookupVersion) super.setUploadProtocol(uploadProtocol);
            }

            /**
             * Required. The subject to lookup the schema in. Structured like: `projects/{project}/l
             * ocations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}` or `projec
             * ts/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{contex
             * t}/subjects/{subject}`
             */
            @com.google.api.client.util.Key
            private java.lang.String parent;

            /** Required. The subject to lookup the schema in. Structured like:
           `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}` or
           `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subj
           ects/{subject}`
             */
            public java.lang.String getParent() {
              return parent;
            }

            /**
             * Required. The subject to lookup the schema in. Structured like: `projects/{project}/l
             * ocations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}` or `projec
             * ts/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{contex
             * t}/subjects/{subject}`
             */
            public LookupVersion setParent(java.lang.String parent) {
              if (!getSuppressPatternChecks()) {
                com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                    "Parameter parent must conform to the pattern " +
                    "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+$");
              }
              this.parent = parent;
              return this;
            }

            @Override
            public LookupVersion set(String parameterName, Object value) {
              return (LookupVersion) super.set(parameterName, value);
            }
          }

          /**
           * An accessor for creating requests from the Versions collection.
           *
           * <p>The typical use is:</p>
           * <pre>
           *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
           *   {@code ManagedKafka.Versions.List request = managedkafka.versions().list(parameters ...)}
           * </pre>
           *
           * @return the resource collection
           */
          public Versions versions() {
            return new Versions();
          }

          /**
           * The "versions" collection of methods.
           */
          public class Versions {

            /**
             * Register a new version under a given subject with the given schema.
             *
             * Create a request for the method "versions.create".
             *
             * This request holds the parameters needed by the managedkafka server.  After setting any optional
             * parameters, call the {@link Create#execute()} method to invoke the remote operation.
             *
             * @param parent Required. The subject to create the version for. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subj
             *        ect}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/conte
             *        xts/{context}/subjects/{subject}`
             * @param content the {@link com.google.api.services.managedkafka.v1.model.CreateVersionRequest}
             * @return the request
             */
            public Create create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.CreateVersionRequest content) throws java.io.IOException {
              Create result = new Create(parent, content);
              initialize(result);
              return result;
            }

            public class Create extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.CreateVersionResponse> {

              private static final String REST_PATH = "v1/{+parent}/versions";

              private final java.util.regex.Pattern PARENT_PATTERN =
                  java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+$");

              /**
               * Register a new version under a given subject with the given schema.
               *
               * Create a request for the method "versions.create".
               *
               * This request holds the parameters needed by the the managedkafka server.  After setting any
               * optional parameters, call the {@link Create#execute()} method to invoke the remote operation.
               * <p> {@link
               * Create#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
               * be called to initialize this instance immediately after invoking the constructor. </p>
               *
               * @param parent Required. The subject to create the version for. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subj
             *        ect}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/conte
             *        xts/{context}/subjects/{subject}`
               * @param content the {@link com.google.api.services.managedkafka.v1.model.CreateVersionRequest}
               * @since 1.13
               */
              protected Create(java.lang.String parent, com.google.api.services.managedkafka.v1.model.CreateVersionRequest content) {
                super(ManagedKafka.this, "POST", REST_PATH, content, com.google.api.services.managedkafka.v1.model.CreateVersionResponse.class);
                this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                      "Parameter parent must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+$");
                }
              }

              @Override
              public Create set$Xgafv(java.lang.String $Xgafv) {
                return (Create) super.set$Xgafv($Xgafv);
              }

              @Override
              public Create setAccessToken(java.lang.String accessToken) {
                return (Create) super.setAccessToken(accessToken);
              }

              @Override
              public Create setAlt(java.lang.String alt) {
                return (Create) super.setAlt(alt);
              }

              @Override
              public Create setCallback(java.lang.String callback) {
                return (Create) super.setCallback(callback);
              }

              @Override
              public Create setFields(java.lang.String fields) {
                return (Create) super.setFields(fields);
              }

              @Override
              public Create setKey(java.lang.String key) {
                return (Create) super.setKey(key);
              }

              @Override
              public Create setOauthToken(java.lang.String oauthToken) {
                return (Create) super.setOauthToken(oauthToken);
              }

              @Override
              public Create setPrettyPrint(java.lang.Boolean prettyPrint) {
                return (Create) super.setPrettyPrint(prettyPrint);
              }

              @Override
              public Create setQuotaUser(java.lang.String quotaUser) {
                return (Create) super.setQuotaUser(quotaUser);
              }

              @Override
              public Create setUploadType(java.lang.String uploadType) {
                return (Create) super.setUploadType(uploadType);
              }

              @Override
              public Create setUploadProtocol(java.lang.String uploadProtocol) {
                return (Create) super.setUploadProtocol(uploadProtocol);
              }

              /**
               * Required. The subject to create the version for. Structured like: `projects/{projec
               * t}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}` or `
               * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts
               * /{context}/subjects/{subject}`
               */
              @com.google.api.client.util.Key
              private java.lang.String parent;

              /** Required. The subject to create the version for. Structured like:
             `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}` or
             `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subj
             ects/{subject}`
               */
              public java.lang.String getParent() {
                return parent;
              }

              /**
               * Required. The subject to create the version for. Structured like: `projects/{projec
               * t}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}` or `
               * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts
               * /{context}/subjects/{subject}`
               */
              public Create setParent(java.lang.String parent) {
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                      "Parameter parent must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+$");
                }
                this.parent = parent;
                return this;
              }

              @Override
              public Create set(String parameterName, Object value) {
                return (Create) super.set(parameterName, value);
              }
            }
            /**
             * Delete a version of a subject. The response will be the deleted version id.
             *
             * Create a request for the method "versions.delete".
             *
             * This request holds the parameters needed by the managedkafka server.  After setting any optional
             * parameters, call the {@link Delete#execute()} method to invoke the remote operation.
             *
             * @param name Required. The name of the subject version to delete. Structured like: `projects/{project}/locations/
             *        {location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `p
             *        rojects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{contex
             *        t}/subjects/{subject}/versions/{version}`
             * @return the request
             */
            public Delete delete(java.lang.String name) throws java.io.IOException {
              Delete result = new Delete(name);
              initialize(result);
              return result;
            }

            public class Delete extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

              private static final String REST_PATH = "v1/{+name}";

              private final java.util.regex.Pattern NAME_PATTERN =
                  java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+/versions/[^/]+$");

              /**
               * Delete a version of a subject. The response will be the deleted version id.
               *
               * Create a request for the method "versions.delete".
               *
               * This request holds the parameters needed by the the managedkafka server.  After setting any
               * optional parameters, call the {@link Delete#execute()} method to invoke the remote operation.
               * <p> {@link
               * Delete#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
               * be called to initialize this instance immediately after invoking the constructor. </p>
               *
               * @param name Required. The name of the subject version to delete. Structured like: `projects/{project}/locations/
             *        {location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `p
             *        rojects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{contex
             *        t}/subjects/{subject}/versions/{version}`
               * @since 1.13
               */
              protected Delete(java.lang.String name) {
                super(ManagedKafka.this, "DELETE", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
                this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+/versions/[^/]+$");
                }
              }

              @Override
              public Delete set$Xgafv(java.lang.String $Xgafv) {
                return (Delete) super.set$Xgafv($Xgafv);
              }

              @Override
              public Delete setAccessToken(java.lang.String accessToken) {
                return (Delete) super.setAccessToken(accessToken);
              }

              @Override
              public Delete setAlt(java.lang.String alt) {
                return (Delete) super.setAlt(alt);
              }

              @Override
              public Delete setCallback(java.lang.String callback) {
                return (Delete) super.setCallback(callback);
              }

              @Override
              public Delete setFields(java.lang.String fields) {
                return (Delete) super.setFields(fields);
              }

              @Override
              public Delete setKey(java.lang.String key) {
                return (Delete) super.setKey(key);
              }

              @Override
              public Delete setOauthToken(java.lang.String oauthToken) {
                return (Delete) super.setOauthToken(oauthToken);
              }

              @Override
              public Delete setPrettyPrint(java.lang.Boolean prettyPrint) {
                return (Delete) super.setPrettyPrint(prettyPrint);
              }

              @Override
              public Delete setQuotaUser(java.lang.String quotaUser) {
                return (Delete) super.setQuotaUser(quotaUser);
              }

              @Override
              public Delete setUploadType(java.lang.String uploadType) {
                return (Delete) super.setUploadType(uploadType);
              }

              @Override
              public Delete setUploadProtocol(java.lang.String uploadProtocol) {
                return (Delete) super.setUploadProtocol(uploadProtocol);
              }

              /**
               * Required. The name of the subject version to delete. Structured like: `projects/{pr
               * oject}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/v
               * ersions/{version}` or `projects/{project}/locations/{location}/schemaRegistries/{sc
               * hema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
               */
              @com.google.api.client.util.Key
              private java.lang.String name;

              /** Required. The name of the subject version to delete. Structured like: `projects/{project}/locations
             /{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `projects/
             {project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subj
             ect}/versions/{version}`
               */
              public java.lang.String getName() {
                return name;
              }

              /**
               * Required. The name of the subject version to delete. Structured like: `projects/{pr
               * oject}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/v
               * ersions/{version}` or `projects/{project}/locations/{location}/schemaRegistries/{sc
               * hema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
               */
              public Delete setName(java.lang.String name) {
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+/versions/[^/]+$");
                }
                this.name = name;
                return this;
              }

              /**
               * Optional. If true, both the version and the referenced schema ID will be
               * permanently deleted. The default is false. If false, the version will be deleted
               * but the schema ID will be retained. Soft-deleted versions can still be searched in
               * ListVersions API call with deleted=true query parameter. A soft-delete of a version
               * must be performed before a hard-delete.
               */
              @com.google.api.client.util.Key
              private java.lang.Boolean permanent;

              /** Optional. If true, both the version and the referenced schema ID will be permanently deleted. The
             default is false. If false, the version will be deleted but the schema ID will be retained. Soft-
             deleted versions can still be searched in ListVersions API call with deleted=true query parameter.
             A soft-delete of a version must be performed before a hard-delete.
               */
              public java.lang.Boolean getPermanent() {
                return permanent;
              }

              /**
               * Optional. If true, both the version and the referenced schema ID will be
               * permanently deleted. The default is false. If false, the version will be deleted
               * but the schema ID will be retained. Soft-deleted versions can still be searched in
               * ListVersions API call with deleted=true query parameter. A soft-delete of a version
               * must be performed before a hard-delete.
               */
              public Delete setPermanent(java.lang.Boolean permanent) {
                this.permanent = permanent;
                return this;
              }

              @Override
              public Delete set(String parameterName, Object value) {
                return (Delete) super.set(parameterName, value);
              }
            }
            /**
             * Get a versioned schema (schema with subject/version) of a subject.
             *
             * Create a request for the method "versions.get".
             *
             * This request holds the parameters needed by the managedkafka server.  After setting any optional
             * parameters, call the {@link Get#execute()} method to invoke the remote operation.
             *
             * @param name Required. The name of the subject to return versions. Structured like: `projects/{project}/locations
             *        /{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `
             *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{conte
             *        xt}/subjects/{subject}/versions/{version}`
             * @return the request
             */
            public Get get(java.lang.String name) throws java.io.IOException {
              Get result = new Get(name);
              initialize(result);
              return result;
            }

            public class Get extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.SchemaVersion> {

              private static final String REST_PATH = "v1/{+name}";

              private final java.util.regex.Pattern NAME_PATTERN =
                  java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+/versions/[^/]+$");

              /**
               * Get a versioned schema (schema with subject/version) of a subject.
               *
               * Create a request for the method "versions.get".
               *
               * This request holds the parameters needed by the the managedkafka server.  After setting any
               * optional parameters, call the {@link Get#execute()} method to invoke the remote operation. <p>
               * {@link Get#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
               * must be called to initialize this instance immediately after invoking the constructor. </p>
               *
               * @param name Required. The name of the subject to return versions. Structured like: `projects/{project}/locations
             *        /{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `
             *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{conte
             *        xt}/subjects/{subject}/versions/{version}`
               * @since 1.13
               */
              protected Get(java.lang.String name) {
                super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.SchemaVersion.class);
                this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+/versions/[^/]+$");
                }
              }

              @Override
              public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
                return super.executeUsingHead();
              }

              @Override
              public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
                return super.buildHttpRequestUsingHead();
              }

              @Override
              public Get set$Xgafv(java.lang.String $Xgafv) {
                return (Get) super.set$Xgafv($Xgafv);
              }

              @Override
              public Get setAccessToken(java.lang.String accessToken) {
                return (Get) super.setAccessToken(accessToken);
              }

              @Override
              public Get setAlt(java.lang.String alt) {
                return (Get) super.setAlt(alt);
              }

              @Override
              public Get setCallback(java.lang.String callback) {
                return (Get) super.setCallback(callback);
              }

              @Override
              public Get setFields(java.lang.String fields) {
                return (Get) super.setFields(fields);
              }

              @Override
              public Get setKey(java.lang.String key) {
                return (Get) super.setKey(key);
              }

              @Override
              public Get setOauthToken(java.lang.String oauthToken) {
                return (Get) super.setOauthToken(oauthToken);
              }

              @Override
              public Get setPrettyPrint(java.lang.Boolean prettyPrint) {
                return (Get) super.setPrettyPrint(prettyPrint);
              }

              @Override
              public Get setQuotaUser(java.lang.String quotaUser) {
                return (Get) super.setQuotaUser(quotaUser);
              }

              @Override
              public Get setUploadType(java.lang.String uploadType) {
                return (Get) super.setUploadType(uploadType);
              }

              @Override
              public Get setUploadProtocol(java.lang.String uploadProtocol) {
                return (Get) super.setUploadProtocol(uploadProtocol);
              }

              /**
               * Required. The name of the subject to return versions. Structured like: `projects/{p
               * roject}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/
               * versions/{version}` or `projects/{project}/locations/{location}/schemaRegistries/{s
               * chema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
               */
              @com.google.api.client.util.Key
              private java.lang.String name;

              /** Required. The name of the subject to return versions. Structured like: `projects/{project}/location
             s/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `projects
             /{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{sub
             ject}/versions/{version}`
               */
              public java.lang.String getName() {
                return name;
              }

              /**
               * Required. The name of the subject to return versions. Structured like: `projects/{p
               * roject}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/
               * versions/{version}` or `projects/{project}/locations/{location}/schemaRegistries/{s
               * chema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
               */
              public Get setName(java.lang.String name) {
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+/versions/[^/]+$");
                }
                this.name = name;
                return this;
              }

              /**
               * Optional. If true, no matter if the subject/version is soft-deleted or not, it
               * returns the version details. If false, it returns NOT_FOUND error if the
               * subject/version is soft-deleted. The default is false.
               */
              @com.google.api.client.util.Key
              private java.lang.Boolean deleted;

              /** Optional. If true, no matter if the subject/version is soft-deleted or not, it returns the version
             details. If false, it returns NOT_FOUND error if the subject/version is soft-deleted. The default
             is false.
               */
              public java.lang.Boolean getDeleted() {
                return deleted;
              }

              /**
               * Optional. If true, no matter if the subject/version is soft-deleted or not, it
               * returns the version details. If false, it returns NOT_FOUND error if the
               * subject/version is soft-deleted. The default is false.
               */
              public Get setDeleted(java.lang.Boolean deleted) {
                this.deleted = deleted;
                return this;
              }

              @Override
              public Get set(String parameterName, Object value) {
                return (Get) super.set(parameterName, value);
              }
            }
            /**
             * Get the schema string only for a version of a subject. The response will be the schema string.
             *
             * Create a request for the method "versions.getSchema".
             *
             * This request holds the parameters needed by the managedkafka server.  After setting any optional
             * parameters, call the {@link GetSchema#execute()} method to invoke the remote operation.
             *
             * @param name Required. The name of the subject to return versions. Structured like: `projects/{project}/locations
             *        /{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `
             *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{conte
             *        xt}/subjects/{subject}/versions/{version}`
             * @return the request
             */
            public GetSchema getSchema(java.lang.String name) throws java.io.IOException {
              GetSchema result = new GetSchema(name);
              initialize(result);
              return result;
            }

            public class GetSchema extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

              private static final String REST_PATH = "v1/{+name}/schema";

              private final java.util.regex.Pattern NAME_PATTERN =
                  java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+/versions/[^/]+$");

              /**
               * Get the schema string only for a version of a subject. The response will be the schema string.
               *
               * Create a request for the method "versions.getSchema".
               *
               * This request holds the parameters needed by the the managedkafka server.  After setting any
               * optional parameters, call the {@link GetSchema#execute()} method to invoke the remote
               * operation. <p> {@link
               * GetSchema#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
               * must be called to initialize this instance immediately after invoking the constructor. </p>
               *
               * @param name Required. The name of the subject to return versions. Structured like: `projects/{project}/locations
             *        /{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `
             *        projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{conte
             *        xt}/subjects/{subject}/versions/{version}`
               * @since 1.13
               */
              protected GetSchema(java.lang.String name) {
                super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
                this.name = com.google.api.client.util.Preconditions.checkNotNull(name, "Required parameter name must be specified.");
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+/versions/[^/]+$");
                }
              }

              @Override
              public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
                return super.executeUsingHead();
              }

              @Override
              public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
                return super.buildHttpRequestUsingHead();
              }

              @Override
              public GetSchema set$Xgafv(java.lang.String $Xgafv) {
                return (GetSchema) super.set$Xgafv($Xgafv);
              }

              @Override
              public GetSchema setAccessToken(java.lang.String accessToken) {
                return (GetSchema) super.setAccessToken(accessToken);
              }

              @Override
              public GetSchema setAlt(java.lang.String alt) {
                return (GetSchema) super.setAlt(alt);
              }

              @Override
              public GetSchema setCallback(java.lang.String callback) {
                return (GetSchema) super.setCallback(callback);
              }

              @Override
              public GetSchema setFields(java.lang.String fields) {
                return (GetSchema) super.setFields(fields);
              }

              @Override
              public GetSchema setKey(java.lang.String key) {
                return (GetSchema) super.setKey(key);
              }

              @Override
              public GetSchema setOauthToken(java.lang.String oauthToken) {
                return (GetSchema) super.setOauthToken(oauthToken);
              }

              @Override
              public GetSchema setPrettyPrint(java.lang.Boolean prettyPrint) {
                return (GetSchema) super.setPrettyPrint(prettyPrint);
              }

              @Override
              public GetSchema setQuotaUser(java.lang.String quotaUser) {
                return (GetSchema) super.setQuotaUser(quotaUser);
              }

              @Override
              public GetSchema setUploadType(java.lang.String uploadType) {
                return (GetSchema) super.setUploadType(uploadType);
              }

              @Override
              public GetSchema setUploadProtocol(java.lang.String uploadProtocol) {
                return (GetSchema) super.setUploadProtocol(uploadProtocol);
              }

              /**
               * Required. The name of the subject to return versions. Structured like: `projects/{p
               * roject}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/
               * versions/{version}` or `projects/{project}/locations/{location}/schemaRegistries/{s
               * chema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
               */
              @com.google.api.client.util.Key
              private java.lang.String name;

              /** Required. The name of the subject to return versions. Structured like: `projects/{project}/location
             s/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `projects
             /{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{sub
             ject}/versions/{version}`
               */
              public java.lang.String getName() {
                return name;
              }

              /**
               * Required. The name of the subject to return versions. Structured like: `projects/{p
               * roject}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/
               * versions/{version}` or `projects/{project}/locations/{location}/schemaRegistries/{s
               * chema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
               */
              public GetSchema setName(java.lang.String name) {
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(NAME_PATTERN.matcher(name).matches(),
                      "Parameter name must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+/versions/[^/]+$");
                }
                this.name = name;
                return this;
              }

              /**
               * Optional. If true, no matter if the subject/version is soft-deleted or not, it
               * returns the version details. If false, it returns NOT_FOUND error if the
               * subject/version is soft-deleted. The default is false.
               */
              @com.google.api.client.util.Key
              private java.lang.Boolean deleted;

              /** Optional. If true, no matter if the subject/version is soft-deleted or not, it returns the version
             details. If false, it returns NOT_FOUND error if the subject/version is soft-deleted. The default
             is false.
               */
              public java.lang.Boolean getDeleted() {
                return deleted;
              }

              /**
               * Optional. If true, no matter if the subject/version is soft-deleted or not, it
               * returns the version details. If false, it returns NOT_FOUND error if the
               * subject/version is soft-deleted. The default is false.
               */
              public GetSchema setDeleted(java.lang.Boolean deleted) {
                this.deleted = deleted;
                return this;
              }

              @Override
              public GetSchema set(String parameterName, Object value) {
                return (GetSchema) super.set(parameterName, value);
              }
            }
            /**
             * Get all versions of a subject. The response will be an array of versions of the subject.
             *
             * Create a request for the method "versions.list".
             *
             * This request holds the parameters needed by the managedkafka server.  After setting any optional
             * parameters, call the {@link List#execute()} method to invoke the remote operation.
             *
             * @param parent Required. The subject whose versions are to be listed. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subj
             *        ect}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/conte
             *        xts/{context}/subjects/{subject}`
             * @return the request
             */
            public List list(java.lang.String parent) throws java.io.IOException {
              List result = new List(parent);
              initialize(result);
              return result;
            }

            public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

              private static final String REST_PATH = "v1/{+parent}/versions";

              private final java.util.regex.Pattern PARENT_PATTERN =
                  java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+$");

              /**
               * Get all versions of a subject. The response will be an array of versions of the subject.
               *
               * Create a request for the method "versions.list".
               *
               * This request holds the parameters needed by the the managedkafka server.  After setting any
               * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
               * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
               * must be called to initialize this instance immediately after invoking the constructor. </p>
               *
               * @param parent Required. The subject whose versions are to be listed. Structured like:
             *        `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subj
             *        ect}` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/conte
             *        xts/{context}/subjects/{subject}`
               * @since 1.13
               */
              protected List(java.lang.String parent) {
                super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
                this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                      "Parameter parent must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+$");
                }
              }

              @Override
              public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
                return super.executeUsingHead();
              }

              @Override
              public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
                return super.buildHttpRequestUsingHead();
              }

              @Override
              public List set$Xgafv(java.lang.String $Xgafv) {
                return (List) super.set$Xgafv($Xgafv);
              }

              @Override
              public List setAccessToken(java.lang.String accessToken) {
                return (List) super.setAccessToken(accessToken);
              }

              @Override
              public List setAlt(java.lang.String alt) {
                return (List) super.setAlt(alt);
              }

              @Override
              public List setCallback(java.lang.String callback) {
                return (List) super.setCallback(callback);
              }

              @Override
              public List setFields(java.lang.String fields) {
                return (List) super.setFields(fields);
              }

              @Override
              public List setKey(java.lang.String key) {
                return (List) super.setKey(key);
              }

              @Override
              public List setOauthToken(java.lang.String oauthToken) {
                return (List) super.setOauthToken(oauthToken);
              }

              @Override
              public List setPrettyPrint(java.lang.Boolean prettyPrint) {
                return (List) super.setPrettyPrint(prettyPrint);
              }

              @Override
              public List setQuotaUser(java.lang.String quotaUser) {
                return (List) super.setQuotaUser(quotaUser);
              }

              @Override
              public List setUploadType(java.lang.String uploadType) {
                return (List) super.setUploadType(uploadType);
              }

              @Override
              public List setUploadProtocol(java.lang.String uploadProtocol) {
                return (List) super.setUploadProtocol(uploadProtocol);
              }

              /**
               * Required. The subject whose versions are to be listed. Structured like: `projects/{
               * project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}
               * ` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/co
               * ntexts/{context}/subjects/{subject}`
               */
              @com.google.api.client.util.Key
              private java.lang.String parent;

              /** Required. The subject whose versions are to be listed. Structured like:
             `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}` or
             `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subj
             ects/{subject}`
               */
              public java.lang.String getParent() {
                return parent;
              }

              /**
               * Required. The subject whose versions are to be listed. Structured like: `projects/{
               * project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}
               * ` or `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/co
               * ntexts/{context}/subjects/{subject}`
               */
              public List setParent(java.lang.String parent) {
                if (!getSuppressPatternChecks()) {
                  com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                      "Parameter parent must conform to the pattern " +
                      "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+$");
                }
                this.parent = parent;
                return this;
              }

              /**
               * Optional. If true, the response will include soft-deleted versions of an active or
               * soft-deleted subject. The default is false.
               */
              @com.google.api.client.util.Key
              private java.lang.Boolean deleted;

              /** Optional. If true, the response will include soft-deleted versions of an active or soft-deleted
             subject. The default is false.
               */
              public java.lang.Boolean getDeleted() {
                return deleted;
              }

              /**
               * Optional. If true, the response will include soft-deleted versions of an active or
               * soft-deleted subject. The default is false.
               */
              public List setDeleted(java.lang.Boolean deleted) {
                this.deleted = deleted;
                return this;
              }

              @Override
              public List set(String parameterName, Object value) {
                return (List) super.set(parameterName, value);
              }
            }

            /**
             * An accessor for creating requests from the Referencedby collection.
             *
             * <p>The typical use is:</p>
             * <pre>
             *   {@code ManagedKafka managedkafka = new ManagedKafka(...);}
             *   {@code ManagedKafka.Referencedby.List request = managedkafka.referencedby().list(parameters ...)}
             * </pre>
             *
             * @return the resource collection
             */
            public Referencedby referencedby() {
              return new Referencedby();
            }

            /**
             * The "referencedby" collection of methods.
             */
            public class Referencedby {

              /**
               * Get a list of IDs of schemas that reference the schema with the given subject and version.
               *
               * Create a request for the method "referencedby.list".
               *
               * This request holds the parameters needed by the managedkafka server.  After setting any optional
               * parameters, call the {@link List#execute()} method to invoke the remote operation.
               *
               * @param parent Required. The version to list referenced by. Structured like: `projects/{project}/locations/{locatio
               *        n}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `projects/
               *        {project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subje
               *        cts/{subject}/versions/{version}`
               * @return the request
               */
              public List list(java.lang.String parent) throws java.io.IOException {
                List result = new List(parent);
                initialize(result);
                return result;
              }

              public class List extends ManagedKafkaRequest<com.google.api.services.managedkafka.v1.model.HttpBody> {

                private static final String REST_PATH = "v1/{+parent}/referencedby";

                private final java.util.regex.Pattern PARENT_PATTERN =
                    java.util.regex.Pattern.compile("^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+/versions/[^/]+$");

                /**
                 * Get a list of IDs of schemas that reference the schema with the given subject and version.
                 *
                 * Create a request for the method "referencedby.list".
                 *
                 * This request holds the parameters needed by the the managedkafka server.  After setting any
                 * optional parameters, call the {@link List#execute()} method to invoke the remote operation. <p>
                 * {@link List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)}
                 * must be called to initialize this instance immediately after invoking the constructor. </p>
                 *
                 * @param parent Required. The version to list referenced by. Structured like: `projects/{project}/locations/{locatio
               *        n}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `projects/
               *        {project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subje
               *        cts/{subject}/versions/{version}`
                 * @since 1.13
                 */
                protected List(java.lang.String parent) {
                  super(ManagedKafka.this, "GET", REST_PATH, null, com.google.api.services.managedkafka.v1.model.HttpBody.class);
                  this.parent = com.google.api.client.util.Preconditions.checkNotNull(parent, "Required parameter parent must be specified.");
                  if (!getSuppressPatternChecks()) {
                    com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                        "Parameter parent must conform to the pattern " +
                        "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+/versions/[^/]+$");
                  }
                }

                @Override
                public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
                  return super.executeUsingHead();
                }

                @Override
                public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
                  return super.buildHttpRequestUsingHead();
                }

                @Override
                public List set$Xgafv(java.lang.String $Xgafv) {
                  return (List) super.set$Xgafv($Xgafv);
                }

                @Override
                public List setAccessToken(java.lang.String accessToken) {
                  return (List) super.setAccessToken(accessToken);
                }

                @Override
                public List setAlt(java.lang.String alt) {
                  return (List) super.setAlt(alt);
                }

                @Override
                public List setCallback(java.lang.String callback) {
                  return (List) super.setCallback(callback);
                }

                @Override
                public List setFields(java.lang.String fields) {
                  return (List) super.setFields(fields);
                }

                @Override
                public List setKey(java.lang.String key) {
                  return (List) super.setKey(key);
                }

                @Override
                public List setOauthToken(java.lang.String oauthToken) {
                  return (List) super.setOauthToken(oauthToken);
                }

                @Override
                public List setPrettyPrint(java.lang.Boolean prettyPrint) {
                  return (List) super.setPrettyPrint(prettyPrint);
                }

                @Override
                public List setQuotaUser(java.lang.String quotaUser) {
                  return (List) super.setQuotaUser(quotaUser);
                }

                @Override
                public List setUploadType(java.lang.String uploadType) {
                  return (List) super.setUploadType(uploadType);
                }

                @Override
                public List setUploadProtocol(java.lang.String uploadProtocol) {
                  return (List) super.setUploadProtocol(uploadProtocol);
                }

                /**
                 * Required. The version to list referenced by. Structured like: `projects/{project}
                 * /locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versi
                 * ons/{version}` or `projects/{project}/locations/{location}/schemaRegistries/{sche
                 * ma_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
                 */
                @com.google.api.client.util.Key
                private java.lang.String parent;

                /** Required. The version to list referenced by. Structured like: `projects/{project}/locations/{locati
               on}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}` or `projects/{project
               }/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/ver
               sions/{version}`
                 */
                public java.lang.String getParent() {
                  return parent;
                }

                /**
                 * Required. The version to list referenced by. Structured like: `projects/{project}
                 * /locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versi
                 * ons/{version}` or `projects/{project}/locations/{location}/schemaRegistries/{sche
                 * ma_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
                 */
                public List setParent(java.lang.String parent) {
                  if (!getSuppressPatternChecks()) {
                    com.google.api.client.util.Preconditions.checkArgument(PARENT_PATTERN.matcher(parent).matches(),
                        "Parameter parent must conform to the pattern " +
                        "^projects/[^/]+/locations/[^/]+/schemaRegistries/[^/]+/subjects/[^/]+/versions/[^/]+$");
                  }
                  this.parent = parent;
                  return this;
                }

                @Override
                public List set(String parameterName, Object value) {
                  return (List) super.set(parameterName, value);
                }
              }

            }
          }
        }
      }
    }
  }

  /**
   * Builder for {@link ManagedKafka}.
   *
   * <p>
   * Implementation is not thread-safe.
   * </p>
   *
   * @since 1.3.0
   */
  public static final class Builder extends com.google.api.client.googleapis.services.json.AbstractGoogleJsonClient.Builder {

    private static String chooseEndpoint(com.google.api.client.http.HttpTransport transport) {
      // If the GOOGLE_API_USE_MTLS_ENDPOINT environment variable value is "always", use mTLS endpoint.
      // If the env variable is "auto", use mTLS endpoint if and only if the transport is mTLS.
      // Use the regular endpoint for all other cases.
      String useMtlsEndpoint = System.getenv("GOOGLE_API_USE_MTLS_ENDPOINT");
      useMtlsEndpoint = useMtlsEndpoint == null ? "auto" : useMtlsEndpoint;
      if ("always".equals(useMtlsEndpoint) || ("auto".equals(useMtlsEndpoint) && transport != null && transport.isMtls())) {
        return DEFAULT_MTLS_ROOT_URL;
      }
      return DEFAULT_ROOT_URL;
    }

    /**
     * Returns an instance of a new builder.
     *
     * @param transport HTTP transport, which should normally be:
     *        <ul>
     *        <li>Google App Engine:
     *        {@code com.google.api.client.extensions.appengine.http.UrlFetchTransport}</li>
     *        <li>Android: {@code newCompatibleTransport} from
     *        {@code com.google.api.client.extensions.android.http.AndroidHttp}</li>
     *        <li>Java: {@link com.google.api.client.googleapis.javanet.GoogleNetHttpTransport#newTrustedTransport()}
     *        </li>
     *        </ul>
     * @param jsonFactory JSON factory, which may be:
     *        <ul>
     *        <li>Jackson: {@code com.google.api.client.json.jackson2.JacksonFactory}</li>
     *        <li>Google GSON: {@code com.google.api.client.json.gson.GsonFactory}</li>
     *        <li>Android Honeycomb or higher:
     *        {@code com.google.api.client.extensions.android.json.AndroidJsonFactory}</li>
     *        </ul>
     * @param httpRequestInitializer HTTP request initializer or {@code null} for none
     * @since 1.7
     */
    public Builder(com.google.api.client.http.HttpTransport transport, com.google.api.client.json.JsonFactory jsonFactory,
        com.google.api.client.http.HttpRequestInitializer httpRequestInitializer) {
      super(
          transport,
          jsonFactory,
          Builder.chooseEndpoint(transport),
          DEFAULT_SERVICE_PATH,
          httpRequestInitializer,
          false);
      setBatchPath(DEFAULT_BATCH_PATH);
    }

    /** Builds a new instance of {@link ManagedKafka}. */
    @Override
    public ManagedKafka build() {
      return new ManagedKafka(this);
    }

    @Override
    public Builder setRootUrl(String rootUrl) {
      return (Builder) super.setRootUrl(rootUrl);
    }

    @Override
    public Builder setServicePath(String servicePath) {
      return (Builder) super.setServicePath(servicePath);
    }

    @Override
    public Builder setBatchPath(String batchPath) {
      return (Builder) super.setBatchPath(batchPath);
    }

    @Override
    public Builder setHttpRequestInitializer(com.google.api.client.http.HttpRequestInitializer httpRequestInitializer) {
      return (Builder) super.setHttpRequestInitializer(httpRequestInitializer);
    }

    @Override
    public Builder setApplicationName(String applicationName) {
      return (Builder) super.setApplicationName(applicationName);
    }

    @Override
    public Builder setSuppressPatternChecks(boolean suppressPatternChecks) {
      return (Builder) super.setSuppressPatternChecks(suppressPatternChecks);
    }

    @Override
    public Builder setSuppressRequiredParameterChecks(boolean suppressRequiredParameterChecks) {
      return (Builder) super.setSuppressRequiredParameterChecks(suppressRequiredParameterChecks);
    }

    @Override
    public Builder setSuppressAllChecks(boolean suppressAllChecks) {
      return (Builder) super.setSuppressAllChecks(suppressAllChecks);
    }

    /**
     * Set the {@link ManagedKafkaRequestInitializer}.
     *
     * @since 1.12
     */
    public Builder setManagedKafkaRequestInitializer(
        ManagedKafkaRequestInitializer managedkafkaRequestInitializer) {
      return (Builder) super.setGoogleClientRequestInitializer(managedkafkaRequestInitializer);
    }

    @Override
    public Builder setGoogleClientRequestInitializer(
        com.google.api.client.googleapis.services.GoogleClientRequestInitializer googleClientRequestInitializer) {
      return (Builder) super.setGoogleClientRequestInitializer(googleClientRequestInitializer);
    }

    @Override
    public Builder setUniverseDomain(String universeDomain) {
      return (Builder) super.setUniverseDomain(universeDomain);
    }
  }
}
