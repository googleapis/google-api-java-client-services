{
  "id": "spanner:v1",
  "fullyEncodeReservedExpansion": true,
  "title": "Cloud Spanner API",
  "rootUrl": "https://spanner.googleapis.com/",
  "canonicalName": "Spanner",
  "mtlsRootUrl": "https://spanner.mtls.googleapis.com/",
  "parameters": {
    "alt": {
      "description": "Data format for response.",
      "default": "json",
      "type": "string",
      "enumDescriptions": [
        "Responses with Content-Type of application/json",
        "Media download with context-dependent Content-Type",
        "Responses with Content-Type of application/x-protobuf"
      ],
      "location": "query",
      "enum": [
        "json",
        "media",
        "proto"
      ]
    },
    "key": {
      "type": "string",
      "location": "query",
      "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
    },
    "uploadType": {
      "location": "query",
      "type": "string",
      "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
    },
    "oauth_token": {
      "description": "OAuth 2.0 token for the current user.",
      "type": "string",
      "location": "query"
    },
    "access_token": {
      "location": "query",
      "type": "string",
      "description": "OAuth access token."
    },
    "$.xgafv": {
      "type": "string",
      "location": "query",
      "enumDescriptions": [
        "v1 error format",
        "v2 error format"
      ],
      "enum": [
        "1",
        "2"
      ],
      "description": "V1 error format."
    },
    "fields": {
      "location": "query",
      "description": "Selector specifying which fields to include in a partial response.",
      "type": "string"
    },
    "quotaUser": {
      "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.",
      "location": "query",
      "type": "string"
    },
    "prettyPrint": {
      "type": "boolean",
      "default": "true",
      "description": "Returns response with indentations and line breaks.",
      "location": "query"
    },
    "callback": {
      "type": "string",
      "description": "JSONP",
      "location": "query"
    },
    "upload_protocol": {
      "description": "Upload protocol for media (e.g. \"raw\", \"multipart\").",
      "location": "query",
      "type": "string"
    }
  },
  "basePath": "",
  "discoveryVersion": "v1",
  "version_module": true,
  "revision": "20200526",
  "resources": {
    "projects": {
      "resources": {
        "instanceConfigs": {
          "methods": {
            "list": {
              "path": "v1/{+parent}/instanceConfigs",
              "description": "Lists the supported instance configurations for a given project.",
              "parameters": {
                "pageSize": {
                  "location": "query",
                  "type": "integer",
                  "format": "int32",
                  "description": "Number of instance configurations to be returned in the response. If 0 or\nless, defaults to the server's maximum allowed page size."
                },
                "pageToken": {
                  "location": "query",
                  "description": "If non-empty, `page_token` should contain a\nnext_page_token\nfrom a previous ListInstanceConfigsResponse.",
                  "type": "string"
                },
                "parent": {
                  "pattern": "^projects/[^/]+$",
                  "location": "path",
                  "type": "string",
                  "required": true,
                  "description": "Required. The name of the project for which a list of supported instance\nconfigurations is requested. Values are of the form\n`projects/\u003cproject\u003e`."
                }
              },
              "id": "spanner.projects.instanceConfigs.list",
              "httpMethod": "GET",
              "parameterOrder": [
                "parent"
              ],
              "response": {
                "$ref": "ListInstanceConfigsResponse"
              },
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/spanner.admin"
              ],
              "flatPath": "v1/projects/{projectsId}/instanceConfigs"
            },
            "get": {
              "parameters": {
                "name": {
                  "pattern": "^projects/[^/]+/instanceConfigs/[^/]+$",
                  "type": "string",
                  "description": "Required. The name of the requested instance configuration. Values are of\nthe form `projects/\u003cproject\u003e/instanceConfigs/\u003cconfig\u003e`.",
                  "required": true,
                  "location": "path"
                }
              },
              "parameterOrder": [
                "name"
              ],
              "httpMethod": "GET",
              "description": "Gets information about a particular instance configuration.",
              "path": "v1/{+name}",
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/spanner.admin"
              ],
              "id": "spanner.projects.instanceConfigs.get",
              "flatPath": "v1/projects/{projectsId}/instanceConfigs/{instanceConfigsId}",
              "response": {
                "$ref": "InstanceConfig"
              }
            }
          }
        },
        "instances": {
          "resources": {
            "databases": {
              "methods": {
                "dropDatabase": {
                  "path": "v1/{+database}",
                  "response": {
                    "$ref": "Empty"
                  },
                  "id": "spanner.projects.instances.databases.dropDatabase",
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "parameters": {
                    "database": {
                      "type": "string",
                      "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+$",
                      "required": true,
                      "description": "Required. The database to be dropped.",
                      "location": "path"
                    }
                  },
                  "parameterOrder": [
                    "database"
                  ],
                  "httpMethod": "DELETE",
                  "description": "Drops (aka deletes) a Cloud Spanner database.\nCompleted backups for the database will be retained according to their\n`expire_time`.",
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}"
                },
                "restore": {
                  "response": {
                    "$ref": "Operation"
                  },
                  "parameters": {
                    "parent": {
                      "pattern": "^projects/[^/]+/instances/[^/]+$",
                      "type": "string",
                      "description": "Required. The name of the instance in which to create the\nrestored database. This instance must be in the same project and\nhave the same instance configuration as the instance containing\nthe source backup. Values are of the form\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e`.",
                      "required": true,
                      "location": "path"
                    }
                  },
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases:restore",
                  "id": "spanner.projects.instances.databases.restore",
                  "description": "Create a new database by restoring from a completed backup. The new\ndatabase must be in the same project and in an instance with the same\ninstance configuration as the instance containing\nthe backup. The returned database long-running\noperation has a name of the format\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e/databases/\u003cdatabase\u003e/operations/\u003coperation_id\u003e`,\nand can be used to track the progress of the operation, and to cancel it.\nThe metadata field type is\nRestoreDatabaseMetadata.\nThe response type\nis Database, if\nsuccessful. Cancelling the returned operation will stop the restore and\ndelete the database.\nThere can be only one database being restored into an instance at a time.\nOnce the restore operation completes, a new restore operation can be\ninitiated, without waiting for the optimize operation associated with the\nfirst restore to complete.",
                  "request": {
                    "$ref": "RestoreDatabaseRequest"
                  },
                  "parameterOrder": [
                    "parent"
                  ],
                  "path": "v1/{+parent}/databases:restore",
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "httpMethod": "POST"
                },
                "setIamPolicy": {
                  "path": "v1/{+resource}:setIamPolicy",
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}:setIamPolicy",
                  "response": {
                    "$ref": "Policy"
                  },
                  "id": "spanner.projects.instances.databases.setIamPolicy",
                  "request": {
                    "$ref": "SetIamPolicyRequest"
                  },
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "description": "Sets the access control policy on a database or backup resource.\nReplaces any existing policy.\n\nAuthorization requires `spanner.databases.setIamPolicy`\npermission on resource.\nFor backups, authorization requires `spanner.backups.setIamPolicy`\npermission on resource.",
                  "parameters": {
                    "resource": {
                      "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+$",
                      "location": "path",
                      "type": "string",
                      "description": "REQUIRED: The Cloud Spanner resource for which the policy is being set. The format is `projects/\u003cproject ID\u003e/instances/\u003cinstance ID\u003e` for instance resources and `projects/\u003cproject ID\u003e/instances/\u003cinstance ID\u003e/databases/\u003cdatabase ID\u003e` for databases resources.",
                      "required": true
                    }
                  },
                  "parameterOrder": [
                    "resource"
                  ],
                  "httpMethod": "POST"
                },
                "updateDdl": {
                  "path": "v1/{+database}/ddl",
                  "id": "spanner.projects.instances.databases.updateDdl",
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "httpMethod": "PATCH",
                  "description": "Updates the schema of a Cloud Spanner database by\ncreating/altering/dropping tables, columns, indexes, etc. The returned\nlong-running operation will have a name of\nthe format `\u003cdatabase_name\u003e/operations/\u003coperation_id\u003e` and can be used to\ntrack execution of the schema change(s). The\nmetadata field type is\nUpdateDatabaseDdlMetadata.  The operation has no response.",
                  "response": {
                    "$ref": "Operation"
                  },
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/ddl",
                  "parameterOrder": [
                    "database"
                  ],
                  "parameters": {
                    "database": {
                      "location": "path",
                      "required": true,
                      "description": "Required. The database to update.",
                      "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+$",
                      "type": "string"
                    }
                  },
                  "request": {
                    "$ref": "UpdateDatabaseDdlRequest"
                  }
                },
                "get": {
                  "response": {
                    "$ref": "Database"
                  },
                  "parameters": {
                    "name": {
                      "location": "path",
                      "description": "Required. The name of the requested database. Values are of the form\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e/databases/\u003cdatabase\u003e`.",
                      "required": true,
                      "type": "string",
                      "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+$"
                    }
                  },
                  "path": "v1/{+name}",
                  "description": "Gets the state of a Cloud Spanner database.",
                  "httpMethod": "GET",
                  "id": "spanner.projects.instances.databases.get",
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}",
                  "parameterOrder": [
                    "name"
                  ],
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ]
                },
                "testIamPermissions": {
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}:testIamPermissions",
                  "description": "Returns permissions that the caller has on the specified database or backup\nresource.\n\nAttempting this RPC on a non-existent Cloud Spanner database will\nresult in a NOT_FOUND error if the user has\n`spanner.databases.list` permission on the containing Cloud\nSpanner instance. Otherwise returns an empty set of permissions.\nCalling this method on a backup that does not exist will\nresult in a NOT_FOUND error if the user has\n`spanner.backups.list` permission on the containing instance.",
                  "response": {
                    "$ref": "TestIamPermissionsResponse"
                  },
                  "request": {
                    "$ref": "TestIamPermissionsRequest"
                  },
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "path": "v1/{+resource}:testIamPermissions",
                  "id": "spanner.projects.instances.databases.testIamPermissions",
                  "parameterOrder": [
                    "resource"
                  ],
                  "parameters": {
                    "resource": {
                      "description": "REQUIRED: The Cloud Spanner resource for which permissions are being tested. The format is `projects/\u003cproject ID\u003e/instances/\u003cinstance ID\u003e` for instance resources and `projects/\u003cproject ID\u003e/instances/\u003cinstance ID\u003e/databases/\u003cdatabase ID\u003e` for database resources.",
                      "type": "string",
                      "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+$",
                      "required": true,
                      "location": "path"
                    }
                  },
                  "httpMethod": "POST"
                },
                "create": {
                  "parameters": {
                    "parent": {
                      "location": "path",
                      "pattern": "^projects/[^/]+/instances/[^/]+$",
                      "description": "Required. The name of the instance that will serve the new database.\nValues are of the form `projects/\u003cproject\u003e/instances/\u003cinstance\u003e`.",
                      "required": true,
                      "type": "string"
                    }
                  },
                  "parameterOrder": [
                    "parent"
                  ],
                  "path": "v1/{+parent}/databases",
                  "request": {
                    "$ref": "CreateDatabaseRequest"
                  },
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "id": "spanner.projects.instances.databases.create",
                  "response": {
                    "$ref": "Operation"
                  },
                  "httpMethod": "POST",
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases",
                  "description": "Creates a new Cloud Spanner database and starts to prepare it for serving.\nThe returned long-running operation will\nhave a name of the format `\u003cdatabase_name\u003e/operations/\u003coperation_id\u003e` and\ncan be used to track preparation of the database. The\nmetadata field type is\nCreateDatabaseMetadata. The\nresponse field type is\nDatabase, if successful."
                },
                "list": {
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases",
                  "parameterOrder": [
                    "parent"
                  ],
                  "path": "v1/{+parent}/databases",
                  "description": "Lists Cloud Spanner databases.",
                  "httpMethod": "GET",
                  "response": {
                    "$ref": "ListDatabasesResponse"
                  },
                  "id": "spanner.projects.instances.databases.list",
                  "parameters": {
                    "parent": {
                      "description": "Required. The instance whose databases should be listed.\nValues are of the form `projects/\u003cproject\u003e/instances/\u003cinstance\u003e`.",
                      "pattern": "^projects/[^/]+/instances/[^/]+$",
                      "required": true,
                      "type": "string",
                      "location": "path"
                    },
                    "pageSize": {
                      "type": "integer",
                      "location": "query",
                      "format": "int32",
                      "description": "Number of databases to be returned in the response. If 0 or less,\ndefaults to the server's maximum allowed page size."
                    },
                    "pageToken": {
                      "location": "query",
                      "description": "If non-empty, `page_token` should contain a\nnext_page_token from a\nprevious ListDatabasesResponse.",
                      "type": "string"
                    }
                  }
                },
                "getDdl": {
                  "parameterOrder": [
                    "database"
                  ],
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/ddl",
                  "description": "Returns the schema of a Cloud Spanner database as a list of formatted\nDDL statements. This method does not show pending schema updates, those may\nbe queried using the Operations API.",
                  "response": {
                    "$ref": "GetDatabaseDdlResponse"
                  },
                  "parameters": {
                    "database": {
                      "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+$",
                      "required": true,
                      "description": "Required. The database whose schema we wish to get.",
                      "type": "string",
                      "location": "path"
                    }
                  },
                  "path": "v1/{+database}/ddl",
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "httpMethod": "GET",
                  "id": "spanner.projects.instances.databases.getDdl"
                },
                "getIamPolicy": {
                  "httpMethod": "POST",
                  "description": "Gets the access control policy for a database or backup resource.\nReturns an empty policy if a database or backup exists but does not have a\npolicy set.\n\nAuthorization requires `spanner.databases.getIamPolicy` permission on\nresource.\nFor backups, authorization requires `spanner.backups.getIamPolicy`\npermission on resource.",
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}:getIamPolicy",
                  "path": "v1/{+resource}:getIamPolicy",
                  "id": "spanner.projects.instances.databases.getIamPolicy",
                  "response": {
                    "$ref": "Policy"
                  },
                  "parameters": {
                    "resource": {
                      "description": "REQUIRED: The Cloud Spanner resource for which the policy is being retrieved. The format is `projects/\u003cproject ID\u003e/instances/\u003cinstance ID\u003e` for instance resources and `projects/\u003cproject ID\u003e/instances/\u003cinstance ID\u003e/databases/\u003cdatabase ID\u003e` for database resources.",
                      "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+$",
                      "type": "string",
                      "location": "path",
                      "required": true
                    }
                  },
                  "request": {
                    "$ref": "GetIamPolicyRequest"
                  },
                  "parameterOrder": [
                    "resource"
                  ]
                }
              },
              "resources": {
                "operations": {
                  "methods": {
                    "cancel": {
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/operations/{operationsId}:cancel",
                      "path": "v1/{+name}:cancel",
                      "description": "Starts asynchronous cancellation on a long-running operation.  The server\nmakes a best effort to cancel the operation, but success is not\nguaranteed.  If the server doesn't support this method, it returns\n`google.rpc.Code.UNIMPLEMENTED`.  Clients can use\nOperations.GetOperation or\nother methods to check whether the cancellation succeeded or whether the\noperation completed despite cancellation. On successful cancellation,\nthe operation is not deleted; instead, it becomes an operation with\nan Operation.error value with a google.rpc.Status.code of 1,\ncorresponding to `Code.CANCELLED`.",
                      "parameterOrder": [
                        "name"
                      ],
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.admin"
                      ],
                      "id": "spanner.projects.instances.databases.operations.cancel",
                      "httpMethod": "POST",
                      "parameters": {
                        "name": {
                          "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+/operations/[^/]+$",
                          "location": "path",
                          "required": true,
                          "description": "The name of the operation resource to be cancelled.",
                          "type": "string"
                        }
                      },
                      "response": {
                        "$ref": "Empty"
                      }
                    },
                    "list": {
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/operations",
                      "description": "Lists operations that match the specified filter in the request. If the\nserver doesn't support this method, it returns `UNIMPLEMENTED`.\n\nNOTE: the `name` binding allows API services to override the binding\nto use different resource name schemes, such as `users/*/operations`. To\noverride the binding, API services can add a binding such as\n`\"/v1/{name=users/*}/operations\"` to their service configuration.\nFor backwards compatibility, the default name includes the operations\ncollection id, however overriding users must ensure the name binding\nis the parent resource, without the operations collection id.",
                      "path": "v1/{+name}",
                      "parameters": {
                        "pageSize": {
                          "format": "int32",
                          "description": "The standard list page size.",
                          "location": "query",
                          "type": "integer"
                        },
                        "name": {
                          "description": "The name of the operation's parent resource.",
                          "required": true,
                          "location": "path",
                          "type": "string",
                          "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+/operations$"
                        },
                        "filter": {
                          "type": "string",
                          "location": "query",
                          "description": "The standard list filter."
                        },
                        "pageToken": {
                          "type": "string",
                          "description": "The standard list page token.",
                          "location": "query"
                        }
                      },
                      "id": "spanner.projects.instances.databases.operations.list",
                      "parameterOrder": [
                        "name"
                      ],
                      "httpMethod": "GET",
                      "response": {
                        "$ref": "ListOperationsResponse"
                      },
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.admin"
                      ]
                    },
                    "delete": {
                      "parameters": {
                        "name": {
                          "required": true,
                          "description": "The name of the operation resource to be deleted.",
                          "location": "path",
                          "type": "string",
                          "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+/operations/[^/]+$"
                        }
                      },
                      "path": "v1/{+name}",
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.admin"
                      ],
                      "httpMethod": "DELETE",
                      "id": "spanner.projects.instances.databases.operations.delete",
                      "response": {
                        "$ref": "Empty"
                      },
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/operations/{operationsId}",
                      "description": "Deletes a long-running operation. This method indicates that the client is\nno longer interested in the operation result. It does not cancel the\noperation. If the server doesn't support this method, it returns\n`google.rpc.Code.UNIMPLEMENTED`.",
                      "parameterOrder": [
                        "name"
                      ]
                    },
                    "get": {
                      "description": "Gets the latest state of a long-running operation.  Clients can use this\nmethod to poll the operation result at intervals as recommended by the API\nservice.",
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.admin"
                      ],
                      "httpMethod": "GET",
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/operations/{operationsId}",
                      "parameters": {
                        "name": {
                          "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+/operations/[^/]+$",
                          "description": "The name of the operation resource.",
                          "location": "path",
                          "type": "string",
                          "required": true
                        }
                      },
                      "id": "spanner.projects.instances.databases.operations.get",
                      "parameterOrder": [
                        "name"
                      ],
                      "response": {
                        "$ref": "Operation"
                      },
                      "path": "v1/{+name}"
                    }
                  }
                },
                "sessions": {
                  "methods": {
                    "partitionQuery": {
                      "httpMethod": "POST",
                      "id": "spanner.projects.instances.databases.sessions.partitionQuery",
                      "description": "Creates a set of partition tokens that can be used to execute a query\noperation in parallel.  Each of the returned partition tokens can be used\nby ExecuteStreamingSql to specify a subset\nof the query result to read.  The same session and read-only transaction\nmust be used by the PartitionQueryRequest used to create the\npartition tokens and the ExecuteSqlRequests that use the partition tokens.\n\nPartition tokens become invalid when the session used to create them\nis deleted, is idle for too long, begins a new transaction, or becomes too\nold.  When any of these happen, it is not possible to resume the query, and\nthe whole operation must be restarted from the beginning.",
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.data"
                      ],
                      "parameters": {
                        "session": {
                          "type": "string",
                          "description": "Required. The session used to create the partitions.",
                          "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+/sessions/[^/]+$",
                          "required": true,
                          "location": "path"
                        }
                      },
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/sessions/{sessionsId}:partitionQuery",
                      "parameterOrder": [
                        "session"
                      ],
                      "path": "v1/{+session}:partitionQuery",
                      "response": {
                        "$ref": "PartitionResponse"
                      },
                      "request": {
                        "$ref": "PartitionQueryRequest"
                      }
                    },
                    "rollback": {
                      "parameterOrder": [
                        "session"
                      ],
                      "parameters": {
                        "session": {
                          "description": "Required. The session in which the transaction to roll back is running.",
                          "location": "path",
                          "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+/sessions/[^/]+$",
                          "required": true,
                          "type": "string"
                        }
                      },
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.data"
                      ],
                      "id": "spanner.projects.instances.databases.sessions.rollback",
                      "request": {
                        "$ref": "RollbackRequest"
                      },
                      "httpMethod": "POST",
                      "path": "v1/{+session}:rollback",
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/sessions/{sessionsId}:rollback",
                      "description": "Rolls back a transaction, releasing any locks it holds. It is a good\nidea to call this for any transaction that includes one or more\nRead or ExecuteSql requests and\nultimately decides not to commit.\n\n`Rollback` returns `OK` if it successfully aborts the transaction, the\ntransaction was already aborted, or the transaction is not\nfound. `Rollback` never returns `ABORTED`.",
                      "response": {
                        "$ref": "Empty"
                      }
                    },
                    "list": {
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/sessions",
                      "parameterOrder": [
                        "database"
                      ],
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.data"
                      ],
                      "id": "spanner.projects.instances.databases.sessions.list",
                      "parameters": {
                        "pageToken": {
                          "description": "If non-empty, `page_token` should contain a\nnext_page_token from a previous\nListSessionsResponse.",
                          "location": "query",
                          "type": "string"
                        },
                        "filter": {
                          "description": "An expression for filtering the results of the request. Filter rules are\ncase insensitive. The fields eligible for filtering are:\n\n  * `labels.key` where key is the name of a label\n\nSome examples of using filters are:\n\n  * `labels.env:*` --\u003e The session has the label \"env\".\n  * `labels.env:dev` --\u003e The session has the label \"env\" and the value of\n                       the label contains the string \"dev\".",
                          "location": "query",
                          "type": "string"
                        },
                        "database": {
                          "location": "path",
                          "required": true,
                          "type": "string",
                          "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+$",
                          "description": "Required. The database in which to list sessions."
                        },
                        "pageSize": {
                          "description": "Number of sessions to be returned in the response. If 0 or less, defaults\nto the server's maximum allowed page size.",
                          "location": "query",
                          "type": "integer",
                          "format": "int32"
                        }
                      },
                      "httpMethod": "GET",
                      "response": {
                        "$ref": "ListSessionsResponse"
                      },
                      "description": "Lists all sessions in a given database.",
                      "path": "v1/{+database}/sessions"
                    },
                    "get": {
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.data"
                      ],
                      "description": "Gets a session. Returns `NOT_FOUND` if the session does not exist.\nThis is mainly useful for determining whether a session is still\nalive.",
                      "path": "v1/{+name}",
                      "parameterOrder": [
                        "name"
                      ],
                      "response": {
                        "$ref": "Session"
                      },
                      "httpMethod": "GET",
                      "parameters": {
                        "name": {
                          "required": true,
                          "type": "string",
                          "location": "path",
                          "description": "Required. The name of the session to retrieve.",
                          "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+/sessions/[^/]+$"
                        }
                      },
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/sessions/{sessionsId}",
                      "id": "spanner.projects.instances.databases.sessions.get"
                    },
                    "create": {
                      "parameters": {
                        "database": {
                          "description": "Required. The database in which the new session is created.",
                          "type": "string",
                          "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+$",
                          "location": "path",
                          "required": true
                        }
                      },
                      "httpMethod": "POST",
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/sessions",
                      "parameterOrder": [
                        "database"
                      ],
                      "response": {
                        "$ref": "Session"
                      },
                      "request": {
                        "$ref": "CreateSessionRequest"
                      },
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.data"
                      ],
                      "description": "Creates a new session. A session can be used to perform\ntransactions that read and/or modify data in a Cloud Spanner database.\nSessions are meant to be reused for many consecutive\ntransactions.\n\nSessions can only execute one transaction at a time. To execute\nmultiple concurrent read-write/write-only transactions, create\nmultiple sessions. Note that standalone reads and queries use a\ntransaction internally, and count toward the one transaction\nlimit.\n\nActive sessions use additional server resources, so it is a good idea to\ndelete idle and unneeded sessions.\nAside from explicit deletes, Cloud Spanner may delete sessions for which no\noperations are sent for more than an hour. If a session is deleted,\nrequests to it return `NOT_FOUND`.\n\nIdle sessions can be kept alive by sending a trivial SQL query\nperiodically, e.g., `\"SELECT 1\"`.",
                      "id": "spanner.projects.instances.databases.sessions.create",
                      "path": "v1/{+database}/sessions"
                    },
                    "delete": {
                      "response": {
                        "$ref": "Empty"
                      },
                      "description": "Ends a session, releasing server resources associated with it. This will\nasynchronously trigger cancellation of any operations that are running with\nthis session.",
                      "httpMethod": "DELETE",
                      "id": "spanner.projects.instances.databases.sessions.delete",
                      "parameterOrder": [
                        "name"
                      ],
                      "path": "v1/{+name}",
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.data"
                      ],
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/sessions/{sessionsId}",
                      "parameters": {
                        "name": {
                          "type": "string",
                          "location": "path",
                          "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+/sessions/[^/]+$",
                          "required": true,
                          "description": "Required. The name of the session to delete."
                        }
                      }
                    },
                    "executeSql": {
                      "id": "spanner.projects.instances.databases.sessions.executeSql",
                      "description": "Executes an SQL statement, returning all results in a single reply. This\nmethod cannot be used to return a result set larger than 10 MiB;\nif the query yields more data than that, the query fails with\na `FAILED_PRECONDITION` error.\n\nOperations inside read-write transactions might return `ABORTED`. If\nthis occurs, the application should restart the transaction from\nthe beginning. See Transaction for more details.\n\nLarger result sets can be fetched in streaming fashion by calling\nExecuteStreamingSql instead.",
                      "request": {
                        "$ref": "ExecuteSqlRequest"
                      },
                      "httpMethod": "POST",
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.data"
                      ],
                      "parameterOrder": [
                        "session"
                      ],
                      "parameters": {
                        "session": {
                          "type": "string",
                          "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+/sessions/[^/]+$",
                          "description": "Required. The session in which the SQL query should be performed.",
                          "required": true,
                          "location": "path"
                        }
                      },
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/sessions/{sessionsId}:executeSql",
                      "response": {
                        "$ref": "ResultSet"
                      },
                      "path": "v1/{+session}:executeSql"
                    },
                    "executeBatchDml": {
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/sessions/{sessionsId}:executeBatchDml",
                      "path": "v1/{+session}:executeBatchDml",
                      "parameterOrder": [
                        "session"
                      ],
                      "request": {
                        "$ref": "ExecuteBatchDmlRequest"
                      },
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.data"
                      ],
                      "id": "spanner.projects.instances.databases.sessions.executeBatchDml",
                      "response": {
                        "$ref": "ExecuteBatchDmlResponse"
                      },
                      "description": "Executes a batch of SQL DML statements. This method allows many statements\nto be run with lower latency than submitting them sequentially with\nExecuteSql.\n\nStatements are executed in sequential order. A request can succeed even if\na statement fails. The ExecuteBatchDmlResponse.status field in the\nresponse provides information about the statement that failed. Clients must\ninspect this field to determine whether an error occurred.\n\nExecution stops after the first failed statement; the remaining statements\nare not executed.",
                      "httpMethod": "POST",
                      "parameters": {
                        "session": {
                          "type": "string",
                          "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+/sessions/[^/]+$",
                          "location": "path",
                          "required": true,
                          "description": "Required. The session in which the DML statements should be performed."
                        }
                      }
                    },
                    "commit": {
                      "response": {
                        "$ref": "CommitResponse"
                      },
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/sessions/{sessionsId}:commit",
                      "id": "spanner.projects.instances.databases.sessions.commit",
                      "httpMethod": "POST",
                      "parameters": {
                        "session": {
                          "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+/sessions/[^/]+$",
                          "location": "path",
                          "description": "Required. The session in which the transaction to be committed is running.",
                          "type": "string",
                          "required": true
                        }
                      },
                      "description": "Commits a transaction. The request includes the mutations to be\napplied to rows in the database.\n\n`Commit` might return an `ABORTED` error. This can occur at any time;\ncommonly, the cause is conflicts with concurrent\ntransactions. However, it can also happen for a variety of other\nreasons. If `Commit` returns `ABORTED`, the caller should re-attempt\nthe transaction from the beginning, re-using the same session.",
                      "parameterOrder": [
                        "session"
                      ],
                      "path": "v1/{+session}:commit",
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.data"
                      ],
                      "request": {
                        "$ref": "CommitRequest"
                      }
                    },
                    "partitionRead": {
                      "path": "v1/{+session}:partitionRead",
                      "parameterOrder": [
                        "session"
                      ],
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/sessions/{sessionsId}:partitionRead",
                      "parameters": {
                        "session": {
                          "type": "string",
                          "location": "path",
                          "required": true,
                          "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+/sessions/[^/]+$",
                          "description": "Required. The session used to create the partitions."
                        }
                      },
                      "id": "spanner.projects.instances.databases.sessions.partitionRead",
                      "description": "Creates a set of partition tokens that can be used to execute a read\noperation in parallel.  Each of the returned partition tokens can be used\nby StreamingRead to specify a subset of the read\nresult to read.  The same session and read-only transaction must be used by\nthe PartitionReadRequest used to create the partition tokens and the\nReadRequests that use the partition tokens.  There are no ordering\nguarantees on rows returned among the returned partition tokens, or even\nwithin each individual StreamingRead call issued with a partition_token.\n\nPartition tokens become invalid when the session used to create them\nis deleted, is idle for too long, begins a new transaction, or becomes too\nold.  When any of these happen, it is not possible to resume the read, and\nthe whole operation must be restarted from the beginning.",
                      "request": {
                        "$ref": "PartitionReadRequest"
                      },
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.data"
                      ],
                      "httpMethod": "POST",
                      "response": {
                        "$ref": "PartitionResponse"
                      }
                    },
                    "batchCreate": {
                      "httpMethod": "POST",
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/sessions:batchCreate",
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.data"
                      ],
                      "parameterOrder": [
                        "database"
                      ],
                      "parameters": {
                        "database": {
                          "description": "Required. The database in which the new sessions are created.",
                          "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+$",
                          "type": "string",
                          "required": true,
                          "location": "path"
                        }
                      },
                      "id": "spanner.projects.instances.databases.sessions.batchCreate",
                      "request": {
                        "$ref": "BatchCreateSessionsRequest"
                      },
                      "response": {
                        "$ref": "BatchCreateSessionsResponse"
                      },
                      "description": "Creates multiple new sessions.\n\nThis API can be used to initialize a session cache on the clients.\nSee https://goo.gl/TgSFN2 for best practices on session cache management.",
                      "path": "v1/{+database}/sessions:batchCreate"
                    },
                    "read": {
                      "request": {
                        "$ref": "ReadRequest"
                      },
                      "response": {
                        "$ref": "ResultSet"
                      },
                      "parameterOrder": [
                        "session"
                      ],
                      "httpMethod": "POST",
                      "path": "v1/{+session}:read",
                      "description": "Reads rows from the database using key lookups and scans, as a\nsimple key/value style alternative to\nExecuteSql.  This method cannot be used to\nreturn a result set larger than 10 MiB; if the read matches more\ndata than that, the read fails with a `FAILED_PRECONDITION`\nerror.\n\nReads inside read-write transactions might return `ABORTED`. If\nthis occurs, the application should restart the transaction from\nthe beginning. See Transaction for more details.\n\nLarger result sets can be yielded in streaming fashion by calling\nStreamingRead instead.",
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.data"
                      ],
                      "parameters": {
                        "session": {
                          "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+/sessions/[^/]+$",
                          "type": "string",
                          "required": true,
                          "location": "path",
                          "description": "Required. The session in which the read should be performed."
                        }
                      },
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/sessions/{sessionsId}:read",
                      "id": "spanner.projects.instances.databases.sessions.read"
                    },
                    "executeStreamingSql": {
                      "description": "Like ExecuteSql, except returns the result\nset as a stream. Unlike ExecuteSql, there\nis no limit on the size of the returned result set. However, no\nindividual row in the result set can exceed 100 MiB, and no\ncolumn value can exceed 10 MiB.",
                      "response": {
                        "$ref": "PartialResultSet"
                      },
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.data"
                      ],
                      "parameterOrder": [
                        "session"
                      ],
                      "httpMethod": "POST",
                      "path": "v1/{+session}:executeStreamingSql",
                      "parameters": {
                        "session": {
                          "description": "Required. The session in which the SQL query should be performed.",
                          "type": "string",
                          "location": "path",
                          "required": true,
                          "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+/sessions/[^/]+$"
                        }
                      },
                      "request": {
                        "$ref": "ExecuteSqlRequest"
                      },
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/sessions/{sessionsId}:executeStreamingSql",
                      "id": "spanner.projects.instances.databases.sessions.executeStreamingSql"
                    },
                    "beginTransaction": {
                      "request": {
                        "$ref": "BeginTransactionRequest"
                      },
                      "parameters": {
                        "session": {
                          "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+/sessions/[^/]+$",
                          "description": "Required. The session in which the transaction runs.",
                          "location": "path",
                          "required": true,
                          "type": "string"
                        }
                      },
                      "response": {
                        "$ref": "Transaction"
                      },
                      "parameterOrder": [
                        "session"
                      ],
                      "id": "spanner.projects.instances.databases.sessions.beginTransaction",
                      "path": "v1/{+session}:beginTransaction",
                      "description": "Begins a new transaction. This step can often be skipped:\nRead, ExecuteSql and\nCommit can begin a new transaction as a\nside-effect.",
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/sessions/{sessionsId}:beginTransaction",
                      "httpMethod": "POST",
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.data"
                      ]
                    },
                    "streamingRead": {
                      "id": "spanner.projects.instances.databases.sessions.streamingRead",
                      "description": "Like Read, except returns the result set as a\nstream. Unlike Read, there is no limit on the\nsize of the returned result set. However, no individual row in\nthe result set can exceed 100 MiB, and no column value can exceed\n10 MiB.",
                      "request": {
                        "$ref": "ReadRequest"
                      },
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.data"
                      ],
                      "parameterOrder": [
                        "session"
                      ],
                      "response": {
                        "$ref": "PartialResultSet"
                      },
                      "parameters": {
                        "session": {
                          "description": "Required. The session in which the read should be performed.",
                          "required": true,
                          "pattern": "^projects/[^/]+/instances/[^/]+/databases/[^/]+/sessions/[^/]+$",
                          "type": "string",
                          "location": "path"
                        }
                      },
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databases/{databasesId}/sessions/{sessionsId}:streamingRead",
                      "httpMethod": "POST",
                      "path": "v1/{+session}:streamingRead"
                    }
                  }
                }
              }
            },
            "databaseOperations": {
              "methods": {
                "list": {
                  "path": "v1/{+parent}/databaseOperations",
                  "parameterOrder": [
                    "parent"
                  ],
                  "description": "Lists database longrunning-operations.\nA database operation has a name of the form\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e/databases/\u003cdatabase\u003e/operations/\u003coperation\u003e`.\nThe long-running operation\nmetadata field type\n`metadata.type_url` describes the type of the metadata. Operations returned\ninclude those that have completed/failed/canceled within the last 7 days,\nand pending operations.",
                  "id": "spanner.projects.instances.databaseOperations.list",
                  "response": {
                    "$ref": "ListDatabaseOperationsResponse"
                  },
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/databaseOperations",
                  "httpMethod": "GET",
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "parameters": {
                    "pageToken": {
                      "type": "string",
                      "description": "If non-empty, `page_token` should contain a\nnext_page_token\nfrom a previous ListDatabaseOperationsResponse to the\nsame `parent` and with the same `filter`.",
                      "location": "query"
                    },
                    "filter": {
                      "location": "query",
                      "description": "An expression that filters the list of returned operations.\n\nA filter expression consists of a field name, a\ncomparison operator, and a value for filtering.\nThe value must be a string, a number, or a boolean. The comparison operator\nmust be one of: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `!=`, `=`, or `:`.\nColon `:` is the contains operator. Filter rules are not case sensitive.\n\nThe following fields in the Operation\nare eligible for filtering:\n\n  * `name` - The name of the long-running operation\n  * `done` - False if the operation is in progress, else true.\n  * `metadata.@type` - the type of metadata. For example, the type string\n     for RestoreDatabaseMetadata is\n     `type.googleapis.com/google.spanner.admin.database.v1.RestoreDatabaseMetadata`.\n  * `metadata.\u003cfield_name\u003e` - any field in metadata.value.\n  * `error` - Error associated with the long-running operation.\n  * `response.@type` - the type of response.\n  * `response.\u003cfield_name\u003e` - any field in response.value.\n\nYou can combine multiple expressions by enclosing each expression in\nparentheses. By default, expressions are combined with AND logic. However,\nyou can specify AND, OR, and NOT logic explicitly.\n\nHere are a few examples:\n\n  * `done:true` - The operation is complete.\n  * `(metadata.@type=type.googleapis.com/google.spanner.admin.database.v1.RestoreDatabaseMetadata) AND` \\\n    `(metadata.source_type:BACKUP) AND` \\\n    `(metadata.backup_info.backup:backup_howl) AND` \\\n    `(metadata.name:restored_howl) AND` \\\n    `(metadata.progress.start_time \u003c \\\"2018-03-28T14:50:00Z\\\") AND` \\\n    `(error:*)` - Return operations where:\n    * The operation's metadata type is RestoreDatabaseMetadata.\n    * The database is restored from a backup.\n    * The backup name contains \"backup_howl\".\n    * The restored database's name contains \"restored_howl\".\n    * The operation started before 2018-03-28T14:50:00Z.\n    * The operation resulted in an error.",
                      "type": "string"
                    },
                    "parent": {
                      "type": "string",
                      "pattern": "^projects/[^/]+/instances/[^/]+$",
                      "location": "path",
                      "required": true,
                      "description": "Required. The instance of the database operations.\nValues are of the form `projects/\u003cproject\u003e/instances/\u003cinstance\u003e`."
                    },
                    "pageSize": {
                      "type": "integer",
                      "location": "query",
                      "format": "int32",
                      "description": "Number of operations to be returned in the response. If 0 or\nless, defaults to the server's maximum allowed page size."
                    }
                  }
                }
              }
            },
            "backups": {
              "methods": {
                "get": {
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/backups/{backupsId}",
                  "parameters": {
                    "name": {
                      "location": "path",
                      "type": "string",
                      "pattern": "^projects/[^/]+/instances/[^/]+/backups/[^/]+$",
                      "description": "Required. Name of the backup.\nValues are of the form\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e/backups/\u003cbackup\u003e`.",
                      "required": true
                    }
                  },
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "id": "spanner.projects.instances.backups.get",
                  "description": "Gets metadata on a pending or completed Backup.",
                  "parameterOrder": [
                    "name"
                  ],
                  "response": {
                    "$ref": "Backup"
                  },
                  "path": "v1/{+name}",
                  "httpMethod": "GET"
                },
                "setIamPolicy": {
                  "parameterOrder": [
                    "resource"
                  ],
                  "response": {
                    "$ref": "Policy"
                  },
                  "path": "v1/{+resource}:setIamPolicy",
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/backups/{backupsId}:setIamPolicy",
                  "description": "Sets the access control policy on a database or backup resource.\nReplaces any existing policy.\n\nAuthorization requires `spanner.databases.setIamPolicy`\npermission on resource.\nFor backups, authorization requires `spanner.backups.setIamPolicy`\npermission on resource.",
                  "id": "spanner.projects.instances.backups.setIamPolicy",
                  "request": {
                    "$ref": "SetIamPolicyRequest"
                  },
                  "httpMethod": "POST",
                  "parameters": {
                    "resource": {
                      "type": "string",
                      "required": true,
                      "description": "REQUIRED: The Cloud Spanner resource for which the policy is being set. The format is `projects/\u003cproject ID\u003e/instances/\u003cinstance ID\u003e` for instance resources and `projects/\u003cproject ID\u003e/instances/\u003cinstance ID\u003e/databases/\u003cdatabase ID\u003e` for databases resources.",
                      "pattern": "^projects/[^/]+/instances/[^/]+/backups/[^/]+$",
                      "location": "path"
                    }
                  }
                },
                "create": {
                  "path": "v1/{+parent}/backups",
                  "response": {
                    "$ref": "Operation"
                  },
                  "id": "spanner.projects.instances.backups.create",
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/backups",
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "description": "Starts creating a new Cloud Spanner Backup.\nThe returned backup long-running operation\nwill have a name of the format\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e/backups/\u003cbackup\u003e/operations/\u003coperation_id\u003e`\nand can be used to track creation of the backup. The\nmetadata field type is\nCreateBackupMetadata. The\nresponse field type is\nBackup, if successful. Cancelling the returned operation will stop the\ncreation and delete the backup.\nThere can be only one pending backup creation per database. Backup creation\nof different databases can run concurrently.",
                  "httpMethod": "POST",
                  "request": {
                    "$ref": "Backup"
                  },
                  "parameterOrder": [
                    "parent"
                  ],
                  "parameters": {
                    "backupId": {
                      "location": "query",
                      "type": "string",
                      "description": "Required. The id of the backup to be created. The `backup_id` appended to\n`parent` forms the full backup name of the form\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e/backups/\u003cbackup_id\u003e`."
                    },
                    "parent": {
                      "pattern": "^projects/[^/]+/instances/[^/]+$",
                      "type": "string",
                      "location": "path",
                      "required": true,
                      "description": "Required. The name of the instance in which the backup will be\ncreated. This must be the same instance that contains the database the\nbackup will be created from. The backup will be stored in the\nlocation(s) specified in the instance configuration of this\ninstance. Values are of the form\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e`."
                    }
                  }
                },
                "testIamPermissions": {
                  "parameters": {
                    "resource": {
                      "type": "string",
                      "pattern": "^projects/[^/]+/instances/[^/]+/backups/[^/]+$",
                      "location": "path",
                      "required": true,
                      "description": "REQUIRED: The Cloud Spanner resource for which permissions are being tested. The format is `projects/\u003cproject ID\u003e/instances/\u003cinstance ID\u003e` for instance resources and `projects/\u003cproject ID\u003e/instances/\u003cinstance ID\u003e/databases/\u003cdatabase ID\u003e` for database resources."
                    }
                  },
                  "description": "Returns permissions that the caller has on the specified database or backup\nresource.\n\nAttempting this RPC on a non-existent Cloud Spanner database will\nresult in a NOT_FOUND error if the user has\n`spanner.databases.list` permission on the containing Cloud\nSpanner instance. Otherwise returns an empty set of permissions.\nCalling this method on a backup that does not exist will\nresult in a NOT_FOUND error if the user has\n`spanner.backups.list` permission on the containing instance.",
                  "id": "spanner.projects.instances.backups.testIamPermissions",
                  "response": {
                    "$ref": "TestIamPermissionsResponse"
                  },
                  "parameterOrder": [
                    "resource"
                  ],
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/backups/{backupsId}:testIamPermissions",
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "httpMethod": "POST",
                  "request": {
                    "$ref": "TestIamPermissionsRequest"
                  },
                  "path": "v1/{+resource}:testIamPermissions"
                },
                "patch": {
                  "httpMethod": "PATCH",
                  "parameters": {
                    "name": {
                      "type": "string",
                      "pattern": "^projects/[^/]+/instances/[^/]+/backups/[^/]+$",
                      "required": true,
                      "location": "path",
                      "description": "Output only for the CreateBackup operation.\nRequired for the UpdateBackup operation.\n\nA globally unique identifier for the backup which cannot be\nchanged. Values are of the form\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e/backups/a-z*[a-z0-9]`\nThe final segment of the name must be between 2 and 60 characters\nin length.\n\nThe backup is stored in the location(s) specified in the instance\nconfiguration of the instance containing the backup, identified\nby the prefix of the backup name of the form\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e`."
                    },
                    "updateMask": {
                      "type": "string",
                      "format": "google-fieldmask",
                      "location": "query",
                      "description": "Required. A mask specifying which fields (e.g. `expire_time`) in the\nBackup resource should be updated. This mask is relative to the Backup\nresource, not to the request message. The field mask must always be\nspecified; this prevents any future fields from being erased accidentally\nby clients that do not know about them."
                    }
                  },
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "parameterOrder": [
                    "name"
                  ],
                  "request": {
                    "$ref": "Backup"
                  },
                  "response": {
                    "$ref": "Backup"
                  },
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/backups/{backupsId}",
                  "path": "v1/{+name}",
                  "description": "Updates a pending or completed Backup.",
                  "id": "spanner.projects.instances.backups.patch"
                },
                "list": {
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/backups",
                  "parameterOrder": [
                    "parent"
                  ],
                  "path": "v1/{+parent}/backups",
                  "response": {
                    "$ref": "ListBackupsResponse"
                  },
                  "description": "Lists completed and pending backups.\nBackups returned are ordered by `create_time` in descending order,\nstarting from the most recent `create_time`.",
                  "parameters": {
                    "parent": {
                      "description": "Required. The instance to list backups from.  Values are of the\nform `projects/\u003cproject\u003e/instances/\u003cinstance\u003e`.",
                      "pattern": "^projects/[^/]+/instances/[^/]+$",
                      "type": "string",
                      "required": true,
                      "location": "path"
                    },
                    "pageToken": {
                      "description": "If non-empty, `page_token` should contain a\nnext_page_token from a\nprevious ListBackupsResponse to the same `parent` and with the same\n`filter`.",
                      "type": "string",
                      "location": "query"
                    },
                    "filter": {
                      "location": "query",
                      "type": "string",
                      "description": "An expression that filters the list of returned backups.\n\nA filter expression consists of a field name, a comparison operator, and a\nvalue for filtering.\nThe value must be a string, a number, or a boolean. The comparison operator\nmust be one of: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `!=`, `=`, or `:`.\nColon `:` is the contains operator. Filter rules are not case sensitive.\n\nThe following fields in the Backup are eligible for filtering:\n\n  * `name`\n  * `database`\n  * `state`\n  * `create_time` (and values are of the format YYYY-MM-DDTHH:MM:SSZ)\n  * `expire_time` (and values are of the format YYYY-MM-DDTHH:MM:SSZ)\n  * `size_bytes`\n\nYou can combine multiple expressions by enclosing each expression in\nparentheses. By default, expressions are combined with AND logic, but\nyou can specify AND, OR, and NOT logic explicitly.\n\nHere are a few examples:\n\n  * `name:Howl` - The backup's name contains the string \"howl\".\n  * `database:prod`\n         - The database's name contains the string \"prod\".\n  * `state:CREATING` - The backup is pending creation.\n  * `state:READY` - The backup is fully created and ready for use.\n  * `(name:howl) AND (create_time \u003c \\\"2018-03-28T14:50:00Z\\\")`\n         - The backup name contains the string \"howl\" and `create_time`\n             of the backup is before 2018-03-28T14:50:00Z.\n  * `expire_time \u003c \\\"2018-03-28T14:50:00Z\\\"`\n         - The backup `expire_time` is before 2018-03-28T14:50:00Z.\n  * `size_bytes \u003e 10000000000` - The backup's size is greater than 10GB"
                    },
                    "pageSize": {
                      "type": "integer",
                      "location": "query",
                      "format": "int32",
                      "description": "Number of backups to be returned in the response. If 0 or\nless, defaults to the server's maximum allowed page size."
                    }
                  },
                  "id": "spanner.projects.instances.backups.list",
                  "httpMethod": "GET",
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ]
                },
                "delete": {
                  "parameterOrder": [
                    "name"
                  ],
                  "id": "spanner.projects.instances.backups.delete",
                  "parameters": {
                    "name": {
                      "required": true,
                      "location": "path",
                      "pattern": "^projects/[^/]+/instances/[^/]+/backups/[^/]+$",
                      "type": "string",
                      "description": "Required. Name of the backup to delete.\nValues are of the form\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e/backups/\u003cbackup\u003e`."
                    }
                  },
                  "path": "v1/{+name}",
                  "response": {
                    "$ref": "Empty"
                  },
                  "httpMethod": "DELETE",
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "description": "Deletes a pending or completed Backup.",
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/backups/{backupsId}"
                },
                "getIamPolicy": {
                  "parameters": {
                    "resource": {
                      "pattern": "^projects/[^/]+/instances/[^/]+/backups/[^/]+$",
                      "location": "path",
                      "required": true,
                      "type": "string",
                      "description": "REQUIRED: The Cloud Spanner resource for which the policy is being retrieved. The format is `projects/\u003cproject ID\u003e/instances/\u003cinstance ID\u003e` for instance resources and `projects/\u003cproject ID\u003e/instances/\u003cinstance ID\u003e/databases/\u003cdatabase ID\u003e` for database resources."
                    }
                  },
                  "httpMethod": "POST",
                  "parameterOrder": [
                    "resource"
                  ],
                  "response": {
                    "$ref": "Policy"
                  },
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/backups/{backupsId}:getIamPolicy",
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "description": "Gets the access control policy for a database or backup resource.\nReturns an empty policy if a database or backup exists but does not have a\npolicy set.\n\nAuthorization requires `spanner.databases.getIamPolicy` permission on\nresource.\nFor backups, authorization requires `spanner.backups.getIamPolicy`\npermission on resource.",
                  "request": {
                    "$ref": "GetIamPolicyRequest"
                  },
                  "id": "spanner.projects.instances.backups.getIamPolicy",
                  "path": "v1/{+resource}:getIamPolicy"
                }
              },
              "resources": {
                "operations": {
                  "methods": {
                    "list": {
                      "httpMethod": "GET",
                      "id": "spanner.projects.instances.backups.operations.list",
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.admin"
                      ],
                      "description": "Lists operations that match the specified filter in the request. If the\nserver doesn't support this method, it returns `UNIMPLEMENTED`.\n\nNOTE: the `name` binding allows API services to override the binding\nto use different resource name schemes, such as `users/*/operations`. To\noverride the binding, API services can add a binding such as\n`\"/v1/{name=users/*}/operations\"` to their service configuration.\nFor backwards compatibility, the default name includes the operations\ncollection id, however overriding users must ensure the name binding\nis the parent resource, without the operations collection id.",
                      "parameterOrder": [
                        "name"
                      ],
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/backups/{backupsId}/operations",
                      "response": {
                        "$ref": "ListOperationsResponse"
                      },
                      "parameters": {
                        "filter": {
                          "description": "The standard list filter.",
                          "type": "string",
                          "location": "query"
                        },
                        "name": {
                          "location": "path",
                          "type": "string",
                          "required": true,
                          "description": "The name of the operation's parent resource.",
                          "pattern": "^projects/[^/]+/instances/[^/]+/backups/[^/]+/operations$"
                        },
                        "pageSize": {
                          "location": "query",
                          "type": "integer",
                          "format": "int32",
                          "description": "The standard list page size."
                        },
                        "pageToken": {
                          "type": "string",
                          "location": "query",
                          "description": "The standard list page token."
                        }
                      },
                      "path": "v1/{+name}"
                    },
                    "cancel": {
                      "parameterOrder": [
                        "name"
                      ],
                      "httpMethod": "POST",
                      "parameters": {
                        "name": {
                          "required": true,
                          "pattern": "^projects/[^/]+/instances/[^/]+/backups/[^/]+/operations/[^/]+$",
                          "description": "The name of the operation resource to be cancelled.",
                          "type": "string",
                          "location": "path"
                        }
                      },
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.admin"
                      ],
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/backups/{backupsId}/operations/{operationsId}:cancel",
                      "response": {
                        "$ref": "Empty"
                      },
                      "description": "Starts asynchronous cancellation on a long-running operation.  The server\nmakes a best effort to cancel the operation, but success is not\nguaranteed.  If the server doesn't support this method, it returns\n`google.rpc.Code.UNIMPLEMENTED`.  Clients can use\nOperations.GetOperation or\nother methods to check whether the cancellation succeeded or whether the\noperation completed despite cancellation. On successful cancellation,\nthe operation is not deleted; instead, it becomes an operation with\nan Operation.error value with a google.rpc.Status.code of 1,\ncorresponding to `Code.CANCELLED`.",
                      "path": "v1/{+name}:cancel",
                      "id": "spanner.projects.instances.backups.operations.cancel"
                    },
                    "delete": {
                      "parameters": {
                        "name": {
                          "description": "The name of the operation resource to be deleted.",
                          "location": "path",
                          "type": "string",
                          "required": true,
                          "pattern": "^projects/[^/]+/instances/[^/]+/backups/[^/]+/operations/[^/]+$"
                        }
                      },
                      "parameterOrder": [
                        "name"
                      ],
                      "description": "Deletes a long-running operation. This method indicates that the client is\nno longer interested in the operation result. It does not cancel the\noperation. If the server doesn't support this method, it returns\n`google.rpc.Code.UNIMPLEMENTED`.",
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/backups/{backupsId}/operations/{operationsId}",
                      "response": {
                        "$ref": "Empty"
                      },
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.admin"
                      ],
                      "httpMethod": "DELETE",
                      "path": "v1/{+name}",
                      "id": "spanner.projects.instances.backups.operations.delete"
                    },
                    "get": {
                      "id": "spanner.projects.instances.backups.operations.get",
                      "scopes": [
                        "https://www.googleapis.com/auth/cloud-platform",
                        "https://www.googleapis.com/auth/spanner.admin"
                      ],
                      "description": "Gets the latest state of a long-running operation.  Clients can use this\nmethod to poll the operation result at intervals as recommended by the API\nservice.",
                      "httpMethod": "GET",
                      "parameters": {
                        "name": {
                          "location": "path",
                          "type": "string",
                          "pattern": "^projects/[^/]+/instances/[^/]+/backups/[^/]+/operations/[^/]+$",
                          "required": true,
                          "description": "The name of the operation resource."
                        }
                      },
                      "parameterOrder": [
                        "name"
                      ],
                      "response": {
                        "$ref": "Operation"
                      },
                      "path": "v1/{+name}",
                      "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/backups/{backupsId}/operations/{operationsId}"
                    }
                  }
                }
              }
            },
            "operations": {
              "methods": {
                "get": {
                  "id": "spanner.projects.instances.operations.get",
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "response": {
                    "$ref": "Operation"
                  },
                  "path": "v1/{+name}",
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/operations/{operationsId}",
                  "description": "Gets the latest state of a long-running operation.  Clients can use this\nmethod to poll the operation result at intervals as recommended by the API\nservice.",
                  "parameters": {
                    "name": {
                      "pattern": "^projects/[^/]+/instances/[^/]+/operations/[^/]+$",
                      "required": true,
                      "type": "string",
                      "description": "The name of the operation resource.",
                      "location": "path"
                    }
                  },
                  "httpMethod": "GET",
                  "parameterOrder": [
                    "name"
                  ]
                },
                "list": {
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/operations",
                  "parameters": {
                    "pageSize": {
                      "type": "integer",
                      "description": "The standard list page size.",
                      "format": "int32",
                      "location": "query"
                    },
                    "name": {
                      "pattern": "^projects/[^/]+/instances/[^/]+/operations$",
                      "required": true,
                      "type": "string",
                      "description": "The name of the operation's parent resource.",
                      "location": "path"
                    },
                    "filter": {
                      "description": "The standard list filter.",
                      "type": "string",
                      "location": "query"
                    },
                    "pageToken": {
                      "description": "The standard list page token.",
                      "location": "query",
                      "type": "string"
                    }
                  },
                  "parameterOrder": [
                    "name"
                  ],
                  "description": "Lists operations that match the specified filter in the request. If the\nserver doesn't support this method, it returns `UNIMPLEMENTED`.\n\nNOTE: the `name` binding allows API services to override the binding\nto use different resource name schemes, such as `users/*/operations`. To\noverride the binding, API services can add a binding such as\n`\"/v1/{name=users/*}/operations\"` to their service configuration.\nFor backwards compatibility, the default name includes the operations\ncollection id, however overriding users must ensure the name binding\nis the parent resource, without the operations collection id.",
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "httpMethod": "GET",
                  "id": "spanner.projects.instances.operations.list",
                  "response": {
                    "$ref": "ListOperationsResponse"
                  },
                  "path": "v1/{+name}"
                },
                "delete": {
                  "response": {
                    "$ref": "Empty"
                  },
                  "id": "spanner.projects.instances.operations.delete",
                  "description": "Deletes a long-running operation. This method indicates that the client is\nno longer interested in the operation result. It does not cancel the\noperation. If the server doesn't support this method, it returns\n`google.rpc.Code.UNIMPLEMENTED`.",
                  "httpMethod": "DELETE",
                  "parameters": {
                    "name": {
                      "location": "path",
                      "required": true,
                      "type": "string",
                      "description": "The name of the operation resource to be deleted.",
                      "pattern": "^projects/[^/]+/instances/[^/]+/operations/[^/]+$"
                    }
                  },
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "parameterOrder": [
                    "name"
                  ],
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/operations/{operationsId}",
                  "path": "v1/{+name}"
                },
                "cancel": {
                  "httpMethod": "POST",
                  "id": "spanner.projects.instances.operations.cancel",
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "response": {
                    "$ref": "Empty"
                  },
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/operations/{operationsId}:cancel",
                  "parameterOrder": [
                    "name"
                  ],
                  "description": "Starts asynchronous cancellation on a long-running operation.  The server\nmakes a best effort to cancel the operation, but success is not\nguaranteed.  If the server doesn't support this method, it returns\n`google.rpc.Code.UNIMPLEMENTED`.  Clients can use\nOperations.GetOperation or\nother methods to check whether the cancellation succeeded or whether the\noperation completed despite cancellation. On successful cancellation,\nthe operation is not deleted; instead, it becomes an operation with\nan Operation.error value with a google.rpc.Status.code of 1,\ncorresponding to `Code.CANCELLED`.",
                  "parameters": {
                    "name": {
                      "location": "path",
                      "pattern": "^projects/[^/]+/instances/[^/]+/operations/[^/]+$",
                      "required": true,
                      "description": "The name of the operation resource to be cancelled.",
                      "type": "string"
                    }
                  },
                  "path": "v1/{+name}:cancel"
                }
              }
            },
            "backupOperations": {
              "methods": {
                "list": {
                  "scopes": [
                    "https://www.googleapis.com/auth/cloud-platform",
                    "https://www.googleapis.com/auth/spanner.admin"
                  ],
                  "id": "spanner.projects.instances.backupOperations.list",
                  "description": "Lists the backup long-running operations in\nthe given instance. A backup operation has a name of the form\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e/backups/\u003cbackup\u003e/operations/\u003coperation\u003e`.\nThe long-running operation\nmetadata field type\n`metadata.type_url` describes the type of the metadata. Operations returned\ninclude those that have completed/failed/canceled within the last 7 days,\nand pending operations. Operations returned are ordered by\n`operation.metadata.value.progress.start_time` in descending order starting\nfrom the most recently started operation.",
                  "flatPath": "v1/projects/{projectsId}/instances/{instancesId}/backupOperations",
                  "path": "v1/{+parent}/backupOperations",
                  "response": {
                    "$ref": "ListBackupOperationsResponse"
                  },
                  "httpMethod": "GET",
                  "parameterOrder": [
                    "parent"
                  ],
                  "parameters": {
                    "parent": {
                      "location": "path",
                      "required": true,
                      "description": "Required. The instance of the backup operations. Values are of\nthe form `projects/\u003cproject\u003e/instances/\u003cinstance\u003e`.",
                      "type": "string",
                      "pattern": "^projects/[^/]+/instances/[^/]+$"
                    },
                    "pageToken": {
                      "type": "string",
                      "location": "query",
                      "description": "If non-empty, `page_token` should contain a\nnext_page_token\nfrom a previous ListBackupOperationsResponse to the\nsame `parent` and with the same `filter`."
                    },
                    "filter": {
                      "location": "query",
                      "type": "string",
                      "description": "An expression that filters the list of returned backup operations.\n\nA filter expression consists of a field name, a\ncomparison operator, and a value for filtering.\nThe value must be a string, a number, or a boolean. The comparison operator\nmust be one of: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `!=`, `=`, or `:`.\nColon `:` is the contains operator. Filter rules are not case sensitive.\n\nThe following fields in the operation\nare eligible for filtering:\n\n  * `name` - The name of the long-running operation\n  * `done` - False if the operation is in progress, else true.\n  * `metadata.@type` - the type of metadata. For example, the type string\n     for CreateBackupMetadata is\n     `type.googleapis.com/google.spanner.admin.database.v1.CreateBackupMetadata`.\n  * `metadata.\u003cfield_name\u003e` - any field in metadata.value.\n  * `error` - Error associated with the long-running operation.\n  * `response.@type` - the type of response.\n  * `response.\u003cfield_name\u003e` - any field in response.value.\n\nYou can combine multiple expressions by enclosing each expression in\nparentheses. By default, expressions are combined with AND logic, but\nyou can specify AND, OR, and NOT logic explicitly.\n\nHere are a few examples:\n\n  * `done:true` - The operation is complete.\n  * `metadata.database:prod` - The database the backup was taken from has\n     a name containing the string \"prod\".\n  * `(metadata.@type=type.googleapis.com/google.spanner.admin.database.v1.CreateBackupMetadata) AND` \\\n    `(metadata.name:howl) AND` \\\n    `(metadata.progress.start_time \u003c \\\"2018-03-28T14:50:00Z\\\") AND` \\\n    `(error:*)` - Returns operations where:\n    * The operation's metadata type is CreateBackupMetadata.\n    * The backup name contains the string \"howl\".\n    * The operation started before 2018-03-28T14:50:00Z.\n    * The operation resulted in an error."
                    },
                    "pageSize": {
                      "type": "integer",
                      "format": "int32",
                      "location": "query",
                      "description": "Number of operations to be returned in the response. If 0 or\nless, defaults to the server's maximum allowed page size."
                    }
                  }
                }
              }
            }
          },
          "methods": {
            "list": {
              "description": "Lists all instances in the given project.",
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/spanner.admin"
              ],
              "httpMethod": "GET",
              "id": "spanner.projects.instances.list",
              "response": {
                "$ref": "ListInstancesResponse"
              },
              "path": "v1/{+parent}/instances",
              "parameters": {
                "pageToken": {
                  "type": "string",
                  "location": "query",
                  "description": "If non-empty, `page_token` should contain a\nnext_page_token from a\nprevious ListInstancesResponse."
                },
                "pageSize": {
                  "location": "query",
                  "description": "Number of instances to be returned in the response. If 0 or less, defaults\nto the server's maximum allowed page size.",
                  "format": "int32",
                  "type": "integer"
                },
                "filter": {
                  "location": "query",
                  "type": "string",
                  "description": "An expression for filtering the results of the request. Filter rules are\ncase insensitive. The fields eligible for filtering are:\n\n  * `name`\n  * `display_name`\n  * `labels.key` where key is the name of a label\n\nSome examples of using filters are:\n\n  * `name:*` --\u003e The instance has a name.\n  * `name:Howl` --\u003e The instance's name contains the string \"howl\".\n  * `name:HOWL` --\u003e Equivalent to above.\n  * `NAME:howl` --\u003e Equivalent to above.\n  * `labels.env:*` --\u003e The instance has the label \"env\".\n  * `labels.env:dev` --\u003e The instance has the label \"env\" and the value of\n                       the label contains the string \"dev\".\n  * `name:howl labels.env:dev` --\u003e The instance's name contains \"howl\" and\n                                 it has the label \"env\" with its value\n                                 containing \"dev\"."
                },
                "parent": {
                  "type": "string",
                  "description": "Required. The name of the project for which a list of instances is\nrequested. Values are of the form `projects/\u003cproject\u003e`.",
                  "location": "path",
                  "required": true,
                  "pattern": "^projects/[^/]+$"
                }
              },
              "parameterOrder": [
                "parent"
              ],
              "flatPath": "v1/projects/{projectsId}/instances"
            },
            "testIamPermissions": {
              "id": "spanner.projects.instances.testIamPermissions",
              "response": {
                "$ref": "TestIamPermissionsResponse"
              },
              "parameters": {
                "resource": {
                  "pattern": "^projects/[^/]+/instances/[^/]+$",
                  "type": "string",
                  "location": "path",
                  "description": "REQUIRED: The Cloud Spanner resource for which permissions are being tested. The format is `projects/\u003cproject ID\u003e/instances/\u003cinstance ID\u003e` for instance resources and `projects/\u003cproject ID\u003e/instances/\u003cinstance ID\u003e/databases/\u003cdatabase ID\u003e` for database resources.",
                  "required": true
                }
              },
              "flatPath": "v1/projects/{projectsId}/instances/{instancesId}:testIamPermissions",
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/spanner.admin"
              ],
              "description": "Returns permissions that the caller has on the specified instance resource.\n\nAttempting this RPC on a non-existent Cloud Spanner instance resource will\nresult in a NOT_FOUND error if the user has `spanner.instances.list`\npermission on the containing Google Cloud Project. Otherwise returns an\nempty set of permissions.",
              "httpMethod": "POST",
              "request": {
                "$ref": "TestIamPermissionsRequest"
              },
              "parameterOrder": [
                "resource"
              ],
              "path": "v1/{+resource}:testIamPermissions"
            },
            "setIamPolicy": {
              "httpMethod": "POST",
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/spanner.admin"
              ],
              "description": "Sets the access control policy on an instance resource. Replaces any\nexisting policy.\n\nAuthorization requires `spanner.instances.setIamPolicy` on\nresource.",
              "parameters": {
                "resource": {
                  "required": true,
                  "pattern": "^projects/[^/]+/instances/[^/]+$",
                  "type": "string",
                  "location": "path",
                  "description": "REQUIRED: The Cloud Spanner resource for which the policy is being set. The format is `projects/\u003cproject ID\u003e/instances/\u003cinstance ID\u003e` for instance resources and `projects/\u003cproject ID\u003e/instances/\u003cinstance ID\u003e/databases/\u003cdatabase ID\u003e` for databases resources."
                }
              },
              "parameterOrder": [
                "resource"
              ],
              "flatPath": "v1/projects/{projectsId}/instances/{instancesId}:setIamPolicy",
              "response": {
                "$ref": "Policy"
              },
              "path": "v1/{+resource}:setIamPolicy",
              "request": {
                "$ref": "SetIamPolicyRequest"
              },
              "id": "spanner.projects.instances.setIamPolicy"
            },
            "delete": {
              "description": "Deletes an instance.\n\nImmediately upon completion of the request:\n\n  * Billing ceases for all of the instance's reserved resources.\n\nSoon afterward:\n\n  * The instance and *all of its databases* immediately and\n    irrevocably disappear from the API. All data in the databases\n    is permanently deleted.",
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/spanner.admin"
              ],
              "httpMethod": "DELETE",
              "id": "spanner.projects.instances.delete",
              "flatPath": "v1/projects/{projectsId}/instances/{instancesId}",
              "parameters": {
                "name": {
                  "description": "Required. The name of the instance to be deleted. Values are of the form\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e`",
                  "required": true,
                  "type": "string",
                  "pattern": "^projects/[^/]+/instances/[^/]+$",
                  "location": "path"
                }
              },
              "response": {
                "$ref": "Empty"
              },
              "path": "v1/{+name}",
              "parameterOrder": [
                "name"
              ]
            },
            "create": {
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/spanner.admin"
              ],
              "id": "spanner.projects.instances.create",
              "request": {
                "$ref": "CreateInstanceRequest"
              },
              "flatPath": "v1/projects/{projectsId}/instances",
              "httpMethod": "POST",
              "parameters": {
                "parent": {
                  "type": "string",
                  "location": "path",
                  "description": "Required. The name of the project in which to create the instance. Values\nare of the form `projects/\u003cproject\u003e`.",
                  "pattern": "^projects/[^/]+$",
                  "required": true
                }
              },
              "description": "Creates an instance and begins preparing it to begin serving. The\nreturned long-running operation\ncan be used to track the progress of preparing the new\ninstance. The instance name is assigned by the caller. If the\nnamed instance already exists, `CreateInstance` returns\n`ALREADY_EXISTS`.\n\nImmediately upon completion of this request:\n\n  * The instance is readable via the API, with all requested attributes\n    but no allocated resources. Its state is `CREATING`.\n\nUntil completion of the returned operation:\n\n  * Cancelling the operation renders the instance immediately unreadable\n    via the API.\n  * The instance can be deleted.\n  * All other attempts to modify the instance are rejected.\n\nUpon completion of the returned operation:\n\n  * Billing for all successfully-allocated resources begins (some types\n    may have lower than the requested levels).\n  * Databases can be created in the instance.\n  * The instance's allocated resource levels are readable via the API.\n  * The instance's state becomes `READY`.\n\nThe returned long-running operation will\nhave a name of the format `\u003cinstance_name\u003e/operations/\u003coperation_id\u003e` and\ncan be used to track creation of the instance.  The\nmetadata field type is\nCreateInstanceMetadata.\nThe response field type is\nInstance, if successful.",
              "path": "v1/{+parent}/instances",
              "response": {
                "$ref": "Operation"
              },
              "parameterOrder": [
                "parent"
              ]
            },
            "get": {
              "id": "spanner.projects.instances.get",
              "parameters": {
                "name": {
                  "location": "path",
                  "description": "Required. The name of the requested instance. Values are of the form\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e`.",
                  "pattern": "^projects/[^/]+/instances/[^/]+$",
                  "type": "string",
                  "required": true
                },
                "fieldMask": {
                  "location": "query",
                  "description": "If field_mask is present, specifies the subset of Instance fields that\nshould be returned.\nIf absent, all Instance fields are returned.",
                  "type": "string",
                  "format": "google-fieldmask"
                }
              },
              "httpMethod": "GET",
              "flatPath": "v1/projects/{projectsId}/instances/{instancesId}",
              "parameterOrder": [
                "name"
              ],
              "path": "v1/{+name}",
              "description": "Gets information about a particular instance.",
              "response": {
                "$ref": "Instance"
              },
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/spanner.admin"
              ]
            },
            "patch": {
              "request": {
                "$ref": "UpdateInstanceRequest"
              },
              "path": "v1/{+name}",
              "flatPath": "v1/projects/{projectsId}/instances/{instancesId}",
              "id": "spanner.projects.instances.patch",
              "httpMethod": "PATCH",
              "parameterOrder": [
                "name"
              ],
              "description": "Updates an instance, and begins allocating or releasing resources\nas requested. The returned long-running\noperation can be used to track the\nprogress of updating the instance. If the named instance does not\nexist, returns `NOT_FOUND`.\n\nImmediately upon completion of this request:\n\n  * For resource types for which a decrease in the instance's allocation\n    has been requested, billing is based on the newly-requested level.\n\nUntil completion of the returned operation:\n\n  * Cancelling the operation sets its metadata's\n    cancel_time, and begins\n    restoring resources to their pre-request values. The operation\n    is guaranteed to succeed at undoing all resource changes,\n    after which point it terminates with a `CANCELLED` status.\n  * All other attempts to modify the instance are rejected.\n  * Reading the instance via the API continues to give the pre-request\n    resource levels.\n\nUpon completion of the returned operation:\n\n  * Billing begins for all successfully-allocated resources (some types\n    may have lower than the requested levels).\n  * All newly-reserved resources are available for serving the instance's\n    tables.\n  * The instance's new resource levels are readable via the API.\n\nThe returned long-running operation will\nhave a name of the format `\u003cinstance_name\u003e/operations/\u003coperation_id\u003e` and\ncan be used to track the instance modification.  The\nmetadata field type is\nUpdateInstanceMetadata.\nThe response field type is\nInstance, if successful.\n\nAuthorization requires `spanner.instances.update` permission on\nresource name.",
              "response": {
                "$ref": "Operation"
              },
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/spanner.admin"
              ],
              "parameters": {
                "name": {
                  "required": true,
                  "type": "string",
                  "location": "path",
                  "pattern": "^projects/[^/]+/instances/[^/]+$",
                  "description": "Required. A unique identifier for the instance, which cannot be changed\nafter the instance is created. Values are of the form\n`projects/\u003cproject\u003e/instances/a-z*[a-z0-9]`. The final\nsegment of the name must be between 2 and 64 characters in length."
                }
              }
            },
            "getIamPolicy": {
              "parameterOrder": [
                "resource"
              ],
              "response": {
                "$ref": "Policy"
              },
              "httpMethod": "POST",
              "id": "spanner.projects.instances.getIamPolicy",
              "flatPath": "v1/projects/{projectsId}/instances/{instancesId}:getIamPolicy",
              "request": {
                "$ref": "GetIamPolicyRequest"
              },
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/spanner.admin"
              ],
              "description": "Gets the access control policy for an instance resource. Returns an empty\npolicy if an instance exists but does not have a policy set.\n\nAuthorization requires `spanner.instances.getIamPolicy` on\nresource.",
              "parameters": {
                "resource": {
                  "description": "REQUIRED: The Cloud Spanner resource for which the policy is being retrieved. The format is `projects/\u003cproject ID\u003e/instances/\u003cinstance ID\u003e` for instance resources and `projects/\u003cproject ID\u003e/instances/\u003cinstance ID\u003e/databases/\u003cdatabase ID\u003e` for database resources.",
                  "location": "path",
                  "type": "string",
                  "pattern": "^projects/[^/]+/instances/[^/]+$",
                  "required": true
                }
              },
              "path": "v1/{+resource}:getIamPolicy"
            }
          }
        }
      }
    }
  },
  "description": "Cloud Spanner is a managed, mission-critical, globally consistent and scalable relational database service.",
  "protocol": "rest",
  "baseUrl": "https://spanner.googleapis.com/",
  "kind": "discovery#restDescription",
  "version": "v1",
  "icons": {
    "x32": "http://www.google.com/images/icons/product/search-32.gif",
    "x16": "http://www.google.com/images/icons/product/search-16.gif"
  },
  "ownerDomain": "google.com",
  "ownerName": "Google",
  "schemas": {
    "Type": {
      "id": "Type",
      "properties": {
        "code": {
          "enumDescriptions": [
            "Not specified.",
            "Encoded as JSON `true` or `false`.",
            "Encoded as `string`, in decimal format.",
            "Encoded as `number`, or the strings `\"NaN\"`, `\"Infinity\"`, or\n`\"-Infinity\"`.",
            "Encoded as `string` in RFC 3339 timestamp format. The time zone\nmust be present, and must be `\"Z\"`.\n\nIf the schema has the column option\n`allow_commit_timestamp=true`, the placeholder string\n`\"spanner.commit_timestamp()\"` can be used to instruct the system\nto insert the commit timestamp associated with the transaction\ncommit.",
            "Encoded as `string` in RFC 3339 date format.",
            "Encoded as `string`.",
            "Encoded as a base64-encoded `string`, as described in RFC 4648,\nsection 4.",
            "Encoded as `list`, where the list elements are represented\naccording to\narray_element_type.",
            "Encoded as `list`, where list element `i` is represented according\nto [struct_type.fields[i]][google.spanner.v1.StructType.fields]."
          ],
          "description": "Required. The TypeCode for this type.",
          "type": "string",
          "enum": [
            "TYPE_CODE_UNSPECIFIED",
            "BOOL",
            "INT64",
            "FLOAT64",
            "TIMESTAMP",
            "DATE",
            "STRING",
            "BYTES",
            "ARRAY",
            "STRUCT"
          ]
        },
        "arrayElementType": {
          "description": "If code == ARRAY, then `array_element_type`\nis the type of the array elements.",
          "$ref": "Type"
        },
        "structType": {
          "$ref": "StructType",
          "description": "If code == STRUCT, then `struct_type`\nprovides type information for the struct's fields."
        }
      },
      "description": "`Type` indicates the type of a Cloud Spanner value, as might be stored in a\ntable cell or returned from an SQL query.",
      "type": "object"
    },
    "Instance": {
      "id": "Instance",
      "properties": {
        "endpointUris": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Deprecated. This field is not populated."
        },
        "displayName": {
          "description": "Required. The descriptive name for this instance as it appears in UIs.\nMust be unique per project and between 4 and 30 characters in length.",
          "type": "string"
        },
        "config": {
          "description": "Required. The name of the instance's configuration. Values are of the form\n`projects/\u003cproject\u003e/instanceConfigs/\u003cconfiguration\u003e`. See\nalso InstanceConfig and\nListInstanceConfigs.",
          "type": "string"
        },
        "name": {
          "description": "Required. A unique identifier for the instance, which cannot be changed\nafter the instance is created. Values are of the form\n`projects/\u003cproject\u003e/instances/a-z*[a-z0-9]`. The final\nsegment of the name must be between 2 and 64 characters in length.",
          "type": "string"
        },
        "labels": {
          "description": "Cloud Labels are a flexible and lightweight mechanism for organizing cloud\nresources into groups that reflect a customer's organizational needs and\ndeployment strategies. Cloud Labels can be used to filter collections of\nresources. They can be used to control how resource metrics are aggregated.\nAnd they can be used as arguments to policy management rules (e.g. route,\nfirewall, load balancing, etc.).\n\n * Label keys must be between 1 and 63 characters long and must conform to\n   the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.\n * Label values must be between 0 and 63 characters long and must conform\n   to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.\n * No more than 64 labels can be associated with a given resource.\n\nSee https://goo.gl/xmQnxf for more information on and examples of labels.\n\nIf you plan to use labels in your own code, please note that additional\ncharacters may be allowed in the future. And so you are advised to use an\ninternal label representation, such as JSON, which doesn't rely upon\nspecific characters being disallowed.  For example, representing labels\nas the string:  name + \"_\" + value  would prove problematic if we were to\nallow \"_\" in a future release.",
          "additionalProperties": {
            "type": "string"
          },
          "type": "object"
        },
        "state": {
          "enum": [
            "STATE_UNSPECIFIED",
            "CREATING",
            "READY"
          ],
          "description": "Output only. The current instance state. For\nCreateInstance, the state must be\neither omitted or set to `CREATING`. For\nUpdateInstance, the state must be\neither omitted or set to `READY`.",
          "type": "string",
          "enumDescriptions": [
            "Not specified.",
            "The instance is still being created. Resources may not be\navailable yet, and operations such as database creation may not\nwork.",
            "The instance is fully created and ready to do work such as\ncreating databases."
          ]
        },
        "nodeCount": {
          "type": "integer",
          "format": "int32",
          "description": "The number of nodes allocated to this instance. This\nmay be zero in API responses for instances that are not yet in state\n`READY`.\n\nSee [the\ndocumentation](https://cloud.google.com/spanner/docs/instances#node_count)\nfor more information about nodes."
        }
      },
      "description": "An isolated set of Cloud Spanner resources on which databases can be hosted.",
      "type": "object"
    },
    "PartitionReadRequest": {
      "properties": {
        "keySet": {
          "description": "Required. `key_set` identifies the rows to be yielded. `key_set` names the\nprimary keys of the rows in table to be yielded, unless index\nis present. If index is present, then key_set instead names\nindex keys in index.\n\nIt is not an error for the `key_set` to name rows that do not\nexist in the database. Read yields nothing for nonexistent rows.",
          "$ref": "KeySet"
        },
        "columns": {
          "type": "array",
          "description": "The columns of table to be returned for each row matching\nthis request.",
          "items": {
            "type": "string"
          }
        },
        "transaction": {
          "$ref": "TransactionSelector",
          "description": "Read only snapshot transactions are supported, read/write and single use\ntransactions are not."
        },
        "partitionOptions": {
          "$ref": "PartitionOptions",
          "description": "Additional options that affect how many partitions are created."
        },
        "table": {
          "description": "Required. The name of the table in the database to be read.",
          "type": "string"
        },
        "index": {
          "description": "If non-empty, the name of an index on table. This index is\nused instead of the table primary key when interpreting key_set\nand sorting result rows. See key_set for further information.",
          "type": "string"
        }
      },
      "id": "PartitionReadRequest",
      "type": "object",
      "description": "The request for PartitionRead"
    },
    "PlanNode": {
      "description": "Node information for nodes appearing in a QueryPlan.plan_nodes.",
      "id": "PlanNode",
      "properties": {
        "index": {
          "format": "int32",
          "type": "integer",
          "description": "The `PlanNode`'s index in node list."
        },
        "childLinks": {
          "description": "List of child node `index`es and their relationship to this parent.",
          "type": "array",
          "items": {
            "$ref": "ChildLink"
          }
        },
        "kind": {
          "enum": [
            "KIND_UNSPECIFIED",
            "RELATIONAL",
            "SCALAR"
          ],
          "enumDescriptions": [
            "Not specified.",
            "Denotes a Relational operator node in the expression tree. Relational\noperators represent iterative processing of rows during query execution.\nFor example, a `TableScan` operation that reads rows from a table.",
            "Denotes a Scalar node in the expression tree. Scalar nodes represent\nnon-iterable entities in the query plan. For example, constants or\narithmetic operators appearing inside predicate expressions or references\nto column names."
          ],
          "description": "Used to determine the type of node. May be needed for visualizing\ndifferent kinds of nodes differently. For example, If the node is a\nSCALAR node, it will have a condensed representation\nwhich can be used to directly embed a description of the node in its\nparent.",
          "type": "string"
        },
        "executionStats": {
          "additionalProperties": {
            "type": "any",
            "description": "Properties of the object."
          },
          "type": "object",
          "description": "The execution statistics associated with the node, contained in a group of\nkey-value pairs. Only present if the plan was returned as a result of a\nprofile query. For example, number of executions, number of rows/time per\nexecution etc."
        },
        "metadata": {
          "type": "object",
          "additionalProperties": {
            "type": "any",
            "description": "Properties of the object."
          },
          "description": "Attributes relevant to the node contained in a group of key-value pairs.\nFor example, a Parameter Reference node could have the following\ninformation in its metadata:\n\n    {\n      \"parameter_reference\": \"param1\",\n      \"parameter_type\": \"array\"\n    }"
        },
        "shortRepresentation": {
          "description": "Condensed representation for SCALAR nodes.",
          "$ref": "ShortRepresentation"
        },
        "displayName": {
          "description": "The display name for the node.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ExecuteBatchDmlResponse": {
      "properties": {
        "resultSets": {
          "items": {
            "$ref": "ResultSet"
          },
          "description": "One ResultSet for each statement in the request that ran successfully,\nin the same order as the statements in the request. Each ResultSet does\nnot contain any rows. The ResultSetStats in each ResultSet contain\nthe number of rows modified by the statement.\n\nOnly the first ResultSet in the response contains valid\nResultSetMetadata.",
          "type": "array"
        },
        "status": {
          "description": "If all DML statements are executed successfully, the status is `OK`.\nOtherwise, the error status of the first failed statement.",
          "$ref": "Status"
        }
      },
      "description": "The response for ExecuteBatchDml. Contains a list\nof ResultSet messages, one for each DML statement that has successfully\nexecuted, in the same order as the statements in the request. If a statement\nfails, the status in the response body identifies the cause of the failure.\n\nTo check for DML statements that failed, use the following approach:\n\n1. Check the status in the response message. The google.rpc.Code enum\n   value `OK` indicates that all statements were executed successfully.\n2. If the status was not `OK`, check the number of result sets in the\n   response. If the response contains `N` ResultSet messages, then\n   statement `N+1` in the request failed.\n\nExample 1:\n\n* Request: 5 DML statements, all executed successfully.\n* Response: 5 ResultSet messages, with the status `OK`.\n\nExample 2:\n\n* Request: 5 DML statements. The third statement has a syntax error.\n* Response: 2 ResultSet messages, and a syntax error (`INVALID_ARGUMENT`)\n  status. The number of ResultSet messages indicates that the third\n  statement failed, and the fourth and fifth statements were not executed.",
      "id": "ExecuteBatchDmlResponse",
      "type": "object"
    },
    "ListDatabasesResponse": {
      "type": "object",
      "description": "The response for ListDatabases.",
      "id": "ListDatabasesResponse",
      "properties": {
        "databases": {
          "type": "array",
          "items": {
            "$ref": "Database"
          },
          "description": "Databases that matched the request."
        },
        "nextPageToken": {
          "type": "string",
          "description": "`next_page_token` can be sent in a subsequent\nListDatabases call to fetch more\nof the matching databases."
        }
      }
    },
    "Mutation": {
      "id": "Mutation",
      "description": "A modification to one or more Cloud Spanner rows.  Mutations can be\napplied to a Cloud Spanner database by sending them in a\nCommit call.",
      "properties": {
        "update": {
          "$ref": "Write",
          "description": "Update existing rows in a table. If any of the rows does not\nalready exist, the transaction fails with error `NOT_FOUND`."
        },
        "insert": {
          "description": "Insert new rows in a table. If any of the rows already exist,\nthe write or transaction fails with error `ALREADY_EXISTS`.",
          "$ref": "Write"
        },
        "insertOrUpdate": {
          "description": "Like insert, except that if the row already exists, then\nits column values are overwritten with the ones provided. Any\ncolumn values not explicitly written are preserved.\n\nWhen using insert_or_update, just as when using insert, all `NOT\nNULL` columns in the table must be given a value. This holds true\neven when the row already exists and will therefore actually be updated.",
          "$ref": "Write"
        },
        "replace": {
          "description": "Like insert, except that if the row already exists, it is\ndeleted, and the column values provided are inserted\ninstead. Unlike insert_or_update, this means any values not\nexplicitly written become `NULL`.\n\nIn an interleaved table, if you create the child table with the\n`ON DELETE CASCADE` annotation, then replacing a parent row\nalso deletes the child rows. Otherwise, you must delete the\nchild rows before you replace the parent row.",
          "$ref": "Write"
        },
        "delete": {
          "$ref": "Delete",
          "description": "Delete rows from a table. Succeeds whether or not the named\nrows were present."
        }
      },
      "type": "object"
    },
    "GetIamPolicyRequest": {
      "type": "object",
      "description": "Request message for `GetIamPolicy` method.",
      "id": "GetIamPolicyRequest",
      "properties": {
        "options": {
          "$ref": "GetPolicyOptions",
          "description": "OPTIONAL: A `GetPolicyOptions` object for specifying options to\n`GetIamPolicy`."
        }
      }
    },
    "ListInstanceConfigsResponse": {
      "description": "The response for ListInstanceConfigs.",
      "type": "object",
      "id": "ListInstanceConfigsResponse",
      "properties": {
        "nextPageToken": {
          "type": "string",
          "description": "`next_page_token` can be sent in a subsequent\nListInstanceConfigs call to\nfetch more of the matching instance configurations."
        },
        "instanceConfigs": {
          "items": {
            "$ref": "InstanceConfig"
          },
          "description": "The list of requested instance configurations.",
          "type": "array"
        }
      }
    },
    "TestIamPermissionsRequest": {
      "type": "object",
      "properties": {
        "permissions": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "REQUIRED: The set of permissions to check for 'resource'.\nPermissions with wildcards (such as '*', 'spanner.*', 'spanner.instances.*') are not allowed."
        }
      },
      "id": "TestIamPermissionsRequest",
      "description": "Request message for `TestIamPermissions` method."
    },
    "RestoreDatabaseRequest": {
      "properties": {
        "databaseId": {
          "description": "Required. The id of the database to create and restore to. This\ndatabase must not already exist. The `database_id` appended to\n`parent` forms the full database name of the form\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e/databases/\u003cdatabase_id\u003e`.",
          "type": "string"
        },
        "backup": {
          "type": "string",
          "description": "Name of the backup from which to restore.  Values are of the form\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e/backups/\u003cbackup\u003e`."
        }
      },
      "description": "The request for\nRestoreDatabase.",
      "type": "object",
      "id": "RestoreDatabaseRequest"
    },
    "Empty": {
      "properties": {},
      "id": "Empty",
      "description": "A generic empty message that you can re-use to avoid defining duplicated\nempty messages in your APIs. A typical example is to use it as the request\nor the response type of an API method. For instance:\n\n    service Foo {\n      rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);\n    }\n\nThe JSON representation for `Empty` is empty JSON object `{}`.",
      "type": "object"
    },
    "InstanceConfig": {
      "description": "A possible configuration for a Cloud Spanner instance. Configurations\ndefine the geographic placement of nodes and their replication.",
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "A unique identifier for the instance configuration.  Values\nare of the form\n`projects/\u003cproject\u003e/instanceConfigs/a-z*`"
        },
        "displayName": {
          "type": "string",
          "description": "The name of this instance configuration as it appears in UIs."
        },
        "replicas": {
          "description": "The geographic placement of nodes in this instance configuration and their\nreplication properties.",
          "type": "array",
          "items": {
            "$ref": "ReplicaInfo"
          }
        }
      },
      "id": "InstanceConfig"
    },
    "ListInstancesResponse": {
      "properties": {
        "nextPageToken": {
          "description": "`next_page_token` can be sent in a subsequent\nListInstances call to fetch more\nof the matching instances.",
          "type": "string"
        },
        "instances": {
          "items": {
            "$ref": "Instance"
          },
          "type": "array",
          "description": "The list of requested instances."
        }
      },
      "description": "The response for ListInstances.",
      "id": "ListInstancesResponse",
      "type": "object"
    },
    "ResultSet": {
      "description": "Results from Read or\nExecuteSql.",
      "type": "object",
      "properties": {
        "rows": {
          "type": "array",
          "description": "Each element in `rows` is a row whose format is defined by\nmetadata.row_type. The ith element\nin each row matches the ith field in\nmetadata.row_type. Elements are\nencoded based on type as described\nhere.",
          "items": {
            "items": {
              "type": "any"
            },
            "type": "array"
          }
        },
        "stats": {
          "description": "Query plan and execution statistics for the SQL statement that\nproduced this result set. These can be requested by setting\nExecuteSqlRequest.query_mode.\nDML statements always produce stats containing the number of rows\nmodified, unless executed using the\nExecuteSqlRequest.QueryMode.PLAN ExecuteSqlRequest.query_mode.\nOther fields may or may not be populated, based on the\nExecuteSqlRequest.query_mode.",
          "$ref": "ResultSetStats"
        },
        "metadata": {
          "$ref": "ResultSetMetadata",
          "description": "Metadata about the result set, such as row type information."
        }
      },
      "id": "ResultSet"
    },
    "UpdateDatabaseDdlMetadata": {
      "type": "object",
      "properties": {
        "commitTimestamps": {
          "type": "array",
          "description": "Reports the commit timestamps of all statements that have\nsucceeded so far, where `commit_timestamps[i]` is the commit\ntimestamp for the statement `statements[i]`.",
          "items": {
            "type": "string",
            "format": "google-datetime"
          }
        },
        "database": {
          "description": "The database being modified.",
          "type": "string"
        },
        "statements": {
          "items": {
            "type": "string"
          },
          "description": "For an update this list contains all the statements. For an\nindividual statement, this list contains only that statement.",
          "type": "array"
        }
      },
      "id": "UpdateDatabaseDdlMetadata",
      "description": "Metadata type for the operation returned by\nUpdateDatabaseDdl."
    },
    "Delete": {
      "description": "Arguments to delete operations.",
      "properties": {
        "keySet": {
          "$ref": "KeySet",
          "description": "Required. The primary keys of the rows within table to delete.  The\nprimary keys must be specified in the order in which they appear in the\n`PRIMARY KEY()` clause of the table's equivalent DDL statement (the DDL\nstatement used to create the table).\nDelete is idempotent. The transaction will succeed even if some or all\nrows do not exist."
        },
        "table": {
          "type": "string",
          "description": "Required. The table whose rows will be deleted."
        }
      },
      "type": "object",
      "id": "Delete"
    },
    "CreateSessionRequest": {
      "properties": {
        "session": {
          "$ref": "Session",
          "description": "Required. The session to create."
        }
      },
      "id": "CreateSessionRequest",
      "type": "object",
      "description": "The request for CreateSession."
    },
    "CreateInstanceMetadata": {
      "type": "object",
      "description": "Metadata type for the operation returned by\nCreateInstance.",
      "properties": {
        "endTime": {
          "format": "google-datetime",
          "type": "string",
          "description": "The time at which this operation failed or was completed successfully."
        },
        "instance": {
          "$ref": "Instance",
          "description": "The instance being created."
        },
        "startTime": {
          "format": "google-datetime",
          "type": "string",
          "description": "The time at which the\nCreateInstance request was\nreceived."
        },
        "cancelTime": {
          "type": "string",
          "description": "The time at which this operation was cancelled. If set, this operation is\nin the process of undoing itself (which is guaranteed to succeed) and\ncannot be cancelled again.",
          "format": "google-datetime"
        }
      },
      "id": "CreateInstanceMetadata"
    },
    "OperationProgress": {
      "type": "object",
      "description": "Encapsulates progress related information for a Cloud Spanner long\nrunning operation.",
      "properties": {
        "endTime": {
          "type": "string",
          "description": "If set, the time at which this operation failed or was completed\nsuccessfully.",
          "format": "google-datetime"
        },
        "startTime": {
          "type": "string",
          "description": "Time the request was received.",
          "format": "google-datetime"
        },
        "progressPercent": {
          "format": "int32",
          "description": "Percent completion of the operation.\nValues are between 0 and 100 inclusive.",
          "type": "integer"
        }
      },
      "id": "OperationProgress"
    },
    "CreateInstanceRequest": {
      "description": "The request for CreateInstance.",
      "type": "object",
      "properties": {
        "instanceId": {
          "description": "Required. The ID of the instance to create.  Valid identifiers are of the\nform `a-z*[a-z0-9]` and must be between 2 and 64 characters in\nlength.",
          "type": "string"
        },
        "instance": {
          "description": "Required. The instance to create.  The name may be omitted, but if\nspecified must be `\u003cparent\u003e/instances/\u003cinstance_id\u003e`.",
          "$ref": "Instance"
        }
      },
      "id": "CreateInstanceRequest"
    },
    "SetIamPolicyRequest": {
      "type": "object",
      "description": "Request message for `SetIamPolicy` method.",
      "id": "SetIamPolicyRequest",
      "properties": {
        "policy": {
          "$ref": "Policy",
          "description": "REQUIRED: The complete policy to be applied to the `resource`. The size of\nthe policy is limited to a few 10s of KB. An empty policy is a\nvalid policy but certain Cloud Platform services (such as Projects)\nmight reject them."
        }
      }
    },
    "BeginTransactionRequest": {
      "id": "BeginTransactionRequest",
      "description": "The request for BeginTransaction.",
      "type": "object",
      "properties": {
        "options": {
          "$ref": "TransactionOptions",
          "description": "Required. Options for the new transaction."
        }
      }
    },
    "ShortRepresentation": {
      "id": "ShortRepresentation",
      "properties": {
        "subqueries": {
          "type": "object",
          "additionalProperties": {
            "type": "integer",
            "format": "int32"
          },
          "description": "A mapping of (subquery variable name) -\u003e (subquery node id) for cases\nwhere the `description` string of this node references a `SCALAR`\nsubquery contained in the expression subtree rooted at this node. The\nreferenced `SCALAR` subquery may not necessarily be a direct child of\nthis node."
        },
        "description": {
          "type": "string",
          "description": "A string representation of the expression subtree rooted at this node."
        }
      },
      "description": "Condensed representation of a node and its subtree. Only present for\n`SCALAR` PlanNode(s).",
      "type": "object"
    },
    "BatchCreateSessionsResponse": {
      "properties": {
        "session": {
          "description": "The freshly created sessions.",
          "items": {
            "$ref": "Session"
          },
          "type": "array"
        }
      },
      "id": "BatchCreateSessionsResponse",
      "type": "object",
      "description": "The response for BatchCreateSessions."
    },
    "ListDatabaseOperationsResponse": {
      "type": "object",
      "id": "ListDatabaseOperationsResponse",
      "properties": {
        "nextPageToken": {
          "type": "string",
          "description": "`next_page_token` can be sent in a subsequent\nListDatabaseOperations\ncall to fetch more of the matching metadata."
        },
        "operations": {
          "type": "array",
          "items": {
            "$ref": "Operation"
          },
          "description": "The list of matching database long-running\noperations. Each operation's name will be\nprefixed by the database's name. The operation's\nmetadata field type\n`metadata.type_url` describes the type of the metadata."
        }
      },
      "description": "The response for\nListDatabaseOperations."
    },
    "CreateDatabaseMetadata": {
      "properties": {
        "database": {
          "description": "The database being created.",
          "type": "string"
        }
      },
      "type": "object",
      "id": "CreateDatabaseMetadata",
      "description": "Metadata type for the operation returned by\nCreateDatabase."
    },
    "UpdateInstanceMetadata": {
      "type": "object",
      "properties": {
        "endTime": {
          "format": "google-datetime",
          "type": "string",
          "description": "The time at which this operation failed or was completed successfully."
        },
        "startTime": {
          "format": "google-datetime",
          "type": "string",
          "description": "The time at which UpdateInstance\nrequest was received."
        },
        "cancelTime": {
          "format": "google-datetime",
          "type": "string",
          "description": "The time at which this operation was cancelled. If set, this operation is\nin the process of undoing itself (which is guaranteed to succeed) and\ncannot be cancelled again."
        },
        "instance": {
          "$ref": "Instance",
          "description": "The desired end state of the update."
        }
      },
      "id": "UpdateInstanceMetadata",
      "description": "Metadata type for the operation returned by\nUpdateInstance."
    },
    "UpdateDatabaseDdlRequest": {
      "id": "UpdateDatabaseDdlRequest",
      "type": "object",
      "properties": {
        "statements": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Required. DDL statements to be applied to the database."
        },
        "operationId": {
          "description": "If empty, the new update request is assigned an\nautomatically-generated operation ID. Otherwise, `operation_id`\nis used to construct the name of the resulting\nOperation.\n\nSpecifying an explicit operation ID simplifies determining\nwhether the statements were executed in the event that the\nUpdateDatabaseDdl call is replayed,\nor the return value is otherwise lost: the database and\n`operation_id` fields can be combined to form the\nname of the resulting\nlongrunning.Operation: `\u003cdatabase\u003e/operations/\u003coperation_id\u003e`.\n\n`operation_id` should be unique within the database, and must be\na valid identifier: `a-z*`. Note that\nautomatically-generated operation IDs always begin with an\nunderscore. If the named operation already exists,\nUpdateDatabaseDdl returns\n`ALREADY_EXISTS`.",
          "type": "string"
        }
      },
      "description": "Enqueues the given DDL statements to be applied, in order but not\nnecessarily all at once, to the database schema at some point (or\npoints) in the future. The server checks that the statements\nare executable (syntactically valid, name tables that exist, etc.)\nbefore enqueueing them, but they may still fail upon\nlater execution (e.g., if a statement from another batch of\nstatements is applied first and it conflicts in some way, or if\nthere is some data-related problem like a `NULL` value in a column to\nwhich `NOT NULL` would be added). If a statement fails, all\nsubsequent statements in the batch are automatically cancelled.\n\nEach batch of statements is assigned a name which can be used with\nthe Operations API to monitor\nprogress. See the\noperation_id field for more\ndetails."
    },
    "TransactionOptions": {
      "properties": {
        "readWrite": {
          "description": "Transaction may write.\n\nAuthorization to begin a read-write transaction requires\n`spanner.databases.beginOrRollbackReadWriteTransaction` permission\non the `session` resource.",
          "$ref": "ReadWrite"
        },
        "partitionedDml": {
          "description": "Partitioned DML transaction.\n\nAuthorization to begin a Partitioned DML transaction requires\n`spanner.databases.beginPartitionedDmlTransaction` permission\non the `session` resource.",
          "$ref": "PartitionedDml"
        },
        "readOnly": {
          "description": "Transaction will not write.\n\nAuthorization to begin a read-only transaction requires\n`spanner.databases.beginReadOnlyTransaction` permission\non the `session` resource.",
          "$ref": "ReadOnly"
        }
      },
      "id": "TransactionOptions",
      "type": "object",
      "description": "# Transactions\n\n\nEach session can have at most one active transaction at a time. After the\nactive transaction is completed, the session can immediately be\nre-used for the next transaction. It is not necessary to create a\nnew session for each transaction.\n\n# Transaction Modes\n\nCloud Spanner supports three transaction modes:\n\n  1. Locking read-write. This type of transaction is the only way\n     to write data into Cloud Spanner. These transactions rely on\n     pessimistic locking and, if necessary, two-phase commit.\n     Locking read-write transactions may abort, requiring the\n     application to retry.\n\n  2. Snapshot read-only. This transaction type provides guaranteed\n     consistency across several reads, but does not allow\n     writes. Snapshot read-only transactions can be configured to\n     read at timestamps in the past. Snapshot read-only\n     transactions do not need to be committed.\n\n  3. Partitioned DML. This type of transaction is used to execute\n     a single Partitioned DML statement. Partitioned DML partitions\n     the key space and runs the DML statement over each partition\n     in parallel using separate, internal transactions that commit\n     independently. Partitioned DML transactions do not need to be\n     committed.\n\nFor transactions that only read, snapshot read-only transactions\nprovide simpler semantics and are almost always faster. In\nparticular, read-only transactions do not take locks, so they do\nnot conflict with read-write transactions. As a consequence of not\ntaking locks, they also do not abort, so retry loops are not needed.\n\nTransactions may only read/write data in a single database. They\nmay, however, read/write data in different tables within that\ndatabase.\n\n## Locking Read-Write Transactions\n\nLocking transactions may be used to atomically read-modify-write\ndata anywhere in a database. This type of transaction is externally\nconsistent.\n\nClients should attempt to minimize the amount of time a transaction\nis active. Faster transactions commit with higher probability\nand cause less contention. Cloud Spanner attempts to keep read locks\nactive as long as the transaction continues to do reads, and the\ntransaction has not been terminated by\nCommit or\nRollback.  Long periods of\ninactivity at the client may cause Cloud Spanner to release a\ntransaction's locks and abort it.\n\nConceptually, a read-write transaction consists of zero or more\nreads or SQL statements followed by\nCommit. At any time before\nCommit, the client can send a\nRollback request to abort the\ntransaction.\n\n### Semantics\n\nCloud Spanner can commit the transaction if all read locks it acquired\nare still valid at commit time, and it is able to acquire write\nlocks for all writes. Cloud Spanner can abort the transaction for any\nreason. If a commit attempt returns `ABORTED`, Cloud Spanner guarantees\nthat the transaction has not modified any user data in Cloud Spanner.\n\nUnless the transaction commits, Cloud Spanner makes no guarantees about\nhow long the transaction's locks were held for. It is an error to\nuse Cloud Spanner locks for any sort of mutual exclusion other than\nbetween Cloud Spanner transactions themselves.\n\n### Retrying Aborted Transactions\n\nWhen a transaction aborts, the application can choose to retry the\nwhole transaction again. To maximize the chances of successfully\ncommitting the retry, the client should execute the retry in the\nsame session as the original attempt. The original session's lock\npriority increases with each consecutive abort, meaning that each\nattempt has a slightly better chance of success than the previous.\n\nUnder some circumstances (e.g., many transactions attempting to\nmodify the same row(s)), a transaction can abort many times in a\nshort period before successfully committing. Thus, it is not a good\nidea to cap the number of retries a transaction can attempt;\ninstead, it is better to limit the total amount of wall time spent\nretrying.\n\n### Idle Transactions\n\nA transaction is considered idle if it has no outstanding reads or\nSQL queries and has not started a read or SQL query within the last 10\nseconds. Idle transactions can be aborted by Cloud Spanner so that they\ndon't hold on to locks indefinitely. In that case, the commit will\nfail with error `ABORTED`.\n\nIf this behavior is undesirable, periodically executing a simple\nSQL query in the transaction (e.g., `SELECT 1`) prevents the\ntransaction from becoming idle.\n\n## Snapshot Read-Only Transactions\n\nSnapshot read-only transactions provides a simpler method than\nlocking read-write transactions for doing several consistent\nreads. However, this type of transaction does not support writes.\n\nSnapshot transactions do not take locks. Instead, they work by\nchoosing a Cloud Spanner timestamp, then executing all reads at that\ntimestamp. Since they do not acquire locks, they do not block\nconcurrent read-write transactions.\n\nUnlike locking read-write transactions, snapshot read-only\ntransactions never abort. They can fail if the chosen read\ntimestamp is garbage collected; however, the default garbage\ncollection policy is generous enough that most applications do not\nneed to worry about this in practice.\n\nSnapshot read-only transactions do not need to call\nCommit or\nRollback (and in fact are not\npermitted to do so).\n\nTo execute a snapshot transaction, the client specifies a timestamp\nbound, which tells Cloud Spanner how to choose a read timestamp.\n\nThe types of timestamp bound are:\n\n  - Strong (the default).\n  - Bounded staleness.\n  - Exact staleness.\n\nIf the Cloud Spanner database to be read is geographically distributed,\nstale read-only transactions can execute more quickly than strong\nor read-write transaction, because they are able to execute far\nfrom the leader replica.\n\nEach type of timestamp bound is discussed in detail below.\n\n### Strong\n\nStrong reads are guaranteed to see the effects of all transactions\nthat have committed before the start of the read. Furthermore, all\nrows yielded by a single read are consistent with each other -- if\nany part of the read observes a transaction, all parts of the read\nsee the transaction.\n\nStrong reads are not repeatable: two consecutive strong read-only\ntransactions might return inconsistent results if there are\nconcurrent writes. If consistency across reads is required, the\nreads should be executed within a transaction or at an exact read\ntimestamp.\n\nSee TransactionOptions.ReadOnly.strong.\n\n### Exact Staleness\n\nThese timestamp bounds execute reads at a user-specified\ntimestamp. Reads at a timestamp are guaranteed to see a consistent\nprefix of the global transaction history: they observe\nmodifications done by all transactions with a commit timestamp \u003c=\nthe read timestamp, and observe none of the modifications done by\ntransactions with a larger commit timestamp. They will block until\nall conflicting transactions that may be assigned commit timestamps\n\u003c= the read timestamp have finished.\n\nThe timestamp can either be expressed as an absolute Cloud Spanner commit\ntimestamp or a staleness relative to the current time.\n\nThese modes do not require a \"negotiation phase\" to pick a\ntimestamp. As a result, they execute slightly faster than the\nequivalent boundedly stale concurrency modes. On the other hand,\nboundedly stale reads usually return fresher results.\n\nSee TransactionOptions.ReadOnly.read_timestamp and\nTransactionOptions.ReadOnly.exact_staleness.\n\n### Bounded Staleness\n\nBounded staleness modes allow Cloud Spanner to pick the read timestamp,\nsubject to a user-provided staleness bound. Cloud Spanner chooses the\nnewest timestamp within the staleness bound that allows execution\nof the reads at the closest available replica without blocking.\n\nAll rows yielded are consistent with each other -- if any part of\nthe read observes a transaction, all parts of the read see the\ntransaction. Boundedly stale reads are not repeatable: two stale\nreads, even if they use the same staleness bound, can execute at\ndifferent timestamps and thus return inconsistent results.\n\nBoundedly stale reads execute in two phases: the first phase\nnegotiates a timestamp among all replicas needed to serve the\nread. In the second phase, reads are executed at the negotiated\ntimestamp.\n\nAs a result of the two phase execution, bounded staleness reads are\nusually a little slower than comparable exact staleness\nreads. However, they are typically able to return fresher\nresults, and are more likely to execute at the closest replica.\n\nBecause the timestamp negotiation requires up-front knowledge of\nwhich rows will be read, it can only be used with single-use\nread-only transactions.\n\nSee TransactionOptions.ReadOnly.max_staleness and\nTransactionOptions.ReadOnly.min_read_timestamp.\n\n### Old Read Timestamps and Garbage Collection\n\nCloud Spanner continuously garbage collects deleted and overwritten data\nin the background to reclaim storage space. This process is known\nas \"version GC\". By default, version GC reclaims versions after they\nare one hour old. Because of this, Cloud Spanner cannot perform reads\nat read timestamps more than one hour in the past. This\nrestriction also applies to in-progress reads and/or SQL queries whose\ntimestamp become too old while executing. Reads and SQL queries with\ntoo-old read timestamps fail with the error `FAILED_PRECONDITION`.\n\n## Partitioned DML Transactions\n\nPartitioned DML transactions are used to execute DML statements with a\ndifferent execution strategy that provides different, and often better,\nscalability properties for large, table-wide operations than DML in a\nReadWrite transaction. Smaller scoped statements, such as an OLTP workload,\nshould prefer using ReadWrite transactions.\n\nPartitioned DML partitions the keyspace and runs the DML statement on each\npartition in separate, internal transactions. These transactions commit\nautomatically when complete, and run independently from one another.\n\nTo reduce lock contention, this execution strategy only acquires read locks\non rows that match the WHERE clause of the statement. Additionally, the\nsmaller per-partition transactions hold locks for less time.\n\nThat said, Partitioned DML is not a drop-in replacement for standard DML used\nin ReadWrite transactions.\n\n - The DML statement must be fully-partitionable. Specifically, the statement\n   must be expressible as the union of many statements which each access only\n   a single row of the table.\n\n - The statement is not applied atomically to all rows of the table. Rather,\n   the statement is applied atomically to partitions of the table, in\n   independent transactions. Secondary index rows are updated atomically\n   with the base table rows.\n\n - Partitioned DML does not guarantee exactly-once execution semantics\n   against a partition. The statement will be applied at least once to each\n   partition. It is strongly recommended that the DML statement should be\n   idempotent to avoid unexpected results. For instance, it is potentially\n   dangerous to run a statement such as\n   `UPDATE table SET column = column + 1` as it could be run multiple times\n   against some rows.\n\n - The partitions are committed automatically - there is no support for\n   Commit or Rollback. If the call returns an error, or if the client issuing\n   the ExecuteSql call dies, it is possible that some rows had the statement\n   executed on them successfully. It is also possible that statement was\n   never executed against other rows.\n\n - Partitioned DML transactions may only contain the execution of a single\n   DML statement via ExecuteSql or ExecuteStreamingSql.\n\n - If any error is encountered during the execution of the partitioned DML\n   operation (for instance, a UNIQUE INDEX violation, division by zero, or a\n   value that cannot be stored due to schema constraints), then the\n   operation is stopped at that point and an error is returned. It is\n   possible that at this point, some partitions have been committed (or even\n   committed multiple times), and other partitions have not been run at all.\n\nGiven the above, Partitioned DML is good fit for large, database-wide,\noperations that are idempotent, such as deleting old rows from a very large\ntable."
    },
    "ExecuteBatchDmlRequest": {
      "type": "object",
      "description": "The request for ExecuteBatchDml.",
      "properties": {
        "seqno": {
          "description": "Required. A per-transaction sequence number used to identify this request. This field\nmakes each request idempotent such that if the request is received multiple\ntimes, at most one will succeed.\n\nThe sequence number must be monotonically increasing within the\ntransaction. If a request arrives for the first time with an out-of-order\nsequence number, the transaction may be aborted. Replays of previously\nhandled requests will yield the same response as the first execution.",
          "type": "string",
          "format": "int64"
        },
        "transaction": {
          "description": "Required. The transaction to use. Must be a read-write transaction.\n\nTo protect against replays, single-use transactions are not supported. The\ncaller must either supply an existing transaction ID or begin a new\ntransaction.",
          "$ref": "TransactionSelector"
        },
        "statements": {
          "description": "Required. The list of statements to execute in this batch. Statements are executed\nserially, such that the effects of statement `i` are visible to statement\n`i+1`. Each statement must be a DML statement. Execution stops at the\nfirst failed statement; the remaining statements are not executed.\n\nCallers must provide at least one statement.",
          "items": {
            "$ref": "Statement"
          },
          "type": "array"
        }
      },
      "id": "ExecuteBatchDmlRequest"
    },
    "BackupInfo": {
      "id": "BackupInfo",
      "properties": {
        "sourceDatabase": {
          "description": "Name of the database the backup was created from.",
          "type": "string"
        },
        "backup": {
          "type": "string",
          "description": "Name of the backup."
        },
        "createTime": {
          "description": "The backup contains an externally consistent copy of `source_database` at\nthe timestamp specified by `create_time`.",
          "type": "string",
          "format": "google-datetime"
        }
      },
      "description": "Information about a backup.",
      "type": "object"
    },
    "ListOperationsResponse": {
      "properties": {
        "nextPageToken": {
          "type": "string",
          "description": "The standard List next-page token."
        },
        "operations": {
          "items": {
            "$ref": "Operation"
          },
          "type": "array",
          "description": "A list of operations that matches the specified filter in the request."
        }
      },
      "type": "object",
      "id": "ListOperationsResponse",
      "description": "The response message for Operations.ListOperations."
    },
    "ResultSetMetadata": {
      "type": "object",
      "id": "ResultSetMetadata",
      "properties": {
        "rowType": {
          "$ref": "StructType",
          "description": "Indicates the field names and types for the rows in the result\nset.  For example, a SQL query like `\"SELECT UserId, UserName FROM\nUsers\"` could return a `row_type` value like:\n\n    \"fields\": [\n      { \"name\": \"UserId\", \"type\": { \"code\": \"INT64\" } },\n      { \"name\": \"UserName\", \"type\": { \"code\": \"STRING\" } },\n    ]"
        },
        "transaction": {
          "$ref": "Transaction",
          "description": "If the read or SQL query began a transaction as a side-effect, the\ninformation about the new transaction is yielded here."
        }
      },
      "description": "Metadata about a ResultSet or PartialResultSet."
    },
    "ReadOnly": {
      "properties": {
        "minReadTimestamp": {
          "description": "Executes all reads at a timestamp \u003e= `min_read_timestamp`.\n\nThis is useful for requesting fresher data than some previous\nread, or data that is fresh enough to observe the effects of some\npreviously committed transaction whose timestamp is known.\n\nNote that this option can only be used in single-use transactions.\n\nA timestamp in RFC3339 UTC \\\"Zulu\\\" format, accurate to nanoseconds.\nExample: `\"2014-10-02T15:01:23.045123456Z\"`.",
          "format": "google-datetime",
          "type": "string"
        },
        "returnReadTimestamp": {
          "type": "boolean",
          "description": "If true, the Cloud Spanner-selected read timestamp is included in\nthe Transaction message that describes the transaction."
        },
        "readTimestamp": {
          "type": "string",
          "format": "google-datetime",
          "description": "Executes all reads at the given timestamp. Unlike other modes,\nreads at a specific timestamp are repeatable; the same read at\nthe same timestamp always returns the same data. If the\ntimestamp is in the future, the read will block until the\nspecified timestamp, modulo the read's deadline.\n\nUseful for large scale consistent reads such as mapreduces, or\nfor coordinating many reads against a consistent snapshot of the\ndata.\n\nA timestamp in RFC3339 UTC \\\"Zulu\\\" format, accurate to nanoseconds.\nExample: `\"2014-10-02T15:01:23.045123456Z\"`."
        },
        "exactStaleness": {
          "format": "google-duration",
          "description": "Executes all reads at a timestamp that is `exact_staleness`\nold. The timestamp is chosen soon after the read is started.\n\nGuarantees that all writes that have committed more than the\nspecified number of seconds ago are visible. Because Cloud Spanner\nchooses the exact timestamp, this mode works even if the client's\nlocal clock is substantially skewed from Cloud Spanner commit\ntimestamps.\n\nUseful for reading at nearby replicas without the distributed\ntimestamp negotiation overhead of `max_staleness`.",
          "type": "string"
        },
        "maxStaleness": {
          "format": "google-duration",
          "type": "string",
          "description": "Read data at a timestamp \u003e= `NOW - max_staleness`\nseconds. Guarantees that all writes that have committed more\nthan the specified number of seconds ago are visible. Because\nCloud Spanner chooses the exact timestamp, this mode works even if\nthe client's local clock is substantially skewed from Cloud Spanner\ncommit timestamps.\n\nUseful for reading the freshest data available at a nearby\nreplica, while bounding the possible staleness if the local\nreplica has fallen behind.\n\nNote that this option can only be used in single-use\ntransactions."
        },
        "strong": {
          "type": "boolean",
          "description": "Read at a timestamp where all previously committed transactions\nare visible."
        }
      },
      "id": "ReadOnly",
      "description": "Message type to initiate a read-only transaction.",
      "type": "object"
    },
    "ReplicaInfo": {
      "id": "ReplicaInfo",
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "TYPE_UNSPECIFIED",
            "READ_WRITE",
            "READ_ONLY",
            "WITNESS"
          ],
          "description": "The type of replica.",
          "enumDescriptions": [
            "Not specified.",
            "Read-write replicas support both reads and writes. These replicas:\n\n* Maintain a full copy of your data.\n* Serve reads.\n* Can vote whether to commit a write.\n* Participate in leadership election.\n* Are eligible to become a leader.",
            "Read-only replicas only support reads (not writes). Read-only replicas:\n\n* Maintain a full copy of your data.\n* Serve reads.\n* Do not participate in voting to commit writes.\n* Are not eligible to become a leader.",
            "Witness replicas don't support reads but do participate in voting to\ncommit writes. Witness replicas:\n\n* Do not maintain a full copy of data.\n* Do not serve reads.\n* Vote whether to commit writes.\n* Participate in leader election but are not eligible to become leader."
          ]
        },
        "defaultLeaderLocation": {
          "type": "boolean",
          "description": "If true, this location is designated as the default leader location where\nleader replicas are placed. See the [region types\ndocumentation](https://cloud.google.com/spanner/docs/instances#region_types)\nfor more details."
        },
        "location": {
          "description": "The location of the serving resources, e.g. \"us-central1\".",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ListSessionsResponse": {
      "type": "object",
      "id": "ListSessionsResponse",
      "properties": {
        "sessions": {
          "items": {
            "$ref": "Session"
          },
          "type": "array",
          "description": "The list of requested sessions."
        },
        "nextPageToken": {
          "description": "`next_page_token` can be sent in a subsequent\nListSessions call to fetch more of the matching\nsessions.",
          "type": "string"
        }
      },
      "description": "The response for ListSessions."
    },
    "TransactionSelector": {
      "properties": {
        "begin": {
          "description": "Begin a new transaction and execute this read or SQL query in\nit. The transaction ID of the new transaction is returned in\nResultSetMetadata.transaction, which is a Transaction.",
          "$ref": "TransactionOptions"
        },
        "id": {
          "type": "string",
          "format": "byte",
          "description": "Execute the read or SQL query in a previously-started transaction."
        },
        "singleUse": {
          "description": "Execute the read or SQL query in a temporary transaction.\nThis is the most efficient way to execute a transaction that\nconsists of a single SQL query.",
          "$ref": "TransactionOptions"
        }
      },
      "type": "object",
      "description": "This message is used to select the transaction in which a\nRead or\nExecuteSql call runs.\n\nSee TransactionOptions for more information about transactions.",
      "id": "TransactionSelector"
    },
    "ResultSetStats": {
      "properties": {
        "queryStats": {
          "additionalProperties": {
            "description": "Properties of the object.",
            "type": "any"
          },
          "type": "object",
          "description": "Aggregated statistics from the execution of the query. Only present when\nthe query is profiled. For example, a query could return the statistics as\nfollows:\n\n    {\n      \"rows_returned\": \"3\",\n      \"elapsed_time\": \"1.22 secs\",\n      \"cpu_time\": \"1.19 secs\"\n    }"
        },
        "rowCountLowerBound": {
          "type": "string",
          "description": "Partitioned DML does not offer exactly-once semantics, so it\nreturns a lower bound of the rows modified.",
          "format": "int64"
        },
        "queryPlan": {
          "$ref": "QueryPlan",
          "description": "QueryPlan for the query associated with this result."
        },
        "rowCountExact": {
          "description": "Standard DML returns an exact count of rows that were modified.",
          "format": "int64",
          "type": "string"
        }
      },
      "id": "ResultSetStats",
      "description": "Additional statistics about a ResultSet or PartialResultSet.",
      "type": "object"
    },
    "Expr": {
      "description": "Represents a textual expression in the Common Expression Language (CEL)\nsyntax. CEL is a C-like expression language. The syntax and semantics of CEL\nare documented at https://github.com/google/cel-spec.\n\nExample (Comparison):\n\n    title: \"Summary size limit\"\n    description: \"Determines if a summary is less than 100 chars\"\n    expression: \"document.summary.size() \u003c 100\"\n\nExample (Equality):\n\n    title: \"Requestor is owner\"\n    description: \"Determines if requestor is the document owner\"\n    expression: \"document.owner == request.auth.claims.email\"\n\nExample (Logic):\n\n    title: \"Public documents\"\n    description: \"Determine whether the document should be publicly visible\"\n    expression: \"document.type != 'private' && document.type != 'internal'\"\n\nExample (Data Manipulation):\n\n    title: \"Notification string\"\n    description: \"Create a notification string with a timestamp.\"\n    expression: \"'New message received at ' + string(document.create_time)\"\n\nThe exact variables and functions that may be referenced within an expression\nare determined by the service that evaluates it. See the service\ndocumentation for additional information.",
      "properties": {
        "description": {
          "description": "Optional. Description of the expression. This is a longer text which\ndescribes the expression, e.g. when hovered over it in a UI.",
          "type": "string"
        },
        "location": {
          "description": "Optional. String indicating the location of the expression for error\nreporting, e.g. a file name and a position in the file.",
          "type": "string"
        },
        "expression": {
          "type": "string",
          "description": "Textual representation of an expression in Common Expression Language\nsyntax."
        },
        "title": {
          "type": "string",
          "description": "Optional. Title for the expression, i.e. a short string describing\nits purpose. This can be used e.g. in UIs which allow to enter the\nexpression."
        }
      },
      "id": "Expr",
      "type": "object"
    },
    "Database": {
      "type": "object",
      "properties": {
        "state": {
          "type": "string",
          "enumDescriptions": [
            "Not specified.",
            "The database is still being created. Operations on the database may fail\nwith `FAILED_PRECONDITION` in this state.",
            "The database is fully created and ready for use.",
            "The database is fully created and ready for use, but is still\nbeing optimized for performance and cannot handle full load.\n\nIn this state, the database still references the backup\nit was restore from, preventing the backup\nfrom being deleted. When optimizations are complete, the full performance\nof the database will be restored, and the database will transition to\n`READY` state."
          ],
          "enum": [
            "STATE_UNSPECIFIED",
            "CREATING",
            "READY",
            "READY_OPTIMIZING"
          ],
          "description": "Output only. The current database state."
        },
        "restoreInfo": {
          "$ref": "RestoreInfo",
          "description": "Output only. Applicable only for restored databases. Contains information\nabout the restore source."
        },
        "name": {
          "type": "string",
          "description": "Required. The name of the database. Values are of the form\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e/databases/\u003cdatabase\u003e`,\nwhere `\u003cdatabase\u003e` is as specified in the `CREATE DATABASE`\nstatement. This name can be passed to other API methods to\nidentify the database."
        },
        "createTime": {
          "type": "string",
          "description": "Output only. If exists, the time at which the database creation started.",
          "format": "google-datetime"
        }
      },
      "id": "Database",
      "description": "A Cloud Spanner database."
    },
    "PartitionQueryRequest": {
      "description": "The request for PartitionQuery",
      "properties": {
        "transaction": {
          "description": "Read only snapshot transactions are supported, read/write and single use\ntransactions are not.",
          "$ref": "TransactionSelector"
        },
        "params": {
          "type": "object",
          "additionalProperties": {
            "type": "any",
            "description": "Properties of the object."
          },
          "description": "Parameter names and values that bind to placeholders in the SQL string.\n\nA parameter placeholder consists of the `@` character followed by the\nparameter name (for example, `@firstName`). Parameter names can contain\nletters, numbers, and underscores.\n\nParameters can appear anywhere that a literal value is expected.  The same\nparameter name can be used more than once, for example:\n\n`\"WHERE id \u003e @msg_id AND id \u003c @msg_id + 100\"`\n\nIt is an error to execute a SQL statement with unbound parameters."
        },
        "paramTypes": {
          "type": "object",
          "description": "It is not always possible for Cloud Spanner to infer the right SQL type\nfrom a JSON value.  For example, values of type `BYTES` and values\nof type `STRING` both appear in params as JSON strings.\n\nIn these cases, `param_types` can be used to specify the exact\nSQL type for some or all of the SQL query parameters. See the\ndefinition of Type for more information\nabout SQL types.",
          "additionalProperties": {
            "$ref": "Type"
          }
        },
        "sql": {
          "description": "Required. The query request to generate partitions for. The request will fail if\nthe query is not root partitionable. The query plan of a root\npartitionable query has a single distributed union operator. A distributed\nunion operator conceptually divides one or more tables into multiple\nsplits, remotely evaluates a subquery independently on each split, and\nthen unions all results.\n\nThis must not contain DML commands, such as INSERT, UPDATE, or\nDELETE. Use ExecuteStreamingSql with a\nPartitionedDml transaction for large, partition-friendly DML operations.",
          "type": "string"
        },
        "partitionOptions": {
          "$ref": "PartitionOptions",
          "description": "Additional options that affect how many partitions are created."
        }
      },
      "type": "object",
      "id": "PartitionQueryRequest"
    },
    "Write": {
      "description": "Arguments to insert, update, insert_or_update, and\nreplace operations.",
      "type": "object",
      "id": "Write",
      "properties": {
        "table": {
          "type": "string",
          "description": "Required. The table whose rows will be written."
        },
        "columns": {
          "description": "The names of the columns in table to be written.\n\nThe list of columns must contain enough columns to allow\nCloud Spanner to derive values for all primary key columns in the\nrow(s) to be modified.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "values": {
          "description": "The values to be written. `values` can contain more than one\nlist of values. If it does, then multiple rows are written, one\nfor each entry in `values`. Each list in `values` must have\nexactly as many entries as there are entries in columns\nabove. Sending multiple lists is equivalent to sending multiple\n`Mutation`s, each containing one `values` entry and repeating\ntable and columns. Individual values in each list are\nencoded as described here.",
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "type": "any"
            }
          }
        }
      }
    },
    "Partition": {
      "properties": {
        "partitionToken": {
          "type": "string",
          "description": "This token can be passed to Read, StreamingRead, ExecuteSql, or\nExecuteStreamingSql requests to restrict the results to those identified by\nthis partition token.",
          "format": "byte"
        }
      },
      "description": "Information returned for each partition returned in a\nPartitionResponse.",
      "id": "Partition",
      "type": "object"
    },
    "ListBackupsResponse": {
      "description": "The response for ListBackups.",
      "id": "ListBackupsResponse",
      "type": "object",
      "properties": {
        "nextPageToken": {
          "description": "`next_page_token` can be sent in a subsequent\nListBackups call to fetch more\nof the matching backups.",
          "type": "string"
        },
        "backups": {
          "items": {
            "$ref": "Backup"
          },
          "type": "array",
          "description": "The list of matching backups. Backups returned are ordered by `create_time`\nin descending order, starting from the most recent `create_time`."
        }
      }
    },
    "StructType": {
      "properties": {
        "fields": {
          "type": "array",
          "items": {
            "$ref": "Field"
          },
          "description": "The list of fields that make up this struct. Order is\nsignificant, because values of this struct type are represented as\nlists, where the order of field values matches the order of\nfields in the StructType. In turn, the order of fields\nmatches the order of columns in a read request, or the order of\nfields in the `SELECT` clause of a query."
        }
      },
      "type": "object",
      "description": "`StructType` defines the fields of a STRUCT type.",
      "id": "StructType"
    },
    "ReadWrite": {
      "type": "object",
      "properties": {},
      "id": "ReadWrite",
      "description": "Message type to initiate a read-write transaction. Currently this\ntransaction type has no options."
    },
    "ChildLink": {
      "type": "object",
      "id": "ChildLink",
      "description": "Metadata associated with a parent-child relationship appearing in a\nPlanNode.",
      "properties": {
        "childIndex": {
          "description": "The node to which the link points.",
          "type": "integer",
          "format": "int32"
        },
        "type": {
          "type": "string",
          "description": "The type of the link. For example, in Hash Joins this could be used to\ndistinguish between the build child and the probe child, or in the case\nof the child being an output variable, to represent the tag associated\nwith the output variable."
        },
        "variable": {
          "description": "Only present if the child node is SCALAR and corresponds\nto an output variable of the parent node. The field carries the name of\nthe output variable.\nFor example, a `TableScan` operator that reads rows from a table will\nhave child links to the `SCALAR` nodes representing the output variables\ncreated for each column that is read by the operator. The corresponding\n`variable` fields will be set to the variable names assigned to the\ncolumns.",
          "type": "string"
        }
      }
    },
    "Transaction": {
      "properties": {
        "readTimestamp": {
          "type": "string",
          "description": "For snapshot read-only transactions, the read timestamp chosen\nfor the transaction. Not returned by default: see\nTransactionOptions.ReadOnly.return_read_timestamp.\n\nA timestamp in RFC3339 UTC \\\"Zulu\\\" format, accurate to nanoseconds.\nExample: `\"2014-10-02T15:01:23.045123456Z\"`.",
          "format": "google-datetime"
        },
        "id": {
          "description": "`id` may be used to identify the transaction in subsequent\nRead,\nExecuteSql,\nCommit, or\nRollback calls.\n\nSingle-use read-only transactions do not have IDs, because\nsingle-use transactions do not support multiple requests.",
          "type": "string",
          "format": "byte"
        }
      },
      "id": "Transaction",
      "description": "A transaction.",
      "type": "object"
    },
    "QueryPlan": {
      "description": "Contains an ordered list of nodes appearing in the query plan.",
      "properties": {
        "planNodes": {
          "items": {
            "$ref": "PlanNode"
          },
          "description": "The nodes in the query plan. Plan nodes are returned in pre-order starting\nwith the plan root. Each PlanNode's `id` corresponds to its index in\n`plan_nodes`.",
          "type": "array"
        }
      },
      "id": "QueryPlan",
      "type": "object"
    },
    "QueryOptions": {
      "properties": {
        "optimizerVersion": {
          "type": "string",
          "description": "An option to control the selection of optimizer version.\n\nThis parameter allows individual queries to pick different query\noptimizer versions.\n\nSpecifying \"latest\" as a value instructs Cloud Spanner to use the\nlatest supported query optimizer version. If not specified, Cloud Spanner\nuses optimizer version set at the database level options. Any other\npositive integer (from the list of supported optimizer versions)\noverrides the default optimizer version for query execution.\nThe list of supported optimizer versions can be queried from\nSPANNER_SYS.SUPPORTED_OPTIMIZER_VERSIONS. Executing a SQL statement\nwith an invalid optimizer version will fail with a syntax error\n(`INVALID_ARGUMENT`) status.\nSee\nhttps://cloud.google.com/spanner/docs/query-optimizer/manage-query-optimizer\nfor more information on managing the query optimizer.\n\nThe `optimizer_version` statement hint has precedence over this setting."
        }
      },
      "id": "QueryOptions",
      "type": "object",
      "description": "Query optimizer configuration."
    },
    "Statement": {
      "properties": {
        "params": {
          "type": "object",
          "description": "Parameter names and values that bind to placeholders in the DML string.\n\nA parameter placeholder consists of the `@` character followed by the\nparameter name (for example, `@firstName`). Parameter names can contain\nletters, numbers, and underscores.\n\nParameters can appear anywhere that a literal value is expected.  The\nsame parameter name can be used more than once, for example:\n\n`\"WHERE id \u003e @msg_id AND id \u003c @msg_id + 100\"`\n\nIt is an error to execute a SQL statement with unbound parameters.",
          "additionalProperties": {
            "description": "Properties of the object.",
            "type": "any"
          }
        },
        "paramTypes": {
          "additionalProperties": {
            "$ref": "Type"
          },
          "type": "object",
          "description": "It is not always possible for Cloud Spanner to infer the right SQL type\nfrom a JSON value.  For example, values of type `BYTES` and values\nof type `STRING` both appear in params as JSON strings.\n\nIn these cases, `param_types` can be used to specify the exact\nSQL type for some or all of the SQL statement parameters. See the\ndefinition of Type for more information\nabout SQL types."
        },
        "sql": {
          "description": "Required. The DML string.",
          "type": "string"
        }
      },
      "type": "object",
      "description": "A single DML statement.",
      "id": "Statement"
    },
    "ReadRequest": {
      "id": "ReadRequest",
      "description": "The request for Read and\nStreamingRead.",
      "properties": {
        "keySet": {
          "description": "Required. `key_set` identifies the rows to be yielded. `key_set` names the\nprimary keys of the rows in table to be yielded, unless index\nis present. If index is present, then key_set instead names\nindex keys in index.\n\nIf the partition_token field is empty, rows are yielded\nin table primary key order (if index is empty) or index key order\n(if index is non-empty).  If the partition_token field is not\nempty, rows will be yielded in an unspecified order.\n\nIt is not an error for the `key_set` to name rows that do not\nexist in the database. Read yields nothing for nonexistent rows.",
          "$ref": "KeySet"
        },
        "columns": {
          "type": "array",
          "description": "Required. The columns of table to be returned for each row matching\nthis request.",
          "items": {
            "type": "string"
          }
        },
        "index": {
          "description": "If non-empty, the name of an index on table. This index is\nused instead of the table primary key when interpreting key_set\nand sorting result rows. See key_set for further information.",
          "type": "string"
        },
        "resumeToken": {
          "description": "If this request is resuming a previously interrupted read,\n`resume_token` should be copied from the last\nPartialResultSet yielded before the interruption. Doing this\nenables the new read to resume where the last read left off. The\nrest of the request parameters must exactly match the request\nthat yielded this token.",
          "type": "string",
          "format": "byte"
        },
        "partitionToken": {
          "type": "string",
          "description": "If present, results will be restricted to the specified partition\npreviously created using PartitionRead().    There must be an exact\nmatch for the values of fields common to this message and the\nPartitionReadRequest message used to create this partition_token.",
          "format": "byte"
        },
        "transaction": {
          "$ref": "TransactionSelector",
          "description": "The transaction to use. If none is provided, the default is a\ntemporary read-only transaction with strong concurrency."
        },
        "limit": {
          "format": "int64",
          "description": "If greater than zero, only the first `limit` rows are yielded. If `limit`\nis zero, the default is no limit. A limit cannot be specified if\n`partition_token` is set.",
          "type": "string"
        },
        "table": {
          "description": "Required. The name of the table in the database to be read.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "CommitRequest": {
      "description": "The request for Commit.",
      "type": "object",
      "id": "CommitRequest",
      "properties": {
        "singleUseTransaction": {
          "description": "Execute mutations in a temporary transaction. Note that unlike\ncommit of a previously-started transaction, commit with a\ntemporary transaction is non-idempotent. That is, if the\n`CommitRequest` is sent to Cloud Spanner more than once (for\ninstance, due to retries in the application, or in the\ntransport library), it is possible that the mutations are\nexecuted more than once. If this is undesirable, use\nBeginTransaction and\nCommit instead.",
          "$ref": "TransactionOptions"
        },
        "transactionId": {
          "type": "string",
          "description": "Commit a previously-started transaction.",
          "format": "byte"
        },
        "mutations": {
          "description": "The mutations to be executed when this transaction commits. All\nmutations are applied atomically, in the order they appear in\nthis list.",
          "items": {
            "$ref": "Mutation"
          },
          "type": "array"
        }
      }
    },
    "CreateBackupMetadata": {
      "description": "Metadata type for the operation returned by\nCreateBackup.",
      "properties": {
        "database": {
          "description": "The name of the database the backup is created from.",
          "type": "string"
        },
        "cancelTime": {
          "type": "string",
          "description": "The time at which cancellation of this operation was received.\nOperations.CancelOperation\nstarts asynchronous cancellation on a long-running operation. The server\nmakes a best effort to cancel the operation, but success is not guaranteed.\nClients can use\nOperations.GetOperation or\nother methods to check whether the cancellation succeeded or whether the\noperation completed despite cancellation. On successful cancellation,\nthe operation is not deleted; instead, it becomes an operation with\nan Operation.error value with a google.rpc.Status.code of 1,\ncorresponding to `Code.CANCELLED`.",
          "format": "google-datetime"
        },
        "name": {
          "description": "The name of the backup being created.",
          "type": "string"
        },
        "progress": {
          "$ref": "OperationProgress",
          "description": "The progress of the\nCreateBackup operation."
        }
      },
      "type": "object",
      "id": "CreateBackupMetadata"
    },
    "Status": {
      "type": "object",
      "id": "Status",
      "properties": {
        "details": {
          "description": "A list of messages that carry the error details.  There is a common set of\nmessage types for APIs to use.",
          "items": {
            "additionalProperties": {
              "description": "Properties of the object. Contains field @type with type URL.",
              "type": "any"
            },
            "type": "object"
          },
          "type": "array"
        },
        "code": {
          "description": "The status code, which should be an enum value of google.rpc.Code.",
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string",
          "description": "A developer-facing error message, which should be in English. Any\nuser-facing error message should be localized and sent in the\ngoogle.rpc.Status.details field, or localized by the client."
        }
      },
      "description": "The `Status` type defines a logical error model that is suitable for\ndifferent programming environments, including REST APIs and RPC APIs. It is\nused by [gRPC](https://github.com/grpc). Each `Status` message contains\nthree pieces of data: error code, error message, and error details.\n\nYou can find out more about this error model and how to work with it in the\n[API Design Guide](https://cloud.google.com/apis/design/errors)."
    },
    "PartitionResponse": {
      "properties": {
        "transaction": {
          "description": "Transaction created by this request.",
          "$ref": "Transaction"
        },
        "partitions": {
          "items": {
            "$ref": "Partition"
          },
          "description": "Partitions created by this request.",
          "type": "array"
        }
      },
      "id": "PartitionResponse",
      "description": "The response for PartitionQuery\nor PartitionRead",
      "type": "object"
    },
    "ListBackupOperationsResponse": {
      "properties": {
        "nextPageToken": {
          "description": "`next_page_token` can be sent in a subsequent\nListBackupOperations\ncall to fetch more of the matching metadata.",
          "type": "string"
        },
        "operations": {
          "type": "array",
          "items": {
            "$ref": "Operation"
          },
          "description": "The list of matching backup long-running\noperations. Each operation's name will be\nprefixed by the backup's name and the operation's\nmetadata will be of type\nCreateBackupMetadata. Operations returned include those that are\npending or have completed/failed/canceled within the last 7 days.\nOperations returned are ordered by\n`operation.metadata.value.progress.start_time` in descending order starting\nfrom the most recently started operation."
        }
      },
      "type": "object",
      "description": "The response for\nListBackupOperations.",
      "id": "ListBackupOperationsResponse"
    },
    "OptimizeRestoredDatabaseMetadata": {
      "id": "OptimizeRestoredDatabaseMetadata",
      "properties": {
        "progress": {
          "$ref": "OperationProgress",
          "description": "The progress of the post-restore optimizations."
        },
        "name": {
          "type": "string",
          "description": "Name of the restored database being optimized."
        }
      },
      "description": "Metadata type for the long-running operation used to track the progress\nof optimizations performed on a newly restored database. This long-running\noperation is automatically created by the system after the successful\ncompletion of a database restore, and cannot be cancelled.",
      "type": "object"
    },
    "Session": {
      "type": "object",
      "properties": {
        "name": {
          "description": "Output only. The name of the session. This is always system-assigned.",
          "type": "string"
        },
        "createTime": {
          "format": "google-datetime",
          "description": "Output only. The timestamp when the session is created.",
          "type": "string"
        },
        "labels": {
          "description": "The labels for the session.\n\n * Label keys must be between 1 and 63 characters long and must conform to\n   the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.\n * Label values must be between 0 and 63 characters long and must conform\n   to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.\n * No more than 64 labels can be associated with a given session.\n\nSee https://goo.gl/xmQnxf for more information on and examples of labels.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "approximateLastUseTime": {
          "description": "Output only. The approximate timestamp when the session is last used. It is\ntypically earlier than the actual last use time.",
          "format": "google-datetime",
          "type": "string"
        }
      },
      "description": "A session in the Cloud Spanner API.",
      "id": "Session"
    },
    "Binding": {
      "description": "Associates `members` with a `role`.",
      "type": "object",
      "properties": {
        "condition": {
          "description": "The condition that is associated with this binding.\n\nIf the condition evaluates to `true`, then this binding applies to the\ncurrent request.\n\nIf the condition evaluates to `false`, then this binding does not apply to\nthe current request. However, a different role binding might grant the same\nrole to one or more of the members in this binding.\n\nTo learn which resources support conditions in their IAM policies, see the\n[IAM\ndocumentation](https://cloud.google.com/iam/help/conditions/resource-policies).",
          "$ref": "Expr"
        },
        "members": {
          "type": "array",
          "description": "Specifies the identities requesting access for a Cloud Platform resource.\n`members` can have the following values:\n\n* `allUsers`: A special identifier that represents anyone who is\n   on the internet; with or without a Google account.\n\n* `allAuthenticatedUsers`: A special identifier that represents anyone\n   who is authenticated with a Google account or a service account.\n\n* `user:{emailid}`: An email address that represents a specific Google\n   account. For example, `alice@example.com` .\n\n\n* `serviceAccount:{emailid}`: An email address that represents a service\n   account. For example, `my-other-app@appspot.gserviceaccount.com`.\n\n* `group:{emailid}`: An email address that represents a Google group.\n   For example, `admins@example.com`.\n\n* `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique\n   identifier) representing a user that has been recently deleted. For\n   example, `alice@example.com?uid=123456789012345678901`. If the user is\n   recovered, this value reverts to `user:{emailid}` and the recovered user\n   retains the role in the binding.\n\n* `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus\n   unique identifier) representing a service account that has been recently\n   deleted. For example,\n   `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`.\n   If the service account is undeleted, this value reverts to\n   `serviceAccount:{emailid}` and the undeleted service account retains the\n   role in the binding.\n\n* `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique\n   identifier) representing a Google group that has been recently\n   deleted. For example, `admins@example.com?uid=123456789012345678901`. If\n   the group is recovered, this value reverts to `group:{emailid}` and the\n   recovered group retains the role in the binding.\n\n\n* `domain:{domain}`: The G Suite domain (primary) that represents all the\n   users of that domain. For example, `google.com` or `example.com`.\n\n",
          "items": {
            "type": "string"
          }
        },
        "role": {
          "type": "string",
          "description": "Role that is assigned to `members`.\nFor example, `roles/viewer`, `roles/editor`, or `roles/owner`."
        }
      },
      "id": "Binding"
    },
    "CommitResponse": {
      "id": "CommitResponse",
      "properties": {
        "commitTimestamp": {
          "description": "The Cloud Spanner timestamp at which the transaction committed.",
          "type": "string",
          "format": "google-datetime"
        }
      },
      "description": "The response for Commit.",
      "type": "object"
    },
    "KeyRange": {
      "id": "KeyRange",
      "type": "object",
      "description": "KeyRange represents a range of rows in a table or index.\n\nA range has a start key and an end key. These keys can be open or\nclosed, indicating if the range includes rows with that key.\n\nKeys are represented by lists, where the ith value in the list\ncorresponds to the ith component of the table or index primary key.\nIndividual values are encoded as described\nhere.\n\nFor example, consider the following table definition:\n\n    CREATE TABLE UserEvents (\n      UserName STRING(MAX),\n      EventDate STRING(10)\n    ) PRIMARY KEY(UserName, EventDate);\n\nThe following keys name rows in this table:\n\n    \"Bob\", \"2014-09-23\"\n\nSince the `UserEvents` table's `PRIMARY KEY` clause names two\ncolumns, each `UserEvents` key has two elements; the first is the\n`UserName`, and the second is the `EventDate`.\n\nKey ranges with multiple components are interpreted\nlexicographically by component using the table or index key's declared\nsort order. For example, the following range returns all events for\nuser `\"Bob\"` that occurred in the year 2015:\n\n    \"start_closed\": [\"Bob\", \"2015-01-01\"]\n    \"end_closed\": [\"Bob\", \"2015-12-31\"]\n\nStart and end keys can omit trailing key components. This affects the\ninclusion and exclusion of rows that exactly match the provided key\ncomponents: if the key is closed, then rows that exactly match the\nprovided components are included; if the key is open, then rows\nthat exactly match are not included.\n\nFor example, the following range includes all events for `\"Bob\"` that\noccurred during and after the year 2000:\n\n    \"start_closed\": [\"Bob\", \"2000-01-01\"]\n    \"end_closed\": [\"Bob\"]\n\nThe next example retrieves all events for `\"Bob\"`:\n\n    \"start_closed\": [\"Bob\"]\n    \"end_closed\": [\"Bob\"]\n\nTo retrieve events before the year 2000:\n\n    \"start_closed\": [\"Bob\"]\n    \"end_open\": [\"Bob\", \"2000-01-01\"]\n\nThe following range includes all rows in the table:\n\n    \"start_closed\": []\n    \"end_closed\": []\n\nThis range returns all users whose `UserName` begins with any\ncharacter from A to C:\n\n    \"start_closed\": [\"A\"]\n    \"end_open\": [\"D\"]\n\nThis range returns all users whose `UserName` begins with B:\n\n    \"start_closed\": [\"B\"]\n    \"end_open\": [\"C\"]\n\nKey ranges honor column sort order. For example, suppose a table is\ndefined as follows:\n\n    CREATE TABLE DescendingSortedTable {\n      Key INT64,\n      ...\n    ) PRIMARY KEY(Key DESC);\n\nThe following range retrieves all rows with key values between 1\nand 100 inclusive:\n\n    \"start_closed\": [\"100\"]\n    \"end_closed\": [\"1\"]\n\nNote that 100 is passed as the start, and 1 is passed as the end,\nbecause `Key` is a descending column in the schema.",
      "properties": {
        "endOpen": {
          "type": "array",
          "items": {
            "type": "any"
          },
          "description": "If the end is open, then the range excludes rows whose first\n`len(end_open)` key columns exactly match `end_open`."
        },
        "endClosed": {
          "items": {
            "type": "any"
          },
          "description": "If the end is closed, then the range includes all rows whose\nfirst `len(end_closed)` key columns exactly match `end_closed`.",
          "type": "array"
        },
        "startClosed": {
          "description": "If the start is closed, then the range includes all rows whose\nfirst `len(start_closed)` key columns exactly match `start_closed`.",
          "items": {
            "type": "any"
          },
          "type": "array"
        },
        "startOpen": {
          "description": "If the start is open, then the range excludes rows whose first\n`len(start_open)` key columns exactly match `start_open`.",
          "items": {
            "type": "any"
          },
          "type": "array"
        }
      }
    },
    "PartialResultSet": {
      "description": "Partial results from a streaming read or SQL query. Streaming reads and\nSQL queries better tolerate large result sets, large rows, and large\nvalues, but are a little trickier to consume.",
      "properties": {
        "resumeToken": {
          "description": "Streaming calls might be interrupted for a variety of reasons, such\nas TCP connection loss. If this occurs, the stream of results can\nbe resumed by re-sending the original request and including\n`resume_token`. Note that executing any other transaction in the\nsame session invalidates the token.",
          "format": "byte",
          "type": "string"
        },
        "stats": {
          "$ref": "ResultSetStats",
          "description": "Query plan and execution statistics for the statement that produced this\nstreaming result set. These can be requested by setting\nExecuteSqlRequest.query_mode and are sent\nonly once with the last response in the stream.\nThis field will also be present in the last response for DML\nstatements."
        },
        "metadata": {
          "$ref": "ResultSetMetadata",
          "description": "Metadata about the result set, such as row type information.\nOnly present in the first response."
        },
        "values": {
          "description": "A streamed result set consists of a stream of values, which might\nbe split into many `PartialResultSet` messages to accommodate\nlarge rows and/or large values. Every N complete values defines a\nrow, where N is equal to the number of entries in\nmetadata.row_type.fields.\n\nMost values are encoded based on type as described\nhere.\n\nIt is possible that the last value in values is \"chunked\",\nmeaning that the rest of the value is sent in subsequent\n`PartialResultSet`(s). This is denoted by the chunked_value\nfield. Two or more chunked values can be merged to form a\ncomplete value as follows:\n\n  * `bool/number/null`: cannot be chunked\n  * `string`: concatenate the strings\n  * `list`: concatenate the lists. If the last element in a list is a\n    `string`, `list`, or `object`, merge it with the first element in\n    the next list by applying these rules recursively.\n  * `object`: concatenate the (field name, field value) pairs. If a\n    field name is duplicated, then apply these rules recursively\n    to merge the field values.\n\nSome examples of merging:\n\n    # Strings are concatenated.\n    \"foo\", \"bar\" =\u003e \"foobar\"\n\n    # Lists of non-strings are concatenated.\n    [2, 3], [4] =\u003e [2, 3, 4]\n\n    # Lists are concatenated, but the last and first elements are merged\n    # because they are strings.\n    [\"a\", \"b\"], [\"c\", \"d\"] =\u003e [\"a\", \"bc\", \"d\"]\n\n    # Lists are concatenated, but the last and first elements are merged\n    # because they are lists. Recursively, the last and first elements\n    # of the inner lists are merged because they are strings.\n    [\"a\", [\"b\", \"c\"]], [[\"d\"], \"e\"] =\u003e [\"a\", [\"b\", \"cd\"], \"e\"]\n\n    # Non-overlapping object fields are combined.\n    {\"a\": \"1\"}, {\"b\": \"2\"} =\u003e {\"a\": \"1\", \"b\": 2\"}\n\n    # Overlapping object fields are merged.\n    {\"a\": \"1\"}, {\"a\": \"2\"} =\u003e {\"a\": \"12\"}\n\n    # Examples of merging objects containing lists of strings.\n    {\"a\": [\"1\"]}, {\"a\": [\"2\"]} =\u003e {\"a\": [\"12\"]}\n\nFor a more complete example, suppose a streaming SQL query is\nyielding a result set whose rows contain a single string\nfield. The following `PartialResultSet`s might be yielded:\n\n    {\n      \"metadata\": { ... }\n      \"values\": [\"Hello\", \"W\"]\n      \"chunked_value\": true\n      \"resume_token\": \"Af65...\"\n    }\n    {\n      \"values\": [\"orl\"]\n      \"chunked_value\": true\n      \"resume_token\": \"Bqp2...\"\n    }\n    {\n      \"values\": [\"d\"]\n      \"resume_token\": \"Zx1B...\"\n    }\n\nThis sequence of `PartialResultSet`s encodes two rows, one\ncontaining the field value `\"Hello\"`, and a second containing the\nfield value `\"World\" = \"W\" + \"orl\" + \"d\"`.",
          "items": {
            "type": "any"
          },
          "type": "array"
        },
        "chunkedValue": {
          "description": "If true, then the final value in values is chunked, and must\nbe combined with more values from subsequent `PartialResultSet`s\nto obtain a complete field value.",
          "type": "boolean"
        }
      },
      "id": "PartialResultSet",
      "type": "object"
    },
    "RollbackRequest": {
      "properties": {
        "transactionId": {
          "type": "string",
          "format": "byte",
          "description": "Required. The transaction to roll back."
        }
      },
      "type": "object",
      "id": "RollbackRequest",
      "description": "The request for Rollback."
    },
    "Field": {
      "id": "Field",
      "type": "object",
      "properties": {
        "name": {
          "description": "The name of the field. For reads, this is the column name. For\nSQL queries, it is the column alias (e.g., `\"Word\"` in the\nquery `\"SELECT 'hello' AS Word\"`), or the column name (e.g.,\n`\"ColName\"` in the query `\"SELECT ColName FROM Table\"`). Some\ncolumns might have an empty name (e.g., !\"SELECT\nUPPER(ColName)\"`). Note that a query result can contain\nmultiple fields with the same name.",
          "type": "string"
        },
        "type": {
          "description": "The type of the field.",
          "$ref": "Type"
        }
      },
      "description": "Message representing a single field of a struct."
    },
    "CreateDatabaseRequest": {
      "description": "The request for CreateDatabase.",
      "type": "object",
      "properties": {
        "extraStatements": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Optional. A list of DDL statements to run inside the newly created\ndatabase. Statements can create tables, indexes, etc. These\nstatements execute atomically with the creation of the database:\nif there is an error in any statement, the database is not created."
        },
        "createStatement": {
          "description": "Required. A `CREATE DATABASE` statement, which specifies the ID of the\nnew database.  The database ID must conform to the regular expression\n`a-z*[a-z0-9]` and be between 2 and 30 characters in length.\nIf the database ID is a reserved word or if it contains a hyphen, the\ndatabase ID must be enclosed in backticks (`` ` ``).",
          "type": "string"
        }
      },
      "id": "CreateDatabaseRequest"
    },
    "UpdateInstanceRequest": {
      "type": "object",
      "description": "The request for UpdateInstance.",
      "id": "UpdateInstanceRequest",
      "properties": {
        "fieldMask": {
          "format": "google-fieldmask",
          "type": "string",
          "description": "Required. A mask specifying which fields in Instance should be updated.\nThe field mask must always be specified; this prevents any future fields in\nInstance from being erased accidentally by clients that do not know\nabout them."
        },
        "instance": {
          "description": "Required. The instance to update, which must always include the instance\nname.  Otherwise, only fields mentioned in field_mask need be included.",
          "$ref": "Instance"
        }
      }
    },
    "GetPolicyOptions": {
      "id": "GetPolicyOptions",
      "properties": {
        "requestedPolicyVersion": {
          "description": "Optional. The policy format version to be returned.\n\nValid values are 0, 1, and 3. Requests specifying an invalid value will be\nrejected.\n\nRequests for policies with any conditional bindings must specify version 3.\nPolicies without any conditional bindings may specify any valid value or\nleave the field unset.\n\nTo learn which resources support conditions in their IAM policies, see the\n[IAM\ndocumentation](https://cloud.google.com/iam/help/conditions/resource-policies).",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object",
      "description": "Encapsulates settings provided to GetIamPolicy."
    },
    "GetDatabaseDdlResponse": {
      "description": "The response for GetDatabaseDdl.",
      "type": "object",
      "properties": {
        "statements": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "A list of formatted DDL statements defining the schema of the database\nspecified in the request."
        }
      },
      "id": "GetDatabaseDdlResponse"
    },
    "Operation": {
      "id": "Operation",
      "description": "This resource represents a long-running operation that is the result of a\nnetwork API call.",
      "properties": {
        "response": {
          "description": "The normal response of the operation in case of success.  If the original\nmethod returns no data on success, such as `Delete`, the response is\n`google.protobuf.Empty`.  If the original method is standard\n`Get`/`Create`/`Update`, the response should be the resource.  For other\nmethods, the response should have the type `XxxResponse`, where `Xxx`\nis the original method name.  For example, if the original method name\nis `TakeSnapshot()`, the inferred response type is\n`TakeSnapshotResponse`.",
          "additionalProperties": {
            "type": "any",
            "description": "Properties of the object. Contains field @type with type URL."
          },
          "type": "object"
        },
        "metadata": {
          "additionalProperties": {
            "type": "any",
            "description": "Properties of the object. Contains field @type with type URL."
          },
          "description": "Service-specific metadata associated with the operation.  It typically\ncontains progress information and common metadata such as create time.\nSome services might not provide such metadata.  Any method that returns a\nlong-running operation should document the metadata type, if any.",
          "type": "object"
        },
        "done": {
          "type": "boolean",
          "description": "If the value is `false`, it means the operation is still in progress.\nIf `true`, the operation is completed, and either `error` or `response` is\navailable."
        },
        "error": {
          "$ref": "Status",
          "description": "The error result of the operation in case of failure or cancellation."
        },
        "name": {
          "type": "string",
          "description": "The server-assigned name, which is only unique within the same service that\noriginally returns it. If you use the default HTTP mapping, the\n`name` should be a resource name ending with `operations/{unique_id}`."
        }
      },
      "type": "object"
    },
    "BatchCreateSessionsRequest": {
      "type": "object",
      "properties": {
        "sessionTemplate": {
          "$ref": "Session",
          "description": "Parameters to be applied to each created session."
        },
        "sessionCount": {
          "type": "integer",
          "description": "Required. The number of sessions to be created in this batch call.\nThe API may return fewer than the requested number of sessions. If a\nspecific number of sessions are desired, the client can make additional\ncalls to BatchCreateSessions (adjusting\nsession_count as necessary).",
          "format": "int32"
        }
      },
      "description": "The request for BatchCreateSessions.",
      "id": "BatchCreateSessionsRequest"
    },
    "Policy": {
      "type": "object",
      "properties": {
        "version": {
          "format": "int32",
          "type": "integer",
          "description": "Specifies the format of the policy.\n\nValid values are `0`, `1`, and `3`. Requests that specify an invalid value\nare rejected.\n\nAny operation that affects conditional role bindings must specify version\n`3`. This requirement applies to the following operations:\n\n* Getting a policy that includes a conditional role binding\n* Adding a conditional role binding to a policy\n* Changing a conditional role binding in a policy\n* Removing any role binding, with or without a condition, from a policy\n  that includes conditions\n\n**Important:** If you use IAM Conditions, you must include the `etag` field\nwhenever you call `setIamPolicy`. If you omit this field, then IAM allows\nyou to overwrite a version `3` policy with a version `1` policy, and all of\nthe conditions in the version `3` policy are lost.\n\nIf a policy does not include any conditions, operations on that policy may\nspecify any valid version or leave the field unset.\n\nTo learn which resources support conditions in their IAM policies, see the\n[IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies)."
        },
        "etag": {
          "type": "string",
          "format": "byte",
          "description": "`etag` is used for optimistic concurrency control as a way to help\nprevent simultaneous updates of a policy from overwriting each other.\nIt is strongly suggested that systems make use of the `etag` in the\nread-modify-write cycle to perform policy updates in order to avoid race\nconditions: An `etag` is returned in the response to `getIamPolicy`, and\nsystems are expected to put that etag in the request to `setIamPolicy` to\nensure that their change will be applied to the same version of the policy.\n\n**Important:** If you use IAM Conditions, you must include the `etag` field\nwhenever you call `setIamPolicy`. If you omit this field, then IAM allows\nyou to overwrite a version `3` policy with a version `1` policy, and all of\nthe conditions in the version `3` policy are lost."
        },
        "bindings": {
          "description": "Associates a list of `members` to a `role`. Optionally, may specify a\n`condition` that determines how and when the `bindings` are applied. Each\nof the `bindings` must contain at least one member.",
          "items": {
            "$ref": "Binding"
          },
          "type": "array"
        }
      },
      "description": "An Identity and Access Management (IAM) policy, which specifies access\ncontrols for Google Cloud resources.\n\n\nA `Policy` is a collection of `bindings`. A `binding` binds one or more\n`members` to a single `role`. Members can be user accounts, service accounts,\nGoogle groups, and domains (such as G Suite). A `role` is a named list of\npermissions; each `role` can be an IAM predefined role or a user-created\ncustom role.\n\nFor some types of Google Cloud resources, a `binding` can also specify a\n`condition`, which is a logical expression that allows access to a resource\nonly if the expression evaluates to `true`. A condition can add constraints\nbased on attributes of the request, the resource, or both. To learn which\nresources support conditions in their IAM policies, see the\n[IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).\n\n**JSON example:**\n\n    {\n      \"bindings\": [\n        {\n          \"role\": \"roles/resourcemanager.organizationAdmin\",\n          \"members\": [\n            \"user:mike@example.com\",\n            \"group:admins@example.com\",\n            \"domain:google.com\",\n            \"serviceAccount:my-project-id@appspot.gserviceaccount.com\"\n          ]\n        },\n        {\n          \"role\": \"roles/resourcemanager.organizationViewer\",\n          \"members\": [\n            \"user:eve@example.com\"\n          ],\n          \"condition\": {\n            \"title\": \"expirable access\",\n            \"description\": \"Does not grant access after Sep 2020\",\n            \"expression\": \"request.time \u003c timestamp('2020-10-01T00:00:00.000Z')\",\n          }\n        }\n      ],\n      \"etag\": \"BwWWja0YfJA=\",\n      \"version\": 3\n    }\n\n**YAML example:**\n\n    bindings:\n    - members:\n      - user:mike@example.com\n      - group:admins@example.com\n      - domain:google.com\n      - serviceAccount:my-project-id@appspot.gserviceaccount.com\n      role: roles/resourcemanager.organizationAdmin\n    - members:\n      - user:eve@example.com\n      role: roles/resourcemanager.organizationViewer\n      condition:\n        title: expirable access\n        description: Does not grant access after Sep 2020\n        expression: request.time \u003c timestamp('2020-10-01T00:00:00.000Z')\n    - etag: BwWWja0YfJA=\n    - version: 3\n\nFor a description of IAM and its features, see the\n[IAM documentation](https://cloud.google.com/iam/docs/).",
      "id": "Policy"
    },
    "RestoreInfo": {
      "properties": {
        "backupInfo": {
          "description": "Information about the backup used to restore the database. The backup\nmay no longer exist.",
          "$ref": "BackupInfo"
        },
        "sourceType": {
          "enumDescriptions": [
            "No restore associated.",
            "A backup was used as the source of the restore."
          ],
          "description": "The type of the restore source.",
          "type": "string",
          "enum": [
            "TYPE_UNSPECIFIED",
            "BACKUP"
          ]
        }
      },
      "description": "Information about the database restore.",
      "type": "object",
      "id": "RestoreInfo"
    },
    "PartitionedDml": {
      "properties": {},
      "type": "object",
      "description": "Message type to initiate a Partitioned DML transaction.",
      "id": "PartitionedDml"
    },
    "ExecuteSqlRequest": {
      "type": "object",
      "description": "The request for ExecuteSql and\nExecuteStreamingSql.",
      "id": "ExecuteSqlRequest",
      "properties": {
        "transaction": {
          "$ref": "TransactionSelector",
          "description": "The transaction to use.\n\nFor queries, if none is provided, the default is a temporary read-only\ntransaction with strong concurrency.\n\nStandard DML statements require a read-write transaction. To protect\nagainst replays, single-use transactions are not supported.  The caller\nmust either supply an existing transaction ID or begin a new transaction.\n\nPartitioned DML requires an existing Partitioned DML transaction ID."
        },
        "params": {
          "additionalProperties": {
            "description": "Properties of the object.",
            "type": "any"
          },
          "description": "Parameter names and values that bind to placeholders in the SQL string.\n\nA parameter placeholder consists of the `@` character followed by the\nparameter name (for example, `@firstName`). Parameter names can contain\nletters, numbers, and underscores.\n\nParameters can appear anywhere that a literal value is expected.  The same\nparameter name can be used more than once, for example:\n\n`\"WHERE id \u003e @msg_id AND id \u003c @msg_id + 100\"`\n\nIt is an error to execute a SQL statement with unbound parameters.",
          "type": "object"
        },
        "paramTypes": {
          "type": "object",
          "description": "It is not always possible for Cloud Spanner to infer the right SQL type\nfrom a JSON value.  For example, values of type `BYTES` and values\nof type `STRING` both appear in params as JSON strings.\n\nIn these cases, `param_types` can be used to specify the exact\nSQL type for some or all of the SQL statement parameters. See the\ndefinition of Type for more information\nabout SQL types.",
          "additionalProperties": {
            "$ref": "Type"
          }
        },
        "resumeToken": {
          "format": "byte",
          "type": "string",
          "description": "If this request is resuming a previously interrupted SQL statement\nexecution, `resume_token` should be copied from the last\nPartialResultSet yielded before the interruption. Doing this\nenables the new SQL statement execution to resume where the last one left\noff. The rest of the request parameters must exactly match the\nrequest that yielded this token."
        },
        "seqno": {
          "type": "string",
          "format": "int64",
          "description": "A per-transaction sequence number used to identify this request. This field\nmakes each request idempotent such that if the request is received multiple\ntimes, at most one will succeed.\n\nThe sequence number must be monotonically increasing within the\ntransaction. If a request arrives for the first time with an out-of-order\nsequence number, the transaction may be aborted. Replays of previously\nhandled requests will yield the same response as the first execution.\n\nRequired for DML statements. Ignored for queries."
        },
        "queryMode": {
          "enum": [
            "NORMAL",
            "PLAN",
            "PROFILE"
          ],
          "description": "Used to control the amount of debugging information returned in\nResultSetStats. If partition_token is set, query_mode can only\nbe set to QueryMode.NORMAL.",
          "enumDescriptions": [
            "The default mode. Only the statement results are returned.",
            "This mode returns only the query plan, without any results or\nexecution statistics information.",
            "This mode returns both the query plan and the execution statistics along\nwith the results."
          ],
          "type": "string"
        },
        "sql": {
          "description": "Required. The SQL string.",
          "type": "string"
        },
        "partitionToken": {
          "type": "string",
          "description": "If present, results will be restricted to the specified partition\npreviously created using PartitionQuery().  There must be an exact\nmatch for the values of fields common to this message and the\nPartitionQueryRequest message used to create this partition_token.",
          "format": "byte"
        },
        "queryOptions": {
          "description": "Query optimizer configuration to use for the given query.",
          "$ref": "QueryOptions"
        }
      }
    },
    "Backup": {
      "description": "A backup of a Cloud Spanner database.",
      "type": "object",
      "properties": {
        "referencingDatabases": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Output only. The names of the restored databases that reference the backup.\nThe database names are of\nthe form `projects/\u003cproject\u003e/instances/\u003cinstance\u003e/databases/\u003cdatabase\u003e`.\nReferencing databases may exist in different instances. The existence of\nany referencing database prevents the backup from being deleted. When a\nrestored database from the backup enters the `READY` state, the reference\nto the backup is removed."
        },
        "sizeBytes": {
          "format": "int64",
          "type": "string",
          "description": "Output only. Size of the backup in bytes."
        },
        "database": {
          "type": "string",
          "description": "Required for the CreateBackup operation.\nName of the database from which this backup was\ncreated. This needs to be in the same instance as the backup.\nValues are of the form\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e/databases/\u003cdatabase\u003e`."
        },
        "expireTime": {
          "type": "string",
          "description": "Required for the CreateBackup\noperation. The expiration time of the backup, with microseconds\ngranularity that must be at least 6 hours and at most 366 days\nfrom the time the CreateBackup request is processed. Once the `expire_time`\nhas passed, the backup is eligible to be automatically deleted by Cloud\nSpanner to free the resources used by the backup.",
          "format": "google-datetime"
        },
        "state": {
          "enum": [
            "STATE_UNSPECIFIED",
            "CREATING",
            "READY"
          ],
          "type": "string",
          "enumDescriptions": [
            "Not specified.",
            "The pending backup is still being created. Operations on the\nbackup may fail with `FAILED_PRECONDITION` in this state.",
            "The backup is complete and ready for use."
          ],
          "description": "Output only. The current state of the backup."
        },
        "createTime": {
          "type": "string",
          "format": "google-datetime",
          "description": "Output only. The backup will contain an externally consistent\ncopy of the database at the timestamp specified by\n`create_time`. `create_time` is approximately the time the\nCreateBackup request is received."
        },
        "name": {
          "description": "Output only for the CreateBackup operation.\nRequired for the UpdateBackup operation.\n\nA globally unique identifier for the backup which cannot be\nchanged. Values are of the form\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e/backups/a-z*[a-z0-9]`\nThe final segment of the name must be between 2 and 60 characters\nin length.\n\nThe backup is stored in the location(s) specified in the instance\nconfiguration of the instance containing the backup, identified\nby the prefix of the backup name of the form\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e`.",
          "type": "string"
        }
      },
      "id": "Backup"
    },
    "KeySet": {
      "id": "KeySet",
      "type": "object",
      "properties": {
        "keys": {
          "description": "A list of specific keys. Entries in `keys` should have exactly as\nmany elements as there are columns in the primary or index key\nwith which this `KeySet` is used.  Individual key values are\nencoded as described here.",
          "items": {
            "items": {
              "type": "any"
            },
            "type": "array"
          },
          "type": "array"
        },
        "ranges": {
          "items": {
            "$ref": "KeyRange"
          },
          "type": "array",
          "description": "A list of key ranges. See KeyRange for more information about\nkey range specifications."
        },
        "all": {
          "description": "For convenience `all` can be set to `true` to indicate that this\n`KeySet` matches all keys in the table or index. Note that any keys\nspecified in `keys` or `ranges` are only yielded once.",
          "type": "boolean"
        }
      },
      "description": "`KeySet` defines a collection of Cloud Spanner keys and/or key ranges. All\nthe keys are expected to be in the same table or index. The keys need\nnot be sorted in any particular way.\n\nIf the same key is specified multiple times in the set (for example\nif two ranges, two keys, or a key and a range overlap), Cloud Spanner\nbehaves as if the key were only specified once."
    },
    "TestIamPermissionsResponse": {
      "type": "object",
      "id": "TestIamPermissionsResponse",
      "properties": {
        "permissions": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "A subset of `TestPermissionsRequest.permissions` that the caller is\nallowed."
        }
      },
      "description": "Response message for `TestIamPermissions` method."
    },
    "PartitionOptions": {
      "id": "PartitionOptions",
      "properties": {
        "partitionSizeBytes": {
          "description": "**Note:** This hint is currently ignored by PartitionQuery and\nPartitionRead requests.\n\nThe desired data size for each partition generated.  The default for this\noption is currently 1 GiB.  This is only a hint. The actual size of each\npartition may be smaller or larger than this size request.",
          "format": "int64",
          "type": "string"
        },
        "maxPartitions": {
          "description": "**Note:** This hint is currently ignored by PartitionQuery and\nPartitionRead requests.\n\nThe desired maximum number of partitions to return.  For example, this may\nbe set to the number of workers available.  The default for this option\nis currently 10,000. The maximum value is currently 200,000.  This is only\na hint.  The actual number of partitions returned may be smaller or larger\nthan this maximum count request.",
          "format": "int64",
          "type": "string"
        }
      },
      "description": "Options for a PartitionQueryRequest and\nPartitionReadRequest.",
      "type": "object"
    },
    "RestoreDatabaseMetadata": {
      "type": "object",
      "id": "RestoreDatabaseMetadata",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the database being created and restored to."
        },
        "backupInfo": {
          "$ref": "BackupInfo",
          "description": "Information about the backup used to restore the database."
        },
        "cancelTime": {
          "format": "google-datetime",
          "description": "The time at which cancellation of this operation was received.\nOperations.CancelOperation\nstarts asynchronous cancellation on a long-running operation. The server\nmakes a best effort to cancel the operation, but success is not guaranteed.\nClients can use\nOperations.GetOperation or\nother methods to check whether the cancellation succeeded or whether the\noperation completed despite cancellation. On successful cancellation,\nthe operation is not deleted; instead, it becomes an operation with\nan Operation.error value with a\ngoogle.rpc.Status.code of 1, corresponding to `Code.CANCELLED`.",
          "type": "string"
        },
        "progress": {
          "description": "The progress of the\nRestoreDatabase\noperation.",
          "$ref": "OperationProgress"
        },
        "optimizeDatabaseOperationName": {
          "description": "If exists, the name of the long-running operation that will be used to\ntrack the post-restore optimization process to optimize the performance of\nthe restored database, and remove the dependency on the restore source.\nThe name is of the form\n`projects/\u003cproject\u003e/instances/\u003cinstance\u003e/databases/\u003cdatabase\u003e/operations/\u003coperation\u003e`\nwhere the \u003cdatabase\u003e is the name of database being created and restored to.\nThe metadata type of the  long-running operation is\nOptimizeRestoredDatabaseMetadata. This long-running operation will be\nautomatically created by the system after the RestoreDatabase long-running\noperation completes successfully. This operation will not be created if the\nrestore was not successful.",
          "type": "string"
        },
        "sourceType": {
          "type": "string",
          "enumDescriptions": [
            "No restore associated.",
            "A backup was used as the source of the restore."
          ],
          "description": "The type of the restore source.",
          "enum": [
            "TYPE_UNSPECIFIED",
            "BACKUP"
          ]
        }
      },
      "description": "Metadata type for the long-running operation returned by\nRestoreDatabase."
    }
  },
  "servicePath": "",
  "name": "spanner",
  "batchPath": "batch",
  "documentationLink": "https://cloud.google.com/spanner/",
  "auth": {
    "oauth2": {
      "scopes": {
        "https://www.googleapis.com/auth/spanner.data": {
          "description": "View and manage the contents of your Spanner databases"
        },
        "https://www.googleapis.com/auth/cloud-platform": {
          "description": "View and manage your data across Google Cloud Platform services"
        },
        "https://www.googleapis.com/auth/spanner.admin": {
          "description": "Administer your Spanner databases"
        }
      }
    }
  }
}
