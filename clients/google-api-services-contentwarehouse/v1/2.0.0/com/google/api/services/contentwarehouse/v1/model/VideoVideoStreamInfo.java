/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.contentwarehouse.v1.model;

/**
 * Note that when a VSI is from a user video, the information reflects the info in that source.
 * Fields like lengths, fps, etc. are not guaranteed to be the same as those of transcodes. If the
 * relevant info in source is too broken, the corresponding fields (e.g., lengths) could be unset or
 * with the default value, meaning VSI cannot compute them from the given info. Next id: 82
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the Document AI Warehouse API. For a detailed explanation
 * see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class VideoVideoStreamInfo extends com.google.api.client.json.GenericJson {

  /**
   * audio bitrate in bits/s
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Double audioBitrate;

  /**
   * audio channels
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer audioChannels;

  /**
   * Primary audio codec information Fields 15-20, 41-42, 48, 52-53 for audio will be obsolete soon.
   * Please start using the new repeated audio_stream and video_stream. For now, audio_stream(0)
   * will match these fields. Primary audio codec information starts:
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String audioCodecId;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long audioEndTimestamp;

  /**
   * audio frame size
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long audioFrameSize;

  /**
   * audio length in seconds Note that when the VSI is from users videos, it is not guaranteed to be
   * the same as transcode lengths and it could be 0 when the full VSI cannot compute the length
   * from the source header and timestamps (for example when header and timestamps are too broken).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Double audioLength;

  /**
   * Number of audio frames. Ffmpeg does not report the number of frames accurately.
   * video::TranscodedVideoFileInformation calls Google's analyzer to get information of both audio
   * and video frame numbers.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long audioNumberOfFrames;

  /**
   * audio sample rate
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long audioSampleRate;

  /**
   * Number of meaningful bits per decoded audio sample. This is an implicit conceptual meaning.
   * This is *NOT* the same as ffmpeg's internal sample format that is used when actually decoding
   * with ffmpeg.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer audioSampleSize;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long audioStartTimestamp;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<VideoVideoStreamInfoAudioStream> audioStream;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long audioStreamCodecTag;

  /**
   * Audio-Video interleaving distance between packets (in bytes)
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer avDistance;

  /**
   * Audio and video length in seconds. It's the max of the audio and video length. Note that when
   * the VSI is from users videos, it is not guaranteed to be the same as transcode lengths and it
   * could be 0 when the full VSI cannot compute the length from the source header and timestamps
   * (for example when header and timestamps are too broken).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Double avLength;

  /**
   * Average video fps from analyzing entire file.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Double averageVideoFps;

  /**
   * Build label of the VSI mpm.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String buildLabel;

  /**
   * Container Id.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String containerId;

  /**
   * Name of the container format guessed by ffmpeg.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String containerType;

  /**
   * If the video contains chapters info.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean containsChapters;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<VideoVideoStreamInfoDataStream> dataStream;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer displayHeight;

  /**
   * final display video width and height if explicitly set in the video otherwise this can be
   * calculated from source width/height and video_pixel_aspect_ratio
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer displayWidth;

  /**
   * Input file header fingerprint
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.math.BigInteger fileHeaderFingerprint;

  /**
   * The file type string returned by libmagic, a third party library. It might accidentally include
   * some user content. Some normal file_magic examples: -- RIFF (little-endian) data, AVI, 1016 x
   * 696, 30.00 fps, video: XviD, audio: (stereo, 48000 Hz) -- MPEG sequence, v2, program multiplex
   * -- ISO Media, MPEG v4 system, iTunes AVC-LC -- Microsoft Windows Movie Maker project file
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String fileMagic;

  /**
   * Input file modification time
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long fileModifiedTime;

  /**
   * Input file name. DEPRECATED; don't expect the file name to be correct.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String fileName;

  /**
   * Input file size in bytes
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long fileSize;

  /**
   * High-level file type guessed by looking at the file headers and libmagic.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer fileType;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<VideoVideoStreamInfoVideoStream> imageStream;

  /**
   * True if the video is likely to be an ASF file.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean isAsf;

  /**
   * True if the video is actually an image file (JPEG, PNG, GIF, etc) and not a video file.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean isImageFile;

  /**
   * Check if a video size insane or not. It is set if the input file is an MOV file.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean isVideoInsaneSize;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer level;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private VideoVideoStreamInfoMetadata metadata;

  /**
   * Total number of audio streams in the file
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer numAudioStreams;

  /**
   * Total number of data streams in the file
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer numDataStreams;

  /**
   * Total number of image streams in the file
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer numImageStreams;

  /**
   * Total number of timedtext streams in the file
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer numTimedtextStreams;

  /**
   * Total number of video streams in the file
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer numVideoStreams;

  /**
   * If this field is not set, then only base video file information has been generated (and ffmpeg
   * parsing hasn't yet been done). If this is set to 'false', then ffmpeg failed to parse the file
   * - otherwise it will set to 'true'
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean parsedByFfmpeg;

  /**
   * By default we assume that the entire file was given computing the VSI - if that is not true
   * this flag should be set to true.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean partialFile;

  /**
   * Pixel format for the video stream.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String pixFmt;

  /**
   * video profile
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String profile;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<VideoVideoStreamInfoTimedTextStream> timedtextStream;

  /**
   * video bitrate in bits/s
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Double videoBitrate;

  /**
   * Video clip information, such as copyright, title, and author.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private VideoVideoClipInfo videoClipInfo;

  /**
   * Primary video codec information Fields 1-2, 4-10, 28, 37, 44, 49, 51, 54-55, 57-62, 69 will be
   * obsolete soon. Please start using the new repeated video_stream. For now, video_stream(0) will
   * match these fields. Note however that some of the fields in VideoStream are not populated
   * correctly yet in videostreaminfo.cc, but that will be handled gradually.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String videoCodecId;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long videoEndTimestamp;

  /**
   * video frame per second, obtained by parsing video header information. It could be inaccurate
   * for some types of codecs, notably, WMV, ASF, and FLV. It will be inaccurate for videos that
   * does not have constant frame rate since it is the smallest framerate that can accurately
   * represent all timestamps (see ffmpeg doc for AVStream.r_frame_rate). Also frame rate can be
   * parsed from headers and can be wrong if it is not available there since ffmpeg uses a heuristic
   * for determining it.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Double videoFps;

  /**
   * video frame size
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long videoFrameSize;

  /**
   * video has b frames
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean videoHasBFrames;

  /**
   * video (MOV) has fragments
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean videoHasFragments;

  /**
   * video (MOV) has moov atom before mdat atom allowing streaming transcoding
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean videoHasLeadingMoovAtom;

  /**
   * video has non-monotonic DTS (potential problem)
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean videoHasNonMonotonicDts;

  /**
   * video has non-monotonic PTS.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean videoHasNonMonotonicPts;

  /**
   * video (MOV) has a possibly av desync issue due to edit lists not starting at 0
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean videoHasNonZeroStartEditList;

  /**
   * video has possible open GOP
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean videoHasPossibleOpenGop;

  /**
   * video has frames with different aspect ratios.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean videoHasVariableAspectRatio;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer videoHeight;

  /**
   * Information on interlaced video.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String videoInterlace;

  /**
   * video length in seconds Note that when the VSI is from users videos, it is not guaranteed to be
   * the same as transcode lengths and it could be 0 when the full VSI cannot compute the length
   * from the source header and timestamps (for example when header and timestamps are too broken).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Double videoLength;

  /**
   * Number of Video frames Warning: running video::FfmpegVideoFileInformation() won't set this info
   * Ffmpeg tool does not report the number of frames accurately. We can't rely on fps and video
   * length. So we will set this after we processed every frame using the filter framework
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long videoNumberOfFrames;

  /**
   * Invisible frame count Keep a count of frames that are not displayed should the full frame count
   * be needed for the video stream. The only codec currently reporting this value is VP8 with
   * alternate reference frames enabled
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer videoNumberOfInvisibleFrames;

  /**
   * video pixel aspect ratio
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Double videoPixelAspectRatio;

  /**
   * Is the video rotated ?
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String videoRotation;

  /**
   * Start/end timestamps of audio/video in ms.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long videoStartTimestamp;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<VideoVideoStreamInfoVideoStream> videoStream;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer videoStreamCodecTag;

  /**
   * source video width and height
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer videoWidth;

  /**
   * Version number of the videostreaminfo application that generated this protobuf.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer videostreaminfoVersion;

  /**
   * Luma PSNR of the transcoded file.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Double yPsnr;

  /**
   * audio bitrate in bits/s
   * @return value or {@code null} for none
   */
  public java.lang.Double getAudioBitrate() {
    return audioBitrate;
  }

  /**
   * audio bitrate in bits/s
   * @param audioBitrate audioBitrate or {@code null} for none
   */
  public VideoVideoStreamInfo setAudioBitrate(java.lang.Double audioBitrate) {
    this.audioBitrate = audioBitrate;
    return this;
  }

  /**
   * audio channels
   * @return value or {@code null} for none
   */
  public java.lang.Integer getAudioChannels() {
    return audioChannels;
  }

  /**
   * audio channels
   * @param audioChannels audioChannels or {@code null} for none
   */
  public VideoVideoStreamInfo setAudioChannels(java.lang.Integer audioChannels) {
    this.audioChannels = audioChannels;
    return this;
  }

  /**
   * Primary audio codec information Fields 15-20, 41-42, 48, 52-53 for audio will be obsolete soon.
   * Please start using the new repeated audio_stream and video_stream. For now, audio_stream(0)
   * will match these fields. Primary audio codec information starts:
   * @return value or {@code null} for none
   */
  public java.lang.String getAudioCodecId() {
    return audioCodecId;
  }

  /**
   * Primary audio codec information Fields 15-20, 41-42, 48, 52-53 for audio will be obsolete soon.
   * Please start using the new repeated audio_stream and video_stream. For now, audio_stream(0)
   * will match these fields. Primary audio codec information starts:
   * @param audioCodecId audioCodecId or {@code null} for none
   */
  public VideoVideoStreamInfo setAudioCodecId(java.lang.String audioCodecId) {
    this.audioCodecId = audioCodecId;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Long getAudioEndTimestamp() {
    return audioEndTimestamp;
  }

  /**
   * @param audioEndTimestamp audioEndTimestamp or {@code null} for none
   */
  public VideoVideoStreamInfo setAudioEndTimestamp(java.lang.Long audioEndTimestamp) {
    this.audioEndTimestamp = audioEndTimestamp;
    return this;
  }

  /**
   * audio frame size
   * @return value or {@code null} for none
   */
  public java.lang.Long getAudioFrameSize() {
    return audioFrameSize;
  }

  /**
   * audio frame size
   * @param audioFrameSize audioFrameSize or {@code null} for none
   */
  public VideoVideoStreamInfo setAudioFrameSize(java.lang.Long audioFrameSize) {
    this.audioFrameSize = audioFrameSize;
    return this;
  }

  /**
   * audio length in seconds Note that when the VSI is from users videos, it is not guaranteed to be
   * the same as transcode lengths and it could be 0 when the full VSI cannot compute the length
   * from the source header and timestamps (for example when header and timestamps are too broken).
   * @return value or {@code null} for none
   */
  public java.lang.Double getAudioLength() {
    return audioLength;
  }

  /**
   * audio length in seconds Note that when the VSI is from users videos, it is not guaranteed to be
   * the same as transcode lengths and it could be 0 when the full VSI cannot compute the length
   * from the source header and timestamps (for example when header and timestamps are too broken).
   * @param audioLength audioLength or {@code null} for none
   */
  public VideoVideoStreamInfo setAudioLength(java.lang.Double audioLength) {
    this.audioLength = audioLength;
    return this;
  }

  /**
   * Number of audio frames. Ffmpeg does not report the number of frames accurately.
   * video::TranscodedVideoFileInformation calls Google's analyzer to get information of both audio
   * and video frame numbers.
   * @return value or {@code null} for none
   */
  public java.lang.Long getAudioNumberOfFrames() {
    return audioNumberOfFrames;
  }

  /**
   * Number of audio frames. Ffmpeg does not report the number of frames accurately.
   * video::TranscodedVideoFileInformation calls Google's analyzer to get information of both audio
   * and video frame numbers.
   * @param audioNumberOfFrames audioNumberOfFrames or {@code null} for none
   */
  public VideoVideoStreamInfo setAudioNumberOfFrames(java.lang.Long audioNumberOfFrames) {
    this.audioNumberOfFrames = audioNumberOfFrames;
    return this;
  }

  /**
   * audio sample rate
   * @return value or {@code null} for none
   */
  public java.lang.Long getAudioSampleRate() {
    return audioSampleRate;
  }

  /**
   * audio sample rate
   * @param audioSampleRate audioSampleRate or {@code null} for none
   */
  public VideoVideoStreamInfo setAudioSampleRate(java.lang.Long audioSampleRate) {
    this.audioSampleRate = audioSampleRate;
    return this;
  }

  /**
   * Number of meaningful bits per decoded audio sample. This is an implicit conceptual meaning.
   * This is *NOT* the same as ffmpeg's internal sample format that is used when actually decoding
   * with ffmpeg.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getAudioSampleSize() {
    return audioSampleSize;
  }

  /**
   * Number of meaningful bits per decoded audio sample. This is an implicit conceptual meaning.
   * This is *NOT* the same as ffmpeg's internal sample format that is used when actually decoding
   * with ffmpeg.
   * @param audioSampleSize audioSampleSize or {@code null} for none
   */
  public VideoVideoStreamInfo setAudioSampleSize(java.lang.Integer audioSampleSize) {
    this.audioSampleSize = audioSampleSize;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Long getAudioStartTimestamp() {
    return audioStartTimestamp;
  }

  /**
   * @param audioStartTimestamp audioStartTimestamp or {@code null} for none
   */
  public VideoVideoStreamInfo setAudioStartTimestamp(java.lang.Long audioStartTimestamp) {
    this.audioStartTimestamp = audioStartTimestamp;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.util.List<VideoVideoStreamInfoAudioStream> getAudioStream() {
    return audioStream;
  }

  /**
   * @param audioStream audioStream or {@code null} for none
   */
  public VideoVideoStreamInfo setAudioStream(java.util.List<VideoVideoStreamInfoAudioStream> audioStream) {
    this.audioStream = audioStream;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Long getAudioStreamCodecTag() {
    return audioStreamCodecTag;
  }

  /**
   * @param audioStreamCodecTag audioStreamCodecTag or {@code null} for none
   */
  public VideoVideoStreamInfo setAudioStreamCodecTag(java.lang.Long audioStreamCodecTag) {
    this.audioStreamCodecTag = audioStreamCodecTag;
    return this;
  }

  /**
   * Audio-Video interleaving distance between packets (in bytes)
   * @return value or {@code null} for none
   */
  public java.lang.Integer getAvDistance() {
    return avDistance;
  }

  /**
   * Audio-Video interleaving distance between packets (in bytes)
   * @param avDistance avDistance or {@code null} for none
   */
  public VideoVideoStreamInfo setAvDistance(java.lang.Integer avDistance) {
    this.avDistance = avDistance;
    return this;
  }

  /**
   * Audio and video length in seconds. It's the max of the audio and video length. Note that when
   * the VSI is from users videos, it is not guaranteed to be the same as transcode lengths and it
   * could be 0 when the full VSI cannot compute the length from the source header and timestamps
   * (for example when header and timestamps are too broken).
   * @return value or {@code null} for none
   */
  public java.lang.Double getAvLength() {
    return avLength;
  }

  /**
   * Audio and video length in seconds. It's the max of the audio and video length. Note that when
   * the VSI is from users videos, it is not guaranteed to be the same as transcode lengths and it
   * could be 0 when the full VSI cannot compute the length from the source header and timestamps
   * (for example when header and timestamps are too broken).
   * @param avLength avLength or {@code null} for none
   */
  public VideoVideoStreamInfo setAvLength(java.lang.Double avLength) {
    this.avLength = avLength;
    return this;
  }

  /**
   * Average video fps from analyzing entire file.
   * @return value or {@code null} for none
   */
  public java.lang.Double getAverageVideoFps() {
    return averageVideoFps;
  }

  /**
   * Average video fps from analyzing entire file.
   * @param averageVideoFps averageVideoFps or {@code null} for none
   */
  public VideoVideoStreamInfo setAverageVideoFps(java.lang.Double averageVideoFps) {
    this.averageVideoFps = averageVideoFps;
    return this;
  }

  /**
   * Build label of the VSI mpm.
   * @return value or {@code null} for none
   */
  public java.lang.String getBuildLabel() {
    return buildLabel;
  }

  /**
   * Build label of the VSI mpm.
   * @param buildLabel buildLabel or {@code null} for none
   */
  public VideoVideoStreamInfo setBuildLabel(java.lang.String buildLabel) {
    this.buildLabel = buildLabel;
    return this;
  }

  /**
   * Container Id.
   * @return value or {@code null} for none
   */
  public java.lang.String getContainerId() {
    return containerId;
  }

  /**
   * Container Id.
   * @param containerId containerId or {@code null} for none
   */
  public VideoVideoStreamInfo setContainerId(java.lang.String containerId) {
    this.containerId = containerId;
    return this;
  }

  /**
   * Name of the container format guessed by ffmpeg.
   * @return value or {@code null} for none
   */
  public java.lang.String getContainerType() {
    return containerType;
  }

  /**
   * Name of the container format guessed by ffmpeg.
   * @param containerType containerType or {@code null} for none
   */
  public VideoVideoStreamInfo setContainerType(java.lang.String containerType) {
    this.containerType = containerType;
    return this;
  }

  /**
   * If the video contains chapters info.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getContainsChapters() {
    return containsChapters;
  }

  /**
   * If the video contains chapters info.
   * @param containsChapters containsChapters or {@code null} for none
   */
  public VideoVideoStreamInfo setContainsChapters(java.lang.Boolean containsChapters) {
    this.containsChapters = containsChapters;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.util.List<VideoVideoStreamInfoDataStream> getDataStream() {
    return dataStream;
  }

  /**
   * @param dataStream dataStream or {@code null} for none
   */
  public VideoVideoStreamInfo setDataStream(java.util.List<VideoVideoStreamInfoDataStream> dataStream) {
    this.dataStream = dataStream;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getDisplayHeight() {
    return displayHeight;
  }

  /**
   * @param displayHeight displayHeight or {@code null} for none
   */
  public VideoVideoStreamInfo setDisplayHeight(java.lang.Integer displayHeight) {
    this.displayHeight = displayHeight;
    return this;
  }

  /**
   * final display video width and height if explicitly set in the video otherwise this can be
   * calculated from source width/height and video_pixel_aspect_ratio
   * @return value or {@code null} for none
   */
  public java.lang.Integer getDisplayWidth() {
    return displayWidth;
  }

  /**
   * final display video width and height if explicitly set in the video otherwise this can be
   * calculated from source width/height and video_pixel_aspect_ratio
   * @param displayWidth displayWidth or {@code null} for none
   */
  public VideoVideoStreamInfo setDisplayWidth(java.lang.Integer displayWidth) {
    this.displayWidth = displayWidth;
    return this;
  }

  /**
   * Input file header fingerprint
   * @return value or {@code null} for none
   */
  public java.math.BigInteger getFileHeaderFingerprint() {
    return fileHeaderFingerprint;
  }

  /**
   * Input file header fingerprint
   * @param fileHeaderFingerprint fileHeaderFingerprint or {@code null} for none
   */
  public VideoVideoStreamInfo setFileHeaderFingerprint(java.math.BigInteger fileHeaderFingerprint) {
    this.fileHeaderFingerprint = fileHeaderFingerprint;
    return this;
  }

  /**
   * The file type string returned by libmagic, a third party library. It might accidentally include
   * some user content. Some normal file_magic examples: -- RIFF (little-endian) data, AVI, 1016 x
   * 696, 30.00 fps, video: XviD, audio: (stereo, 48000 Hz) -- MPEG sequence, v2, program multiplex
   * -- ISO Media, MPEG v4 system, iTunes AVC-LC -- Microsoft Windows Movie Maker project file
   * @return value or {@code null} for none
   */
  public java.lang.String getFileMagic() {
    return fileMagic;
  }

  /**
   * The file type string returned by libmagic, a third party library. It might accidentally include
   * some user content. Some normal file_magic examples: -- RIFF (little-endian) data, AVI, 1016 x
   * 696, 30.00 fps, video: XviD, audio: (stereo, 48000 Hz) -- MPEG sequence, v2, program multiplex
   * -- ISO Media, MPEG v4 system, iTunes AVC-LC -- Microsoft Windows Movie Maker project file
   * @param fileMagic fileMagic or {@code null} for none
   */
  public VideoVideoStreamInfo setFileMagic(java.lang.String fileMagic) {
    this.fileMagic = fileMagic;
    return this;
  }

  /**
   * Input file modification time
   * @return value or {@code null} for none
   */
  public java.lang.Long getFileModifiedTime() {
    return fileModifiedTime;
  }

  /**
   * Input file modification time
   * @param fileModifiedTime fileModifiedTime or {@code null} for none
   */
  public VideoVideoStreamInfo setFileModifiedTime(java.lang.Long fileModifiedTime) {
    this.fileModifiedTime = fileModifiedTime;
    return this;
  }

  /**
   * Input file name. DEPRECATED; don't expect the file name to be correct.
   * @return value or {@code null} for none
   */
  public java.lang.String getFileName() {
    return fileName;
  }

  /**
   * Input file name. DEPRECATED; don't expect the file name to be correct.
   * @param fileName fileName or {@code null} for none
   */
  public VideoVideoStreamInfo setFileName(java.lang.String fileName) {
    this.fileName = fileName;
    return this;
  }

  /**
   * Input file size in bytes
   * @return value or {@code null} for none
   */
  public java.lang.Long getFileSize() {
    return fileSize;
  }

  /**
   * Input file size in bytes
   * @param fileSize fileSize or {@code null} for none
   */
  public VideoVideoStreamInfo setFileSize(java.lang.Long fileSize) {
    this.fileSize = fileSize;
    return this;
  }

  /**
   * High-level file type guessed by looking at the file headers and libmagic.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getFileType() {
    return fileType;
  }

  /**
   * High-level file type guessed by looking at the file headers and libmagic.
   * @param fileType fileType or {@code null} for none
   */
  public VideoVideoStreamInfo setFileType(java.lang.Integer fileType) {
    this.fileType = fileType;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.util.List<VideoVideoStreamInfoVideoStream> getImageStream() {
    return imageStream;
  }

  /**
   * @param imageStream imageStream or {@code null} for none
   */
  public VideoVideoStreamInfo setImageStream(java.util.List<VideoVideoStreamInfoVideoStream> imageStream) {
    this.imageStream = imageStream;
    return this;
  }

  /**
   * True if the video is likely to be an ASF file.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getIsAsf() {
    return isAsf;
  }

  /**
   * True if the video is likely to be an ASF file.
   * @param isAsf isAsf or {@code null} for none
   */
  public VideoVideoStreamInfo setIsAsf(java.lang.Boolean isAsf) {
    this.isAsf = isAsf;
    return this;
  }

  /**
   * True if the video is actually an image file (JPEG, PNG, GIF, etc) and not a video file.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getIsImageFile() {
    return isImageFile;
  }

  /**
   * True if the video is actually an image file (JPEG, PNG, GIF, etc) and not a video file.
   * @param isImageFile isImageFile or {@code null} for none
   */
  public VideoVideoStreamInfo setIsImageFile(java.lang.Boolean isImageFile) {
    this.isImageFile = isImageFile;
    return this;
  }

  /**
   * Check if a video size insane or not. It is set if the input file is an MOV file.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getIsVideoInsaneSize() {
    return isVideoInsaneSize;
  }

  /**
   * Check if a video size insane or not. It is set if the input file is an MOV file.
   * @param isVideoInsaneSize isVideoInsaneSize or {@code null} for none
   */
  public VideoVideoStreamInfo setIsVideoInsaneSize(java.lang.Boolean isVideoInsaneSize) {
    this.isVideoInsaneSize = isVideoInsaneSize;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getLevel() {
    return level;
  }

  /**
   * @param level level or {@code null} for none
   */
  public VideoVideoStreamInfo setLevel(java.lang.Integer level) {
    this.level = level;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public VideoVideoStreamInfoMetadata getMetadata() {
    return metadata;
  }

  /**
   * @param metadata metadata or {@code null} for none
   */
  public VideoVideoStreamInfo setMetadata(VideoVideoStreamInfoMetadata metadata) {
    this.metadata = metadata;
    return this;
  }

  /**
   * Total number of audio streams in the file
   * @return value or {@code null} for none
   */
  public java.lang.Integer getNumAudioStreams() {
    return numAudioStreams;
  }

  /**
   * Total number of audio streams in the file
   * @param numAudioStreams numAudioStreams or {@code null} for none
   */
  public VideoVideoStreamInfo setNumAudioStreams(java.lang.Integer numAudioStreams) {
    this.numAudioStreams = numAudioStreams;
    return this;
  }

  /**
   * Total number of data streams in the file
   * @return value or {@code null} for none
   */
  public java.lang.Integer getNumDataStreams() {
    return numDataStreams;
  }

  /**
   * Total number of data streams in the file
   * @param numDataStreams numDataStreams or {@code null} for none
   */
  public VideoVideoStreamInfo setNumDataStreams(java.lang.Integer numDataStreams) {
    this.numDataStreams = numDataStreams;
    return this;
  }

  /**
   * Total number of image streams in the file
   * @return value or {@code null} for none
   */
  public java.lang.Integer getNumImageStreams() {
    return numImageStreams;
  }

  /**
   * Total number of image streams in the file
   * @param numImageStreams numImageStreams or {@code null} for none
   */
  public VideoVideoStreamInfo setNumImageStreams(java.lang.Integer numImageStreams) {
    this.numImageStreams = numImageStreams;
    return this;
  }

  /**
   * Total number of timedtext streams in the file
   * @return value or {@code null} for none
   */
  public java.lang.Integer getNumTimedtextStreams() {
    return numTimedtextStreams;
  }

  /**
   * Total number of timedtext streams in the file
   * @param numTimedtextStreams numTimedtextStreams or {@code null} for none
   */
  public VideoVideoStreamInfo setNumTimedtextStreams(java.lang.Integer numTimedtextStreams) {
    this.numTimedtextStreams = numTimedtextStreams;
    return this;
  }

  /**
   * Total number of video streams in the file
   * @return value or {@code null} for none
   */
  public java.lang.Integer getNumVideoStreams() {
    return numVideoStreams;
  }

  /**
   * Total number of video streams in the file
   * @param numVideoStreams numVideoStreams or {@code null} for none
   */
  public VideoVideoStreamInfo setNumVideoStreams(java.lang.Integer numVideoStreams) {
    this.numVideoStreams = numVideoStreams;
    return this;
  }

  /**
   * If this field is not set, then only base video file information has been generated (and ffmpeg
   * parsing hasn't yet been done). If this is set to 'false', then ffmpeg failed to parse the file
   * - otherwise it will set to 'true'
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getParsedByFfmpeg() {
    return parsedByFfmpeg;
  }

  /**
   * If this field is not set, then only base video file information has been generated (and ffmpeg
   * parsing hasn't yet been done). If this is set to 'false', then ffmpeg failed to parse the file
   * - otherwise it will set to 'true'
   * @param parsedByFfmpeg parsedByFfmpeg or {@code null} for none
   */
  public VideoVideoStreamInfo setParsedByFfmpeg(java.lang.Boolean parsedByFfmpeg) {
    this.parsedByFfmpeg = parsedByFfmpeg;
    return this;
  }

  /**
   * By default we assume that the entire file was given computing the VSI - if that is not true
   * this flag should be set to true.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getPartialFile() {
    return partialFile;
  }

  /**
   * By default we assume that the entire file was given computing the VSI - if that is not true
   * this flag should be set to true.
   * @param partialFile partialFile or {@code null} for none
   */
  public VideoVideoStreamInfo setPartialFile(java.lang.Boolean partialFile) {
    this.partialFile = partialFile;
    return this;
  }

  /**
   * Pixel format for the video stream.
   * @return value or {@code null} for none
   */
  public java.lang.String getPixFmt() {
    return pixFmt;
  }

  /**
   * Pixel format for the video stream.
   * @param pixFmt pixFmt or {@code null} for none
   */
  public VideoVideoStreamInfo setPixFmt(java.lang.String pixFmt) {
    this.pixFmt = pixFmt;
    return this;
  }

  /**
   * video profile
   * @return value or {@code null} for none
   */
  public java.lang.String getProfile() {
    return profile;
  }

  /**
   * video profile
   * @param profile profile or {@code null} for none
   */
  public VideoVideoStreamInfo setProfile(java.lang.String profile) {
    this.profile = profile;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.util.List<VideoVideoStreamInfoTimedTextStream> getTimedtextStream() {
    return timedtextStream;
  }

  /**
   * @param timedtextStream timedtextStream or {@code null} for none
   */
  public VideoVideoStreamInfo setTimedtextStream(java.util.List<VideoVideoStreamInfoTimedTextStream> timedtextStream) {
    this.timedtextStream = timedtextStream;
    return this;
  }

  /**
   * video bitrate in bits/s
   * @return value or {@code null} for none
   */
  public java.lang.Double getVideoBitrate() {
    return videoBitrate;
  }

  /**
   * video bitrate in bits/s
   * @param videoBitrate videoBitrate or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoBitrate(java.lang.Double videoBitrate) {
    this.videoBitrate = videoBitrate;
    return this;
  }

  /**
   * Video clip information, such as copyright, title, and author.
   * @return value or {@code null} for none
   */
  public VideoVideoClipInfo getVideoClipInfo() {
    return videoClipInfo;
  }

  /**
   * Video clip information, such as copyright, title, and author.
   * @param videoClipInfo videoClipInfo or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoClipInfo(VideoVideoClipInfo videoClipInfo) {
    this.videoClipInfo = videoClipInfo;
    return this;
  }

  /**
   * Primary video codec information Fields 1-2, 4-10, 28, 37, 44, 49, 51, 54-55, 57-62, 69 will be
   * obsolete soon. Please start using the new repeated video_stream. For now, video_stream(0) will
   * match these fields. Note however that some of the fields in VideoStream are not populated
   * correctly yet in videostreaminfo.cc, but that will be handled gradually.
   * @return value or {@code null} for none
   */
  public java.lang.String getVideoCodecId() {
    return videoCodecId;
  }

  /**
   * Primary video codec information Fields 1-2, 4-10, 28, 37, 44, 49, 51, 54-55, 57-62, 69 will be
   * obsolete soon. Please start using the new repeated video_stream. For now, video_stream(0) will
   * match these fields. Note however that some of the fields in VideoStream are not populated
   * correctly yet in videostreaminfo.cc, but that will be handled gradually.
   * @param videoCodecId videoCodecId or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoCodecId(java.lang.String videoCodecId) {
    this.videoCodecId = videoCodecId;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Long getVideoEndTimestamp() {
    return videoEndTimestamp;
  }

  /**
   * @param videoEndTimestamp videoEndTimestamp or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoEndTimestamp(java.lang.Long videoEndTimestamp) {
    this.videoEndTimestamp = videoEndTimestamp;
    return this;
  }

  /**
   * video frame per second, obtained by parsing video header information. It could be inaccurate
   * for some types of codecs, notably, WMV, ASF, and FLV. It will be inaccurate for videos that
   * does not have constant frame rate since it is the smallest framerate that can accurately
   * represent all timestamps (see ffmpeg doc for AVStream.r_frame_rate). Also frame rate can be
   * parsed from headers and can be wrong if it is not available there since ffmpeg uses a heuristic
   * for determining it.
   * @return value or {@code null} for none
   */
  public java.lang.Double getVideoFps() {
    return videoFps;
  }

  /**
   * video frame per second, obtained by parsing video header information. It could be inaccurate
   * for some types of codecs, notably, WMV, ASF, and FLV. It will be inaccurate for videos that
   * does not have constant frame rate since it is the smallest framerate that can accurately
   * represent all timestamps (see ffmpeg doc for AVStream.r_frame_rate). Also frame rate can be
   * parsed from headers and can be wrong if it is not available there since ffmpeg uses a heuristic
   * for determining it.
   * @param videoFps videoFps or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoFps(java.lang.Double videoFps) {
    this.videoFps = videoFps;
    return this;
  }

  /**
   * video frame size
   * @return value or {@code null} for none
   */
  public java.lang.Long getVideoFrameSize() {
    return videoFrameSize;
  }

  /**
   * video frame size
   * @param videoFrameSize videoFrameSize or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoFrameSize(java.lang.Long videoFrameSize) {
    this.videoFrameSize = videoFrameSize;
    return this;
  }

  /**
   * video has b frames
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getVideoHasBFrames() {
    return videoHasBFrames;
  }

  /**
   * video has b frames
   * @param videoHasBFrames videoHasBFrames or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoHasBFrames(java.lang.Boolean videoHasBFrames) {
    this.videoHasBFrames = videoHasBFrames;
    return this;
  }

  /**
   * video (MOV) has fragments
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getVideoHasFragments() {
    return videoHasFragments;
  }

  /**
   * video (MOV) has fragments
   * @param videoHasFragments videoHasFragments or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoHasFragments(java.lang.Boolean videoHasFragments) {
    this.videoHasFragments = videoHasFragments;
    return this;
  }

  /**
   * video (MOV) has moov atom before mdat atom allowing streaming transcoding
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getVideoHasLeadingMoovAtom() {
    return videoHasLeadingMoovAtom;
  }

  /**
   * video (MOV) has moov atom before mdat atom allowing streaming transcoding
   * @param videoHasLeadingMoovAtom videoHasLeadingMoovAtom or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoHasLeadingMoovAtom(java.lang.Boolean videoHasLeadingMoovAtom) {
    this.videoHasLeadingMoovAtom = videoHasLeadingMoovAtom;
    return this;
  }

  /**
   * video has non-monotonic DTS (potential problem)
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getVideoHasNonMonotonicDts() {
    return videoHasNonMonotonicDts;
  }

  /**
   * video has non-monotonic DTS (potential problem)
   * @param videoHasNonMonotonicDts videoHasNonMonotonicDts or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoHasNonMonotonicDts(java.lang.Boolean videoHasNonMonotonicDts) {
    this.videoHasNonMonotonicDts = videoHasNonMonotonicDts;
    return this;
  }

  /**
   * video has non-monotonic PTS.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getVideoHasNonMonotonicPts() {
    return videoHasNonMonotonicPts;
  }

  /**
   * video has non-monotonic PTS.
   * @param videoHasNonMonotonicPts videoHasNonMonotonicPts or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoHasNonMonotonicPts(java.lang.Boolean videoHasNonMonotonicPts) {
    this.videoHasNonMonotonicPts = videoHasNonMonotonicPts;
    return this;
  }

  /**
   * video (MOV) has a possibly av desync issue due to edit lists not starting at 0
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getVideoHasNonZeroStartEditList() {
    return videoHasNonZeroStartEditList;
  }

  /**
   * video (MOV) has a possibly av desync issue due to edit lists not starting at 0
   * @param videoHasNonZeroStartEditList videoHasNonZeroStartEditList or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoHasNonZeroStartEditList(java.lang.Boolean videoHasNonZeroStartEditList) {
    this.videoHasNonZeroStartEditList = videoHasNonZeroStartEditList;
    return this;
  }

  /**
   * video has possible open GOP
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getVideoHasPossibleOpenGop() {
    return videoHasPossibleOpenGop;
  }

  /**
   * video has possible open GOP
   * @param videoHasPossibleOpenGop videoHasPossibleOpenGop or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoHasPossibleOpenGop(java.lang.Boolean videoHasPossibleOpenGop) {
    this.videoHasPossibleOpenGop = videoHasPossibleOpenGop;
    return this;
  }

  /**
   * video has frames with different aspect ratios.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getVideoHasVariableAspectRatio() {
    return videoHasVariableAspectRatio;
  }

  /**
   * video has frames with different aspect ratios.
   * @param videoHasVariableAspectRatio videoHasVariableAspectRatio or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoHasVariableAspectRatio(java.lang.Boolean videoHasVariableAspectRatio) {
    this.videoHasVariableAspectRatio = videoHasVariableAspectRatio;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getVideoHeight() {
    return videoHeight;
  }

  /**
   * @param videoHeight videoHeight or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoHeight(java.lang.Integer videoHeight) {
    this.videoHeight = videoHeight;
    return this;
  }

  /**
   * Information on interlaced video.
   * @return value or {@code null} for none
   */
  public java.lang.String getVideoInterlace() {
    return videoInterlace;
  }

  /**
   * Information on interlaced video.
   * @param videoInterlace videoInterlace or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoInterlace(java.lang.String videoInterlace) {
    this.videoInterlace = videoInterlace;
    return this;
  }

  /**
   * video length in seconds Note that when the VSI is from users videos, it is not guaranteed to be
   * the same as transcode lengths and it could be 0 when the full VSI cannot compute the length
   * from the source header and timestamps (for example when header and timestamps are too broken).
   * @return value or {@code null} for none
   */
  public java.lang.Double getVideoLength() {
    return videoLength;
  }

  /**
   * video length in seconds Note that when the VSI is from users videos, it is not guaranteed to be
   * the same as transcode lengths and it could be 0 when the full VSI cannot compute the length
   * from the source header and timestamps (for example when header and timestamps are too broken).
   * @param videoLength videoLength or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoLength(java.lang.Double videoLength) {
    this.videoLength = videoLength;
    return this;
  }

  /**
   * Number of Video frames Warning: running video::FfmpegVideoFileInformation() won't set this info
   * Ffmpeg tool does not report the number of frames accurately. We can't rely on fps and video
   * length. So we will set this after we processed every frame using the filter framework
   * @return value or {@code null} for none
   */
  public java.lang.Long getVideoNumberOfFrames() {
    return videoNumberOfFrames;
  }

  /**
   * Number of Video frames Warning: running video::FfmpegVideoFileInformation() won't set this info
   * Ffmpeg tool does not report the number of frames accurately. We can't rely on fps and video
   * length. So we will set this after we processed every frame using the filter framework
   * @param videoNumberOfFrames videoNumberOfFrames or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoNumberOfFrames(java.lang.Long videoNumberOfFrames) {
    this.videoNumberOfFrames = videoNumberOfFrames;
    return this;
  }

  /**
   * Invisible frame count Keep a count of frames that are not displayed should the full frame count
   * be needed for the video stream. The only codec currently reporting this value is VP8 with
   * alternate reference frames enabled
   * @return value or {@code null} for none
   */
  public java.lang.Integer getVideoNumberOfInvisibleFrames() {
    return videoNumberOfInvisibleFrames;
  }

  /**
   * Invisible frame count Keep a count of frames that are not displayed should the full frame count
   * be needed for the video stream. The only codec currently reporting this value is VP8 with
   * alternate reference frames enabled
   * @param videoNumberOfInvisibleFrames videoNumberOfInvisibleFrames or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoNumberOfInvisibleFrames(java.lang.Integer videoNumberOfInvisibleFrames) {
    this.videoNumberOfInvisibleFrames = videoNumberOfInvisibleFrames;
    return this;
  }

  /**
   * video pixel aspect ratio
   * @return value or {@code null} for none
   */
  public java.lang.Double getVideoPixelAspectRatio() {
    return videoPixelAspectRatio;
  }

  /**
   * video pixel aspect ratio
   * @param videoPixelAspectRatio videoPixelAspectRatio or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoPixelAspectRatio(java.lang.Double videoPixelAspectRatio) {
    this.videoPixelAspectRatio = videoPixelAspectRatio;
    return this;
  }

  /**
   * Is the video rotated ?
   * @return value or {@code null} for none
   */
  public java.lang.String getVideoRotation() {
    return videoRotation;
  }

  /**
   * Is the video rotated ?
   * @param videoRotation videoRotation or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoRotation(java.lang.String videoRotation) {
    this.videoRotation = videoRotation;
    return this;
  }

  /**
   * Start/end timestamps of audio/video in ms.
   * @return value or {@code null} for none
   */
  public java.lang.Long getVideoStartTimestamp() {
    return videoStartTimestamp;
  }

  /**
   * Start/end timestamps of audio/video in ms.
   * @param videoStartTimestamp videoStartTimestamp or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoStartTimestamp(java.lang.Long videoStartTimestamp) {
    this.videoStartTimestamp = videoStartTimestamp;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.util.List<VideoVideoStreamInfoVideoStream> getVideoStream() {
    return videoStream;
  }

  /**
   * @param videoStream videoStream or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoStream(java.util.List<VideoVideoStreamInfoVideoStream> videoStream) {
    this.videoStream = videoStream;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.Integer getVideoStreamCodecTag() {
    return videoStreamCodecTag;
  }

  /**
   * @param videoStreamCodecTag videoStreamCodecTag or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoStreamCodecTag(java.lang.Integer videoStreamCodecTag) {
    this.videoStreamCodecTag = videoStreamCodecTag;
    return this;
  }

  /**
   * source video width and height
   * @return value or {@code null} for none
   */
  public java.lang.Integer getVideoWidth() {
    return videoWidth;
  }

  /**
   * source video width and height
   * @param videoWidth videoWidth or {@code null} for none
   */
  public VideoVideoStreamInfo setVideoWidth(java.lang.Integer videoWidth) {
    this.videoWidth = videoWidth;
    return this;
  }

  /**
   * Version number of the videostreaminfo application that generated this protobuf.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getVideostreaminfoVersion() {
    return videostreaminfoVersion;
  }

  /**
   * Version number of the videostreaminfo application that generated this protobuf.
   * @param videostreaminfoVersion videostreaminfoVersion or {@code null} for none
   */
  public VideoVideoStreamInfo setVideostreaminfoVersion(java.lang.Integer videostreaminfoVersion) {
    this.videostreaminfoVersion = videostreaminfoVersion;
    return this;
  }

  /**
   * Luma PSNR of the transcoded file.
   * @return value or {@code null} for none
   */
  public java.lang.Double getYPsnr() {
    return yPsnr;
  }

  /**
   * Luma PSNR of the transcoded file.
   * @param yPsnr yPsnr or {@code null} for none
   */
  public VideoVideoStreamInfo setYPsnr(java.lang.Double yPsnr) {
    this.yPsnr = yPsnr;
    return this;
  }

  @Override
  public VideoVideoStreamInfo set(String fieldName, Object value) {
    return (VideoVideoStreamInfo) super.set(fieldName, value);
  }

  @Override
  public VideoVideoStreamInfo clone() {
    return (VideoVideoStreamInfo) super.clone();
  }

}
