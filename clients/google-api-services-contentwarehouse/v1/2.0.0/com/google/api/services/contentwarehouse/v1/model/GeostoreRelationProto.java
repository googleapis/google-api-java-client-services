/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.contentwarehouse.v1.model;

/**
 * This message is embedded within a FeatureProto, and represents a geographic or logical
 * relationship of that feature to some other feature. Note that some relation types are there
 * purely for the purpose of grouping together other relation types. They are noted as ABSTRACT in
 * comments. Other relation types are no longer supported / in use. They are noted as DEPRECATED in
 * comments (and marked with the standard deprecated option, too). Other relation types are reserved
 * for future use or just not intended for use at all, for various internal reasons. They are noted
 * as RESERVED in comments. WARNING: Updates to this proto within a FeatureProto's related_feature
 * field handled by standalone pipelines and are NOT atomic with regard to updates to the features
 * being referenced; we do not guarantee that a given MapFacts snapshot will be consistent between
 * this field and the related features.
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the contentwarehouse API. For a detailed explanation see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class GeostoreRelationProto extends com.google.api.client.json.GenericJson {

  /**
   * Field-level metadata for this relation.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFieldMetadataProto metadata;

  /**
   * If and only if the other feature is of TYPE_COUNTRY, the 2-letter country code. This is the
   * FLAG_COUNTRY_CODE_2 name of the country component.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String otherFeatureCountryCode;

  /**
   * The feature ID of the feature to which we're relating. WARNING: the related feature does not
   * necessarily have a bound that encloses this feature, so in a bucketing MapReduce, you may not
   * be able to follow all relationships. Relations that use strong references are annotated above
   * but you can also refer to IsRelationStrong() in geostore/base/public/relation.h.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private GeostoreFeatureIdProto otherFeatureId;

  /**
   * RESERVED
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<GeostoreNameProto> otherFeatureName;

  static {
    // hack to force ProGuard to consider GeostoreNameProto used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(GeostoreNameProto.class);
  }

  /**
   * If and only if the other feature is of TYPE_DISPUTED_AREA, the territorial administrator found
   * in its GeopoliticalAttachmentProto.administered_by field, if any. Since this string is copied
   * exactly, it may be a 2-letter country code or another type of descriptive string.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String otherFeatureTerritorialAdministrator;

  /**
   * The type of the feature to which we're relating.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer otherFeatureType;

  /**
   * ** DEPRECATED ** If relation is exactly RELATION_OVERLAPS but not any of its subcategories,
   * overlap_fraction contains an estimate of the fraction of the geometry of this feature that
   * intersects with the other feature, ranging from 0.0 to 1.0. Note that this is a rough estimate
   * based on cell coverings, and may not be very accurate. In particular, values of 0.0 and 1.0 are
   * possible, even though in principle they should not be.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Float overlapFraction;

  /**
   * The relationship of the feature that contains this RelationProto to the feature
   * other_feature_id. Note the relation_is_reversed field below. Some relations imply weak
   * references, other strong ones. Strong references are annotated above but you can also refer to
   * IsRelationStrong() in geostore/base/public/relation.h.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String relation;

  /**
   * RESERVED
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean relationIsReversed;

  /**
   * A place for clients to attach arbitrary data to a relation. Never set in MapFacts.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private Proto2BridgeMessageSet temporaryData;

  /**
   * Field-level metadata for this relation.
   * @return value or {@code null} for none
   */
  public GeostoreFieldMetadataProto getMetadata() {
    return metadata;
  }

  /**
   * Field-level metadata for this relation.
   * @param metadata metadata or {@code null} for none
   */
  public GeostoreRelationProto setMetadata(GeostoreFieldMetadataProto metadata) {
    this.metadata = metadata;
    return this;
  }

  /**
   * If and only if the other feature is of TYPE_COUNTRY, the 2-letter country code. This is the
   * FLAG_COUNTRY_CODE_2 name of the country component.
   * @return value or {@code null} for none
   */
  public java.lang.String getOtherFeatureCountryCode() {
    return otherFeatureCountryCode;
  }

  /**
   * If and only if the other feature is of TYPE_COUNTRY, the 2-letter country code. This is the
   * FLAG_COUNTRY_CODE_2 name of the country component.
   * @param otherFeatureCountryCode otherFeatureCountryCode or {@code null} for none
   */
  public GeostoreRelationProto setOtherFeatureCountryCode(java.lang.String otherFeatureCountryCode) {
    this.otherFeatureCountryCode = otherFeatureCountryCode;
    return this;
  }

  /**
   * The feature ID of the feature to which we're relating. WARNING: the related feature does not
   * necessarily have a bound that encloses this feature, so in a bucketing MapReduce, you may not
   * be able to follow all relationships. Relations that use strong references are annotated above
   * but you can also refer to IsRelationStrong() in geostore/base/public/relation.h.
   * @return value or {@code null} for none
   */
  public GeostoreFeatureIdProto getOtherFeatureId() {
    return otherFeatureId;
  }

  /**
   * The feature ID of the feature to which we're relating. WARNING: the related feature does not
   * necessarily have a bound that encloses this feature, so in a bucketing MapReduce, you may not
   * be able to follow all relationships. Relations that use strong references are annotated above
   * but you can also refer to IsRelationStrong() in geostore/base/public/relation.h.
   * @param otherFeatureId otherFeatureId or {@code null} for none
   */
  public GeostoreRelationProto setOtherFeatureId(GeostoreFeatureIdProto otherFeatureId) {
    this.otherFeatureId = otherFeatureId;
    return this;
  }

  /**
   * RESERVED
   * @return value or {@code null} for none
   */
  public java.util.List<GeostoreNameProto> getOtherFeatureName() {
    return otherFeatureName;
  }

  /**
   * RESERVED
   * @param otherFeatureName otherFeatureName or {@code null} for none
   */
  public GeostoreRelationProto setOtherFeatureName(java.util.List<GeostoreNameProto> otherFeatureName) {
    this.otherFeatureName = otherFeatureName;
    return this;
  }

  /**
   * If and only if the other feature is of TYPE_DISPUTED_AREA, the territorial administrator found
   * in its GeopoliticalAttachmentProto.administered_by field, if any. Since this string is copied
   * exactly, it may be a 2-letter country code or another type of descriptive string.
   * @return value or {@code null} for none
   */
  public java.lang.String getOtherFeatureTerritorialAdministrator() {
    return otherFeatureTerritorialAdministrator;
  }

  /**
   * If and only if the other feature is of TYPE_DISPUTED_AREA, the territorial administrator found
   * in its GeopoliticalAttachmentProto.administered_by field, if any. Since this string is copied
   * exactly, it may be a 2-letter country code or another type of descriptive string.
   * @param otherFeatureTerritorialAdministrator otherFeatureTerritorialAdministrator or {@code null} for none
   */
  public GeostoreRelationProto setOtherFeatureTerritorialAdministrator(java.lang.String otherFeatureTerritorialAdministrator) {
    this.otherFeatureTerritorialAdministrator = otherFeatureTerritorialAdministrator;
    return this;
  }

  /**
   * The type of the feature to which we're relating.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getOtherFeatureType() {
    return otherFeatureType;
  }

  /**
   * The type of the feature to which we're relating.
   * @param otherFeatureType otherFeatureType or {@code null} for none
   */
  public GeostoreRelationProto setOtherFeatureType(java.lang.Integer otherFeatureType) {
    this.otherFeatureType = otherFeatureType;
    return this;
  }

  /**
   * ** DEPRECATED ** If relation is exactly RELATION_OVERLAPS but not any of its subcategories,
   * overlap_fraction contains an estimate of the fraction of the geometry of this feature that
   * intersects with the other feature, ranging from 0.0 to 1.0. Note that this is a rough estimate
   * based on cell coverings, and may not be very accurate. In particular, values of 0.0 and 1.0 are
   * possible, even though in principle they should not be.
   * @return value or {@code null} for none
   */
  public java.lang.Float getOverlapFraction() {
    return overlapFraction;
  }

  /**
   * ** DEPRECATED ** If relation is exactly RELATION_OVERLAPS but not any of its subcategories,
   * overlap_fraction contains an estimate of the fraction of the geometry of this feature that
   * intersects with the other feature, ranging from 0.0 to 1.0. Note that this is a rough estimate
   * based on cell coverings, and may not be very accurate. In particular, values of 0.0 and 1.0 are
   * possible, even though in principle they should not be.
   * @param overlapFraction overlapFraction or {@code null} for none
   */
  public GeostoreRelationProto setOverlapFraction(java.lang.Float overlapFraction) {
    this.overlapFraction = overlapFraction;
    return this;
  }

  /**
   * The relationship of the feature that contains this RelationProto to the feature
   * other_feature_id. Note the relation_is_reversed field below. Some relations imply weak
   * references, other strong ones. Strong references are annotated above but you can also refer to
   * IsRelationStrong() in geostore/base/public/relation.h.
   * @return value or {@code null} for none
   */
  public java.lang.String getRelation() {
    return relation;
  }

  /**
   * The relationship of the feature that contains this RelationProto to the feature
   * other_feature_id. Note the relation_is_reversed field below. Some relations imply weak
   * references, other strong ones. Strong references are annotated above but you can also refer to
   * IsRelationStrong() in geostore/base/public/relation.h.
   * @param relation relation or {@code null} for none
   */
  public GeostoreRelationProto setRelation(java.lang.String relation) {
    this.relation = relation;
    return this;
  }

  /**
   * RESERVED
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getRelationIsReversed() {
    return relationIsReversed;
  }

  /**
   * RESERVED
   * @param relationIsReversed relationIsReversed or {@code null} for none
   */
  public GeostoreRelationProto setRelationIsReversed(java.lang.Boolean relationIsReversed) {
    this.relationIsReversed = relationIsReversed;
    return this;
  }

  /**
   * A place for clients to attach arbitrary data to a relation. Never set in MapFacts.
   * @return value or {@code null} for none
   */
  public Proto2BridgeMessageSet getTemporaryData() {
    return temporaryData;
  }

  /**
   * A place for clients to attach arbitrary data to a relation. Never set in MapFacts.
   * @param temporaryData temporaryData or {@code null} for none
   */
  public GeostoreRelationProto setTemporaryData(Proto2BridgeMessageSet temporaryData) {
    this.temporaryData = temporaryData;
    return this;
  }

  @Override
  public GeostoreRelationProto set(String fieldName, Object value) {
    return (GeostoreRelationProto) super.set(fieldName, value);
  }

  @Override
  public GeostoreRelationProto clone() {
    return (GeostoreRelationProto) super.clone();
  }

}
