/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.androidmanagement.v1.model;

/**
 * A policy resources represents a group settings that govern the behavior of a managed device and
 * the apps installed on it.
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the Android Management API. For a detailed explanation
 * see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class Policy extends com.google.api.client.json.GenericJson {

  /**
   * Account types that can't be managed by the user.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.String> accountTypesWithManagementDisabled;

  /**
   * Whether adding new users and profiles is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean addUserDisabled;

  /**
   * Whether adjusting the master volume is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean adjustVolumeDisabled;

  /**
   * Configuration for an always-on VPN connection. Use with vpn_config_disabled to prevent
   * modification of this setting.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private AlwaysOnVpnPackage alwaysOnVpnPackage;

  /**
   * The app tracks for Android Device Policy the device can access. The device receives the latest
   * version among all accessible tracks. If no tracks are specified, then the device only uses the
   * production track.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.String> androidDevicePolicyTracks;

  /**
   * The app auto update policy, which controls when automatic app updates can be applied.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String appAutoUpdatePolicy;

  /**
   * Policy applied to apps.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<ApplicationPolicy> applications;

  static {
    // hack to force ProGuard to consider ApplicationPolicy used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(ApplicationPolicy.class);
  }

  /**
   * Whether auto time is required, which prevents the user from manually setting the date and time.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean autoTimeRequired;

  /**
   * Whether applications other than the ones configured in applications are blocked from being
   * installed. When set, applications that were installed under a previous policy but no longer
   * appear in the policy are automatically uninstalled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean blockApplicationsEnabled;

  /**
   * Whether configuring bluetooth is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean bluetoothConfigDisabled;

  /**
   * Whether bluetooth contact sharing is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean bluetoothContactSharingDisabled;

  /**
   * Whether bluetooth is disabled. Prefer this setting over bluetooth_config_disabled because
   * bluetooth_config_disabled can be bypassed by the user.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean bluetoothDisabled;

  /**
   * Whether all cameras on the device are disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean cameraDisabled;

  /**
   * Whether configuring cell broadcast is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean cellBroadcastsConfigDisabled;

  /**
   * Rules for automatically choosing a private key and certificate to authenticate the device to a
   * server. The rules are ordered by increasing precedence, so if an outgoing request matches more
   * than one rule, the last rule defines which private key to use.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<ChoosePrivateKeyRule> choosePrivateKeyRules;

  static {
    // hack to force ProGuard to consider ChoosePrivateKeyRule used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(ChoosePrivateKeyRule.class);
  }

  /**
   * Rules declaring which mitigating actions to take when a device is not compliant with its
   * policy. When the conditions for multiple rules are satisfied, all of the mitigating actions for
   * the rules are taken. There is a maximum limit of 100 rules. Use policy enforcement rules
   * instead.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<ComplianceRule> complianceRules;

  static {
    // hack to force ProGuard to consider ComplianceRule used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(ComplianceRule.class);
  }

  /**
   * Whether creating windows besides app windows is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean createWindowsDisabled;

  /**
   * Whether configuring user credentials is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean credentialsConfigDisabled;

  /**
   * Whether roaming data services are disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean dataRoamingDisabled;

  /**
   * Whether the user is allowed to enable debugging features.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean debuggingFeaturesAllowed;

  /**
   * The default permission policy for runtime permission requests.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String defaultPermissionPolicy;

  /**
   * The device owner information to be shown on the lock screen.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private UserFacingMessage deviceOwnerLockScreenInfo;

  /**
   * Whether encryption is enabled
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String encryptionPolicy;

  /**
   * Whether app verification is force-enabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean ensureVerifyAppsEnabled;

  /**
   * Whether factory resetting from settings is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean factoryResetDisabled;

  /**
   * Email addresses of device administrators for factory reset protection. When the device is
   * factory reset, it will require one of these admins to log in with the Google account email and
   * password to unlock the device. If no admins are specified, the device won't provide factory
   * reset protection.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.String> frpAdminEmails;

  /**
   * Whether the user is allowed to have fun. Controls whether the Easter egg game in Settings is
   * disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean funDisabled;

  /**
   * Whether user installation of apps is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean installAppsDisabled;

  /**
   * Whether the user is allowed to enable the "Unknown Sources" setting, which allows installation
   * of apps from unknown sources.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean installUnknownSourcesAllowed;

  /**
   * Whether the keyguard is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean keyguardDisabled;

  /**
   * Disabled keyguard customizations, such as widgets.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.String> keyguardDisabledFeatures;

  /**
   * Whether the kiosk custom launcher is enabled. This replaces the home screen with a launcher
   * that locks down the device to the apps installed via the applications setting. The apps appear
   * on a single page in alphabetical order. It is recommended to also use status_bar_disabled to
   * block access to device settings.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean kioskCustomLauncherEnabled;

  /**
   * The degree of location detection enabled. The user may change the value unless the user is
   * otherwise blocked from accessing device settings.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String locationMode;

  /**
   * A message displayed to the user in the device administators settings screen.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private UserFacingMessage longSupportMessage;

  /**
   * Maximum time in milliseconds for user activity until the device locks. A value of 0 means there
   * is no restriction.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long maximumTimeToLock;

  /**
   * The minimum allowed Android API level.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Integer minimumApiLevel;

  /**
   * Whether configuring mobile networks is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean mobileNetworksConfigDisabled;

  /**
   * Whether adding or removing accounts is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean modifyAccountsDisabled;

  /**
   * Whether the user mounting physical external media is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean mountPhysicalMediaDisabled;

  /**
   * The name of the policy in the form enterprises/{enterpriseId}/policies/{policyId}.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String name;

  /**
   * Whether the network escape hatch is enabled. If a network connection can't be made at boot
   * time, the escape hatch prompts the user to temporarily connect to a network in order to refresh
   * the device policy. After applying policy, the temporary network will be forgotten and the
   * device will continue booting. This prevents being unable to connect to a network if there is no
   * suitable network in the last policy and the device boots into an app in lock task mode, or the
   * user is otherwise unable to reach device settings.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean networkEscapeHatchEnabled;

  /**
   * Whether resetting network settings is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean networkResetDisabled;

  /**
   * Network configuration for the device. See configure networks for more information.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.Map<String, java.lang.Object> openNetworkConfiguration;

  /**
   * Whether using NFC to beam data from apps is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean outgoingBeamDisabled;

  /**
   * Whether outgoing calls are disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean outgoingCallsDisabled;

  /**
   * Password requirement policies. Different policies can be set for work profile or fully managed
   * devices by setting the password_scope field in the policy.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<PasswordRequirements> passwordPolicies;

  static {
    // hack to force ProGuard to consider PasswordRequirements used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(PasswordRequirements.class);
  }

  /**
   * Password requirements. DEPRECATED - Use password_policies
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private PasswordRequirements passwordRequirements;

  /**
   * Explicit permission or group grants or denials for all apps. These values override the
   * default_permission_policy.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<PermissionGrant> permissionGrants;

  static {
    // hack to force ProGuard to consider PermissionGrant used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(PermissionGrant.class);
  }

  /**
   * If present, only the input methods provided by packages in this list are permitted. If this
   * field is present, but the list is empty, then only system input methods are permitted.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private PackageNameList permittedInputMethods;

  /**
   * Default intent handler activities.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<PersistentPreferredActivity> persistentPreferredActivities;

  static {
    // hack to force ProGuard to consider PersistentPreferredActivity used, since otherwise it would be stripped out
    // see https://github.com/google/google-api-java-client/issues/543
    com.google.api.client.util.Data.nullOf(PersistentPreferredActivity.class);
  }

  /**
   * This mode controls which apps are available to the user in the Play Store and the behavior on
   * the device when apps are removed from the policy.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String playStoreMode;

  /**
   * Rules that define the behavior when a particular policy can not be applied on device
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<PolicyEnforcementRule> policyEnforcementRules;

  /**
   * Allows showing UI on a device for a user to choose a private key alias if there are no matching
   * rules in ChoosePrivateKeyRules. For devices below Android P, setting this may leave enterprise
   * keys vulnerable.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean privateKeySelectionEnabled;

  /**
   * The network-independent global HTTP proxy. Typically proxies should be configured per-network
   * in open_network_configuration. However for unusual configurations like general internal
   * filtering a global HTTP proxy may be useful. If the proxy is not accessible, network access may
   * break. The global proxy is only a recommendation and some apps may ignore it.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private ProxyInfo recommendedGlobalProxy;

  /**
   * Whether removing other users is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean removeUserDisabled;

  /**
   * Whether rebooting the device into safe boot is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean safeBootDisabled;

  /**
   * Whether screen capture is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean screenCaptureDisabled;

  /**
   * Whether changing the user icon is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean setUserIconDisabled;

  /**
   * Whether changing the wallpaper is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean setWallpaperDisabled;

  /**
   * Actions to take during the setup process.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<SetupAction> setupActions;

  /**
   * Whether location sharing is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean shareLocationDisabled;

  /**
   * A message displayed to the user in the settings screen wherever functionality has been disabled
   * by the admin.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private UserFacingMessage shortSupportMessage;

  /**
   * Flag to skip hints on the first use. Enterprise admin can enable the system recommendation for
   * apps to skip their user tutorial and other introductory hints on first start-up.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean skipFirstUseHintsEnabled;

  /**
   * Whether sending and receiving SMS messages is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean smsDisabled;

  /**
   * Whether the status bar is disabled. This disables notifications, quick settings, and other
   * screen overlays that allow escape from full-screen mode.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean statusBarDisabled;

  /**
   * Status reporting settings
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private StatusReportingSettings statusReportingSettings;

  /**
   * The battery plugged in modes for which the device stays on. When using this setting, it is
   * recommended to clear maximum_time_to_lock so that the device doesn't lock itself while it stays
   * on.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<java.lang.String> stayOnPluggedModes;

  /**
   * The system update policy, which controls how OS updates are applied. If the update type is
   * WINDOWED, the update window will automatically apply to Play app updates as well.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private SystemUpdate systemUpdate;

  /**
   * Whether configuring tethering and portable hotspots is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean tetheringConfigDisabled;

  /**
   * Whether user uninstallation of applications is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean uninstallAppsDisabled;

  /**
   * Whether the microphone is muted and adjusting microphone volume is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean unmuteMicrophoneDisabled;

  /**
   * Whether transferring files over USB is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean usbFileTransferDisabled;

  /**
   * Whether USB storage is enabled. Deprecated.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean usbMassStorageEnabled;

  /**
   * The version of the policy. This is a read-only field. The version is incremented each time the
   * policy is updated.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.lang.Long version;

  /**
   * Whether configuring VPN is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean vpnConfigDisabled;

  /**
   * Whether configuring Wi-Fi access points is disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean wifiConfigDisabled;

  /**
   * DEPRECATED - Use wifi_config_disabled.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.Boolean wifiConfigsLockdownEnabled;

  /**
   * Account types that can't be managed by the user.
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.String> getAccountTypesWithManagementDisabled() {
    return accountTypesWithManagementDisabled;
  }

  /**
   * Account types that can't be managed by the user.
   * @param accountTypesWithManagementDisabled accountTypesWithManagementDisabled or {@code null} for none
   */
  public Policy setAccountTypesWithManagementDisabled(java.util.List<java.lang.String> accountTypesWithManagementDisabled) {
    this.accountTypesWithManagementDisabled = accountTypesWithManagementDisabled;
    return this;
  }

  /**
   * Whether adding new users and profiles is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getAddUserDisabled() {
    return addUserDisabled;
  }

  /**
   * Whether adding new users and profiles is disabled.
   * @param addUserDisabled addUserDisabled or {@code null} for none
   */
  public Policy setAddUserDisabled(java.lang.Boolean addUserDisabled) {
    this.addUserDisabled = addUserDisabled;
    return this;
  }

  /**
   * Whether adjusting the master volume is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getAdjustVolumeDisabled() {
    return adjustVolumeDisabled;
  }

  /**
   * Whether adjusting the master volume is disabled.
   * @param adjustVolumeDisabled adjustVolumeDisabled or {@code null} for none
   */
  public Policy setAdjustVolumeDisabled(java.lang.Boolean adjustVolumeDisabled) {
    this.adjustVolumeDisabled = adjustVolumeDisabled;
    return this;
  }

  /**
   * Configuration for an always-on VPN connection. Use with vpn_config_disabled to prevent
   * modification of this setting.
   * @return value or {@code null} for none
   */
  public AlwaysOnVpnPackage getAlwaysOnVpnPackage() {
    return alwaysOnVpnPackage;
  }

  /**
   * Configuration for an always-on VPN connection. Use with vpn_config_disabled to prevent
   * modification of this setting.
   * @param alwaysOnVpnPackage alwaysOnVpnPackage or {@code null} for none
   */
  public Policy setAlwaysOnVpnPackage(AlwaysOnVpnPackage alwaysOnVpnPackage) {
    this.alwaysOnVpnPackage = alwaysOnVpnPackage;
    return this;
  }

  /**
   * The app tracks for Android Device Policy the device can access. The device receives the latest
   * version among all accessible tracks. If no tracks are specified, then the device only uses the
   * production track.
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.String> getAndroidDevicePolicyTracks() {
    return androidDevicePolicyTracks;
  }

  /**
   * The app tracks for Android Device Policy the device can access. The device receives the latest
   * version among all accessible tracks. If no tracks are specified, then the device only uses the
   * production track.
   * @param androidDevicePolicyTracks androidDevicePolicyTracks or {@code null} for none
   */
  public Policy setAndroidDevicePolicyTracks(java.util.List<java.lang.String> androidDevicePolicyTracks) {
    this.androidDevicePolicyTracks = androidDevicePolicyTracks;
    return this;
  }

  /**
   * The app auto update policy, which controls when automatic app updates can be applied.
   * @return value or {@code null} for none
   */
  public java.lang.String getAppAutoUpdatePolicy() {
    return appAutoUpdatePolicy;
  }

  /**
   * The app auto update policy, which controls when automatic app updates can be applied.
   * @param appAutoUpdatePolicy appAutoUpdatePolicy or {@code null} for none
   */
  public Policy setAppAutoUpdatePolicy(java.lang.String appAutoUpdatePolicy) {
    this.appAutoUpdatePolicy = appAutoUpdatePolicy;
    return this;
  }

  /**
   * Policy applied to apps.
   * @return value or {@code null} for none
   */
  public java.util.List<ApplicationPolicy> getApplications() {
    return applications;
  }

  /**
   * Policy applied to apps.
   * @param applications applications or {@code null} for none
   */
  public Policy setApplications(java.util.List<ApplicationPolicy> applications) {
    this.applications = applications;
    return this;
  }

  /**
   * Whether auto time is required, which prevents the user from manually setting the date and time.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getAutoTimeRequired() {
    return autoTimeRequired;
  }

  /**
   * Whether auto time is required, which prevents the user from manually setting the date and time.
   * @param autoTimeRequired autoTimeRequired or {@code null} for none
   */
  public Policy setAutoTimeRequired(java.lang.Boolean autoTimeRequired) {
    this.autoTimeRequired = autoTimeRequired;
    return this;
  }

  /**
   * Whether applications other than the ones configured in applications are blocked from being
   * installed. When set, applications that were installed under a previous policy but no longer
   * appear in the policy are automatically uninstalled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getBlockApplicationsEnabled() {
    return blockApplicationsEnabled;
  }

  /**
   * Whether applications other than the ones configured in applications are blocked from being
   * installed. When set, applications that were installed under a previous policy but no longer
   * appear in the policy are automatically uninstalled.
   * @param blockApplicationsEnabled blockApplicationsEnabled or {@code null} for none
   */
  public Policy setBlockApplicationsEnabled(java.lang.Boolean blockApplicationsEnabled) {
    this.blockApplicationsEnabled = blockApplicationsEnabled;
    return this;
  }

  /**
   * Whether configuring bluetooth is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getBluetoothConfigDisabled() {
    return bluetoothConfigDisabled;
  }

  /**
   * Whether configuring bluetooth is disabled.
   * @param bluetoothConfigDisabled bluetoothConfigDisabled or {@code null} for none
   */
  public Policy setBluetoothConfigDisabled(java.lang.Boolean bluetoothConfigDisabled) {
    this.bluetoothConfigDisabled = bluetoothConfigDisabled;
    return this;
  }

  /**
   * Whether bluetooth contact sharing is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getBluetoothContactSharingDisabled() {
    return bluetoothContactSharingDisabled;
  }

  /**
   * Whether bluetooth contact sharing is disabled.
   * @param bluetoothContactSharingDisabled bluetoothContactSharingDisabled or {@code null} for none
   */
  public Policy setBluetoothContactSharingDisabled(java.lang.Boolean bluetoothContactSharingDisabled) {
    this.bluetoothContactSharingDisabled = bluetoothContactSharingDisabled;
    return this;
  }

  /**
   * Whether bluetooth is disabled. Prefer this setting over bluetooth_config_disabled because
   * bluetooth_config_disabled can be bypassed by the user.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getBluetoothDisabled() {
    return bluetoothDisabled;
  }

  /**
   * Whether bluetooth is disabled. Prefer this setting over bluetooth_config_disabled because
   * bluetooth_config_disabled can be bypassed by the user.
   * @param bluetoothDisabled bluetoothDisabled or {@code null} for none
   */
  public Policy setBluetoothDisabled(java.lang.Boolean bluetoothDisabled) {
    this.bluetoothDisabled = bluetoothDisabled;
    return this;
  }

  /**
   * Whether all cameras on the device are disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getCameraDisabled() {
    return cameraDisabled;
  }

  /**
   * Whether all cameras on the device are disabled.
   * @param cameraDisabled cameraDisabled or {@code null} for none
   */
  public Policy setCameraDisabled(java.lang.Boolean cameraDisabled) {
    this.cameraDisabled = cameraDisabled;
    return this;
  }

  /**
   * Whether configuring cell broadcast is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getCellBroadcastsConfigDisabled() {
    return cellBroadcastsConfigDisabled;
  }

  /**
   * Whether configuring cell broadcast is disabled.
   * @param cellBroadcastsConfigDisabled cellBroadcastsConfigDisabled or {@code null} for none
   */
  public Policy setCellBroadcastsConfigDisabled(java.lang.Boolean cellBroadcastsConfigDisabled) {
    this.cellBroadcastsConfigDisabled = cellBroadcastsConfigDisabled;
    return this;
  }

  /**
   * Rules for automatically choosing a private key and certificate to authenticate the device to a
   * server. The rules are ordered by increasing precedence, so if an outgoing request matches more
   * than one rule, the last rule defines which private key to use.
   * @return value or {@code null} for none
   */
  public java.util.List<ChoosePrivateKeyRule> getChoosePrivateKeyRules() {
    return choosePrivateKeyRules;
  }

  /**
   * Rules for automatically choosing a private key and certificate to authenticate the device to a
   * server. The rules are ordered by increasing precedence, so if an outgoing request matches more
   * than one rule, the last rule defines which private key to use.
   * @param choosePrivateKeyRules choosePrivateKeyRules or {@code null} for none
   */
  public Policy setChoosePrivateKeyRules(java.util.List<ChoosePrivateKeyRule> choosePrivateKeyRules) {
    this.choosePrivateKeyRules = choosePrivateKeyRules;
    return this;
  }

  /**
   * Rules declaring which mitigating actions to take when a device is not compliant with its
   * policy. When the conditions for multiple rules are satisfied, all of the mitigating actions for
   * the rules are taken. There is a maximum limit of 100 rules. Use policy enforcement rules
   * instead.
   * @return value or {@code null} for none
   */
  public java.util.List<ComplianceRule> getComplianceRules() {
    return complianceRules;
  }

  /**
   * Rules declaring which mitigating actions to take when a device is not compliant with its
   * policy. When the conditions for multiple rules are satisfied, all of the mitigating actions for
   * the rules are taken. There is a maximum limit of 100 rules. Use policy enforcement rules
   * instead.
   * @param complianceRules complianceRules or {@code null} for none
   */
  public Policy setComplianceRules(java.util.List<ComplianceRule> complianceRules) {
    this.complianceRules = complianceRules;
    return this;
  }

  /**
   * Whether creating windows besides app windows is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getCreateWindowsDisabled() {
    return createWindowsDisabled;
  }

  /**
   * Whether creating windows besides app windows is disabled.
   * @param createWindowsDisabled createWindowsDisabled or {@code null} for none
   */
  public Policy setCreateWindowsDisabled(java.lang.Boolean createWindowsDisabled) {
    this.createWindowsDisabled = createWindowsDisabled;
    return this;
  }

  /**
   * Whether configuring user credentials is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getCredentialsConfigDisabled() {
    return credentialsConfigDisabled;
  }

  /**
   * Whether configuring user credentials is disabled.
   * @param credentialsConfigDisabled credentialsConfigDisabled or {@code null} for none
   */
  public Policy setCredentialsConfigDisabled(java.lang.Boolean credentialsConfigDisabled) {
    this.credentialsConfigDisabled = credentialsConfigDisabled;
    return this;
  }

  /**
   * Whether roaming data services are disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getDataRoamingDisabled() {
    return dataRoamingDisabled;
  }

  /**
   * Whether roaming data services are disabled.
   * @param dataRoamingDisabled dataRoamingDisabled or {@code null} for none
   */
  public Policy setDataRoamingDisabled(java.lang.Boolean dataRoamingDisabled) {
    this.dataRoamingDisabled = dataRoamingDisabled;
    return this;
  }

  /**
   * Whether the user is allowed to enable debugging features.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getDebuggingFeaturesAllowed() {
    return debuggingFeaturesAllowed;
  }

  /**
   * Whether the user is allowed to enable debugging features.
   * @param debuggingFeaturesAllowed debuggingFeaturesAllowed or {@code null} for none
   */
  public Policy setDebuggingFeaturesAllowed(java.lang.Boolean debuggingFeaturesAllowed) {
    this.debuggingFeaturesAllowed = debuggingFeaturesAllowed;
    return this;
  }

  /**
   * The default permission policy for runtime permission requests.
   * @return value or {@code null} for none
   */
  public java.lang.String getDefaultPermissionPolicy() {
    return defaultPermissionPolicy;
  }

  /**
   * The default permission policy for runtime permission requests.
   * @param defaultPermissionPolicy defaultPermissionPolicy or {@code null} for none
   */
  public Policy setDefaultPermissionPolicy(java.lang.String defaultPermissionPolicy) {
    this.defaultPermissionPolicy = defaultPermissionPolicy;
    return this;
  }

  /**
   * The device owner information to be shown on the lock screen.
   * @return value or {@code null} for none
   */
  public UserFacingMessage getDeviceOwnerLockScreenInfo() {
    return deviceOwnerLockScreenInfo;
  }

  /**
   * The device owner information to be shown on the lock screen.
   * @param deviceOwnerLockScreenInfo deviceOwnerLockScreenInfo or {@code null} for none
   */
  public Policy setDeviceOwnerLockScreenInfo(UserFacingMessage deviceOwnerLockScreenInfo) {
    this.deviceOwnerLockScreenInfo = deviceOwnerLockScreenInfo;
    return this;
  }

  /**
   * Whether encryption is enabled
   * @return value or {@code null} for none
   */
  public java.lang.String getEncryptionPolicy() {
    return encryptionPolicy;
  }

  /**
   * Whether encryption is enabled
   * @param encryptionPolicy encryptionPolicy or {@code null} for none
   */
  public Policy setEncryptionPolicy(java.lang.String encryptionPolicy) {
    this.encryptionPolicy = encryptionPolicy;
    return this;
  }

  /**
   * Whether app verification is force-enabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getEnsureVerifyAppsEnabled() {
    return ensureVerifyAppsEnabled;
  }

  /**
   * Whether app verification is force-enabled.
   * @param ensureVerifyAppsEnabled ensureVerifyAppsEnabled or {@code null} for none
   */
  public Policy setEnsureVerifyAppsEnabled(java.lang.Boolean ensureVerifyAppsEnabled) {
    this.ensureVerifyAppsEnabled = ensureVerifyAppsEnabled;
    return this;
  }

  /**
   * Whether factory resetting from settings is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getFactoryResetDisabled() {
    return factoryResetDisabled;
  }

  /**
   * Whether factory resetting from settings is disabled.
   * @param factoryResetDisabled factoryResetDisabled or {@code null} for none
   */
  public Policy setFactoryResetDisabled(java.lang.Boolean factoryResetDisabled) {
    this.factoryResetDisabled = factoryResetDisabled;
    return this;
  }

  /**
   * Email addresses of device administrators for factory reset protection. When the device is
   * factory reset, it will require one of these admins to log in with the Google account email and
   * password to unlock the device. If no admins are specified, the device won't provide factory
   * reset protection.
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.String> getFrpAdminEmails() {
    return frpAdminEmails;
  }

  /**
   * Email addresses of device administrators for factory reset protection. When the device is
   * factory reset, it will require one of these admins to log in with the Google account email and
   * password to unlock the device. If no admins are specified, the device won't provide factory
   * reset protection.
   * @param frpAdminEmails frpAdminEmails or {@code null} for none
   */
  public Policy setFrpAdminEmails(java.util.List<java.lang.String> frpAdminEmails) {
    this.frpAdminEmails = frpAdminEmails;
    return this;
  }

  /**
   * Whether the user is allowed to have fun. Controls whether the Easter egg game in Settings is
   * disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getFunDisabled() {
    return funDisabled;
  }

  /**
   * Whether the user is allowed to have fun. Controls whether the Easter egg game in Settings is
   * disabled.
   * @param funDisabled funDisabled or {@code null} for none
   */
  public Policy setFunDisabled(java.lang.Boolean funDisabled) {
    this.funDisabled = funDisabled;
    return this;
  }

  /**
   * Whether user installation of apps is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getInstallAppsDisabled() {
    return installAppsDisabled;
  }

  /**
   * Whether user installation of apps is disabled.
   * @param installAppsDisabled installAppsDisabled or {@code null} for none
   */
  public Policy setInstallAppsDisabled(java.lang.Boolean installAppsDisabled) {
    this.installAppsDisabled = installAppsDisabled;
    return this;
  }

  /**
   * Whether the user is allowed to enable the "Unknown Sources" setting, which allows installation
   * of apps from unknown sources.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getInstallUnknownSourcesAllowed() {
    return installUnknownSourcesAllowed;
  }

  /**
   * Whether the user is allowed to enable the "Unknown Sources" setting, which allows installation
   * of apps from unknown sources.
   * @param installUnknownSourcesAllowed installUnknownSourcesAllowed or {@code null} for none
   */
  public Policy setInstallUnknownSourcesAllowed(java.lang.Boolean installUnknownSourcesAllowed) {
    this.installUnknownSourcesAllowed = installUnknownSourcesAllowed;
    return this;
  }

  /**
   * Whether the keyguard is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getKeyguardDisabled() {
    return keyguardDisabled;
  }

  /**
   * Whether the keyguard is disabled.
   * @param keyguardDisabled keyguardDisabled or {@code null} for none
   */
  public Policy setKeyguardDisabled(java.lang.Boolean keyguardDisabled) {
    this.keyguardDisabled = keyguardDisabled;
    return this;
  }

  /**
   * Disabled keyguard customizations, such as widgets.
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.String> getKeyguardDisabledFeatures() {
    return keyguardDisabledFeatures;
  }

  /**
   * Disabled keyguard customizations, such as widgets.
   * @param keyguardDisabledFeatures keyguardDisabledFeatures or {@code null} for none
   */
  public Policy setKeyguardDisabledFeatures(java.util.List<java.lang.String> keyguardDisabledFeatures) {
    this.keyguardDisabledFeatures = keyguardDisabledFeatures;
    return this;
  }

  /**
   * Whether the kiosk custom launcher is enabled. This replaces the home screen with a launcher
   * that locks down the device to the apps installed via the applications setting. The apps appear
   * on a single page in alphabetical order. It is recommended to also use status_bar_disabled to
   * block access to device settings.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getKioskCustomLauncherEnabled() {
    return kioskCustomLauncherEnabled;
  }

  /**
   * Whether the kiosk custom launcher is enabled. This replaces the home screen with a launcher
   * that locks down the device to the apps installed via the applications setting. The apps appear
   * on a single page in alphabetical order. It is recommended to also use status_bar_disabled to
   * block access to device settings.
   * @param kioskCustomLauncherEnabled kioskCustomLauncherEnabled or {@code null} for none
   */
  public Policy setKioskCustomLauncherEnabled(java.lang.Boolean kioskCustomLauncherEnabled) {
    this.kioskCustomLauncherEnabled = kioskCustomLauncherEnabled;
    return this;
  }

  /**
   * The degree of location detection enabled. The user may change the value unless the user is
   * otherwise blocked from accessing device settings.
   * @return value or {@code null} for none
   */
  public java.lang.String getLocationMode() {
    return locationMode;
  }

  /**
   * The degree of location detection enabled. The user may change the value unless the user is
   * otherwise blocked from accessing device settings.
   * @param locationMode locationMode or {@code null} for none
   */
  public Policy setLocationMode(java.lang.String locationMode) {
    this.locationMode = locationMode;
    return this;
  }

  /**
   * A message displayed to the user in the device administators settings screen.
   * @return value or {@code null} for none
   */
  public UserFacingMessage getLongSupportMessage() {
    return longSupportMessage;
  }

  /**
   * A message displayed to the user in the device administators settings screen.
   * @param longSupportMessage longSupportMessage or {@code null} for none
   */
  public Policy setLongSupportMessage(UserFacingMessage longSupportMessage) {
    this.longSupportMessage = longSupportMessage;
    return this;
  }

  /**
   * Maximum time in milliseconds for user activity until the device locks. A value of 0 means there
   * is no restriction.
   * @return value or {@code null} for none
   */
  public java.lang.Long getMaximumTimeToLock() {
    return maximumTimeToLock;
  }

  /**
   * Maximum time in milliseconds for user activity until the device locks. A value of 0 means there
   * is no restriction.
   * @param maximumTimeToLock maximumTimeToLock or {@code null} for none
   */
  public Policy setMaximumTimeToLock(java.lang.Long maximumTimeToLock) {
    this.maximumTimeToLock = maximumTimeToLock;
    return this;
  }

  /**
   * The minimum allowed Android API level.
   * @return value or {@code null} for none
   */
  public java.lang.Integer getMinimumApiLevel() {
    return minimumApiLevel;
  }

  /**
   * The minimum allowed Android API level.
   * @param minimumApiLevel minimumApiLevel or {@code null} for none
   */
  public Policy setMinimumApiLevel(java.lang.Integer minimumApiLevel) {
    this.minimumApiLevel = minimumApiLevel;
    return this;
  }

  /**
   * Whether configuring mobile networks is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getMobileNetworksConfigDisabled() {
    return mobileNetworksConfigDisabled;
  }

  /**
   * Whether configuring mobile networks is disabled.
   * @param mobileNetworksConfigDisabled mobileNetworksConfigDisabled or {@code null} for none
   */
  public Policy setMobileNetworksConfigDisabled(java.lang.Boolean mobileNetworksConfigDisabled) {
    this.mobileNetworksConfigDisabled = mobileNetworksConfigDisabled;
    return this;
  }

  /**
   * Whether adding or removing accounts is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getModifyAccountsDisabled() {
    return modifyAccountsDisabled;
  }

  /**
   * Whether adding or removing accounts is disabled.
   * @param modifyAccountsDisabled modifyAccountsDisabled or {@code null} for none
   */
  public Policy setModifyAccountsDisabled(java.lang.Boolean modifyAccountsDisabled) {
    this.modifyAccountsDisabled = modifyAccountsDisabled;
    return this;
  }

  /**
   * Whether the user mounting physical external media is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getMountPhysicalMediaDisabled() {
    return mountPhysicalMediaDisabled;
  }

  /**
   * Whether the user mounting physical external media is disabled.
   * @param mountPhysicalMediaDisabled mountPhysicalMediaDisabled or {@code null} for none
   */
  public Policy setMountPhysicalMediaDisabled(java.lang.Boolean mountPhysicalMediaDisabled) {
    this.mountPhysicalMediaDisabled = mountPhysicalMediaDisabled;
    return this;
  }

  /**
   * The name of the policy in the form enterprises/{enterpriseId}/policies/{policyId}.
   * @return value or {@code null} for none
   */
  public java.lang.String getName() {
    return name;
  }

  /**
   * The name of the policy in the form enterprises/{enterpriseId}/policies/{policyId}.
   * @param name name or {@code null} for none
   */
  public Policy setName(java.lang.String name) {
    this.name = name;
    return this;
  }

  /**
   * Whether the network escape hatch is enabled. If a network connection can't be made at boot
   * time, the escape hatch prompts the user to temporarily connect to a network in order to refresh
   * the device policy. After applying policy, the temporary network will be forgotten and the
   * device will continue booting. This prevents being unable to connect to a network if there is no
   * suitable network in the last policy and the device boots into an app in lock task mode, or the
   * user is otherwise unable to reach device settings.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getNetworkEscapeHatchEnabled() {
    return networkEscapeHatchEnabled;
  }

  /**
   * Whether the network escape hatch is enabled. If a network connection can't be made at boot
   * time, the escape hatch prompts the user to temporarily connect to a network in order to refresh
   * the device policy. After applying policy, the temporary network will be forgotten and the
   * device will continue booting. This prevents being unable to connect to a network if there is no
   * suitable network in the last policy and the device boots into an app in lock task mode, or the
   * user is otherwise unable to reach device settings.
   * @param networkEscapeHatchEnabled networkEscapeHatchEnabled or {@code null} for none
   */
  public Policy setNetworkEscapeHatchEnabled(java.lang.Boolean networkEscapeHatchEnabled) {
    this.networkEscapeHatchEnabled = networkEscapeHatchEnabled;
    return this;
  }

  /**
   * Whether resetting network settings is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getNetworkResetDisabled() {
    return networkResetDisabled;
  }

  /**
   * Whether resetting network settings is disabled.
   * @param networkResetDisabled networkResetDisabled or {@code null} for none
   */
  public Policy setNetworkResetDisabled(java.lang.Boolean networkResetDisabled) {
    this.networkResetDisabled = networkResetDisabled;
    return this;
  }

  /**
   * Network configuration for the device. See configure networks for more information.
   * @return value or {@code null} for none
   */
  public java.util.Map<String, java.lang.Object> getOpenNetworkConfiguration() {
    return openNetworkConfiguration;
  }

  /**
   * Network configuration for the device. See configure networks for more information.
   * @param openNetworkConfiguration openNetworkConfiguration or {@code null} for none
   */
  public Policy setOpenNetworkConfiguration(java.util.Map<String, java.lang.Object> openNetworkConfiguration) {
    this.openNetworkConfiguration = openNetworkConfiguration;
    return this;
  }

  /**
   * Whether using NFC to beam data from apps is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getOutgoingBeamDisabled() {
    return outgoingBeamDisabled;
  }

  /**
   * Whether using NFC to beam data from apps is disabled.
   * @param outgoingBeamDisabled outgoingBeamDisabled or {@code null} for none
   */
  public Policy setOutgoingBeamDisabled(java.lang.Boolean outgoingBeamDisabled) {
    this.outgoingBeamDisabled = outgoingBeamDisabled;
    return this;
  }

  /**
   * Whether outgoing calls are disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getOutgoingCallsDisabled() {
    return outgoingCallsDisabled;
  }

  /**
   * Whether outgoing calls are disabled.
   * @param outgoingCallsDisabled outgoingCallsDisabled or {@code null} for none
   */
  public Policy setOutgoingCallsDisabled(java.lang.Boolean outgoingCallsDisabled) {
    this.outgoingCallsDisabled = outgoingCallsDisabled;
    return this;
  }

  /**
   * Password requirement policies. Different policies can be set for work profile or fully managed
   * devices by setting the password_scope field in the policy.
   * @return value or {@code null} for none
   */
  public java.util.List<PasswordRequirements> getPasswordPolicies() {
    return passwordPolicies;
  }

  /**
   * Password requirement policies. Different policies can be set for work profile or fully managed
   * devices by setting the password_scope field in the policy.
   * @param passwordPolicies passwordPolicies or {@code null} for none
   */
  public Policy setPasswordPolicies(java.util.List<PasswordRequirements> passwordPolicies) {
    this.passwordPolicies = passwordPolicies;
    return this;
  }

  /**
   * Password requirements. DEPRECATED - Use password_policies
   * @return value or {@code null} for none
   */
  public PasswordRequirements getPasswordRequirements() {
    return passwordRequirements;
  }

  /**
   * Password requirements. DEPRECATED - Use password_policies
   * @param passwordRequirements passwordRequirements or {@code null} for none
   */
  public Policy setPasswordRequirements(PasswordRequirements passwordRequirements) {
    this.passwordRequirements = passwordRequirements;
    return this;
  }

  /**
   * Explicit permission or group grants or denials for all apps. These values override the
   * default_permission_policy.
   * @return value or {@code null} for none
   */
  public java.util.List<PermissionGrant> getPermissionGrants() {
    return permissionGrants;
  }

  /**
   * Explicit permission or group grants or denials for all apps. These values override the
   * default_permission_policy.
   * @param permissionGrants permissionGrants or {@code null} for none
   */
  public Policy setPermissionGrants(java.util.List<PermissionGrant> permissionGrants) {
    this.permissionGrants = permissionGrants;
    return this;
  }

  /**
   * If present, only the input methods provided by packages in this list are permitted. If this
   * field is present, but the list is empty, then only system input methods are permitted.
   * @return value or {@code null} for none
   */
  public PackageNameList getPermittedInputMethods() {
    return permittedInputMethods;
  }

  /**
   * If present, only the input methods provided by packages in this list are permitted. If this
   * field is present, but the list is empty, then only system input methods are permitted.
   * @param permittedInputMethods permittedInputMethods or {@code null} for none
   */
  public Policy setPermittedInputMethods(PackageNameList permittedInputMethods) {
    this.permittedInputMethods = permittedInputMethods;
    return this;
  }

  /**
   * Default intent handler activities.
   * @return value or {@code null} for none
   */
  public java.util.List<PersistentPreferredActivity> getPersistentPreferredActivities() {
    return persistentPreferredActivities;
  }

  /**
   * Default intent handler activities.
   * @param persistentPreferredActivities persistentPreferredActivities or {@code null} for none
   */
  public Policy setPersistentPreferredActivities(java.util.List<PersistentPreferredActivity> persistentPreferredActivities) {
    this.persistentPreferredActivities = persistentPreferredActivities;
    return this;
  }

  /**
   * This mode controls which apps are available to the user in the Play Store and the behavior on
   * the device when apps are removed from the policy.
   * @return value or {@code null} for none
   */
  public java.lang.String getPlayStoreMode() {
    return playStoreMode;
  }

  /**
   * This mode controls which apps are available to the user in the Play Store and the behavior on
   * the device when apps are removed from the policy.
   * @param playStoreMode playStoreMode or {@code null} for none
   */
  public Policy setPlayStoreMode(java.lang.String playStoreMode) {
    this.playStoreMode = playStoreMode;
    return this;
  }

  /**
   * Rules that define the behavior when a particular policy can not be applied on device
   * @return value or {@code null} for none
   */
  public java.util.List<PolicyEnforcementRule> getPolicyEnforcementRules() {
    return policyEnforcementRules;
  }

  /**
   * Rules that define the behavior when a particular policy can not be applied on device
   * @param policyEnforcementRules policyEnforcementRules or {@code null} for none
   */
  public Policy setPolicyEnforcementRules(java.util.List<PolicyEnforcementRule> policyEnforcementRules) {
    this.policyEnforcementRules = policyEnforcementRules;
    return this;
  }

  /**
   * Allows showing UI on a device for a user to choose a private key alias if there are no matching
   * rules in ChoosePrivateKeyRules. For devices below Android P, setting this may leave enterprise
   * keys vulnerable.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getPrivateKeySelectionEnabled() {
    return privateKeySelectionEnabled;
  }

  /**
   * Allows showing UI on a device for a user to choose a private key alias if there are no matching
   * rules in ChoosePrivateKeyRules. For devices below Android P, setting this may leave enterprise
   * keys vulnerable.
   * @param privateKeySelectionEnabled privateKeySelectionEnabled or {@code null} for none
   */
  public Policy setPrivateKeySelectionEnabled(java.lang.Boolean privateKeySelectionEnabled) {
    this.privateKeySelectionEnabled = privateKeySelectionEnabled;
    return this;
  }

  /**
   * The network-independent global HTTP proxy. Typically proxies should be configured per-network
   * in open_network_configuration. However for unusual configurations like general internal
   * filtering a global HTTP proxy may be useful. If the proxy is not accessible, network access may
   * break. The global proxy is only a recommendation and some apps may ignore it.
   * @return value or {@code null} for none
   */
  public ProxyInfo getRecommendedGlobalProxy() {
    return recommendedGlobalProxy;
  }

  /**
   * The network-independent global HTTP proxy. Typically proxies should be configured per-network
   * in open_network_configuration. However for unusual configurations like general internal
   * filtering a global HTTP proxy may be useful. If the proxy is not accessible, network access may
   * break. The global proxy is only a recommendation and some apps may ignore it.
   * @param recommendedGlobalProxy recommendedGlobalProxy or {@code null} for none
   */
  public Policy setRecommendedGlobalProxy(ProxyInfo recommendedGlobalProxy) {
    this.recommendedGlobalProxy = recommendedGlobalProxy;
    return this;
  }

  /**
   * Whether removing other users is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getRemoveUserDisabled() {
    return removeUserDisabled;
  }

  /**
   * Whether removing other users is disabled.
   * @param removeUserDisabled removeUserDisabled or {@code null} for none
   */
  public Policy setRemoveUserDisabled(java.lang.Boolean removeUserDisabled) {
    this.removeUserDisabled = removeUserDisabled;
    return this;
  }

  /**
   * Whether rebooting the device into safe boot is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getSafeBootDisabled() {
    return safeBootDisabled;
  }

  /**
   * Whether rebooting the device into safe boot is disabled.
   * @param safeBootDisabled safeBootDisabled or {@code null} for none
   */
  public Policy setSafeBootDisabled(java.lang.Boolean safeBootDisabled) {
    this.safeBootDisabled = safeBootDisabled;
    return this;
  }

  /**
   * Whether screen capture is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getScreenCaptureDisabled() {
    return screenCaptureDisabled;
  }

  /**
   * Whether screen capture is disabled.
   * @param screenCaptureDisabled screenCaptureDisabled or {@code null} for none
   */
  public Policy setScreenCaptureDisabled(java.lang.Boolean screenCaptureDisabled) {
    this.screenCaptureDisabled = screenCaptureDisabled;
    return this;
  }

  /**
   * Whether changing the user icon is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getSetUserIconDisabled() {
    return setUserIconDisabled;
  }

  /**
   * Whether changing the user icon is disabled.
   * @param setUserIconDisabled setUserIconDisabled or {@code null} for none
   */
  public Policy setSetUserIconDisabled(java.lang.Boolean setUserIconDisabled) {
    this.setUserIconDisabled = setUserIconDisabled;
    return this;
  }

  /**
   * Whether changing the wallpaper is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getSetWallpaperDisabled() {
    return setWallpaperDisabled;
  }

  /**
   * Whether changing the wallpaper is disabled.
   * @param setWallpaperDisabled setWallpaperDisabled or {@code null} for none
   */
  public Policy setSetWallpaperDisabled(java.lang.Boolean setWallpaperDisabled) {
    this.setWallpaperDisabled = setWallpaperDisabled;
    return this;
  }

  /**
   * Actions to take during the setup process.
   * @return value or {@code null} for none
   */
  public java.util.List<SetupAction> getSetupActions() {
    return setupActions;
  }

  /**
   * Actions to take during the setup process.
   * @param setupActions setupActions or {@code null} for none
   */
  public Policy setSetupActions(java.util.List<SetupAction> setupActions) {
    this.setupActions = setupActions;
    return this;
  }

  /**
   * Whether location sharing is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getShareLocationDisabled() {
    return shareLocationDisabled;
  }

  /**
   * Whether location sharing is disabled.
   * @param shareLocationDisabled shareLocationDisabled or {@code null} for none
   */
  public Policy setShareLocationDisabled(java.lang.Boolean shareLocationDisabled) {
    this.shareLocationDisabled = shareLocationDisabled;
    return this;
  }

  /**
   * A message displayed to the user in the settings screen wherever functionality has been disabled
   * by the admin.
   * @return value or {@code null} for none
   */
  public UserFacingMessage getShortSupportMessage() {
    return shortSupportMessage;
  }

  /**
   * A message displayed to the user in the settings screen wherever functionality has been disabled
   * by the admin.
   * @param shortSupportMessage shortSupportMessage or {@code null} for none
   */
  public Policy setShortSupportMessage(UserFacingMessage shortSupportMessage) {
    this.shortSupportMessage = shortSupportMessage;
    return this;
  }

  /**
   * Flag to skip hints on the first use. Enterprise admin can enable the system recommendation for
   * apps to skip their user tutorial and other introductory hints on first start-up.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getSkipFirstUseHintsEnabled() {
    return skipFirstUseHintsEnabled;
  }

  /**
   * Flag to skip hints on the first use. Enterprise admin can enable the system recommendation for
   * apps to skip their user tutorial and other introductory hints on first start-up.
   * @param skipFirstUseHintsEnabled skipFirstUseHintsEnabled or {@code null} for none
   */
  public Policy setSkipFirstUseHintsEnabled(java.lang.Boolean skipFirstUseHintsEnabled) {
    this.skipFirstUseHintsEnabled = skipFirstUseHintsEnabled;
    return this;
  }

  /**
   * Whether sending and receiving SMS messages is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getSmsDisabled() {
    return smsDisabled;
  }

  /**
   * Whether sending and receiving SMS messages is disabled.
   * @param smsDisabled smsDisabled or {@code null} for none
   */
  public Policy setSmsDisabled(java.lang.Boolean smsDisabled) {
    this.smsDisabled = smsDisabled;
    return this;
  }

  /**
   * Whether the status bar is disabled. This disables notifications, quick settings, and other
   * screen overlays that allow escape from full-screen mode.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getStatusBarDisabled() {
    return statusBarDisabled;
  }

  /**
   * Whether the status bar is disabled. This disables notifications, quick settings, and other
   * screen overlays that allow escape from full-screen mode.
   * @param statusBarDisabled statusBarDisabled or {@code null} for none
   */
  public Policy setStatusBarDisabled(java.lang.Boolean statusBarDisabled) {
    this.statusBarDisabled = statusBarDisabled;
    return this;
  }

  /**
   * Status reporting settings
   * @return value or {@code null} for none
   */
  public StatusReportingSettings getStatusReportingSettings() {
    return statusReportingSettings;
  }

  /**
   * Status reporting settings
   * @param statusReportingSettings statusReportingSettings or {@code null} for none
   */
  public Policy setStatusReportingSettings(StatusReportingSettings statusReportingSettings) {
    this.statusReportingSettings = statusReportingSettings;
    return this;
  }

  /**
   * The battery plugged in modes for which the device stays on. When using this setting, it is
   * recommended to clear maximum_time_to_lock so that the device doesn't lock itself while it stays
   * on.
   * @return value or {@code null} for none
   */
  public java.util.List<java.lang.String> getStayOnPluggedModes() {
    return stayOnPluggedModes;
  }

  /**
   * The battery plugged in modes for which the device stays on. When using this setting, it is
   * recommended to clear maximum_time_to_lock so that the device doesn't lock itself while it stays
   * on.
   * @param stayOnPluggedModes stayOnPluggedModes or {@code null} for none
   */
  public Policy setStayOnPluggedModes(java.util.List<java.lang.String> stayOnPluggedModes) {
    this.stayOnPluggedModes = stayOnPluggedModes;
    return this;
  }

  /**
   * The system update policy, which controls how OS updates are applied. If the update type is
   * WINDOWED, the update window will automatically apply to Play app updates as well.
   * @return value or {@code null} for none
   */
  public SystemUpdate getSystemUpdate() {
    return systemUpdate;
  }

  /**
   * The system update policy, which controls how OS updates are applied. If the update type is
   * WINDOWED, the update window will automatically apply to Play app updates as well.
   * @param systemUpdate systemUpdate or {@code null} for none
   */
  public Policy setSystemUpdate(SystemUpdate systemUpdate) {
    this.systemUpdate = systemUpdate;
    return this;
  }

  /**
   * Whether configuring tethering and portable hotspots is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getTetheringConfigDisabled() {
    return tetheringConfigDisabled;
  }

  /**
   * Whether configuring tethering and portable hotspots is disabled.
   * @param tetheringConfigDisabled tetheringConfigDisabled or {@code null} for none
   */
  public Policy setTetheringConfigDisabled(java.lang.Boolean tetheringConfigDisabled) {
    this.tetheringConfigDisabled = tetheringConfigDisabled;
    return this;
  }

  /**
   * Whether user uninstallation of applications is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getUninstallAppsDisabled() {
    return uninstallAppsDisabled;
  }

  /**
   * Whether user uninstallation of applications is disabled.
   * @param uninstallAppsDisabled uninstallAppsDisabled or {@code null} for none
   */
  public Policy setUninstallAppsDisabled(java.lang.Boolean uninstallAppsDisabled) {
    this.uninstallAppsDisabled = uninstallAppsDisabled;
    return this;
  }

  /**
   * Whether the microphone is muted and adjusting microphone volume is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getUnmuteMicrophoneDisabled() {
    return unmuteMicrophoneDisabled;
  }

  /**
   * Whether the microphone is muted and adjusting microphone volume is disabled.
   * @param unmuteMicrophoneDisabled unmuteMicrophoneDisabled or {@code null} for none
   */
  public Policy setUnmuteMicrophoneDisabled(java.lang.Boolean unmuteMicrophoneDisabled) {
    this.unmuteMicrophoneDisabled = unmuteMicrophoneDisabled;
    return this;
  }

  /**
   * Whether transferring files over USB is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getUsbFileTransferDisabled() {
    return usbFileTransferDisabled;
  }

  /**
   * Whether transferring files over USB is disabled.
   * @param usbFileTransferDisabled usbFileTransferDisabled or {@code null} for none
   */
  public Policy setUsbFileTransferDisabled(java.lang.Boolean usbFileTransferDisabled) {
    this.usbFileTransferDisabled = usbFileTransferDisabled;
    return this;
  }

  /**
   * Whether USB storage is enabled. Deprecated.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getUsbMassStorageEnabled() {
    return usbMassStorageEnabled;
  }

  /**
   * Whether USB storage is enabled. Deprecated.
   * @param usbMassStorageEnabled usbMassStorageEnabled or {@code null} for none
   */
  public Policy setUsbMassStorageEnabled(java.lang.Boolean usbMassStorageEnabled) {
    this.usbMassStorageEnabled = usbMassStorageEnabled;
    return this;
  }

  /**
   * The version of the policy. This is a read-only field. The version is incremented each time the
   * policy is updated.
   * @return value or {@code null} for none
   */
  public java.lang.Long getVersion() {
    return version;
  }

  /**
   * The version of the policy. This is a read-only field. The version is incremented each time the
   * policy is updated.
   * @param version version or {@code null} for none
   */
  public Policy setVersion(java.lang.Long version) {
    this.version = version;
    return this;
  }

  /**
   * Whether configuring VPN is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getVpnConfigDisabled() {
    return vpnConfigDisabled;
  }

  /**
   * Whether configuring VPN is disabled.
   * @param vpnConfigDisabled vpnConfigDisabled or {@code null} for none
   */
  public Policy setVpnConfigDisabled(java.lang.Boolean vpnConfigDisabled) {
    this.vpnConfigDisabled = vpnConfigDisabled;
    return this;
  }

  /**
   * Whether configuring Wi-Fi access points is disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getWifiConfigDisabled() {
    return wifiConfigDisabled;
  }

  /**
   * Whether configuring Wi-Fi access points is disabled.
   * @param wifiConfigDisabled wifiConfigDisabled or {@code null} for none
   */
  public Policy setWifiConfigDisabled(java.lang.Boolean wifiConfigDisabled) {
    this.wifiConfigDisabled = wifiConfigDisabled;
    return this;
  }

  /**
   * DEPRECATED - Use wifi_config_disabled.
   * @return value or {@code null} for none
   */
  public java.lang.Boolean getWifiConfigsLockdownEnabled() {
    return wifiConfigsLockdownEnabled;
  }

  /**
   * DEPRECATED - Use wifi_config_disabled.
   * @param wifiConfigsLockdownEnabled wifiConfigsLockdownEnabled or {@code null} for none
   */
  public Policy setWifiConfigsLockdownEnabled(java.lang.Boolean wifiConfigsLockdownEnabled) {
    this.wifiConfigsLockdownEnabled = wifiConfigsLockdownEnabled;
    return this;
  }

  @Override
  public Policy set(String fieldName, Object value) {
    return (Policy) super.set(fieldName, value);
  }

  @Override
  public Policy clone() {
    return (Policy) super.clone();
  }

}
