/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.networkservices.v1beta1.model;

/**
 * The matcher that is based on node metadata presented by xDS clients.
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the Network Services API. For a detailed explanation see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class MetadataLabelMatcher extends com.google.api.client.json.GenericJson {

  /**
   * Specifies how matching should be done. Supported values are: MATCH_ANY: At least one of the
   * Labels specified in the matcher should match the metadata presented by xDS client. MATCH_ALL:
   * The metadata presented by the xDS client should contain all of the labels specified here. The
   * selection is determined based on the best match. For example, suppose there are three
   * EndpointPolicy resources P1, P2 and P3 and if P1 has a the matcher as MATCH_ANY , P2 has
   * MATCH_ALL , and P3 has MATCH_ALL . If a client with label connects, the config from P1 will be
   * selected. If a client with label connects, the config from P2 will be selected. If a client
   * with label connects, the config from P3 will be selected. If there is more than one best match,
   * (for example, if a config P4 with selector exists and if a client with label connects), an
   * error will be thrown.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String metadataLabelMatchCriteria;

  /**
   * The list of label value pairs that must match labels in the provided metadata based on
   * filterMatchCriteria This list can have at most 64 entries. The list can be empty if the match
   * criteria is MATCH_ANY, to specify a wildcard match (i.e this matches any client).
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.util.List<MetadataLabels> metadataLabels;

  /**
   * Specifies how matching should be done. Supported values are: MATCH_ANY: At least one of the
   * Labels specified in the matcher should match the metadata presented by xDS client. MATCH_ALL:
   * The metadata presented by the xDS client should contain all of the labels specified here. The
   * selection is determined based on the best match. For example, suppose there are three
   * EndpointPolicy resources P1, P2 and P3 and if P1 has a the matcher as MATCH_ANY , P2 has
   * MATCH_ALL , and P3 has MATCH_ALL . If a client with label connects, the config from P1 will be
   * selected. If a client with label connects, the config from P2 will be selected. If a client
   * with label connects, the config from P3 will be selected. If there is more than one best match,
   * (for example, if a config P4 with selector exists and if a client with label connects), an
   * error will be thrown.
   * @return value or {@code null} for none
   */
  public java.lang.String getMetadataLabelMatchCriteria() {
    return metadataLabelMatchCriteria;
  }

  /**
   * Specifies how matching should be done. Supported values are: MATCH_ANY: At least one of the
   * Labels specified in the matcher should match the metadata presented by xDS client. MATCH_ALL:
   * The metadata presented by the xDS client should contain all of the labels specified here. The
   * selection is determined based on the best match. For example, suppose there are three
   * EndpointPolicy resources P1, P2 and P3 and if P1 has a the matcher as MATCH_ANY , P2 has
   * MATCH_ALL , and P3 has MATCH_ALL . If a client with label connects, the config from P1 will be
   * selected. If a client with label connects, the config from P2 will be selected. If a client
   * with label connects, the config from P3 will be selected. If there is more than one best match,
   * (for example, if a config P4 with selector exists and if a client with label connects), an
   * error will be thrown.
   * @param metadataLabelMatchCriteria metadataLabelMatchCriteria or {@code null} for none
   */
  public MetadataLabelMatcher setMetadataLabelMatchCriteria(java.lang.String metadataLabelMatchCriteria) {
    this.metadataLabelMatchCriteria = metadataLabelMatchCriteria;
    return this;
  }

  /**
   * The list of label value pairs that must match labels in the provided metadata based on
   * filterMatchCriteria This list can have at most 64 entries. The list can be empty if the match
   * criteria is MATCH_ANY, to specify a wildcard match (i.e this matches any client).
   * @return value or {@code null} for none
   */
  public java.util.List<MetadataLabels> getMetadataLabels() {
    return metadataLabels;
  }

  /**
   * The list of label value pairs that must match labels in the provided metadata based on
   * filterMatchCriteria This list can have at most 64 entries. The list can be empty if the match
   * criteria is MATCH_ANY, to specify a wildcard match (i.e this matches any client).
   * @param metadataLabels metadataLabels or {@code null} for none
   */
  public MetadataLabelMatcher setMetadataLabels(java.util.List<MetadataLabels> metadataLabels) {
    this.metadataLabels = metadataLabels;
    return this;
  }

  @Override
  public MetadataLabelMatcher set(String fieldName, Object value) {
    return (MetadataLabelMatcher) super.set(fieldName, value);
  }

  @Override
  public MetadataLabelMatcher clone() {
    return (MetadataLabelMatcher) super.clone();
  }

}
