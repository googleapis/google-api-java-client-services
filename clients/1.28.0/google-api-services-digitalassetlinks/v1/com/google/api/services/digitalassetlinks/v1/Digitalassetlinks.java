/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.digitalassetlinks.v1;

/**
 * Service definition for Digitalassetlinks (v1).
 *
 * <p>
 * Discovers relationships between online assets such as websites or mobile apps.
 * </p>
 *
 * <p>
 * For more information about this service, see the
 * <a href="https://developers.google.com/digital-asset-links/" target="_blank">API Documentation</a>
 * </p>
 *
 * <p>
 * This service uses {@link DigitalassetlinksRequestInitializer} to initialize global parameters via its
 * {@link Builder}.
 * </p>
 *
 * @since 1.3
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public class Digitalassetlinks extends com.google.api.client.googleapis.services.json.AbstractGoogleJsonClient {

  // Note: Leave this static initializer at the top of the file.
  static {
    com.google.api.client.util.Preconditions.checkState(
        com.google.api.client.googleapis.GoogleUtils.MAJOR_VERSION == 1 &&
        com.google.api.client.googleapis.GoogleUtils.MINOR_VERSION >= 15,
        "You are currently running with version %s of google-api-client. " +
        "You need at least version 1.15 of google-api-client to run version " +
        "1.28.0 of the Digital Asset Links API library.", com.google.api.client.googleapis.GoogleUtils.VERSION);
  }

  /**
   * The default encoded root URL of the service. This is determined when the library is generated
   * and normally should not be changed.
   *
   * @since 1.7
   */
  public static final String DEFAULT_ROOT_URL = "https://digitalassetlinks.googleapis.com/";

  /**
   * The default encoded service path of the service. This is determined when the library is
   * generated and normally should not be changed.
   *
   * @since 1.7
   */
  public static final String DEFAULT_SERVICE_PATH = "";

  /**
   * The default encoded batch path of the service. This is determined when the library is
   * generated and normally should not be changed.
   *
   * @since 1.23
   */
  public static final String DEFAULT_BATCH_PATH = "batch";

  /**
   * The default encoded base URL of the service. This is determined when the library is generated
   * and normally should not be changed.
   */
  public static final String DEFAULT_BASE_URL = DEFAULT_ROOT_URL + DEFAULT_SERVICE_PATH;

  /**
   * Constructor.
   *
   * <p>
   * Use {@link Builder} if you need to specify any of the optional parameters.
   * </p>
   *
   * @param transport HTTP transport, which should normally be:
   *        <ul>
   *        <li>Google App Engine:
   *        {@code com.google.api.client.extensions.appengine.http.UrlFetchTransport}</li>
   *        <li>Android: {@code newCompatibleTransport} from
   *        {@code com.google.api.client.extensions.android.http.AndroidHttp}</li>
   *        <li>Java: {@link com.google.api.client.googleapis.javanet.GoogleNetHttpTransport#newTrustedTransport()}
   *        </li>
   *        </ul>
   * @param jsonFactory JSON factory, which may be:
   *        <ul>
   *        <li>Jackson: {@code com.google.api.client.json.jackson2.JacksonFactory}</li>
   *        <li>Google GSON: {@code com.google.api.client.json.gson.GsonFactory}</li>
   *        <li>Android Honeycomb or higher:
   *        {@code com.google.api.client.extensions.android.json.AndroidJsonFactory}</li>
   *        </ul>
   * @param httpRequestInitializer HTTP request initializer or {@code null} for none
   * @since 1.7
   */
  public Digitalassetlinks(com.google.api.client.http.HttpTransport transport, com.google.api.client.json.JsonFactory jsonFactory,
      com.google.api.client.http.HttpRequestInitializer httpRequestInitializer) {
    this(new Builder(transport, jsonFactory, httpRequestInitializer));
  }

  /**
   * @param builder builder
   */
  Digitalassetlinks(Builder builder) {
    super(builder);
  }

  @Override
  protected void initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest<?> httpClientRequest) throws java.io.IOException {
    super.initialize(httpClientRequest);
  }

  /**
   * An accessor for creating requests from the Assetlinks collection.
   *
   * <p>The typical use is:</p>
   * <pre>
   *   {@code Digitalassetlinks digitalassetlinks = new Digitalassetlinks(...);}
   *   {@code Digitalassetlinks.Assetlinks.List request = digitalassetlinks.assetlinks().list(parameters ...)}
   * </pre>
   *
   * @return the resource collection
   */
  public Assetlinks assetlinks() {
    return new Assetlinks();
  }

  /**
   * The "assetlinks" collection of methods.
   */
  public class Assetlinks {

    /**
     * Determines whether the specified (directional) relationship exists between the specified source
     * and target assets.
     *
     * The relation describes the intent of the link between the two assets as claimed by the source
     * asset.  An example for such relationships is the delegation of privileges or permissions.
     *
     * This command is most often used by infrastructure systems to check preconditions for an action.
     * For example, a client may want to know if it is OK to send a web URL to a particular mobile app
     * instead. The client can check for the relevant asset link from the website to the mobile app to
     * decide if the operation should be allowed.
     *
     * A note about security: if you specify a secure asset as the source, such as an HTTPS website or
     * an Android app, the API will ensure that any statements used to generate the response have been
     * made in a secure way by the owner of that asset.  Conversely, if the source asset is an insecure
     * HTTP website (that is, the URL starts with `http://` instead of `https://`), the API cannot
     * verify its statements securely, and it is not possible to ensure that the website's statements
     * have not been altered by a third party.  For more information, see the [Digital Asset Links
     * technical design specification](https://github.com/google/digitalassetlinks/blob/master/well-
     * known/details.md).
     *
     * Create a request for the method "assetlinks.check".
     *
     * This request holds the parameters needed by the digitalassetlinks server.  After setting any
     * optional parameters, call the {@link Check#execute()} method to invoke the remote operation.
     *
     * @return the request
     */
    public Check check() throws java.io.IOException {
      Check result = new Check();
      initialize(result);
      return result;
    }

    public class Check extends DigitalassetlinksRequest<com.google.api.services.digitalassetlinks.v1.model.CheckResponse> {

      private static final String REST_PATH = "v1/assetlinks:check";

      /**
       * Determines whether the specified (directional) relationship exists between the specified source
       * and target assets.
       *
       * The relation describes the intent of the link between the two assets as claimed by the source
       * asset.  An example for such relationships is the delegation of privileges or permissions.
       *
       * This command is most often used by infrastructure systems to check preconditions for an action.
       * For example, a client may want to know if it is OK to send a web URL to a particular mobile app
       * instead. The client can check for the relevant asset link from the website to the mobile app to
       * decide if the operation should be allowed.
       *
       * A note about security: if you specify a secure asset as the source, such as an HTTPS website or
       * an Android app, the API will ensure that any statements used to generate the response have been
       * made in a secure way by the owner of that asset.  Conversely, if the source asset is an
       * insecure HTTP website (that is, the URL starts with `http://` instead of `https://`), the API
       * cannot verify its statements securely, and it is not possible to ensure that the website's
       * statements have not been altered by a third party.  For more information, see the [Digital
       * Asset Links technical design
       * specification](https://github.com/google/digitalassetlinks/blob/master/well-known/details.md).
       *
       * Create a request for the method "assetlinks.check".
       *
       * This request holds the parameters needed by the the digitalassetlinks server.  After setting
       * any optional parameters, call the {@link Check#execute()} method to invoke the remote
       * operation. <p> {@link
       * Check#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must
       * be called to initialize this instance immediately after invoking the constructor. </p>
       *
       * @since 1.13
       */
      protected Check() {
        super(Digitalassetlinks.this, "GET", REST_PATH, null, com.google.api.services.digitalassetlinks.v1.model.CheckResponse.class);
      }

      @Override
      public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
        return super.executeUsingHead();
      }

      @Override
      public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
        return super.buildHttpRequestUsingHead();
      }

      @Override
      public Check set$Xgafv(java.lang.String $Xgafv) {
        return (Check) super.set$Xgafv($Xgafv);
      }

      @Override
      public Check setAccessToken(java.lang.String accessToken) {
        return (Check) super.setAccessToken(accessToken);
      }

      @Override
      public Check setAlt(java.lang.String alt) {
        return (Check) super.setAlt(alt);
      }

      @Override
      public Check setCallback(java.lang.String callback) {
        return (Check) super.setCallback(callback);
      }

      @Override
      public Check setFields(java.lang.String fields) {
        return (Check) super.setFields(fields);
      }

      @Override
      public Check setKey(java.lang.String key) {
        return (Check) super.setKey(key);
      }

      @Override
      public Check setOauthToken(java.lang.String oauthToken) {
        return (Check) super.setOauthToken(oauthToken);
      }

      @Override
      public Check setPrettyPrint(java.lang.Boolean prettyPrint) {
        return (Check) super.setPrettyPrint(prettyPrint);
      }

      @Override
      public Check setQuotaUser(java.lang.String quotaUser) {
        return (Check) super.setQuotaUser(quotaUser);
      }

      @Override
      public Check setUploadType(java.lang.String uploadType) {
        return (Check) super.setUploadType(uploadType);
      }

      @Override
      public Check setUploadProtocol(java.lang.String uploadProtocol) {
        return (Check) super.setUploadProtocol(uploadProtocol);
      }

      /**
       * Query string for the relation.
       *
       * We identify relations with strings of the format `/`, where `` must be one of a set of pre-
       * defined purpose categories, and `` is a free-form lowercase alphanumeric string that
       * describes the specific use case of the statement.
       *
       * Refer to [our API documentation](/digital-asset-links/v1/relation-strings) for the current
       * list of supported relations.
       *
       * For a query to match an asset link, both the query's and the asset link's relation strings
       * must match exactly.
       *
       * Example: A query with relation `delegate_permission/common.handle_all_urls` matches an
       * asset link with relation `delegate_permission/common.handle_all_urls`.
       */
      @com.google.api.client.util.Key
      private java.lang.String relation;

      /** Query string for the relation.

     We identify relations with strings of the format `/`, where `` must be one of a set of pre-defined
     purpose categories, and `` is a free-form lowercase alphanumeric string that describes the specific
     use case of the statement.

     Refer to [our API documentation](/digital-asset-links/v1/relation-strings) for the current list of
     supported relations.

     For a query to match an asset link, both the query's and the asset link's relation strings must
     match exactly.

     Example: A query with relation `delegate_permission/common.handle_all_urls` matches an asset link
     with relation `delegate_permission/common.handle_all_urls`.
       */
      public java.lang.String getRelation() {
        return relation;
      }

      /**
       * Query string for the relation.
       *
       * We identify relations with strings of the format `/`, where `` must be one of a set of pre-
       * defined purpose categories, and `` is a free-form lowercase alphanumeric string that
       * describes the specific use case of the statement.
       *
       * Refer to [our API documentation](/digital-asset-links/v1/relation-strings) for the current
       * list of supported relations.
       *
       * For a query to match an asset link, both the query's and the asset link's relation strings
       * must match exactly.
       *
       * Example: A query with relation `delegate_permission/common.handle_all_urls` matches an
       * asset link with relation `delegate_permission/common.handle_all_urls`.
       */
      public Check setRelation(java.lang.String relation) {
        this.relation = relation;
        return this;
      }

      /**
       * The uppercase SHA-265 fingerprint of the certificate.  From the PEM certificate, it can be
       * acquired like this:
       *
       * $ keytool -printcert -file $CERTFILE | grep SHA256: SHA256:
       * 14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83: \
       * 42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5
       *
       * or like this:
       *
       * $ openssl x509 -in $CERTFILE -noout -fingerprint -sha256 SHA256
       * Fingerprint=14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64: \
       * 16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5
       *
       * In this example, the contents of this field would be `14:6D:E9:83:C5:73:
       * 06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF: 44:E5`.
       *
       * If these tools are not available to you, you can convert the PEM certificate into the DER
       * format, compute the SHA-256 hash of that string and represent the result as a hexstring
       * (that is, uppercase hexadecimal representations of each octet, separated by colons).
       */
      @com.google.api.client.util.Key("source.androidApp.certificate.sha256Fingerprint")
      private java.lang.String sourceAndroidAppCertificateSha256Fingerprint;

      /** The uppercase SHA-265 fingerprint of the certificate.  From the PEM certificate, it can be acquired
     like this:

     $ keytool -printcert -file $CERTFILE | grep SHA256: SHA256:
     14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83: \ 42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5

     or like this:

     $ openssl x509 -in $CERTFILE -noout -fingerprint -sha256 SHA256
     Fingerprint=14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64: \
     16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5

     In this example, the contents of this field would be `14:6D:E9:83:C5:73:
     06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF: 44:E5`.

     If these tools are not available to you, you can convert the PEM certificate into the DER format,
     compute the SHA-256 hash of that string and represent the result as a hexstring (that is, uppercase
     hexadecimal representations of each octet, separated by colons).
       */
      public java.lang.String getSourceAndroidAppCertificateSha256Fingerprint() {
        return sourceAndroidAppCertificateSha256Fingerprint;
      }

      /**
       * The uppercase SHA-265 fingerprint of the certificate.  From the PEM certificate, it can be
       * acquired like this:
       *
       * $ keytool -printcert -file $CERTFILE | grep SHA256: SHA256:
       * 14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83: \
       * 42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5
       *
       * or like this:
       *
       * $ openssl x509 -in $CERTFILE -noout -fingerprint -sha256 SHA256
       * Fingerprint=14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64: \
       * 16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5
       *
       * In this example, the contents of this field would be `14:6D:E9:83:C5:73:
       * 06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF: 44:E5`.
       *
       * If these tools are not available to you, you can convert the PEM certificate into the DER
       * format, compute the SHA-256 hash of that string and represent the result as a hexstring
       * (that is, uppercase hexadecimal representations of each octet, separated by colons).
       */
      public Check setSourceAndroidAppCertificateSha256Fingerprint(java.lang.String sourceAndroidAppCertificateSha256Fingerprint) {
        this.sourceAndroidAppCertificateSha256Fingerprint = sourceAndroidAppCertificateSha256Fingerprint;
        return this;
      }

      /**
       * Android App assets are naturally identified by their Java package name. For example, the
       * Google Maps app uses the package name `com.google.android.apps.maps`. REQUIRED
       */
      @com.google.api.client.util.Key("source.androidApp.packageName")
      private java.lang.String sourceAndroidAppPackageName;

      /** Android App assets are naturally identified by their Java package name. For example, the Google
     Maps app uses the package name `com.google.android.apps.maps`. REQUIRED
       */
      public java.lang.String getSourceAndroidAppPackageName() {
        return sourceAndroidAppPackageName;
      }

      /**
       * Android App assets are naturally identified by their Java package name. For example, the
       * Google Maps app uses the package name `com.google.android.apps.maps`. REQUIRED
       */
      public Check setSourceAndroidAppPackageName(java.lang.String sourceAndroidAppPackageName) {
        this.sourceAndroidAppPackageName = sourceAndroidAppPackageName;
        return this;
      }

      /**
       * Web assets are identified by a URL that contains only the scheme, hostname and port parts.
       * The format is
       *
       * http[s]://[:]
       *
       * Hostnames must be fully qualified: they must end in a single period ("`.`").
       *
       * Only the schemes "http" and "https" are currently allowed.
       *
       * Port numbers are given as a decimal number, and they must be omitted if the standard port
       * numbers are used: 80 for http and 443 for https.
       *
       * We call this limited URL the "site".  All URLs that share the same scheme, hostname and
       * port are considered to be a part of the site and thus belong to the web asset.
       *
       * Example: the asset with the site `https://www.google.com` contains all these URLs:
       *
       * *   `https://www.google.com/` *   `https://www.google.com:443/` *
       * `https://www.google.com/foo` *   `https://www.google.com/foo?bar` *
       * `https://www.google.com/foo#bar` *   `https://user@password:www.google.com/`
       *
       * But it does not contain these URLs:
       *
       * *   `http://www.google.com/`       (wrong scheme) *   `https://google.com/`
       * (hostname does not match) *   `https://www.google.com:444/`  (port does not match) REQUIRED
       */
      @com.google.api.client.util.Key("source.web.site")
      private java.lang.String sourceWebSite;

      /** Web assets are identified by a URL that contains only the scheme, hostname and port parts.  The
     format is

     http[s]://[:]

     Hostnames must be fully qualified: they must end in a single period ("`.`").

     Only the schemes "http" and "https" are currently allowed.

     Port numbers are given as a decimal number, and they must be omitted if the standard port numbers
     are used: 80 for http and 443 for https.

     We call this limited URL the "site".  All URLs that share the same scheme, hostname and port are
     considered to be a part of the site and thus belong to the web asset.

     Example: the asset with the site `https://www.google.com` contains all these URLs:

     *   `https://www.google.com/` *   `https://www.google.com:443/` *   `https://www.google.com/foo` *
     `https://www.google.com/foo?bar` *   `https://www.google.com/foo#bar` *
     `https://user@password:www.google.com/`

     But it does not contain these URLs:

     *   `http://www.google.com/`       (wrong scheme) *   `https://google.com/`          (hostname does
     not match) *   `https://www.google.com:444/`  (port does not match) REQUIRED
       */
      public java.lang.String getSourceWebSite() {
        return sourceWebSite;
      }

      /**
       * Web assets are identified by a URL that contains only the scheme, hostname and port parts.
       * The format is
       *
       * http[s]://[:]
       *
       * Hostnames must be fully qualified: they must end in a single period ("`.`").
       *
       * Only the schemes "http" and "https" are currently allowed.
       *
       * Port numbers are given as a decimal number, and they must be omitted if the standard port
       * numbers are used: 80 for http and 443 for https.
       *
       * We call this limited URL the "site".  All URLs that share the same scheme, hostname and
       * port are considered to be a part of the site and thus belong to the web asset.
       *
       * Example: the asset with the site `https://www.google.com` contains all these URLs:
       *
       * *   `https://www.google.com/` *   `https://www.google.com:443/` *
       * `https://www.google.com/foo` *   `https://www.google.com/foo?bar` *
       * `https://www.google.com/foo#bar` *   `https://user@password:www.google.com/`
       *
       * But it does not contain these URLs:
       *
       * *   `http://www.google.com/`       (wrong scheme) *   `https://google.com/`
       * (hostname does not match) *   `https://www.google.com:444/`  (port does not match) REQUIRED
       */
      public Check setSourceWebSite(java.lang.String sourceWebSite) {
        this.sourceWebSite = sourceWebSite;
        return this;
      }

      /**
       * The uppercase SHA-265 fingerprint of the certificate.  From the PEM certificate, it can be
       * acquired like this:
       *
       * $ keytool -printcert -file $CERTFILE | grep SHA256: SHA256:
       * 14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83: \
       * 42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5
       *
       * or like this:
       *
       * $ openssl x509 -in $CERTFILE -noout -fingerprint -sha256 SHA256
       * Fingerprint=14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64: \
       * 16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5
       *
       * In this example, the contents of this field would be `14:6D:E9:83:C5:73:
       * 06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF: 44:E5`.
       *
       * If these tools are not available to you, you can convert the PEM certificate into the DER
       * format, compute the SHA-256 hash of that string and represent the result as a hexstring
       * (that is, uppercase hexadecimal representations of each octet, separated by colons).
       */
      @com.google.api.client.util.Key("target.androidApp.certificate.sha256Fingerprint")
      private java.lang.String targetAndroidAppCertificateSha256Fingerprint;

      /** The uppercase SHA-265 fingerprint of the certificate.  From the PEM certificate, it can be acquired
     like this:

     $ keytool -printcert -file $CERTFILE | grep SHA256: SHA256:
     14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83: \ 42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5

     or like this:

     $ openssl x509 -in $CERTFILE -noout -fingerprint -sha256 SHA256
     Fingerprint=14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64: \
     16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5

     In this example, the contents of this field would be `14:6D:E9:83:C5:73:
     06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF: 44:E5`.

     If these tools are not available to you, you can convert the PEM certificate into the DER format,
     compute the SHA-256 hash of that string and represent the result as a hexstring (that is, uppercase
     hexadecimal representations of each octet, separated by colons).
       */
      public java.lang.String getTargetAndroidAppCertificateSha256Fingerprint() {
        return targetAndroidAppCertificateSha256Fingerprint;
      }

      /**
       * The uppercase SHA-265 fingerprint of the certificate.  From the PEM certificate, it can be
       * acquired like this:
       *
       * $ keytool -printcert -file $CERTFILE | grep SHA256: SHA256:
       * 14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83: \
       * 42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5
       *
       * or like this:
       *
       * $ openssl x509 -in $CERTFILE -noout -fingerprint -sha256 SHA256
       * Fingerprint=14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64: \
       * 16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5
       *
       * In this example, the contents of this field would be `14:6D:E9:83:C5:73:
       * 06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF: 44:E5`.
       *
       * If these tools are not available to you, you can convert the PEM certificate into the DER
       * format, compute the SHA-256 hash of that string and represent the result as a hexstring
       * (that is, uppercase hexadecimal representations of each octet, separated by colons).
       */
      public Check setTargetAndroidAppCertificateSha256Fingerprint(java.lang.String targetAndroidAppCertificateSha256Fingerprint) {
        this.targetAndroidAppCertificateSha256Fingerprint = targetAndroidAppCertificateSha256Fingerprint;
        return this;
      }

      /**
       * Android App assets are naturally identified by their Java package name. For example, the
       * Google Maps app uses the package name `com.google.android.apps.maps`. REQUIRED
       */
      @com.google.api.client.util.Key("target.androidApp.packageName")
      private java.lang.String targetAndroidAppPackageName;

      /** Android App assets are naturally identified by their Java package name. For example, the Google
     Maps app uses the package name `com.google.android.apps.maps`. REQUIRED
       */
      public java.lang.String getTargetAndroidAppPackageName() {
        return targetAndroidAppPackageName;
      }

      /**
       * Android App assets are naturally identified by their Java package name. For example, the
       * Google Maps app uses the package name `com.google.android.apps.maps`. REQUIRED
       */
      public Check setTargetAndroidAppPackageName(java.lang.String targetAndroidAppPackageName) {
        this.targetAndroidAppPackageName = targetAndroidAppPackageName;
        return this;
      }

      /**
       * Web assets are identified by a URL that contains only the scheme, hostname and port parts.
       * The format is
       *
       * http[s]://[:]
       *
       * Hostnames must be fully qualified: they must end in a single period ("`.`").
       *
       * Only the schemes "http" and "https" are currently allowed.
       *
       * Port numbers are given as a decimal number, and they must be omitted if the standard port
       * numbers are used: 80 for http and 443 for https.
       *
       * We call this limited URL the "site".  All URLs that share the same scheme, hostname and
       * port are considered to be a part of the site and thus belong to the web asset.
       *
       * Example: the asset with the site `https://www.google.com` contains all these URLs:
       *
       * *   `https://www.google.com/` *   `https://www.google.com:443/` *
       * `https://www.google.com/foo` *   `https://www.google.com/foo?bar` *
       * `https://www.google.com/foo#bar` *   `https://user@password:www.google.com/`
       *
       * But it does not contain these URLs:
       *
       * *   `http://www.google.com/`       (wrong scheme) *   `https://google.com/`
       * (hostname does not match) *   `https://www.google.com:444/`  (port does not match) REQUIRED
       */
      @com.google.api.client.util.Key("target.web.site")
      private java.lang.String targetWebSite;

      /** Web assets are identified by a URL that contains only the scheme, hostname and port parts.  The
     format is

     http[s]://[:]

     Hostnames must be fully qualified: they must end in a single period ("`.`").

     Only the schemes "http" and "https" are currently allowed.

     Port numbers are given as a decimal number, and they must be omitted if the standard port numbers
     are used: 80 for http and 443 for https.

     We call this limited URL the "site".  All URLs that share the same scheme, hostname and port are
     considered to be a part of the site and thus belong to the web asset.

     Example: the asset with the site `https://www.google.com` contains all these URLs:

     *   `https://www.google.com/` *   `https://www.google.com:443/` *   `https://www.google.com/foo` *
     `https://www.google.com/foo?bar` *   `https://www.google.com/foo#bar` *
     `https://user@password:www.google.com/`

     But it does not contain these URLs:

     *   `http://www.google.com/`       (wrong scheme) *   `https://google.com/`          (hostname does
     not match) *   `https://www.google.com:444/`  (port does not match) REQUIRED
       */
      public java.lang.String getTargetWebSite() {
        return targetWebSite;
      }

      /**
       * Web assets are identified by a URL that contains only the scheme, hostname and port parts.
       * The format is
       *
       * http[s]://[:]
       *
       * Hostnames must be fully qualified: they must end in a single period ("`.`").
       *
       * Only the schemes "http" and "https" are currently allowed.
       *
       * Port numbers are given as a decimal number, and they must be omitted if the standard port
       * numbers are used: 80 for http and 443 for https.
       *
       * We call this limited URL the "site".  All URLs that share the same scheme, hostname and
       * port are considered to be a part of the site and thus belong to the web asset.
       *
       * Example: the asset with the site `https://www.google.com` contains all these URLs:
       *
       * *   `https://www.google.com/` *   `https://www.google.com:443/` *
       * `https://www.google.com/foo` *   `https://www.google.com/foo?bar` *
       * `https://www.google.com/foo#bar` *   `https://user@password:www.google.com/`
       *
       * But it does not contain these URLs:
       *
       * *   `http://www.google.com/`       (wrong scheme) *   `https://google.com/`
       * (hostname does not match) *   `https://www.google.com:444/`  (port does not match) REQUIRED
       */
      public Check setTargetWebSite(java.lang.String targetWebSite) {
        this.targetWebSite = targetWebSite;
        return this;
      }

      @Override
      public Check set(String parameterName, Object value) {
        return (Check) super.set(parameterName, value);
      }
    }

  }

  /**
   * An accessor for creating requests from the Statements collection.
   *
   * <p>The typical use is:</p>
   * <pre>
   *   {@code Digitalassetlinks digitalassetlinks = new Digitalassetlinks(...);}
   *   {@code Digitalassetlinks.Statements.List request = digitalassetlinks.statements().list(parameters ...)}
   * </pre>
   *
   * @return the resource collection
   */
  public Statements statements() {
    return new Statements();
  }

  /**
   * The "statements" collection of methods.
   */
  public class Statements {

    /**
     * Retrieves a list of all statements from a given source that match the specified target and
     * statement string.
     *
     * The API guarantees that all statements with secure source assets, such as HTTPS websites or
     * Android apps, have been made in a secure way by the owner of those assets, as described in the
     * [Digital Asset Links technical design
     * specification](https://github.com/google/digitalassetlinks/blob/master/well-known/details.md).
     * Specifically, you should consider that for insecure websites (that is, where the URL starts with
     * `http://` instead of `https://`), this guarantee cannot be made.
     *
     * The `List` command is most useful in cases where the API client wants to know all the ways in
     * which two assets are related, or enumerate all the relationships from a particular source asset.
     * Example: a feature that helps users navigate to related items.  When a mobile app is running on a
     * device, the feature would make it easy to navigate to the corresponding web site or Google+
     * profile.
     *
     * Create a request for the method "statements.list".
     *
     * This request holds the parameters needed by the digitalassetlinks server.  After setting any
     * optional parameters, call the {@link List#execute()} method to invoke the remote operation.
     *
     * @return the request
     */
    public List list() throws java.io.IOException {
      List result = new List();
      initialize(result);
      return result;
    }

    public class List extends DigitalassetlinksRequest<com.google.api.services.digitalassetlinks.v1.model.ListResponse> {

      private static final String REST_PATH = "v1/statements:list";

      /**
       * Retrieves a list of all statements from a given source that match the specified target and
       * statement string.
       *
       * The API guarantees that all statements with secure source assets, such as HTTPS websites or
       * Android apps, have been made in a secure way by the owner of those assets, as described in the
       * [Digital Asset Links technical design
       * specification](https://github.com/google/digitalassetlinks/blob/master/well-known/details.md).
       * Specifically, you should consider that for insecure websites (that is, where the URL starts
       * with `http://` instead of `https://`), this guarantee cannot be made.
       *
       * The `List` command is most useful in cases where the API client wants to know all the ways in
       * which two assets are related, or enumerate all the relationships from a particular source
       * asset.  Example: a feature that helps users navigate to related items.  When a mobile app is
       * running on a device, the feature would make it easy to navigate to the corresponding web site
       * or Google+ profile.
       *
       * Create a request for the method "statements.list".
       *
       * This request holds the parameters needed by the the digitalassetlinks server.  After setting
       * any optional parameters, call the {@link List#execute()} method to invoke the remote operation.
       * <p> {@link
       * List#initialize(com.google.api.client.googleapis.services.AbstractGoogleClientRequest)} must be
       * called to initialize this instance immediately after invoking the constructor. </p>
       *
       * @since 1.13
       */
      protected List() {
        super(Digitalassetlinks.this, "GET", REST_PATH, null, com.google.api.services.digitalassetlinks.v1.model.ListResponse.class);
      }

      @Override
      public com.google.api.client.http.HttpResponse executeUsingHead() throws java.io.IOException {
        return super.executeUsingHead();
      }

      @Override
      public com.google.api.client.http.HttpRequest buildHttpRequestUsingHead() throws java.io.IOException {
        return super.buildHttpRequestUsingHead();
      }

      @Override
      public List set$Xgafv(java.lang.String $Xgafv) {
        return (List) super.set$Xgafv($Xgafv);
      }

      @Override
      public List setAccessToken(java.lang.String accessToken) {
        return (List) super.setAccessToken(accessToken);
      }

      @Override
      public List setAlt(java.lang.String alt) {
        return (List) super.setAlt(alt);
      }

      @Override
      public List setCallback(java.lang.String callback) {
        return (List) super.setCallback(callback);
      }

      @Override
      public List setFields(java.lang.String fields) {
        return (List) super.setFields(fields);
      }

      @Override
      public List setKey(java.lang.String key) {
        return (List) super.setKey(key);
      }

      @Override
      public List setOauthToken(java.lang.String oauthToken) {
        return (List) super.setOauthToken(oauthToken);
      }

      @Override
      public List setPrettyPrint(java.lang.Boolean prettyPrint) {
        return (List) super.setPrettyPrint(prettyPrint);
      }

      @Override
      public List setQuotaUser(java.lang.String quotaUser) {
        return (List) super.setQuotaUser(quotaUser);
      }

      @Override
      public List setUploadType(java.lang.String uploadType) {
        return (List) super.setUploadType(uploadType);
      }

      @Override
      public List setUploadProtocol(java.lang.String uploadProtocol) {
        return (List) super.setUploadProtocol(uploadProtocol);
      }

      /**
       * Use only associations that match the specified relation.
       *
       * See the [`Statement`](#Statement) message for a detailed definition of relation strings.
       *
       * For a query to match a statement, one of the following must be true:
       *
       * *    both the query's and the statement's relation strings match exactly, or *    the
       * query's relation string is empty or missing.
       *
       * Example: A query with relation `delegate_permission/common.handle_all_urls` matches an
       * asset link with relation `delegate_permission/common.handle_all_urls`.
       */
      @com.google.api.client.util.Key
      private java.lang.String relation;

      /** Use only associations that match the specified relation.

     See the [`Statement`](#Statement) message for a detailed definition of relation strings.

     For a query to match a statement, one of the following must be true:

     *    both the query's and the statement's relation strings match exactly, or *    the query's
     relation string is empty or missing.

     Example: A query with relation `delegate_permission/common.handle_all_urls` matches an asset link
     with relation `delegate_permission/common.handle_all_urls`.
       */
      public java.lang.String getRelation() {
        return relation;
      }

      /**
       * Use only associations that match the specified relation.
       *
       * See the [`Statement`](#Statement) message for a detailed definition of relation strings.
       *
       * For a query to match a statement, one of the following must be true:
       *
       * *    both the query's and the statement's relation strings match exactly, or *    the
       * query's relation string is empty or missing.
       *
       * Example: A query with relation `delegate_permission/common.handle_all_urls` matches an
       * asset link with relation `delegate_permission/common.handle_all_urls`.
       */
      public List setRelation(java.lang.String relation) {
        this.relation = relation;
        return this;
      }

      /**
       * The uppercase SHA-265 fingerprint of the certificate.  From the PEM certificate, it can be
       * acquired like this:
       *
       * $ keytool -printcert -file $CERTFILE | grep SHA256: SHA256:
       * 14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83: \
       * 42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5
       *
       * or like this:
       *
       * $ openssl x509 -in $CERTFILE -noout -fingerprint -sha256 SHA256
       * Fingerprint=14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64: \
       * 16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5
       *
       * In this example, the contents of this field would be `14:6D:E9:83:C5:73:
       * 06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF: 44:E5`.
       *
       * If these tools are not available to you, you can convert the PEM certificate into the DER
       * format, compute the SHA-256 hash of that string and represent the result as a hexstring
       * (that is, uppercase hexadecimal representations of each octet, separated by colons).
       */
      @com.google.api.client.util.Key("source.androidApp.certificate.sha256Fingerprint")
      private java.lang.String sourceAndroidAppCertificateSha256Fingerprint;

      /** The uppercase SHA-265 fingerprint of the certificate.  From the PEM certificate, it can be acquired
     like this:

     $ keytool -printcert -file $CERTFILE | grep SHA256: SHA256:
     14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83: \ 42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5

     or like this:

     $ openssl x509 -in $CERTFILE -noout -fingerprint -sha256 SHA256
     Fingerprint=14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64: \
     16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5

     In this example, the contents of this field would be `14:6D:E9:83:C5:73:
     06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF: 44:E5`.

     If these tools are not available to you, you can convert the PEM certificate into the DER format,
     compute the SHA-256 hash of that string and represent the result as a hexstring (that is, uppercase
     hexadecimal representations of each octet, separated by colons).
       */
      public java.lang.String getSourceAndroidAppCertificateSha256Fingerprint() {
        return sourceAndroidAppCertificateSha256Fingerprint;
      }

      /**
       * The uppercase SHA-265 fingerprint of the certificate.  From the PEM certificate, it can be
       * acquired like this:
       *
       * $ keytool -printcert -file $CERTFILE | grep SHA256: SHA256:
       * 14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83: \
       * 42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5
       *
       * or like this:
       *
       * $ openssl x509 -in $CERTFILE -noout -fingerprint -sha256 SHA256
       * Fingerprint=14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64: \
       * 16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5
       *
       * In this example, the contents of this field would be `14:6D:E9:83:C5:73:
       * 06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF: 44:E5`.
       *
       * If these tools are not available to you, you can convert the PEM certificate into the DER
       * format, compute the SHA-256 hash of that string and represent the result as a hexstring
       * (that is, uppercase hexadecimal representations of each octet, separated by colons).
       */
      public List setSourceAndroidAppCertificateSha256Fingerprint(java.lang.String sourceAndroidAppCertificateSha256Fingerprint) {
        this.sourceAndroidAppCertificateSha256Fingerprint = sourceAndroidAppCertificateSha256Fingerprint;
        return this;
      }

      /**
       * Android App assets are naturally identified by their Java package name. For example, the
       * Google Maps app uses the package name `com.google.android.apps.maps`. REQUIRED
       */
      @com.google.api.client.util.Key("source.androidApp.packageName")
      private java.lang.String sourceAndroidAppPackageName;

      /** Android App assets are naturally identified by their Java package name. For example, the Google
     Maps app uses the package name `com.google.android.apps.maps`. REQUIRED
       */
      public java.lang.String getSourceAndroidAppPackageName() {
        return sourceAndroidAppPackageName;
      }

      /**
       * Android App assets are naturally identified by their Java package name. For example, the
       * Google Maps app uses the package name `com.google.android.apps.maps`. REQUIRED
       */
      public List setSourceAndroidAppPackageName(java.lang.String sourceAndroidAppPackageName) {
        this.sourceAndroidAppPackageName = sourceAndroidAppPackageName;
        return this;
      }

      /**
       * Web assets are identified by a URL that contains only the scheme, hostname and port parts.
       * The format is
       *
       * http[s]://[:]
       *
       * Hostnames must be fully qualified: they must end in a single period ("`.`").
       *
       * Only the schemes "http" and "https" are currently allowed.
       *
       * Port numbers are given as a decimal number, and they must be omitted if the standard port
       * numbers are used: 80 for http and 443 for https.
       *
       * We call this limited URL the "site".  All URLs that share the same scheme, hostname and
       * port are considered to be a part of the site and thus belong to the web asset.
       *
       * Example: the asset with the site `https://www.google.com` contains all these URLs:
       *
       * *   `https://www.google.com/` *   `https://www.google.com:443/` *
       * `https://www.google.com/foo` *   `https://www.google.com/foo?bar` *
       * `https://www.google.com/foo#bar` *   `https://user@password:www.google.com/`
       *
       * But it does not contain these URLs:
       *
       * *   `http://www.google.com/`       (wrong scheme) *   `https://google.com/`
       * (hostname does not match) *   `https://www.google.com:444/`  (port does not match) REQUIRED
       */
      @com.google.api.client.util.Key("source.web.site")
      private java.lang.String sourceWebSite;

      /** Web assets are identified by a URL that contains only the scheme, hostname and port parts.  The
     format is

     http[s]://[:]

     Hostnames must be fully qualified: they must end in a single period ("`.`").

     Only the schemes "http" and "https" are currently allowed.

     Port numbers are given as a decimal number, and they must be omitted if the standard port numbers
     are used: 80 for http and 443 for https.

     We call this limited URL the "site".  All URLs that share the same scheme, hostname and port are
     considered to be a part of the site and thus belong to the web asset.

     Example: the asset with the site `https://www.google.com` contains all these URLs:

     *   `https://www.google.com/` *   `https://www.google.com:443/` *   `https://www.google.com/foo` *
     `https://www.google.com/foo?bar` *   `https://www.google.com/foo#bar` *
     `https://user@password:www.google.com/`

     But it does not contain these URLs:

     *   `http://www.google.com/`       (wrong scheme) *   `https://google.com/`          (hostname does
     not match) *   `https://www.google.com:444/`  (port does not match) REQUIRED
       */
      public java.lang.String getSourceWebSite() {
        return sourceWebSite;
      }

      /**
       * Web assets are identified by a URL that contains only the scheme, hostname and port parts.
       * The format is
       *
       * http[s]://[:]
       *
       * Hostnames must be fully qualified: they must end in a single period ("`.`").
       *
       * Only the schemes "http" and "https" are currently allowed.
       *
       * Port numbers are given as a decimal number, and they must be omitted if the standard port
       * numbers are used: 80 for http and 443 for https.
       *
       * We call this limited URL the "site".  All URLs that share the same scheme, hostname and
       * port are considered to be a part of the site and thus belong to the web asset.
       *
       * Example: the asset with the site `https://www.google.com` contains all these URLs:
       *
       * *   `https://www.google.com/` *   `https://www.google.com:443/` *
       * `https://www.google.com/foo` *   `https://www.google.com/foo?bar` *
       * `https://www.google.com/foo#bar` *   `https://user@password:www.google.com/`
       *
       * But it does not contain these URLs:
       *
       * *   `http://www.google.com/`       (wrong scheme) *   `https://google.com/`
       * (hostname does not match) *   `https://www.google.com:444/`  (port does not match) REQUIRED
       */
      public List setSourceWebSite(java.lang.String sourceWebSite) {
        this.sourceWebSite = sourceWebSite;
        return this;
      }

      @Override
      public List set(String parameterName, Object value) {
        return (List) super.set(parameterName, value);
      }
    }

  }

  /**
   * Builder for {@link Digitalassetlinks}.
   *
   * <p>
   * Implementation is not thread-safe.
   * </p>
   *
   * @since 1.3.0
   */
  public static final class Builder extends com.google.api.client.googleapis.services.json.AbstractGoogleJsonClient.Builder {

    /**
     * Returns an instance of a new builder.
     *
     * @param transport HTTP transport, which should normally be:
     *        <ul>
     *        <li>Google App Engine:
     *        {@code com.google.api.client.extensions.appengine.http.UrlFetchTransport}</li>
     *        <li>Android: {@code newCompatibleTransport} from
     *        {@code com.google.api.client.extensions.android.http.AndroidHttp}</li>
     *        <li>Java: {@link com.google.api.client.googleapis.javanet.GoogleNetHttpTransport#newTrustedTransport()}
     *        </li>
     *        </ul>
     * @param jsonFactory JSON factory, which may be:
     *        <ul>
     *        <li>Jackson: {@code com.google.api.client.json.jackson2.JacksonFactory}</li>
     *        <li>Google GSON: {@code com.google.api.client.json.gson.GsonFactory}</li>
     *        <li>Android Honeycomb or higher:
     *        {@code com.google.api.client.extensions.android.json.AndroidJsonFactory}</li>
     *        </ul>
     * @param httpRequestInitializer HTTP request initializer or {@code null} for none
     * @since 1.7
     */
    public Builder(com.google.api.client.http.HttpTransport transport, com.google.api.client.json.JsonFactory jsonFactory,
        com.google.api.client.http.HttpRequestInitializer httpRequestInitializer) {
      super(
          transport,
          jsonFactory,
          DEFAULT_ROOT_URL,
          DEFAULT_SERVICE_PATH,
          httpRequestInitializer,
          false);
      setBatchPath(DEFAULT_BATCH_PATH);
    }

    /** Builds a new instance of {@link Digitalassetlinks}. */
    @Override
    public Digitalassetlinks build() {
      return new Digitalassetlinks(this);
    }

    @Override
    public Builder setRootUrl(String rootUrl) {
      return (Builder) super.setRootUrl(rootUrl);
    }

    @Override
    public Builder setServicePath(String servicePath) {
      return (Builder) super.setServicePath(servicePath);
    }

    @Override
    public Builder setBatchPath(String batchPath) {
      return (Builder) super.setBatchPath(batchPath);
    }

    @Override
    public Builder setHttpRequestInitializer(com.google.api.client.http.HttpRequestInitializer httpRequestInitializer) {
      return (Builder) super.setHttpRequestInitializer(httpRequestInitializer);
    }

    @Override
    public Builder setApplicationName(String applicationName) {
      return (Builder) super.setApplicationName(applicationName);
    }

    @Override
    public Builder setSuppressPatternChecks(boolean suppressPatternChecks) {
      return (Builder) super.setSuppressPatternChecks(suppressPatternChecks);
    }

    @Override
    public Builder setSuppressRequiredParameterChecks(boolean suppressRequiredParameterChecks) {
      return (Builder) super.setSuppressRequiredParameterChecks(suppressRequiredParameterChecks);
    }

    @Override
    public Builder setSuppressAllChecks(boolean suppressAllChecks) {
      return (Builder) super.setSuppressAllChecks(suppressAllChecks);
    }

    /**
     * Set the {@link DigitalassetlinksRequestInitializer}.
     *
     * @since 1.12
     */
    public Builder setDigitalassetlinksRequestInitializer(
        DigitalassetlinksRequestInitializer digitalassetlinksRequestInitializer) {
      return (Builder) super.setGoogleClientRequestInitializer(digitalassetlinksRequestInitializer);
    }

    @Override
    public Builder setGoogleClientRequestInitializer(
        com.google.api.client.googleapis.services.GoogleClientRequestInitializer googleClientRequestInitializer) {
      return (Builder) super.setGoogleClientRequestInitializer(googleClientRequestInitializer);
    }
  }
}
