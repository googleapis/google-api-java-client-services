/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/googleapis/google-api-java-client-services/
 * Modify at your own risk.
 */

package com.google.api.services.cloudsearch.v1.model;

/**
 * Model definition for HistoryRecord.
 *
 * <p> This is the Java data model class that specifies how to parse/serialize into the JSON that is
 * transmitted over HTTP when working with the Cloud Search API. For a detailed explanation see:
 * <a href="https://developers.google.com/api-client-library/java/google-http-java-client/json">https://developers.google.com/api-client-library/java/google-http-java-client/json</a>
 * </p>
 *
 * @author Google, Inc.
 */
@SuppressWarnings("javadoc")
public final class HistoryRecord extends com.google.api.client.json.GenericJson {

  /**
   * This will almost always be set, but there are corner cases in which the information is not
   * available, and thus applications must handle its absence appropriately.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private ClientContext clientContext;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private FilterUpdate filterUpdate;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private ImapUpdate imapUpdate;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private LabelUpdate labelUpdate;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private PrefUpdate prefUpdate;

  /**
   * Each HistoryRecord has a unique id. Ids are monotonically increasing, and not necessarily
   * contiguous.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key @com.google.api.client.json.JsonString
  private java.math.BigInteger recordId;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private ThreadUpdate threadUpdate;

  /**
   * This will almost always be set, but there are corner cases in which the information is not
   * available, and thus applications must handle its absence appropriately.
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private TransactionContext transactionContext;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private TransactionDebugInfo txnDebugInfo;

  /**
   * The value may be {@code null}.
   */
  @com.google.api.client.util.Key
  private java.lang.String type;

  /**
   * This will almost always be set, but there are corner cases in which the information is not
   * available, and thus applications must handle its absence appropriately.
   * @return value or {@code null} for none
   */
  public ClientContext getClientContext() {
    return clientContext;
  }

  /**
   * This will almost always be set, but there are corner cases in which the information is not
   * available, and thus applications must handle its absence appropriately.
   * @param clientContext clientContext or {@code null} for none
   */
  public HistoryRecord setClientContext(ClientContext clientContext) {
    this.clientContext = clientContext;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public FilterUpdate getFilterUpdate() {
    return filterUpdate;
  }

  /**
   * @param filterUpdate filterUpdate or {@code null} for none
   */
  public HistoryRecord setFilterUpdate(FilterUpdate filterUpdate) {
    this.filterUpdate = filterUpdate;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public ImapUpdate getImapUpdate() {
    return imapUpdate;
  }

  /**
   * @param imapUpdate imapUpdate or {@code null} for none
   */
  public HistoryRecord setImapUpdate(ImapUpdate imapUpdate) {
    this.imapUpdate = imapUpdate;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public LabelUpdate getLabelUpdate() {
    return labelUpdate;
  }

  /**
   * @param labelUpdate labelUpdate or {@code null} for none
   */
  public HistoryRecord setLabelUpdate(LabelUpdate labelUpdate) {
    this.labelUpdate = labelUpdate;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public PrefUpdate getPrefUpdate() {
    return prefUpdate;
  }

  /**
   * @param prefUpdate prefUpdate or {@code null} for none
   */
  public HistoryRecord setPrefUpdate(PrefUpdate prefUpdate) {
    this.prefUpdate = prefUpdate;
    return this;
  }

  /**
   * Each HistoryRecord has a unique id. Ids are monotonically increasing, and not necessarily
   * contiguous.
   * @return value or {@code null} for none
   */
  public java.math.BigInteger getRecordId() {
    return recordId;
  }

  /**
   * Each HistoryRecord has a unique id. Ids are monotonically increasing, and not necessarily
   * contiguous.
   * @param recordId recordId or {@code null} for none
   */
  public HistoryRecord setRecordId(java.math.BigInteger recordId) {
    this.recordId = recordId;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public ThreadUpdate getThreadUpdate() {
    return threadUpdate;
  }

  /**
   * @param threadUpdate threadUpdate or {@code null} for none
   */
  public HistoryRecord setThreadUpdate(ThreadUpdate threadUpdate) {
    this.threadUpdate = threadUpdate;
    return this;
  }

  /**
   * This will almost always be set, but there are corner cases in which the information is not
   * available, and thus applications must handle its absence appropriately.
   * @return value or {@code null} for none
   */
  public TransactionContext getTransactionContext() {
    return transactionContext;
  }

  /**
   * This will almost always be set, but there are corner cases in which the information is not
   * available, and thus applications must handle its absence appropriately.
   * @param transactionContext transactionContext or {@code null} for none
   */
  public HistoryRecord setTransactionContext(TransactionContext transactionContext) {
    this.transactionContext = transactionContext;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public TransactionDebugInfo getTxnDebugInfo() {
    return txnDebugInfo;
  }

  /**
   * @param txnDebugInfo txnDebugInfo or {@code null} for none
   */
  public HistoryRecord setTxnDebugInfo(TransactionDebugInfo txnDebugInfo) {
    this.txnDebugInfo = txnDebugInfo;
    return this;
  }

  /**
   * @return value or {@code null} for none
   */
  public java.lang.String getType() {
    return type;
  }

  /**
   * @param type type or {@code null} for none
   */
  public HistoryRecord setType(java.lang.String type) {
    this.type = type;
    return this;
  }

  @Override
  public HistoryRecord set(String fieldName, Object value) {
    return (HistoryRecord) super.set(fieldName, value);
  }

  @Override
  public HistoryRecord clone() {
    return (HistoryRecord) super.clone();
  }

}
